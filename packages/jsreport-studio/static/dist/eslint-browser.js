(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["eslint-browser"] = factory();
	else
		root["eslint-browser"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Main Linter Class
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const eslintScope = __webpack_require__(2),
  evk = __webpack_require__(89),
  espree = __webpack_require__(91),
  lodash = __webpack_require__(99),
  CodePathAnalyzer = __webpack_require__(100),
  ConfigOps = __webpack_require__(115),
  validator = __webpack_require__(121),
  Environments = __webpack_require__(174),
  applyDisableDirectives = __webpack_require__(178),
  createEmitter = __webpack_require__(179),
  NodeEventGenerator = __webpack_require__(180),
  SourceCode = __webpack_require__(182),
  Traverser = __webpack_require__(196),
  createReportTranslator = __webpack_require__(197),
  Rules = __webpack_require__(200),
  timing = __webpack_require__(486),
  ConfigCommentParser = __webpack_require__(487),
  astUtils = __webpack_require__(110),
  pkg = __webpack_require__(500),
  SourceCodeFixer = __webpack_require__(501);
const debug = __webpack_require__(105)("eslint:linter");
const MAX_AUTOFIX_PASSES = 10;
const DEFAULT_PARSER_NAME = "espree";
const commentParser = new ConfigCommentParser();

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * The result of a parsing operation from parseForESLint()
 * @typedef {Object} CustomParseResult
 * @property {ASTNode} ast The ESTree AST Program node.
 * @property {Object} services An object containing additional services related
 *      to the parser.
 * @property {ScopeManager|null} scopeManager The scope manager object of this AST.
 * @property {Object|null} visitorKeys The visitor keys to traverse this AST.
 */

/**
 * @typedef {Object} DisableDirective
 * @property {("disable"|"enable"|"disable-line"|"disable-next-line")} type
 * @property {number} line
 * @property {number} column
 * @property {(string|null)} ruleId
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Ensures that variables representing built-in properties of the Global Object,
 * and any globals declared by special block comments, are present in the global
 * scope.
 * @param {Scope} globalScope The global scope.
 * @param {Object} configGlobals The globals declared in configuration
 * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration
 * @returns {void}
 */
function addDeclaredGlobals(globalScope, configGlobals, commentDirectives) {
  const mergedGlobalsInfo = Object.assign({}, lodash.mapValues(configGlobals, value => ({
    sourceComment: null,
    value: ConfigOps.normalizeConfigGlobal(value)
  })), lodash.mapValues(commentDirectives.enabledGlobals, _ref => {
    let {
      comment,
      value
    } = _ref;
    return {
      sourceComment: comment,
      value: ConfigOps.normalizeConfigGlobal(value)
    };
  }));
  Object.keys(mergedGlobalsInfo).filter(name => mergedGlobalsInfo[name].value !== "off").forEach(name => {
    let variable = globalScope.set.get(name);
    if (!variable) {
      variable = new eslintScope.Variable(name, globalScope);
      if (mergedGlobalsInfo[name].sourceComment === null) {
        variable.eslintExplicitGlobal = false;
      } else {
        variable.eslintExplicitGlobal = true;
        variable.eslintExplicitGlobalComment = mergedGlobalsInfo[name].sourceComment;
      }
      globalScope.variables.push(variable);
      globalScope.set.set(name, variable);
    }
    variable.writeable = mergedGlobalsInfo[name].value === "writeable";
  });

  // mark all exported variables as such
  Object.keys(commentDirectives.exportedVariables).forEach(name => {
    const variable = globalScope.set.get(name);
    if (variable) {
      variable.eslintUsed = true;
    }
  });

  /*
   * "through" contains all references which definitions cannot be found.
   * Since we augment the global scope using configuration, we need to update
   * references and remove the ones that were added by configuration.
   */
  globalScope.through = globalScope.through.filter(reference => {
    const name = reference.identifier.name;
    const variable = globalScope.set.get(name);
    if (variable) {
      /*
       * Links the variable and the reference.
       * And this reference is removed from `Scope#through`.
       */
      reference.resolved = variable;
      variable.references.push(reference);
      return false;
    }
    return true;
  });
}

/**
 * Creates a collection of disable directives from a comment
 * @param {("disable"|"enable"|"disable-line"|"disable-next-line")} type The type of directive comment
 * @param {{line: number, column: number}} loc The 0-based location of the comment token
 * @param {string} value The value after the directive in the comment
 * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)
 * @returns {DisableDirective[]} Directives from the comment
 */
function createDisableDirectives(type, loc, value) {
  const ruleIds = Object.keys(commentParser.parseListConfig(value));
  const directiveRules = ruleIds.length ? ruleIds : [null];
  return directiveRules.map(ruleId => ({
    type,
    line: loc.line,
    column: loc.column + 1,
    ruleId
  }));
}

/**
 * Parses comments in file to extract file-specific config of rules, globals
 * and environments and merges them with global config; also code blocks
 * where reporting is disabled or enabled and merges them with reporting config.
 * @param {string} filename The file being checked.
 * @param {ASTNode} ast The top node of the AST.
 * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules
 * @returns {{configuredRules: Object, enabledGlobals: Object, exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}
 * A collection of the directive comments that were found, along with any problems that occurred when parsing
 */
function getDirectiveComments(filename, ast, ruleMapper) {
  const configuredRules = {};
  const enabledGlobals = {};
  const exportedVariables = {};
  const problems = [];
  const disableDirectives = [];
  ast.comments.filter(token => token.type !== "Shebang").forEach(comment => {
    const trimmedCommentText = comment.value.trim();
    const match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/u.exec(trimmedCommentText);
    if (!match) {
      return;
    }
    const directiveValue = trimmedCommentText.slice(match.index + match[1].length);
    if (/^eslint-disable-(next-)?line$/u.test(match[1])) {
      if (comment.loc.start.line === comment.loc.end.line) {
        const directiveType = match[1].slice("eslint-".length);
        disableDirectives.push(...createDisableDirectives(directiveType, comment.loc.start, directiveValue));
      } else {
        problems.push({
          ruleId: null,
          severity: 2,
          message: `${match[1]} comment should not span multiple lines.`,
          line: comment.loc.start.line,
          column: comment.loc.start.column + 1,
          endLine: comment.loc.end.line,
          endColumn: comment.loc.end.column + 1,
          nodeType: null
        });
      }
    } else if (comment.type === "Block") {
      switch (match[1]) {
        case "exported":
          Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
          break;
        case "globals":
        case "global":
          Object.assign(enabledGlobals, commentParser.parseStringConfig(directiveValue, comment));
          break;
        case "eslint-disable":
          disableDirectives.push(...createDisableDirectives("disable", comment.loc.start, directiveValue));
          break;
        case "eslint-enable":
          disableDirectives.push(...createDisableDirectives("enable", comment.loc.start, directiveValue));
          break;
        case "eslint":
          {
            const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);
            if (parseResult.success) {
              Object.keys(parseResult.config).forEach(name => {
                const ruleValue = parseResult.config[name];
                try {
                  validator.validateRuleOptions(ruleMapper(name), name, ruleValue);
                } catch (err) {
                  problems.push({
                    ruleId: name,
                    severity: 2,
                    message: err.message,
                    line: comment.loc.start.line,
                    column: comment.loc.start.column + 1,
                    endLine: comment.loc.end.line,
                    endColumn: comment.loc.end.column + 1,
                    nodeType: null
                  });
                }
                configuredRules[name] = ruleValue;
              });
            } else {
              problems.push(parseResult.error);
            }
            break;
          }

        // no default
      }
    }
  });
  return {
    configuredRules,
    enabledGlobals,
    exportedVariables,
    problems,
    disableDirectives
  };
}

/**
 * Normalize ECMAScript version from the initial config
 * @param  {number} ecmaVersion ECMAScript version from the initial config
 * @param  {boolean} isModule Whether the source type is module or not
 * @returns {number} normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion, isModule) {
  // Need at least ES6 for modules
  if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
    return 6;
  }

  /*
   * Calculate ECMAScript edition number from official year version starting with
   * ES2015, which corresponds with ES6 (or a difference of 2009).
   */
  if (ecmaVersion >= 2015) {
    return ecmaVersion - 2009;
  }
  return ecmaVersion;
}
const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//gu;

/**
 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
 * @param {string} text - A source code text to check.
 * @returns {Object|null} A result of parseListConfig() with "eslint-env *" comment.
 */
function findEslintEnv(text) {
  let match, retv;
  eslintEnvPattern.lastIndex = 0;
  while (match = eslintEnvPattern.exec(text)) {
    retv = Object.assign(retv || {}, commentParser.parseListConfig(match[1]));
  }
  return retv;
}

/**
 * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a
 * consistent shape.
 * @param {(string|{reportUnusedDisableDirectives: boolean, filename: string, allowInlineConfig: boolean})} providedOptions Options
 * @returns {{reportUnusedDisableDirectives: boolean, filename: string, allowInlineConfig: boolean}} Normalized options
 */
function normalizeVerifyOptions(providedOptions) {
  const isObjectOptions = typeof providedOptions === "object";
  const providedFilename = isObjectOptions ? providedOptions.filename : providedOptions;
  return {
    filename: typeof providedFilename === "string" ? providedFilename : "<input>",
    allowInlineConfig: !isObjectOptions || providedOptions.allowInlineConfig !== false,
    reportUnusedDisableDirectives: isObjectOptions && !!providedOptions.reportUnusedDisableDirectives
  };
}

/**
 * Combines the provided parserOptions with the options from environments
 * @param {string} parserName The parser name which uses this options.
 * @param {Object} providedOptions The provided 'parserOptions' key in a config
 * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {Object} Resulting parser options after merge
 */
function resolveParserOptions(parserName, providedOptions, enabledEnvironments) {
  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => ConfigOps.merge(parserOptions, env.parserOptions), {});
  const mergedParserOptions = ConfigOps.merge(parserOptionsFromEnv, providedOptions || {});
  const isModule = mergedParserOptions.sourceType === "module";
  if (isModule) {
    // can't have global return inside of modules
    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {
      globalReturn: false
    });
  }
  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion, isModule);

  // TODO: For backward compatibility. Will remove on v6.0.0.
  if (parserName === DEFAULT_PARSER_NAME && mergedParserOptions.ecmaFeatures && mergedParserOptions.ecmaFeatures.experimentalObjectRestSpread && (!mergedParserOptions.ecmaVersion || mergedParserOptions.ecmaVersion < 9)) {
    mergedParserOptions.ecmaVersion = 9;
  }
  return mergedParserOptions;
}

/**
 * Combines the provided globals object with the globals from environments
 * @param {Object} providedGlobals The 'globals' key in a config
 * @param {Environments[]} enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {Object} The resolved globals object
 */
function resolveGlobals(providedGlobals, enabledEnvironments) {
  return Object.assign({}, ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);
}

/**
 * Strips Unicode BOM from a given text.
 *
 * @param {string} text - A text to strip.
 * @returns {string} The stripped text.
 */
function stripUnicodeBOM(text) {
  /*
   * Check Unicode BOM.
   * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
   * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
   */
  if (text.charCodeAt(0) === 0xFEFF) {
    return text.slice(1);
  }
  return text;
}

/**
 * Get the options for a rule (not including severity), if any
 * @param {Array|number} ruleConfig rule configuration
 * @returns {Array} of rule options, empty Array if none
 */
function getRuleOptions(ruleConfig) {
  if (Array.isArray(ruleConfig)) {
    return ruleConfig.slice(1);
  }
  return [];
}

/**
 * Analyze scope of the given AST.
 * @param {ASTNode} ast The `Program` node to analyze.
 * @param {Object} parserOptions The parser options.
 * @param {Object} visitorKeys The visitor keys.
 * @returns {ScopeManager} The analysis result.
 */
function analyzeScope(ast, parserOptions, visitorKeys) {
  const ecmaFeatures = parserOptions.ecmaFeatures || {};
  const ecmaVersion = parserOptions.ecmaVersion || 5;
  return eslintScope.analyze(ast, {
    ignoreEval: true,
    nodejsScope: ecmaFeatures.globalReturn,
    impliedStrict: ecmaFeatures.impliedStrict,
    ecmaVersion,
    sourceType: parserOptions.sourceType || "script",
    childVisitorKeys: visitorKeys || evk.KEYS,
    fallback: Traverser.getKeys
  });
}

/**
 * Parses text into an AST. Moved out here because the try-catch prevents
 * optimization of functions, so it's best to keep the try-catch as isolated
 * as possible
 * @param {string} text The text to parse.
 * @param {Object} providedParserOptions Options to pass to the parser
 * @param {string} parserName The name of the parser
 * @param {Map<string, Object>} parserMap A map from names to loaded parsers
 * @param {string} filePath The path to the file being parsed.
 * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}
 * An object containing the AST and parser services if parsing was successful, or the error if parsing failed
 * @private
 */
function parse(text, providedParserOptions, parserName, parserMap, filePath) {
  const textToParse = stripUnicodeBOM(text).replace(astUtils.SHEBANG_MATCHER, (match, captured) => `//${captured}`);
  const parserOptions = Object.assign({}, providedParserOptions, {
    loc: true,
    range: true,
    raw: true,
    tokens: true,
    comment: true,
    eslintVisitorKeys: true,
    eslintScopeManager: true,
    filePath
  });
  let parser;
  try {
    parser = parserMap.get(parserName) ;
  } catch (ex) {
    return {
      success: false,
      error: {
        ruleId: null,
        fatal: true,
        severity: 2,
        message: ex.message,
        line: 0,
        column: 0
      }
    };
  }

  /*
   * Check for parsing errors first. If there's a parsing error, nothing
   * else can happen. However, a parsing error does not throw an error
   * from this method - it's just considered a fatal error message, a
   * problem that ESLint identified just like any other.
   */
  try {
    const parseResult = typeof parser.parseForESLint === "function" ? parser.parseForESLint(textToParse, parserOptions) : {
      ast: parser.parse(textToParse, parserOptions)
    };
    const ast = parseResult.ast;
    const parserServices = parseResult.services || {};
    const visitorKeys = parseResult.visitorKeys || evk.KEYS;
    const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);
    return {
      success: true,
      /*
       * Save all values that `parseForESLint()` returned.
       * If a `SourceCode` object is given as the first parameter instead of source code text,
       * linter skips the parsing process and reuses the source code object.
       * In that case, linter needs all the values that `parseForESLint()` returned.
       */
      sourceCode: new SourceCode({
        text,
        ast,
        parserServices,
        scopeManager,
        visitorKeys
      })
    };
  } catch (ex) {
    // If the message includes a leading line number, strip it:
    const message = `Parsing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
    return {
      success: false,
      error: {
        ruleId: null,
        fatal: true,
        severity: 2,
        message,
        line: ex.lineNumber,
        column: ex.column
      }
    };
  }
}

/**
 * Gets the scope for the current node
 * @param {ScopeManager} scopeManager The scope manager for this AST
 * @param {ASTNode} currentNode The node to get the scope of
 * @returns {eslint-scope.Scope} The scope information for this node
 */
function getScope(scopeManager, currentNode) {
  // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.
  const inner = currentNode.type !== "Program";
  for (let node = currentNode; node; node = node.parent) {
    const scope = scopeManager.acquire(node, inner);
    if (scope) {
      if (scope.type === "function-expression-name") {
        return scope.childScopes[0];
      }
      return scope;
    }
  }
  return scopeManager.scopes[0];
}

/**
 * Marks a variable as used in the current scope
 * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.
 * @param {ASTNode} currentNode The node currently being traversed
 * @param {Object} parserOptions The options used to parse this text
 * @param {string} name The name of the variable that should be marked as used.
 * @returns {boolean} True if the variable was found and marked as used, false if not.
 */
function markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
  const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
  const specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
  const currentScope = getScope(scopeManager, currentNode);

  // Special Node.js scope means we need to start one level deeper
  const initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;
  for (let scope = initialScope; scope; scope = scope.upper) {
    const variable = scope.variables.find(scopeVar => scopeVar.name === name);
    if (variable) {
      variable.eslintUsed = true;
      return true;
    }
  }
  return false;
}

/**
 * Runs a rule, and gets its listeners
 * @param {Rule} rule A normalized rule with a `create` method
 * @param {Context} ruleContext The context that should be passed to the rule
 * @returns {Object} A map of selector listeners provided by the rule
 */
function createRuleListeners(rule, ruleContext) {
  try {
    return rule.create(ruleContext);
  } catch (ex) {
    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;
    throw ex;
  }
}

/**
 * Gets all the ancestors of a given node
 * @param {ASTNode} node The node
 * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting
 * from the root node and going inwards to the parent node.
 */
function getAncestors(node) {
  const ancestorsStartingAtParent = [];
  for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
    ancestorsStartingAtParent.push(ancestor);
  }
  return ancestorsStartingAtParent.reverse();
}

// methods that exist on SourceCode object
const DEPRECATED_SOURCECODE_PASSTHROUGHS = {
  getSource: "getText",
  getSourceLines: "getLines",
  getAllComments: "getAllComments",
  getNodeByRangeIndex: "getNodeByRangeIndex",
  getComments: "getComments",
  getCommentsBefore: "getCommentsBefore",
  getCommentsAfter: "getCommentsAfter",
  getCommentsInside: "getCommentsInside",
  getJSDocComment: "getJSDocComment",
  getFirstToken: "getFirstToken",
  getFirstTokens: "getFirstTokens",
  getLastToken: "getLastToken",
  getLastTokens: "getLastTokens",
  getTokenAfter: "getTokenAfter",
  getTokenBefore: "getTokenBefore",
  getTokenByRangeStart: "getTokenByRangeStart",
  getTokens: "getTokens",
  getTokensAfter: "getTokensAfter",
  getTokensBefore: "getTokensBefore",
  getTokensBetween: "getTokensBetween"
};
const BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {
  [methodName]() {
    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...arguments);
  }
}), {}));

/**
 * Runs the given rules on the given SourceCode object
 * @param {SourceCode} sourceCode A SourceCode object for the given text
 * @param {Object} configuredRules The rules configuration
 * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules
 * @param {Object} parserOptions The options that were passed to the parser
 * @param {string} parserName The name of the parser in the config
 * @param {Object} settings The settings that were enabled in the config
 * @param {string} filename The reported filename of the code
 * @returns {Problem[]} An array of reported problems
 */
function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) {
  const emitter = createEmitter();
  const nodeQueue = [];
  let currentNode = sourceCode.ast;
  Traverser.traverse(sourceCode.ast, {
    enter(node, parent) {
      node.parent = parent;
      nodeQueue.push({
        isEntering: true,
        node
      });
    },
    leave(node) {
      nodeQueue.push({
        isEntering: false,
        node
      });
    },
    visitorKeys: sourceCode.visitorKeys
  });

  /*
   * Create a frozen object with the ruleContext properties and methods that are shared by all rules.
   * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the
   * properties once for each rule.
   */
  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
    getAncestors: () => getAncestors(currentNode),
    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),
    getFilename: () => filename,
    getScope: () => getScope(sourceCode.scopeManager, currentNode),
    getSourceCode: () => sourceCode,
    markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),
    parserOptions,
    parserPath: parserName,
    parserServices: sourceCode.parserServices,
    settings
  }));
  const lintingProblems = [];
  Object.keys(configuredRules).forEach(ruleId => {
    const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);
    if (severity === 0) {
      return;
    }
    const rule = ruleMapper(ruleId);
    const messageIds = rule.meta && rule.meta.messages;
    let reportTranslator = null;
    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
      id: ruleId,
      options: getRuleOptions(configuredRules[ruleId]),
      report() {
        /*
         * Create a report translator lazily.
         * In a vast majority of cases, any given rule reports zero errors on a given
         * piece of code. Creating a translator lazily avoids the performance cost of
         * creating a new translator function for each rule that usually doesn't get
         * called.
         *
         * Using lazy report translators improves end-to-end performance by about 3%
         * with Node 8.4.0.
         */
        if (reportTranslator === null) {
          reportTranslator = createReportTranslator({
            ruleId,
            severity,
            sourceCode,
            messageIds
          });
        }
        const problem = reportTranslator(...arguments);
        if (problem.fix && rule.meta && !rule.meta.fixable) {
          throw new Error("Fixable rules should export a `meta.fixable` property.");
        }
        lintingProblems.push(problem);
      }
    }));
    const ruleListeners = createRuleListeners(rule, ruleContext);

    // add all the selectors from the rule as listeners
    Object.keys(ruleListeners).forEach(selector => {
      emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
    });
  });
  const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
  nodeQueue.forEach(traversalInfo => {
    currentNode = traversalInfo.node;
    try {
      if (traversalInfo.isEntering) {
        eventGenerator.enterNode(currentNode);
      } else {
        eventGenerator.leaveNode(currentNode);
      }
    } catch (err) {
      err.currentNode = currentNode;
      throw err;
    }
  });
  return lintingProblems;
}
const lastSourceCodes = new WeakMap();
const loadedParserMaps = new WeakMap();
const ruleMaps = new WeakMap();

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object that is responsible for verifying JavaScript text
 * @name eslint
 */
module.exports = class Linter {
  constructor() {
    lastSourceCodes.set(this, null);
    loadedParserMaps.set(this, new Map());
    ruleMaps.set(this, new Rules());
    this.version = pkg.version;
    this.environments = new Environments();
    this.defineParser("espree", espree);
  }

  /**
   * Getter for package version.
   * @static
   * @returns {string} The version from package.json.
   */
  static get version() {
    return pkg.version;
  }

  /**
   * Configuration object for the `verify` API. A JS representation of the eslintrc files.
   * @typedef {Object} ESLintConfig
   * @property {Object} rules The rule configuration to verify against.
   * @property {string} [parser] Parser to use when generatig the AST.
   * @property {Object} [parserOptions] Options for the parsed used.
   * @property {Object} [settings] Global settings passed to each rule.
   * @property {Object} [env] The environment to verify in.
   * @property {Object} [globals] Available globals to the code.
   */

  /**
   * Same as linter.verify, except without support for processors.
   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
   * @param {ESLintConfig} providedConfig An ESLintConfig instance to configure everything.
   * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
   *      If this is not set, the filename will default to '<input>' in the rule context. If
   *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
   * @param {boolean} [filenameOrOptions.allowInlineConfig=true] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
   *      Useful if you want to validate JS without comments overriding rules.
   * @param {boolean} [filenameOrOptions.reportUnusedDisableDirectives=false] Adds reported errors for unused
   *      eslint-disable directives
   * @returns {Object[]} The results as an array of messages or an empty array if no messages.
   */
  _verifyWithoutProcessors(textOrSourceCode, providedConfig, filenameOrOptions) {
    const config = providedConfig || {};
    const options = normalizeVerifyOptions(filenameOrOptions);
    let text;

    // evaluate arguments
    if (typeof textOrSourceCode === "string") {
      lastSourceCodes.set(this, null);
      text = textOrSourceCode;
    } else {
      lastSourceCodes.set(this, textOrSourceCode);
      text = textOrSourceCode.text;
    }

    // search and apply "eslint-env *".
    const envInFile = findEslintEnv(text);
    const resolvedEnvConfig = Object.assign({
      builtin: true
    }, config.env, envInFile);
    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => this.environments.get(envName)).filter(env => env);
    const parserName = config.parser || DEFAULT_PARSER_NAME;
    const parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);
    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);
    const settings = config.settings || {};
    if (!lastSourceCodes.get(this)) {
      const parseResult = parse(text, parserOptions, parserName, loadedParserMaps.get(this), options.filename);
      if (!parseResult.success) {
        return [parseResult.error];
      }
      lastSourceCodes.set(this, parseResult.sourceCode);
    } else {
      /*
       * If the given source code object as the first argument does not have scopeManager, analyze the scope.
       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).
       */
      const lastSourceCode = lastSourceCodes.get(this);
      if (!lastSourceCode.scopeManager) {
        lastSourceCodes.set(this, new SourceCode({
          text: lastSourceCode.text,
          ast: lastSourceCode.ast,
          parserServices: lastSourceCode.parserServices,
          visitorKeys: lastSourceCode.visitorKeys,
          scopeManager: analyzeScope(lastSourceCode.ast, parserOptions)
        }));
      }
    }
    const sourceCode = lastSourceCodes.get(this);
    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => ruleMaps.get(this).get(ruleId)) : {
      configuredRules: {},
      enabledGlobals: {},
      exportedVariables: {},
      problems: [],
      disableDirectives: []
    };

    // augment global scope with declared global variables
    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {
      exportedVariables: commentDirectives.exportedVariables,
      enabledGlobals: commentDirectives.enabledGlobals
    });
    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
    let lintingProblems;
    try {
      lintingProblems = runRules(sourceCode, configuredRules, ruleId => ruleMaps.get(this).get(ruleId), parserOptions, parserName, settings, options.filename);
    } catch (err) {
      err.message += `\nOccurred while linting ${options.filename}`;
      debug("An error occurred while traversing");
      debug("Filename:", options.filename);
      if (err.currentNode) {
        const {
          line
        } = err.currentNode.loc.start;
        debug("Line:", line);
        err.message += `:${line}`;
      }
      debug("Parser Options:", parserOptions);
      debug("Parser Path:", parserName);
      debug("Settings:", settings);
      throw err;
    }
    return applyDisableDirectives({
      directives: commentDirectives.disableDirectives,
      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
    });
  }

  /**
   * Verifies the text against the rules specified by the second argument.
   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
   * @param {ESLintConfig} config An ESLintConfig instance to configure everything.
   * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
   *      If this is not set, the filename will default to '<input>' in the rule context. If
   *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
   * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
   *      Useful if you want to validate JS without comments overriding rules.
   * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,
   *      this should accept a string of source text, and return an array of code blocks to lint.
   * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,
   *      this should accept an array of the message lists for each code block returned from the preprocessor,
   *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages
   * @returns {Object[]} The results as an array of messages or an empty array if no messages.
   */
  verify(textOrSourceCode, config, filenameOrOptions) {
    const preprocess = filenameOrOptions && filenameOrOptions.preprocess || (rawText => [rawText]);
    const postprocess = filenameOrOptions && filenameOrOptions.postprocess || lodash.flatten;
    return postprocess(preprocess(textOrSourceCode).map(textBlock => this._verifyWithoutProcessors(textBlock, config, filenameOrOptions)));
  }

  /**
   * Gets the SourceCode object representing the parsed source.
   * @returns {SourceCode} The SourceCode object.
   */
  getSourceCode() {
    return lastSourceCodes.get(this);
  }

  /**
   * Defines a new linting rule.
   * @param {string} ruleId A unique rule identifier
   * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers
   * @returns {void}
   */
  defineRule(ruleId, ruleModule) {
    ruleMaps.get(this).define(ruleId, ruleModule);
  }

  /**
   * Defines many new linting rules.
   * @param {Object} rulesToDefine map from unique rule identifier to rule
   * @returns {void}
   */
  defineRules(rulesToDefine) {
    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {
      this.defineRule(ruleId, rulesToDefine[ruleId]);
    });
  }

  /**
   * Gets an object with all loaded rules.
   * @returns {Map} All loaded rules
   */
  getRules() {
    return ruleMaps.get(this).getAllLoadedRules();
  }

  /**
   * Define a new parser module
   * @param {any} parserId Name of the parser
   * @param {any} parserModule The parser object
   * @returns {void}
   */
  defineParser(parserId, parserModule) {
    loadedParserMaps.get(this).set(parserId, parserModule);
  }

  /**
   * Performs multiple autofix passes over the text until as many fixes as possible
   * have been applied.
   * @param {string} text The source text to apply fixes to.
   * @param {Object} config The ESLint config object to use.
   * @param {Object} options The ESLint options object to use.
   * @param {string} options.filename The filename from which the text was read.
   * @param {boolean} options.allowInlineConfig Flag indicating if inline comments
   *      should be allowed.
   * @param {boolean|Function} options.fix Determines whether fixes should be applied
   * @param {Function} options.preprocess preprocessor for source text. If provided, this should
   *      accept a string of source text, and return an array of code blocks to lint.
   * @param {Function} options.postprocess postprocessor for report messages. If provided,
   *      this should accept an array of the message lists for each code block returned from the preprocessor,
   *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages
   * @returns {Object} The result of the fix operation as returned from the
   *      SourceCodeFixer.
   */
  verifyAndFix(text, config, options) {
    let messages = [],
      fixedResult,
      fixed = false,
      passNumber = 0,
      currentText = text;
    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
    const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;

    /**
     * This loop continues until one of the following is true:
     *
     * 1. No more fixes have been applied.
     * 2. Ten passes have been made.
     *
     * That means anytime a fix is successfully applied, there will be another pass.
     * Essentially, guaranteeing a minimum of two passes.
     */
    do {
      passNumber++;
      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);
      messages = this.verify(currentText, config, options);
      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);
      fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);

      /*
       * stop if there are any syntax errors.
       * 'fixedResult.output' is a empty string.
       */
      if (messages.length === 1 && messages[0].fatal) {
        break;
      }

      // keep track if any fixes were ever applied - important for return value
      fixed = fixed || fixedResult.fixed;

      // update to use the fixed output instead of the original text
      currentText = fixedResult.output;
    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);

    /*
     * If the last result had fixes, we need to lint again to be sure we have
     * the most up-to-date information.
     */
    if (fixedResult.fixed) {
      fixedResult.messages = this.verify(currentText, config, options);
    }

    // ensure the last result properly reflects if fixes were done
    fixedResult.fixed = fixed;
    fixedResult.output = currentText;
    return fixedResult;
  }
};

/***/ }),
/* 2 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>
  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/**
 * Escope (<a href="http://github.com/estools/escope">escope</a>) is an <a
 * href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript</a>
 * scope analyzer extracted from the <a
 * href="http://github.com/estools/esmangle">esmangle project</a/>.
 * <p>
 * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that
 * program where different occurrences of the same identifier refer to the same
 * variable. With each scope the contained variables are collected, and each
 * identifier reference in code is linked to its corresponding variable (if
 * possible).
 * <p>
 * <em>escope</em> works on a syntax tree of the parsed source code which has
 * to adhere to the <a
 * href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">
 * Mozilla Parser API</a>. E.g. <a href="https://github.com/eslint/espree">espree</a> is a parser
 * that produces such syntax trees.
 * <p>
 * The main interface is the {@link analyze} function.
 * @module escope
 */


/* eslint no-underscore-dangle: ["error", { "allow": ["__currentScope"] }] */
const assert = __webpack_require__(3);
const ScopeManager = __webpack_require__(76);
const Referencer = __webpack_require__(83);
const Reference = __webpack_require__(80);
const Variable = __webpack_require__(81);
const Scope = (__webpack_require__(77).Scope);
const version = (__webpack_require__(88).version);

/**
 * Set the default options
 * @returns {Object} options
 */
function defaultOptions() {
  return {
    optimistic: false,
    directive: false,
    nodejsScope: false,
    impliedStrict: false,
    sourceType: "script",
    // one of ['script', 'module']
    ecmaVersion: 5,
    childVisitorKeys: null,
    fallback: "iteration"
  };
}

/**
 * Preform deep update on option object
 * @param {Object} target - Options
 * @param {Object} override - Updates
 * @returns {Object} Updated options
 */
function updateDeeply(target, override) {
  /**
   * Is hash object
   * @param {Object} value - Test value
   * @returns {boolean} Result
   */
  function isHashObject(value) {
    return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
  }
  for (const key in override) {
    if (override.hasOwnProperty(key)) {
      const val = override[key];
      if (isHashObject(val)) {
        if (isHashObject(target[key])) {
          updateDeeply(target[key], val);
        } else {
          target[key] = updateDeeply({}, val);
        }
      } else {
        target[key] = val;
      }
    }
  }
  return target;
}

/**
 * Main interface function. Takes an Espree syntax tree and returns the
 * analyzed scopes.
 * @function analyze
 * @param {espree.Tree} tree - Abstract Syntax Tree
 * @param {Object} providedOptions - Options that tailor the scope analysis
 * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag
 * @param {boolean} [providedOptions.directive=false]- the directive flag
 * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls
 * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole
 * script is executed under node.js environment. When enabled, escope adds
 * a function scope immediately following the global scope.
 * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode
 * (if ecmaVersion >= 5).
 * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'
 * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered
 * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.
 * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.
 * @returns {ScopeManager} ScopeManager
 */
function analyze(tree, providedOptions) {
  const options = updateDeeply(defaultOptions(), providedOptions);
  const scopeManager = new ScopeManager(options);
  const referencer = new Referencer(options, scopeManager);
  referencer.visit(tree);
  assert(scopeManager.__currentScope === null, "currentScope should be null.");
  return scopeManager;
}
module.exports = {
  /** @name module:escope.version */
  version,
  /** @name module:escope.Reference */
  Reference,
  /** @name module:escope.Variable */
  Variable,
  /** @name module:escope.Scope */
  Scope,
  /** @name module:escope.ScopeManager */
  ScopeManager,
  analyze
};

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 3 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(6);
// Currently in sync with Node.js lib/assert.js
// https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var _require = __webpack_require__(4),
  _require$codes = _require.codes,
  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = __webpack_require__(61);
var _require2 = __webpack_require__(5),
  inspect = _require2.inspect;
var _require$types = (__webpack_require__(5).types),
  isPromise = _require$types.isPromise,
  isRegExp = _require$types.isRegExp;
var objectAssign = Object.assign ? Object.assign : (__webpack_require__(62).assign);
var objectIs = Object.is ? Object.is : __webpack_require__(63);
var errorCache = new Map();
var isDeepEqual;
var isDeepStrictEqual;
var parseExpressionAt;
var findNodeAround;
var decoder;
function lazyLoadComparison() {
  var comparison = __webpack_require__(71);
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
} // Escape control characters but not \n and \t to keep the line breaks and
// indentation intact.
// eslint-disable-next-line no-control-regex

var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
var meta = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", '\\b', '', '', "\\u000b", '\\f', '', "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f"];
var escapeFn = function escapeFn(str) {
  return meta[str.charCodeAt(0)];
};
var warned = false; // The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;
var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided. All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function innerFail(obj) {
  if (obj.message instanceof Error) throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = 'Failed';
  } else if (argsLen === 1) {
    message = actual;
    actual = undefined;
  } else {
    if (warned === false) {
      warned = true;
      var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
    }
    if (argsLen === 2) operator = '!=';
  }
  if (message instanceof Error) throw message;
  var errArgs = {
    actual: actual,
    expected: expected,
    operator: operator === undefined ? 'fail' : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== undefined) {
    errArgs.message = message;
  }
  var err = new AssertionError(errArgs);
  if (internalMessage) {
    err.message = internalMessage;
    err.generatedMessage = true;
  }
  throw err;
}
assert.fail = fail; // The AssertionError is defined in internal/error.

assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value, message) {
  if (!value) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = 'No value argument passed to `assert.ok()`';
    } else if (message instanceof Error) {
      throw message;
    }
    var err = new AssertionError({
      actual: value,
      expected: true,
      message: message,
      operator: '==',
      stackStartFn: fn
    });
    err.generatedMessage = generatedMessage;
    throw err;
  }
} // Pure assertion tests whether a value is truthy, as determined
// by !!value.

function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.

/* eslint-disable no-restricted-properties */

assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq

  if (actual != expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '==',
      stackStartFn: equal
    });
  }
}; // The non-equality assertion tests for whether two objects are not
// equal with !=.

assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  } // eslint-disable-next-line eqeqeq

  if (actual == expected) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: '!=',
      stackStartFn: notEqual
    });
  }
}; // The equivalence assertion tests a deep equality relation.

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepEqual',
      stackStartFn: deepEqual
    });
  }
}; // The non-equivalence assertion tests for any deep inequality.

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepEqual',
      stackStartFn: notDeepEqual
    });
  }
};
/* eslint-enable */

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'deepStrictEqual',
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (isDeepEqual === undefined) lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notDeepStrictEqual',
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'strictEqual',
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS('actual', 'expected');
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: 'notStrictEqual',
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = function Comparison(obj, keys, actual) {
  var _this = this;
  _classCallCheck(this, Comparison);
  keys.forEach(function (key) {
    if (key in obj) {
      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};
function compareExceptionKey(actual, expected, key, message, keys, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      // Create placeholder objects to create a nice output.
      var a = new Comparison(actual, keys);
      var b = new Comparison(expected, keys, actual);
      var err = new AssertionError({
        actual: a,
        expected: b,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.actual = actual;
      err.expected = expected;
      err.operator = fn.name;
      throw err;
    }
    innerFail({
      actual: actual,
      expected: expected,
      message: message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg, fn) {
  if (typeof expected !== 'function') {
    if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.

    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
    } // Handle primitives properly.

    if (_typeof(actual) !== 'object' || actual === null) {
      var err = new AssertionError({
        actual: actual,
        expected: expected,
        message: msg,
        operator: 'deepStrictEqual',
        stackStartFn: fn
      });
      err.operator = fn.name;
      throw err;
    }
    var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
    // as well.

    if (expected instanceof Error) {
      keys.push('name', 'message');
    } else if (keys.length === 0) {
      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
    }
    if (isDeepEqual === undefined) lazyLoadComparison();
    keys.forEach(function (key) {
      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg, keys, fn);
    });
    return true;
  } // Guard instanceof against arrow functions as they don't have a prototype.

  if (expected.prototype !== undefined && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  // Accept native ES6 promises and promises that are implemented in a similar
  // way. Do not accept thenables that use a function as `obj` and that have no
  // `catch` handler.
  // TODO: thenables are checked up until they have the correct methods,
  // but according to documentation, the `then` method should receive
  // the `fulfill` and `reject` arguments as well or it may be never resolved.
  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function () {
    var resultPromise;
    if (typeof promiseFn === 'function') {
      // Return a rejected promise if `promiseFn` throws synchronously.
      resultPromise = promiseFn(); // Fail in case no promise is returned.

      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
    }
    return Promise.resolve().then(function () {
      return resultPromise;
    }).then(function () {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function (e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === 'string') {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
    }
    if (_typeof(actual) === 'object' && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
    }
    message = error;
    error = undefined;
  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = '';
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
    innerFail({
      actual: undefined,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn: stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL) return;
  if (typeof error === 'string') {
    message = error;
    error = undefined;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : '.';
    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
    innerFail({
      actual: actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
      stackStartFn: stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function (result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function (result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err) {
  if (err !== null && err !== undefined) {
    var message = 'ifError got unwanted exception: ';
    if (_typeof(err) === 'object' && typeof err.message === 'string') {
      if (err.message.length === 0 && err.constructor) {
        message += err.constructor.name;
      } else {
        message += err.message;
      }
    } else {
      message += inspect(err);
    }
    var newErr = new AssertionError({
      actual: err,
      expected: null,
      operator: 'ifError',
      message: message,
      stackStartFn: ifError
    }); // Make sure we actually have a stack trace!

    var origStack = err.stack;
    if (typeof origStack === 'string') {
      // This will remove any duplicated frames from the error frames taken
      // from within `ifError` and add the original error frames to the newly
      // created ones.
      var tmp2 = origStack.split('\n');
      tmp2.shift(); // Filter all frames existing in err.stack.

      var tmp1 = newErr.stack.split('\n');
      for (var i = 0; i < tmp2.length; i++) {
        // Find the first occurrence of the frame.
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          // Only keep new frames.
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
    }
    throw newErr;
  }
}; // Expose a strict only variant of assert

function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

/***/ }),
/* 4 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/errors.js
// https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f

/* eslint node-core/documented-errors: "error" */

/* eslint node-core/alphabetize-errors: "error" */

/* eslint node-core/prefer-util-format-errors: "error" */


// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
var codes = {}; // Lazy loaded

var assert;
var util;
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/
  function (_Base) {
    _inherits(NodeError, _Base);
    function NodeError(arg1, arg2, arg3) {
      var _this;
      _classCallCheck(this, NodeError);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code;
      return _this;
    }
    return NodeError;
  }(Base);
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  if (assert === undefined) assert = __webpack_require__(3);
  assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'

  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
  if (util === undefined) util = __webpack_require__(5);
  var inspected = util.inspect(value);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError, RangeError);
createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
  var type;
  if (value && value.constructor && value.constructor.name) {
    type = "instance of ".concat(value.constructor.name);
  } else {
    type = "type ".concat(_typeof(value));
  }
  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
}, TypeError);
createErrorType('ERR_MISSING_ARGS', function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert === undefined) assert = __webpack_require__(3);
  assert(args.length > 0, 'At least one arg needs to be specified');
  var msg = 'The ';
  var len = args.length;
  args = args.map(function (a) {
    return "\"".concat(a, "\"");
  });
  switch (len) {
    case 1:
      msg += "".concat(args[0], " argument");
      break;
    case 2:
      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg += args.slice(0, len - 1).join(', ');
      msg += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg, " must be specified");
}, TypeError);
module.exports.codes = codes;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(6);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function (set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(7);
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__(59);
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(60);
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });
    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function () {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function (rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/***/ }),
/* 6 */
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(8);
var isGeneratorFunction = __webpack_require__(45);
var whichTypedArray = __webpack_require__(48);
var isTypedArray = __webpack_require__(58);
function uncurryThis(f) {
  return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}
if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}
function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
  return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }
  return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }
  return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }
  return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }
  return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }
  return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }
  return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }
  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }
  return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function () {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

/***/ }),
/* 8 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(9)();
var callBound = __webpack_require__(11);
var $toString = callBound('Object.prototype.toString');

/** @type {import('.')} */
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }
  return $toString(value) === '[object Arguments]';
};

/** @type {import('.')} */
var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === 'object' && 'length' in value && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && 'callee' in value && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();

// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

/** @type {import('.')} */
module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(10);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};

/***/ }),
/* 10 */
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  /** @type {{ [k in symbol]?: unknown }} */
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (var _ in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    // eslint-disable-next-line no-extra-parens
    var descriptor = /** @type {PropertyDescriptor} */Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(12);
var callBindBasic = __webpack_require__(37);

/** @type {(thisArg: string, searchString: string, position?: number) => number} */
var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

/** @type {import('.')} */
module.exports = function callBoundIntrinsic(name, allowMissing) {
  /* eslint no-extra-parens: 0 */

  var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBindBasic(/** @type {const} */[intrinsic]);
  }
  return intrinsic;
};

/***/ }),
/* 12 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;
var $Object = __webpack_require__(13);
var $Error = __webpack_require__(14);
var $EvalError = __webpack_require__(15);
var $RangeError = __webpack_require__(16);
var $ReferenceError = __webpack_require__(17);
var $SyntaxError = __webpack_require__(18);
var $TypeError = __webpack_require__(19);
var $URIError = __webpack_require__(20);
var abs = __webpack_require__(21);
var floor = __webpack_require__(22);
var max = __webpack_require__(23);
var min = __webpack_require__(24);
var pow = __webpack_require__(25);
var round = __webpack_require__(26);
var sign = __webpack_require__(27);
var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};
var $gOPD = __webpack_require__(29);
var $defineProperty = __webpack_require__(31);
var throwTypeError = function () {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = __webpack_require__(32)();
var getProto = __webpack_require__(33);
var $ObjectGPO = __webpack_require__(35);
var $ReflectGPO = __webpack_require__(34);
var $apply = __webpack_require__(42);
var $call = __webpack_require__(40);
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': $Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': $EvalError,
  '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': $Object,
  '%Object.getOwnPropertyDescriptor%': $gOPD,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': $RangeError,
  '%ReferenceError%': $ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': $URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
  '%Function.prototype.call%': $call,
  '%Function.prototype.apply%': $apply,
  '%Object.defineProperty%': $defineProperty,
  '%Object.getPrototypeOf%': $ObjectGPO,
  '%Math.abs%': abs,
  '%Math.floor%': floor,
  '%Math.max%': max,
  '%Math.min%': min,
  '%Math.pow%': pow,
  '%Math.round%': round,
  '%Math.sign%': sign,
  '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
  try {
    null.error; // eslint-disable-line no-unused-expressions
  } catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS['%Error.prototype%'] = errorProto;
  }
}
var doEval = function doEval(name) {
  var value;
  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = __webpack_require__(38);
var hasOwn = __webpack_require__(44);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }
    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }
  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }
    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        return void undefined;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;

        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};

/***/ }),
/* 13 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;

/***/ }),
/* 14 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;

/***/ }),
/* 15 */
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;

/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;

/***/ }),
/* 17 */
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;

/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;

/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;

/***/ }),
/* 20 */
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;

/***/ }),
/* 21 */
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;

/***/ }),
/* 22 */
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;

/***/ }),
/* 23 */
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;

/***/ }),
/* 24 */
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;

/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;

/***/ }),
/* 26 */
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;

/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(28);

/** @type {import('./sign')} */
module.exports = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : +1;
};

/***/ }),
/* 28 */
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
  return a !== a;
};

/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(30);
if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}
module.exports = $gOPD;

/***/ }),
/* 30 */
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;

/***/ }),
/* 31 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
  }
}
module.exports = $defineProperty;

/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(10);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }
  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

/***/ }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(34);
var originalGetProto = __webpack_require__(35);
var getDunderProto = __webpack_require__(36);

/** @type {import('.')} */
module.exports = reflectGetProto ? function getProto(O) {
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
  if (!O || typeof O !== 'object' && typeof O !== 'function') {
    throw new TypeError('getProto: not an object');
  }
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
  // @ts-expect-error TS can't narrow inside a closure, for some reason
  return getDunderProto(O);
} : null;

/***/ }),
/* 34 */
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;

/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(13);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;

/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(37);
var gOPD = __webpack_require__(29);
var hasProtoAccessor;
try {
  // eslint-disable-next-line no-extra-parens, no-proto
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */[].__proto__ === Array.prototype;
} catch (e) {
  if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
    throw e;
  }
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */'__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function' ? callBind([desc.get]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */function getDunder(value) {
  // eslint-disable-next-line eqeqeq
  return $getPrototypeOf(value == null ? value : $Object(value));
} : false;

/***/ }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(38);
var $TypeError = __webpack_require__(19);
var $call = __webpack_require__(40);
var $actualApply = __webpack_require__(41);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
  if (args.length < 1 || typeof args[0] !== 'function') {
    throw new $TypeError('a function is required');
  }
  return $actualApply(bind, $call, args);
};

/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(39);
module.exports = Function.prototype.bind || implementation;

/***/ }),
/* 39 */
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function (arr, joiner) {
  var str = '';
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
module.exports = function bind(that) {
  var target = this;
  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, concatty(args, arguments));
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(that, concatty(args, arguments));
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = '$' + i;
  }
  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
  if (target.prototype) {
    var Empty = function Empty() {};
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};

/***/ }),
/* 40 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;

/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(38);
var $apply = __webpack_require__(42);
var $call = __webpack_require__(40);
var $reflectApply = __webpack_require__(43);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);

/***/ }),
/* 42 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;

/***/ }),
/* 43 */
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;

/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(38);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(11);
var safeRegexTest = __webpack_require__(46);
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __webpack_require__(9)();
var getProto = __webpack_require__(33);
var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');
var getGeneratorFunc = function () {
  // eslint-disable-line consistent-return
  if (!hasToStringTag) {
    return false;
  }
  try {
    return Function('return function*() {}')();
  } catch (e) {}
};
/** @type {undefined | false | null | GeneratorFunctionConstructor} */
var GeneratorFunction;

/** @type {import('.')} */
module.exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }
  if (isFnRegex(fnToStr(fn))) {
    return true;
  }
  if (!hasToStringTag) {
    var str = toStr(fn);
    return str === '[object GeneratorFunction]';
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === 'undefined') {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc
    // eslint-disable-next-line no-extra-parens
    ? (/** @type {GeneratorFunctionConstructor} */getProto(generatorFunc)) : false;
  }
  return getProto(fn) === GeneratorFunction;
};

/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(11);
var isRegex = __webpack_require__(47);
var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __webpack_require__(19);

/** @type {import('.')} */
module.exports = function regexTester(regex) {
  if (!isRegex(regex)) {
    throw new $TypeError('`regex` must be a RegExp');
  }
  return function test(s) {
    return $exec(regex, s) !== null;
  };
};

/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBound = __webpack_require__(11);
var hasToStringTag = __webpack_require__(9)();
var hasOwn = __webpack_require__(44);
var gOPD = __webpack_require__(29);

/** @type {import('.')} */
var fn;
if (hasToStringTag) {
  /** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */
  var $exec = callBound('RegExp.prototype.exec');
  /** @type {object} */
  var isRegexMarker = {};
  var throwRegexMarker = function () {
    throw isRegexMarker;
  };
  /** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */
  var badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === 'symbol') {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }

  /** @type {import('.')} */
  // @ts-expect-error TS can't figure out that the $exec call always throws
  // eslint-disable-next-line consistent-return
  fn = function isRegex(value) {
    if (!value || typeof value !== 'object') {
      return false;
    }

    // eslint-disable-next-line no-extra-parens
    var descriptor = /** @type {NonNullable<typeof gOPD>} */gOPD(/** @type {{ lastIndex?: unknown }} */value, 'lastIndex');
    var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      // eslint-disable-next-line no-extra-parens
      $exec(value, /** @type {string} */ /** @type {unknown} */badStringifier);
    } catch (e) {
      return e === isRegexMarker;
    }
  };
} else {
  /** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */
  var $toString = callBound('Object.prototype.toString');
  /** @const @type {'[object RegExp]'} */
  var regexClass = '[object RegExp]';

  /** @type {import('.')} */
  fn = function isRegex(value) {
    // In older browsers, typeof regex incorrectly returns 'function'
    if (!value || typeof value !== 'object' && typeof value !== 'function') {
      return false;
    }
    return $toString(value) === regexClass;
  };
}
module.exports = fn;

/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(49);
var availableTypedArrays = __webpack_require__(51);
var callBind = __webpack_require__(53);
var callBound = __webpack_require__(11);
var gOPD = __webpack_require__(29);
var getProto = __webpack_require__(33);
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(9)();
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};

/** @typedef {import('./types').Getter} Getter */
/** @type {import('./types').Cache} */
var cache = {
  __proto__: null
};
if (hasToStringTag && gOPD && getProto) {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr && getProto) {
      var proto = getProto(arr);
      // @ts-expect-error TS won't narrow inside a closure
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor && proto) {
        var superProto = getProto(proto);
        // @ts-expect-error TS won't narrow inside a closure
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      // @ts-expect-error TODO: fix
      cache['$' + typedArray] = callBind(descriptor.get);
    }
  });
} else {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) {
      cache[(/** @type {`$${import('.').TypedArrayName}`} */'$' + typedArray)] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
      // @ts-expect-error TODO FIXME
      callBind(fn);
    }
  });
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
  /** @type {ReturnType<typeof tryAllTypedArrays>} */var found = false;
  forEach(/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
  function (getter, typedArray) {
    if (!found) {
      try {
        // @ts-expect-error a throw is fine here
        if ('$' + getter(value) === typedArray) {
          found = /** @type {import('.').TypedArrayName} */$slice(typedArray, 1);
        }
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
  /** @type {ReturnType<typeof tryAllSlices>} */var found = false;
  forEach(/** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */function (getter, name) {
    if (!found) {
      try {
        // @ts-expect-error a throw is fine here
        getter(value);
        found = /** @type {import('.').TypedArrayName} */$slice(name, 1);
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }
  if (!hasToStringTag) {
    /** @type {string} */
    var tag = $slice($toString(value), 8, -1);
    if ($indexOf(typedArrays, tag) > -1) {
      return tag;
    }
    if (tag !== 'Object') {
      return false;
    }
    // node < 0.6 hits here on real Typed Arrays
    return trySlices(value);
  }
  if (!gOPD) {
    return null;
  } // unknown engine
  return tryTypedArrays(value);
};

/***/ }),
/* 49 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(50);
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */
var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};

/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */
var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};

/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */
var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};

/** @type {(x: unknown) => x is readonly unknown[]} */
function isArray(x) {
  return toStr.call(x) === '[object Array]';
}

/** @type {import('.')._internal} */
module.exports = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (isArray(list)) {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};

/***/ }),
/* 50 */
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function () {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === 'object') {
  // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
  var all = document.all;
  if (toStr.call(all) === toStr.call(document.all)) {
    isDDA = function isDocumentDotAll(value) {
      /* globals document: false */
      // in IE 6-8, typeof document.all is "object" and it's truthy
      if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
        try {
          var str = toStr.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
          || str === objectClass // IE 6-8
          ) && value('') == null; // eslint-disable-line eqeqeq
        } catch (e) {/**/}
      }
      return false;
    };
  }
}
module.exports = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  if (hasToStringTag) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass = toStr.call(value);
  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
    return false;
  }
  return tryFunctionObject(value);
};

/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = __webpack_require__(52);
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
  var /** @type {ReturnType<typeof availableTypedArrays>} */out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g[possibleNames[i]] === 'function') {
      // @ts-expect-error
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};

/***/ }),
/* 52 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = ['Float16Array', 'Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'BigInt64Array', 'BigUint64Array'];

/***/ }),
/* 53 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var setFunctionLength = __webpack_require__(54);
var $defineProperty = __webpack_require__(31);
var callBindBasic = __webpack_require__(37);
var applyBind = __webpack_require__(57);
module.exports = function callBind(originalFunction) {
  var func = callBindBasic(arguments);
  var adjustedLength = originalFunction.length - (arguments.length - 1);
  return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(12);
var define = __webpack_require__(55);
var hasDescriptors = __webpack_require__(56)();
var gOPD = __webpack_require__(29);
var $TypeError = __webpack_require__(19);
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }
  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    throw new $TypeError('`length` must be a positive 32-bit integer');
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ('length' in fn && gOPD) {
    var desc = gOPD(fn, 'length');
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
    } else {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length);
    }
  }
  return fn;
};

/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(31);
var $SyntaxError = __webpack_require__(18);
var $TypeError = __webpack_require__(19);
var gopd = __webpack_require__(29);

/** @type {import('.')} */
module.exports = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new $TypeError('`obj` must be an object or a function`');
  }
  if (typeof property !== 'string' && typeof property !== 'symbol') {
    throw new $TypeError('`property` must be a string or a symbol`');
  }
  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    throw new $TypeError('`loose`, if provided, must be a boolean');
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;

  /* @type {false | TypedPropertyDescriptor<unknown>} */
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value: value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
  } else {
    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  }
};

/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(31);
var hasPropertyDescriptors = function hasPropertyDescriptors() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};
module.exports = hasPropertyDescriptors;

/***/ }),
/* 57 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(38);
var $apply = __webpack_require__(42);
var actualApply = __webpack_require__(41);

/** @type {import('./applyBind')} */
module.exports = function applyBind() {
  return actualApply(bind, $apply, arguments);
};

/***/ }),
/* 58 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(48);

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
  return !!whichTypedArray(value);
};

/***/ }),
/* 59 */
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),
/* 60 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 61 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(6);
// Currently in sync with Node.js lib/internal/assert/assertion_error.js
// https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c


function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
var _require = __webpack_require__(5),
  inspect = _require.inspect;
var _require2 = __webpack_require__(4),
  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0) return '';
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = '';
var green = '';
var red = '';
var white = '';
var kReadableOperator = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: 'Values identical but not reference-equal:'
}; // Comparing short primitives should just show === / !== instead of using the
// diff.

var kMaxShortLength = 10;
function copyError(source) {
  var keys = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys.forEach(function (key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, 'message', {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  // The util.inspect default values could be changed. This makes sure the
  // error messages contain the necessary information nevertheless.
  return inspect(val, {
    compact: false,
    customInspect: false,
    depth: 1000,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = '';
  var res = '';
  var lastPos = 0;
  var end = '';
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split('\n');
  var expectedLines = inspectValue(expected).split('\n');
  var i = 0;
  var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
  // for the `strictEqual` operator.

  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
    operator = 'strictEqualObject';
  } // If "actual" and "expected" fit on a single line and they are not strictly
  // equal, check further special handling.

  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
    // kMaxShortLength and if neither is an object and at least one of them is
    // not `zero`, use the strict equal comparison to visualize the output.

    if (inputLength <= kMaxShortLength) {
      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
        // -0 === +0
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== 'strictEqualObject') {
      // If the stderr is a tty and the input length is lower than the current
      // columns per line, add a mismatch indicator below the output. If it is
      // not a tty, use a default value of 80 characters.
      var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        } // Ignore the first characters.

        if (i > 2) {
          // Add position indicator for the first mismatch in case it is a
          // single line and the input length is less than the column length.
          indicator = "\n  ".concat(repeat(' ', i), "^");
          i = 0;
        }
      }
    }
  } // Remove all ending lines that match (this optimizes the output for
  // readability by reducing the number of total changed lines).

  var a = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a === b) {
    if (i++ < 2) {
      end = "\n  ".concat(a).concat(end);
    } else {
      other = a;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0) break;
    a = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })

  if (maxLines === 0) {
    // We have to get the result again. The lines were all removed before.
    var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
    // TODO: Accept env to always show the full error.

    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
  }
  if (i > 3) {
    end = "\n".concat(blue, "...").concat(white).concat(end);
    skipped = true;
  }
  if (other !== '') {
    end = "\n  ".concat(other).concat(end);
    other = '';
  }
  var printedLines = 0;
  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    // Only extra expected lines exist
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.

      lastPos = i; // Add the expected line to the cache.

      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++; // Only extra actual lines exist
    } else if (expectedLines.length < i + 1) {
      // If the last diverging line is more than one line above and the
      // current line is at least line three, add some of the former lines and
      // also add dots to indicate skipped entries.
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      } // Mark the current line as the last diverging one.

      lastPos = i; // Add the actual line to the result.

      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++; // Lines diverge
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
      // a trailing comma. In that case it is actually identical and we should
      // mark it as such.

      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
      // add a comma at the end of the actual line. Otherwise the output could
      // look weird as in:
      //
      //   [
      //     1         // No comma at the end!
      // +   2
      //   ]
      //

      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ',';
      }
      if (divergingLines) {
        // If the last diverging line is more than one line above and the
        // current line is at least line three, add some of the former lines and
        // also add dots to indicate skipped entries.
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        } // Mark the current line as the last diverging one.

        lastPos = i; // Add the actual line to the result and cache the expected diverging
        // line so consecutive diverging lines show up as +++--- and not +-+-+-.

        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2; // Lines are identical
      } else {
        // Add all cached information to the result before adding other things
        // and reset the cache.
        res += other;
        other = ''; // If the last diverging line is exactly one line above or if it is the
        // very first line, add the line to the result.

        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    } // Inspected object to big (Show ~20 rows max)

    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
}
var AssertionError = /*#__PURE__*/
function (_Error) {
  _inherits(AssertionError, _Error);
  function AssertionError(options) {
    var _this;
    _classCallCheck(this, AssertionError);
    if (_typeof(options) !== 'object' || options === null) {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    var message = options.message,
      operator = options.operator,
      stackStartFn = options.stackStartFn;
    var actual = options.actual,
      expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
    } else {
      if (process.stderr && process.stderr.isTTY) {
        // Reset on each call to make sure we handle dynamically set environment
        // variables correct.
        if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
          blue = "\x1B[34m";
          green = "\x1B[32m";
          white = "\x1B[39m";
          red = "\x1B[31m";
        } else {
          blue = '';
          green = '';
          white = '';
          red = '';
        }
      } // Prevent the error stack from being visible by duplicating the error
      // in a very close way to the original in case both sides are actually
      // instances of Error.

      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
        // In case the objects are equal but the operator requires unequal, show
        // the first object and say A equals B
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.

        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        } // Only remove lines in case it makes sense to collapse those.
        // TODO: Accept env to always show the full error.

        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        } // Only print a single input.

        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
        }
      } else {
        var _res = inspectValue(actual);
        var other = '';
        var knownOperators = kReadableOperator[operator];
        if (operator === 'notDeepEqual' || operator === 'notEqual') {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === 'deepEqual' || operator === 'equal') {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized(_this), 'name', {
      value: 'AssertionError [ERR_ASSERTION]',
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = 'ERR_ASSERTION';
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      // eslint-disable-next-line no-restricted-syntax
      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
    } // Create error message including the error code in the name.

    _this.stack; // Reset the name.

    _this.name = 'AssertionError';
    return _possibleConstructorReturn(_this);
  }
  _createClass(AssertionError, [{
    key: "toString",
    value: function toString() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect.custom,
    value: function value(recurseTimes, ctx) {
      // This limits the `actual` and `expected` property default inspection to
      // the minimum depth. Otherwise those values would be too verbose compared
      // to the actual error message which contains a combined view of these two
      // input values.
      return inspect(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError;
}(_wrapNativeSuper(Error));
module.exports = AssertionError;

/***/ }),
/* 62 */
/***/ ((module) => {

"use strict";
/**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */



function assign(target, firstSource) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }
  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) {
      continue;
    }
    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== undefined && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}
function polyfill() {
  if (!Object.assign) {
    Object.defineProperty(Object, 'assign', {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}
module.exports = {
  assign: assign,
  polyfill: polyfill
};

/***/ }),
/* 63 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(64);
var callBind = __webpack_require__(53);
var implementation = __webpack_require__(68);
var getPolyfill = __webpack_require__(69);
var shim = __webpack_require__(70);
var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = polyfill;

/***/ }),
/* 64 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keys = __webpack_require__(65);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var defineDataProperty = __webpack_require__(55);
var isFunction = function (fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};
var supportsDescriptors = __webpack_require__(56)();
var defineProperty = function (object, name, value, predicate) {
  if (name in object) {
    if (predicate === true) {
      if (object[name] === value) {
        return;
      }
    } else if (!isFunction(predicate) || !predicate()) {
      return;
    }
  }
  if (supportsDescriptors) {
    defineDataProperty(object, name, value, true);
  } else {
    defineDataProperty(object, name, value);
  }
};
var defineProperties = function (object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);
  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var slice = Array.prototype.slice;
var isArgs = __webpack_require__(66);
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(67);
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
module.exports = keysShim;

/***/ }),
/* 66 */
/***/ ((module) => {

"use strict";


var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';
  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }
  return isArgs;
};

/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var keysShim;
if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var isArgs = __webpack_require__(66); // eslint-disable-line global-require
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
  var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function (o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim = function keys(object) {
    var isObject = object !== null && typeof object === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];
    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }
    var skipProto = hasProtoEnumBug && isFunction;
    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
module.exports = keysShim;

/***/ }),
/* 68 */
/***/ ((module) => {

"use strict";


var numberIsNaN = function (value) {
  return value !== value;
};
module.exports = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }
  if (a === b) {
    return true;
  }
  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }
  return false;
};

/***/ }),
/* 69 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(68);
module.exports = function getPolyfill() {
  return typeof Object.is === 'function' ? Object.is : implementation;
};

/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getPolyfill = __webpack_require__(69);
var define = __webpack_require__(64);
module.exports = function shimObjectIs() {
  var polyfill = getPolyfill();
  define(Object, {
    is: polyfill
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/comparisons.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
var regexFlagsSupported = /a/g.flags !== undefined;
var arrayFromSet = function arrayFromSet(set) {
  var array = [];
  set.forEach(function (value) {
    return array.push(value);
  });
  return array;
};
var arrayFromMap = function arrayFromMap(map) {
  var array = [];
  map.forEach(function (value, key) {
    return array.push([key, value]);
  });
  return array;
};
var objectIs = Object.is ? Object.is : __webpack_require__(63);
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
  return [];
};
var numberIsNaN = Number.isNaN ? Number.isNaN : __webpack_require__(72);
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types = (__webpack_require__(5).types),
  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
  isArrayBufferView = _require$types.isArrayBufferView,
  isDate = _require$types.isDate,
  isMap = _require$types.isMap,
  isRegExp = _require$types.isRegExp,
  isSet = _require$types.isSet,
  isNativeError = _require$types.isNativeError,
  isBoxedPrimitive = _require$types.isBoxedPrimitive,
  isNumberObject = _require$types.isNumberObject,
  isStringObject = _require$types.isStringObject,
  isBooleanObject = _require$types.isBooleanObject,
  isBigIntObject = _require$types.isBigIntObject,
  isSymbolObject = _require$types.isSymbolObject,
  isFloat32Array = _require$types.isFloat32Array,
  isFloat64Array = _require$types.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10) return true;
  for (var i = 0; i < key.length; i++) {
    var code = key.charCodeAt(i);
    if (code < 48 || code > 57) return true;
  } // The maximum size for an array is 2 ** 32 -1.

  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value) {
  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
} // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var ONLY_ENUMERABLE = undefined;
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3; // Check if they have the same source and flags

function areSimilarRegExps(a, b) {
  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset = 0; offset < a.byteLength; offset++) {
    if (a[offset] !== b[offset]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a, b) {
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
} // Notes: Type tags are historical [[Class]] properties that can be set by
// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
// and retrieved using Object.prototype.toString.call(obj) in JS
// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
// for a list of tags pre-defined in the spec.
// There are some unspecified tags in the wild too (e.g. typed array tags).
// Since tags can be altered, they only serve fast failures
//
// Typed arrays and buffers are checked by comparing the content in their
// underlying ArrayBuffer. This optimization requires that it's
// reasonable to interpret their underlying memory in the same way,
// which is checked by comparing their type tags.
// (e.g. a Uint8Array and a Uint16Array with the same memory content
// could still be different because they will be interpreted differently).
//
// For strict comparison, objects should have
// a) The same built-in type tags
// b) The same prototypes.

function innerDeepEqual(val1, val2, strict, memos) {
  // All identical values are equivalent, as determined by ===.
  if (val1 === val2) {
    if (val1 !== 0) return true;
    return strict ? objectIs(val1, val2) : true;
  } // Check more closely if val1 and val2 are equal.

  if (strict) {
    if (_typeof(val1) !== 'object') {
      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
    }
    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof(val1) !== 'object') {
      if (val2 === null || _typeof(val2) !== 'object') {
        // eslint-disable-next-line eqeqeq
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof(val2) !== 'object') {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    // Check for sparse arrays and general fast path
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
  } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
  // wan't to early return out of the rest of the checks. However we can check
  // if the second value is one of these values and the first isn't.

  if (val1Tag === '[object Object]') {
    // return keyCheck(val1, val2, strict, memos, kNoIterator);
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp(val1)) {
    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    // Do not compare the stack as it might differ even though the error itself
    // is otherwise identical.
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    } // Buffer.compare returns true, so val1.length === val2.length. If they both
    // only contain numeric keys, we don't need to exam further than checking
    // the symbols.

    var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
    var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict, memos, kNoIterator);
}
function getEnumerables(val, keys) {
  return keys.filter(function (k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
  // For all remaining Object pairs, including Array, objects and Maps,
  // equivalence is determined by having:
  // a) The same number of owned enumerable properties
  // b) The same set of keys/indexes (although not necessarily the same order)
  // c) Equivalent values for every corresponding key/index
  // d) For Sets and Maps, equal contents
  // Note: this accounts for both named and indexed properties on Arrays.
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.

    if (aKeys.length !== bKeys.length) {
      return false;
    }
  } // Cheap key test

  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  } // Use memos to handle cycles.

  if (memos === undefined) {
    memos = {
      val1: new Map(),
      val2: new Map(),
      position: 0
    };
  } else {
    // We prevent up to two map.has(x) calls by directly retrieving the value
    // and checking for undefined. The map can only contain numbers, so it is
    // safe to check for undefined only.
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== undefined) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== undefined) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set, val1, strict, memo) {
  // Go looking.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict, memo)) {
      // Remove the matching element to make sure we do not check that again.
      set.delete(val2);
      return true;
    }
  }
  return false;
} // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
// Sadly it is not possible to detect corresponding values properly in case the
// type is a string, number, bigint or boolean. The reason is that those values
// can match lots of different string values (e.g., 1n == '+00001').

function findLooseMatchingPrimitives(prim) {
  switch (_typeof(prim)) {
    case 'undefined':
      return null;
    case 'object':
      // Only pass in null as object!
      return undefined;
    case 'symbol':
      return false;
    case 'string':
      prim = +prim;
    // Loose equal entries exist only if the string is possible to convert to
    // a regular number and not NaN.
    // Fall through

    case 'number':
      if (numberIsNaN(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) return altValue;
  return b.has(altValue) && !a.has(altValue);
}
function mapMightHaveLoosePrim(a, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a, b, strict, memo) {
  // This is a lazily initiated Set of entries which have to be compared
  // pairwise.
  var set = null;
  var aValues = arrayFromSet(a);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
    // heavy sets but it is a minor slow down for primitives. As they are fast
    // to check this improves the worst case scenario instead.

    if (_typeof(val) === 'object' && val !== null) {
      if (set === null) {
        set = new Set();
      } // If the specified value doesn't exist in the second set its an not null
      // object (or non strict only: a not matching primitive) we'll need to go
      // hunting for something thats deep-(strict-)equal to it. To make this
      // O(n log n) complexity we have to copy these values in a new set first.

      set.add(val);
    } else if (!b.has(val)) {
      if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.

      if (!setMightHaveLoosePrim(a, b, val)) {
        return false;
      }
      if (set === null) {
        set = new Set();
      }
      set.add(val);
    }
  }
  if (set !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i]; // We have to check if a primitive value is already
      // matching and only if it's not, go hunting for it.

      if (_typeof(_val) === 'object' && _val !== null) {
        if (!setHasEqualElement(set, _val, strict, memo)) return false;
      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
  // To be able to handle cases like:
  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
  // ... we need to consider *all* matching keys, not just the first we find.
  var setValues = arrayFromSet(set);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
      set.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a, b, strict, memo) {
  var set = null;
  var aEntries = arrayFromMap(a);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2),
      key = _aEntries$i[0],
      item1 = _aEntries$i[1];
    if (_typeof(key) === 'object' && key !== null) {
      if (set === null) {
        set = new Set();
      }
      set.add(key);
    } else {
      // By directly retrieving the value we prevent another b.has(key) check in
      // almost all possible cases.
      var item2 = b.get(key);
      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
        if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
        // keys.

        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      }
    }
  }
  if (set !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
        key = _bEntries$_i[0],
        item = _bEntries$_i[1];
      if (_typeof(key) === 'object' && key !== null) {
        if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
      } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
        return false;
      }
    }
    return set.size === 0;
  }
  return true;
}
function objEquiv(a, b, strict, keys, memos, iterationType) {
  // Sets and maps don't have their entries accessible via normal object
  // properties.
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a, b, strict, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a.length; i++) {
      if (hasOwnProperty(a, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        // Array is sparse.
        var keysA = Object.keys(a);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  } // The pair must have equivalent values for every corresponding key.
  // Possibly expensive deep test:

  for (i = 0; i < keys.length; i++) {
    var _key = keys[i];
    if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
module.exports = {
  isDeepEqual: isDeepEqual,
  isDeepStrictEqual: isDeepStrictEqual
};

/***/ }),
/* 72 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(53);
var define = __webpack_require__(64);
var implementation = __webpack_require__(73);
var getPolyfill = __webpack_require__(74);
var shim = __webpack_require__(75);
var polyfill = callBind(getPolyfill(), Number);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

define(polyfill, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = polyfill;

/***/ }),
/* 73 */
/***/ ((module) => {

"use strict";


/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */
module.exports = function isNaN(value) {
  return value !== value;
};

/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(73);
module.exports = function getPolyfill() {
  if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
    return Number.isNaN;
  }
  return implementation;
};

/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var define = __webpack_require__(64);
var getPolyfill = __webpack_require__(74);

/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

module.exports = function shimNumberIsNaN() {
  var polyfill = getPolyfill();
  define(Number, {
    isNaN: polyfill
  }, {
    isNaN: function testIsNaN() {
      return Number.isNaN !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 76 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* eslint-disable no-underscore-dangle */
const Scope = __webpack_require__(77);
const assert = __webpack_require__(3);
const GlobalScope = Scope.GlobalScope;
const CatchScope = Scope.CatchScope;
const WithScope = Scope.WithScope;
const ModuleScope = Scope.ModuleScope;
const ClassScope = Scope.ClassScope;
const SwitchScope = Scope.SwitchScope;
const FunctionScope = Scope.FunctionScope;
const ForScope = Scope.ForScope;
const TDZScope = Scope.TDZScope;
const FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;
const BlockScope = Scope.BlockScope;

/**
 * @class ScopeManager
 */
class ScopeManager {
  constructor(options) {
    this.scopes = [];
    this.globalScope = null;
    this.__nodeToScope = new WeakMap();
    this.__currentScope = null;
    this.__options = options;
    this.__declaredVariables = new WeakMap();
  }
  __useDirective() {
    return this.__options.directive;
  }
  __isOptimistic() {
    return this.__options.optimistic;
  }
  __ignoreEval() {
    return this.__options.ignoreEval;
  }
  __isNodejsScope() {
    return this.__options.nodejsScope;
  }
  isModule() {
    return this.__options.sourceType === "module";
  }
  isImpliedStrict() {
    return this.__options.impliedStrict;
  }
  isStrictModeSupported() {
    return this.__options.ecmaVersion >= 5;
  }

  // Returns appropriate scope for this node.
  __get(node) {
    return this.__nodeToScope.get(node);
  }

  /**
   * Get variables that are declared by the node.
   *
   * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
   * If the node declares nothing, this method returns an empty array.
   * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
   *
   * @param {Espree.Node} node - a node to get.
   * @returns {Variable[]} variables that declared by the node.
   */
  getDeclaredVariables(node) {
    return this.__declaredVariables.get(node) || [];
  }

  /**
   * acquire scope from node.
   * @method ScopeManager#acquire
   * @param {Espree.Node} node - node for the acquired scope.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} Scope from node
   */
  acquire(node, inner) {
    /**
     * predicate
     * @param {Scope} testScope - scope to test
     * @returns {boolean} predicate
     */
    function predicate(testScope) {
      if (testScope.type === "function" && testScope.functionExpressionScope) {
        return false;
      }
      if (testScope.type === "TDZ") {
        return false;
      }
      return true;
    }
    const scopes = this.__get(node);
    if (!scopes || scopes.length === 0) {
      return null;
    }

    // Heuristic selection from all scopes.
    // If you would like to get all scopes, please use ScopeManager#acquireAll.
    if (scopes.length === 1) {
      return scopes[0];
    }
    if (inner) {
      for (let i = scopes.length - 1; i >= 0; --i) {
        const scope = scopes[i];
        if (predicate(scope)) {
          return scope;
        }
      }
    } else {
      for (let i = 0, iz = scopes.length; i < iz; ++i) {
        const scope = scopes[i];
        if (predicate(scope)) {
          return scope;
        }
      }
    }
    return null;
  }

  /**
   * acquire all scopes from node.
   * @method ScopeManager#acquireAll
   * @param {Espree.Node} node - node for the acquired scope.
   * @returns {Scopes?} Scope array
   */
  acquireAll(node) {
    return this.__get(node);
  }

  /**
   * release the node.
   * @method ScopeManager#release
   * @param {Espree.Node} node - releasing node.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} upper scope for the node.
   */
  release(node, inner) {
    const scopes = this.__get(node);
    if (scopes && scopes.length) {
      const scope = scopes[0].upper;
      if (!scope) {
        return null;
      }
      return this.acquire(scope.block, inner);
    }
    return null;
  }
  attach() {} // eslint-disable-line class-methods-use-this

  detach() {} // eslint-disable-line class-methods-use-this

  __nestScope(scope) {
    if (scope instanceof GlobalScope) {
      assert(this.__currentScope === null);
      this.globalScope = scope;
    }
    this.__currentScope = scope;
    return scope;
  }
  __nestGlobalScope(node) {
    return this.__nestScope(new GlobalScope(this, node));
  }
  __nestBlockScope(node) {
    return this.__nestScope(new BlockScope(this, this.__currentScope, node));
  }
  __nestFunctionScope(node, isMethodDefinition) {
    return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
  }
  __nestForScope(node) {
    return this.__nestScope(new ForScope(this, this.__currentScope, node));
  }
  __nestCatchScope(node) {
    return this.__nestScope(new CatchScope(this, this.__currentScope, node));
  }
  __nestWithScope(node) {
    return this.__nestScope(new WithScope(this, this.__currentScope, node));
  }
  __nestClassScope(node) {
    return this.__nestScope(new ClassScope(this, this.__currentScope, node));
  }
  __nestSwitchScope(node) {
    return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
  }
  __nestModuleScope(node) {
    return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
  }
  __nestTDZScope(node) {
    return this.__nestScope(new TDZScope(this, this.__currentScope, node));
  }
  __nestFunctionExpressionNameScope(node) {
    return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
  }
  __isES6() {
    return this.__options.ecmaVersion >= 6;
  }
}
module.exports = ScopeManager;

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* eslint-disable no-underscore-dangle */
/* eslint-disable no-undefined */
const Syntax = (__webpack_require__(78).Syntax);
const Reference = __webpack_require__(80);
const Variable = __webpack_require__(81);
const Definition = (__webpack_require__(82).Definition);
const assert = __webpack_require__(3);

/**
 * Test if scope is struct
 * @param {Scope} scope - scope
 * @param {Block} block - block
 * @param {boolean} isMethodDefinition - is method definiton
 * @param {boolean} useDirective - use directive
 * @returns {boolean} is strict scope
 */
function isStrictScope(scope, block, isMethodDefinition, useDirective) {
  let body;

  // When upper scope is exists and strict, inner scope is also strict.
  if (scope.upper && scope.upper.isStrict) {
    return true;
  }

  // ArrowFunctionExpression's scope is always strict scope.
  if (block.type === Syntax.ArrowFunctionExpression) {
    return true;
  }
  if (isMethodDefinition) {
    return true;
  }
  if (scope.type === "class" || scope.type === "module") {
    return true;
  }
  if (scope.type === "block" || scope.type === "switch") {
    return false;
  }
  if (scope.type === "function") {
    if (block.type === Syntax.Program) {
      body = block;
    } else {
      body = block.body;
    }
    if (!body) {
      return false;
    }
  } else if (scope.type === "global") {
    body = block;
  } else {
    return false;
  }

  // Search 'use strict' directive.
  if (useDirective) {
    for (let i = 0, iz = body.body.length; i < iz; ++i) {
      const stmt = body.body[i];
      if (stmt.type !== Syntax.DirectiveStatement) {
        break;
      }
      if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") {
        return true;
      }
    }
  } else {
    for (let i = 0, iz = body.body.length; i < iz; ++i) {
      const stmt = body.body[i];
      if (stmt.type !== Syntax.ExpressionStatement) {
        break;
      }
      const expr = stmt.expression;
      if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
        break;
      }
      if (expr.raw !== null && expr.raw !== undefined) {
        if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") {
          return true;
        }
      } else {
        if (expr.value === "use strict") {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * Register scope
 * @param {ScopeManager} scopeManager - scope manager
 * @param {Scope} scope - scope
 * @returns {void}
 */
function registerScope(scopeManager, scope) {
  scopeManager.scopes.push(scope);
  const scopes = scopeManager.__nodeToScope.get(scope.block);
  if (scopes) {
    scopes.push(scope);
  } else {
    scopeManager.__nodeToScope.set(scope.block, [scope]);
  }
}

/**
 * Should be statically
 * @param {Object} def - def
 * @returns {boolean} should be statically
 */
function shouldBeStatically(def) {
  return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
}

/**
 * @class Scope
 */
class Scope {
  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
    /**
     * One of 'TDZ', 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.
     * @member {String} Scope#type
     */
    this.type = type;

    /**
    * The scoped {@link Variable}s of this scope, as <code>{ Variable.name
    * : Variable }</code>.
    * @member {Map} Scope#set
    */
    this.set = new Map();

    /**
     * The tainted variables of this scope, as <code>{ Variable.name :
     * boolean }</code>.
     * @member {Map} Scope#taints */
    this.taints = new Map();

    /**
     * Generally, through the lexical scoping of JS you can always know
     * which variable an identifier in the source code refers to. There are
     * a few exceptions to this rule. With 'global' and 'with' scopes you
     * can only decide at runtime which variable a reference refers to.
     * Moreover, if 'eval()' is used in a scope, it might introduce new
     * bindings in this or its parent scopes.
     * All those scopes are considered 'dynamic'.
     * @member {boolean} Scope#dynamic
     */
    this.dynamic = this.type === "global" || this.type === "with";

    /**
     * A reference to the scope-defining syntax node.
     * @member {espree.Node} Scope#block
     */
    this.block = block;

    /**
    * The {@link Reference|references} that are not resolved with this scope.
    * @member {Reference[]} Scope#through
    */
    this.through = [];

    /**
    * The scoped {@link Variable}s of this scope. In the case of a
    * 'function' scope this includes the automatic argument <em>arguments</em> as
    * its first element, as well as all further formal arguments.
    * @member {Variable[]} Scope#variables
    */
    this.variables = [];

    /**
    * Any variable {@link Reference|reference} found in this scope. This
    * includes occurrences of local variables as well as variables from
    * parent scopes (including the global scope). For local variables
    * this also includes defining occurrences (like in a 'var' statement).
    * In a 'function' scope this does not include the occurrences of the
    * formal parameter in the parameter list.
    * @member {Reference[]} Scope#references
    */
    this.references = [];

    /**
    * For 'global' and 'function' scopes, this is a self-reference. For
    * other scope types this is the <em>variableScope</em> value of the
    * parent scope.
    * @member {Scope} Scope#variableScope
    */
    this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;

    /**
    * Whether this scope is created by a FunctionExpression.
    * @member {boolean} Scope#functionExpressionScope
    */
    this.functionExpressionScope = false;

    /**
    * Whether this is a scope that contains an 'eval()' invocation.
    * @member {boolean} Scope#directCallToEvalScope
    */
    this.directCallToEvalScope = false;

    /**
    * @member {boolean} Scope#thisFound
    */
    this.thisFound = false;
    this.__left = [];

    /**
    * Reference to the parent {@link Scope|scope}.
    * @member {Scope} Scope#upper
    */
    this.upper = upperScope;

    /**
    * Whether 'use strict' is in effect in this scope.
    * @member {boolean} Scope#isStrict
    */
    this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());

    /**
    * List of nested {@link Scope}s.
    * @member {Scope[]} Scope#childScopes
    */
    this.childScopes = [];
    if (this.upper) {
      this.upper.childScopes.push(this);
    }
    this.__declaredVariables = scopeManager.__declaredVariables;
    registerScope(scopeManager, this);
  }
  __shouldStaticallyClose(scopeManager) {
    return !this.dynamic || scopeManager.__isOptimistic();
  }
  __shouldStaticallyCloseForGlobal(ref) {
    // On global scope, let/const/class declarations should be resolved statically.
    const name = ref.identifier.name;
    if (!this.set.has(name)) {
      return false;
    }
    const variable = this.set.get(name);
    const defs = variable.defs;
    return defs.length > 0 && defs.every(shouldBeStatically);
  }
  __staticCloseRef(ref) {
    if (!this.__resolve(ref)) {
      this.__delegateToUpperScope(ref);
    }
  }
  __dynamicCloseRef(ref) {
    // notify all names are through to global
    let current = this;
    do {
      current.through.push(ref);
      current = current.upper;
    } while (current);
  }
  __globalCloseRef(ref) {
    // let/const/class declarations should be resolved statically.
    // others should be resolved dynamically.
    if (this.__shouldStaticallyCloseForGlobal(ref)) {
      this.__staticCloseRef(ref);
    } else {
      this.__dynamicCloseRef(ref);
    }
  }
  __close(scopeManager) {
    let closeRef;
    if (this.__shouldStaticallyClose(scopeManager)) {
      closeRef = this.__staticCloseRef;
    } else if (this.type !== "global") {
      closeRef = this.__dynamicCloseRef;
    } else {
      closeRef = this.__globalCloseRef;
    }

    // Try Resolving all references in this scope.
    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];
      closeRef.call(this, ref);
    }
    this.__left = null;
    return this.upper;
  }
  __resolve(ref) {
    const name = ref.identifier.name;
    if (this.set.has(name)) {
      const variable = this.set.get(name);
      variable.references.push(ref);
      variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
      if (ref.tainted) {
        variable.tainted = true;
        this.taints.set(variable.name, true);
      }
      ref.resolved = variable;
      return true;
    }
    return false;
  }
  __delegateToUpperScope(ref) {
    if (this.upper) {
      this.upper.__left.push(ref);
    }
    this.through.push(ref);
  }
  __addDeclaredVariablesOfNode(variable, node) {
    if (node === null || node === undefined) {
      return;
    }
    let variables = this.__declaredVariables.get(node);
    if (variables === null || variables === undefined) {
      variables = [];
      this.__declaredVariables.set(node, variables);
    }
    if (variables.indexOf(variable) === -1) {
      variables.push(variable);
    }
  }
  __defineGeneric(name, set, variables, node, def) {
    let variable;
    variable = set.get(name);
    if (!variable) {
      variable = new Variable(name, this);
      set.set(name, variable);
      variables.push(variable);
    }
    if (def) {
      variable.defs.push(def);
      if (def.type !== Variable.TDZ) {
        this.__addDeclaredVariablesOfNode(variable, def.node);
        this.__addDeclaredVariablesOfNode(variable, def.parent);
      }
    }
    if (node) {
      variable.identifiers.push(node);
    }
  }
  __define(node, def) {
    if (node && node.type === Syntax.Identifier) {
      this.__defineGeneric(node.name, this.set, this.variables, node, def);
    }
  }
  __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
    // because Array element may be null
    if (!node || node.type !== Syntax.Identifier) {
      return;
    }

    // Specially handle like `this`.
    if (node.name === "super") {
      return;
    }
    const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
    this.references.push(ref);
    this.__left.push(ref);
  }
  __detectEval() {
    let current = this;
    this.directCallToEvalScope = true;
    do {
      current.dynamic = true;
      current = current.upper;
    } while (current);
  }
  __detectThis() {
    this.thisFound = true;
  }
  __isClosed() {
    return this.__left === null;
  }

  /**
   * returns resolved {Reference}
   * @method Scope#resolve
   * @param {Espree.Identifier} ident - identifier to be resolved.
   * @returns {Reference} reference
   */
  resolve(ident) {
    let ref, i, iz;
    assert(this.__isClosed(), "Scope should be closed.");
    assert(ident.type === Syntax.Identifier, "Target should be identifier.");
    for (i = 0, iz = this.references.length; i < iz; ++i) {
      ref = this.references[i];
      if (ref.identifier === ident) {
        return ref;
      }
    }
    return null;
  }

  /**
   * returns this scope is static
   * @method Scope#isStatic
   * @returns {boolean} static
   */
  isStatic() {
    return !this.dynamic;
  }

  /**
   * returns this scope has materialized arguments
   * @method Scope#isArgumentsMaterialized
   * @returns {boolean} arguemnts materialized
   */
  isArgumentsMaterialized() {
    // eslint-disable-line class-methods-use-this
    return true;
  }

  /**
   * returns this scope has materialized `this` reference
   * @method Scope#isThisMaterialized
   * @returns {boolean} this materialized
   */
  isThisMaterialized() {
    // eslint-disable-line class-methods-use-this
    return true;
  }
  isUsedName(name) {
    if (this.set.has(name)) {
      return true;
    }
    for (let i = 0, iz = this.through.length; i < iz; ++i) {
      if (this.through[i].identifier.name === name) {
        return true;
      }
    }
    return false;
  }
}
class GlobalScope extends Scope {
  constructor(scopeManager, block) {
    super(scopeManager, "global", null, block, false);
    this.implicit = {
      set: new Map(),
      variables: [],
      /**
      * List of {@link Reference}s that are left to be resolved (i.e. which
      * need to be linked to the variable they refer to).
      * @member {Reference[]} Scope#implicit#left
      */
      left: []
    };
  }
  __close(scopeManager) {
    const implicit = [];
    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];
      if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
        implicit.push(ref.__maybeImplicitGlobal);
      }
    }

    // create an implicit global variable from assignment expression
    for (let i = 0, iz = implicit.length; i < iz; ++i) {
      const info = implicit[i];
      this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
    }
    this.implicit.left = this.__left;
    return super.__close(scopeManager);
  }
  __defineImplicit(node, def) {
    if (node && node.type === Syntax.Identifier) {
      this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
    }
  }
}
class ModuleScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "module", upperScope, block, false);
  }
}
class FunctionExpressionNameScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "function-expression-name", upperScope, block, false);
    this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));
    this.functionExpressionScope = true;
  }
}
class CatchScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "catch", upperScope, block, false);
  }
}
class WithScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "with", upperScope, block, false);
  }
  __close(scopeManager) {
    if (this.__shouldStaticallyClose(scopeManager)) {
      return super.__close(scopeManager);
    }
    for (let i = 0, iz = this.__left.length; i < iz; ++i) {
      const ref = this.__left[i];
      ref.tainted = true;
      this.__delegateToUpperScope(ref);
    }
    this.__left = null;
    return this.upper;
  }
}
class TDZScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "TDZ", upperScope, block, false);
  }
}
class BlockScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "block", upperScope, block, false);
  }
}
class SwitchScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "switch", upperScope, block, false);
  }
}
class FunctionScope extends Scope {
  constructor(scopeManager, upperScope, block, isMethodDefinition) {
    super(scopeManager, "function", upperScope, block, isMethodDefinition);

    // section 9.2.13, FunctionDeclarationInstantiation.
    // NOTE Arrow functions never have an arguments objects.
    if (this.block.type !== Syntax.ArrowFunctionExpression) {
      this.__defineArguments();
    }
  }
  isArgumentsMaterialized() {
    // TODO(Constellation)
    // We can more aggressive on this condition like this.
    //
    // function t() {
    //     // arguments of t is always hidden.
    //     function arguments() {
    //     }
    // }
    if (this.block.type === Syntax.ArrowFunctionExpression) {
      return false;
    }
    if (!this.isStatic()) {
      return true;
    }
    const variable = this.set.get("arguments");
    assert(variable, "Always have arguments variable.");
    return variable.tainted || variable.references.length !== 0;
  }
  isThisMaterialized() {
    if (!this.isStatic()) {
      return true;
    }
    return this.thisFound;
  }
  __defineArguments() {
    this.__defineGeneric("arguments", this.set, this.variables, null, null);
    this.taints.set("arguments", true);
  }
}
class ForScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "for", upperScope, block, false);
  }
}
class ClassScope extends Scope {
  constructor(scopeManager, upperScope, block) {
    super(scopeManager, "class", upperScope, block, false);
  }
}
module.exports = {
  Scope,
  GlobalScope,
  ModuleScope,
  FunctionExpressionNameScope,
  CatchScope,
  WithScope,
  TDZScope,
  BlockScope,
  SwitchScope,
  FunctionScope,
  ForScope,
  ClassScope
};

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
  'use strict';

  var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
  function deepCopy(obj) {
    var ret = {},
      key,
      val;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        val = obj[key];
        if (typeof val === 'object' && val !== null) {
          ret[key] = deepCopy(val);
        } else {
          ret[key] = val;
        }
      }
    }
    return ret;
  }

  // based on LLVM libc++ upper_bound / lower_bound
  // MIT License

  function upperBound(array, func) {
    var diff, len, i, current;
    len = array.length;
    i = 0;
    while (len) {
      diff = len >>> 1;
      current = i + diff;
      if (func(array[current])) {
        len = diff;
      } else {
        i = current + 1;
        len -= diff + 1;
      }
    }
    return i;
  }
  Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    // CAUTION: It's deferred to ES7.
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ComprehensionBlock: 'ComprehensionBlock',
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: 'ComprehensionExpression',
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DebuggerStatement: 'DebuggerStatement',
    DirectiveStatement: 'DirectiveStatement',
    DoWhileStatement: 'DoWhileStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForInStatement: 'ForInStatement',
    ForOfStatement: 'ForOfStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    GeneratorExpression: 'GeneratorExpression',
    // CAUTION: It's deferred to ES7.
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    ImportExpression: 'ImportExpression',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    ModuleSpecifier: 'ModuleSpecifier',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    Program: 'Program',
    Property: 'Property',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchStatement: 'SwitchStatement',
    SwitchCase: 'SwitchCase',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
  };
  VisitorKeys = {
    AssignmentExpression: ['left', 'right'],
    AssignmentPattern: ['left', 'right'],
    ArrayExpression: ['elements'],
    ArrayPattern: ['elements'],
    ArrowFunctionExpression: ['params', 'body'],
    AwaitExpression: ['argument'],
    // CAUTION: It's deferred to ES7.
    BlockStatement: ['body'],
    BinaryExpression: ['left', 'right'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments'],
    CatchClause: ['param', 'body'],
    ClassBody: ['body'],
    ClassDeclaration: ['id', 'superClass', 'body'],
    ClassExpression: ['id', 'superClass', 'body'],
    ComprehensionBlock: ['left', 'right'],
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ['body', 'test'],
    EmptyStatement: [],
    ExportAllDeclaration: ['source'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
    ExportSpecifier: ['exported', 'local'],
    ExpressionStatement: ['expression'],
    ForStatement: ['init', 'test', 'update', 'body'],
    ForInStatement: ['left', 'right', 'body'],
    ForOfStatement: ['left', 'right', 'body'],
    FunctionDeclaration: ['id', 'params', 'body'],
    FunctionExpression: ['id', 'params', 'body'],
    GeneratorExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    Identifier: [],
    IfStatement: ['test', 'consequent', 'alternate'],
    ImportExpression: ['source'],
    ImportDeclaration: ['specifiers', 'source'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['imported', 'local'],
    Literal: [],
    LabeledStatement: ['label', 'body'],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    MetaProperty: ['meta', 'property'],
    MethodDefinition: ['key', 'value'],
    ModuleSpecifier: [],
    NewExpression: ['callee', 'arguments'],
    ObjectExpression: ['properties'],
    ObjectPattern: ['properties'],
    Program: ['body'],
    Property: ['key', 'value'],
    RestElement: ['argument'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    SpreadElement: ['argument'],
    Super: [],
    SwitchStatement: ['discriminant', 'cases'],
    SwitchCase: ['test', 'consequent'],
    TaggedTemplateExpression: ['tag', 'quasi'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    YieldExpression: ['argument']
  };

  // unique id
  BREAK = {};
  SKIP = {};
  REMOVE = {};
  VisitorOption = {
    Break: BREAK,
    Skip: SKIP,
    Remove: REMOVE
  };
  function Reference(parent, key) {
    this.parent = parent;
    this.key = key;
  }
  Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
  };
  Reference.prototype.remove = function remove() {
    if (Array.isArray(this.parent)) {
      this.parent.splice(this.key, 1);
      return true;
    } else {
      this.replace(null);
      return false;
    }
  };
  function Element(node, path, wrap, ref) {
    this.node = node;
    this.path = path;
    this.wrap = wrap;
    this.ref = ref;
  }
  function Controller() {}

  // API:
  // return property path array from root to current node
  Controller.prototype.path = function path() {
    var i, iz, j, jz, result, element;
    function addToPath(result, path) {
      if (Array.isArray(path)) {
        for (j = 0, jz = path.length; j < jz; ++j) {
          result.push(path[j]);
        }
      } else {
        result.push(path);
      }
    }

    // root node
    if (!this.__current.path) {
      return null;
    }

    // first node is sentinel, second node is root element
    result = [];
    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
      element = this.__leavelist[i];
      addToPath(result, element.path);
    }
    addToPath(result, this.__current.path);
    return result;
  };

  // API:
  // return type of current node
  Controller.prototype.type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
  };

  // API:
  // return array of parent elements
  Controller.prototype.parents = function parents() {
    var i, iz, result;

    // first node is sentinel
    result = [];
    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
      result.push(this.__leavelist[i].node);
    }
    return result;
  };

  // API:
  // return current node
  Controller.prototype.current = function current() {
    return this.__current.node;
  };
  Controller.prototype.__execute = function __execute(callback, element) {
    var previous, result;
    result = undefined;
    previous = this.__current;
    this.__current = element;
    this.__state = null;
    if (callback) {
      result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }
    this.__current = previous;
    return result;
  };

  // API:
  // notify control skip / break
  Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
  };

  // API:
  // skip child nodes of current node
  Controller.prototype.skip = function () {
    this.notify(SKIP);
  };

  // API:
  // break traversals
  Controller.prototype['break'] = function () {
    this.notify(BREAK);
  };

  // API:
  // remove node
  Controller.prototype.remove = function () {
    this.notify(REMOVE);
  };
  Controller.prototype.__initialize = function (root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;
    if (visitor.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof visitor.fallback === 'function') {
      this.__fallback = visitor.fallback;
    }
    this.__keys = VisitorKeys;
    if (visitor.keys) {
      this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
    }
  };
  function isNode(node) {
    if (node == null) {
      return false;
    }
    return typeof node === 'object' && typeof node.type === 'string';
  }
  function isProperty(nodeType, key) {
    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
  }
  Controller.prototype.traverse = function traverse(root, visitor) {
    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
    this.__initialize(root, visitor);
    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));
    while (worklist.length) {
      element = worklist.pop();
      if (element === sentinel) {
        element = leavelist.pop();
        ret = this.__execute(visitor.leave, element);
        if (this.__state === BREAK || ret === BREAK) {
          return;
        }
        continue;
      }
      if (element.node) {
        ret = this.__execute(visitor.enter, element);
        if (this.__state === BREAK || ret === BREAK) {
          return;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || ret === SKIP) {
          continue;
        }
        node = element.node;
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', null);
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, null);
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, null));
          }
        }
      }
    }
  };
  Controller.prototype.replace = function replace(root, visitor) {
    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
    function removeElem(element) {
      var i, key, nextElem, parent;
      if (element.ref.remove()) {
        // When the reference is an element of an array.
        key = element.ref.key;
        parent = element.ref.parent;

        // If removed from array, then decrease following items' keys.
        i = worklist.length;
        while (i--) {
          nextElem = worklist[i];
          if (nextElem.ref && nextElem.ref.parent === parent) {
            if (nextElem.ref.key < key) {
              break;
            }
            --nextElem.ref.key;
          }
        }
      }
    }
    this.__initialize(root, visitor);
    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    outer = {
      root: root
    };
    element = new Element(root, null, null, new Reference(outer, 'root'));
    worklist.push(element);
    leavelist.push(element);
    while (worklist.length) {
      element = worklist.pop();
      if (element === sentinel) {
        element = leavelist.pop();
        target = this.__execute(visitor.leave, element);

        // node may be replaced with null,
        // so distinguish between undefined and null in this place
        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        continue;
      }
      target = this.__execute(visitor.enter, element);

      // node may be replaced with null,
      // so distinguish between undefined and null in this place
      if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
        // replace
        element.ref.replace(target);
        element.node = target;
      }
      if (this.__state === REMOVE || target === REMOVE) {
        removeElem(element);
        element.node = null;
      }
      if (this.__state === BREAK || target === BREAK) {
        return outer.root;
      }

      // node may be null
      node = element.node;
      if (!node) {
        continue;
      }
      worklist.push(sentinel);
      leavelist.push(element);
      if (this.__state === SKIP || target === SKIP) {
        continue;
      }
      nodeType = node.type || element.wrap;
      candidates = this.__keys[nodeType];
      if (!candidates) {
        if (this.__fallback) {
          candidates = this.__fallback(node);
        } else {
          throw new Error('Unknown node type ' + nodeType + '.');
        }
      }
      current = candidates.length;
      while ((current -= 1) >= 0) {
        key = candidates[current];
        candidate = node[key];
        if (!candidate) {
          continue;
        }
        if (Array.isArray(candidate)) {
          current2 = candidate.length;
          while ((current2 -= 1) >= 0) {
            if (!candidate[current2]) {
              continue;
            }
            if (isProperty(nodeType, candidates[current])) {
              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
            } else if (isNode(candidate[current2])) {
              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
            } else {
              continue;
            }
            worklist.push(element);
          }
        } else if (isNode(candidate)) {
          worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      }
    }
    return outer.root;
  };
  function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
  }
  function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
  }
  function extendCommentRange(comment, tokens) {
    var target;
    target = upperBound(tokens, function search(token) {
      return token.range[0] > comment.range[0];
    });
    comment.extendedRange = [comment.range[0], comment.range[1]];
    if (target !== tokens.length) {
      comment.extendedRange[1] = tokens[target].range[0];
    }
    target -= 1;
    if (target >= 0) {
      comment.extendedRange[0] = tokens[target].range[1];
    }
    return comment;
  }
  function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [],
      comment,
      len,
      i,
      cursor;
    if (!tree.range) {
      throw new Error('attachComments needs range information');
    }

    // tokens array is empty, we attach comments to tree as 'leadingComments'
    if (!tokens.length) {
      if (providedComments.length) {
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }
        tree.leadingComments = comments;
      }
      return tree;
    }
    for (i = 0, len = providedComments.length; i < len; i += 1) {
      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman's implementation.
    cursor = 0;
    traverse(tree, {
      enter: function (node) {
        var comment;
        while (cursor < comments.length) {
          comment = comments[cursor];
          if (comment.extendedRange[1] > node.range[0]) {
            break;
          }
          if (comment.extendedRange[1] === node.range[0]) {
            if (!node.leadingComments) {
              node.leadingComments = [];
            }
            node.leadingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        }

        // already out of owned node
        if (cursor === comments.length) {
          return VisitorOption.Break;
        }
        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    cursor = 0;
    traverse(tree, {
      leave: function (node) {
        var comment;
        while (cursor < comments.length) {
          comment = comments[cursor];
          if (node.range[1] < comment.extendedRange[0]) {
            break;
          }
          if (node.range[1] === comment.extendedRange[0]) {
            if (!node.trailingComments) {
              node.trailingComments = [];
            }
            node.trailingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        }

        // already out of owned node
        if (cursor === comments.length) {
          return VisitorOption.Break;
        }
        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    return tree;
  }
  exports.version = (__webpack_require__(79).version);
  exports.Syntax = Syntax;
  exports.traverse = traverse;
  exports.replace = replace;
  exports.attachComments = attachComments;
  exports.VisitorKeys = VisitorKeys;
  exports.VisitorOption = VisitorOption;
  exports.Controller = Controller;
  exports.cloneEnvironment = function () {
    return clone({});
  };
  return exports;
})(exports);
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 79 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"estraverse","description":"ECMAScript JS AST traversal functions","homepage":"https://github.com/estools/estraverse","main":"estraverse.js","version":"4.3.0","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"http://github.com/Constellation"}],"repository":{"type":"git","url":"http://github.com/estools/estraverse.git"},"devDependencies":{"babel-preset-env":"^1.6.1","babel-register":"^6.3.13","chai":"^2.1.1","espree":"^1.11.0","gulp":"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.3.0","jshint":"^2.5.6","mocha":"^2.1.0"},"license":"BSD-2-Clause","scripts":{"test":"npm run-script lint && npm run-script unit-test","lint":"jshint estraverse.js","unit-test":"mocha --compilers js:babel-register"}}');

/***/ }),
/* 80 */
/***/ ((module) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


const READ = 0x1;
const WRITE = 0x2;
const RW = READ | WRITE;

/**
 * A Reference represents a single occurrence of an identifier in code.
 * @class Reference
 */
class Reference {
  constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
    /**
     * Identifier syntax node.
     * @member {espreeIdentifier} Reference#identifier
     */
    this.identifier = ident;

    /**
     * Reference to the enclosing Scope.
     * @member {Scope} Reference#from
     */
    this.from = scope;

    /**
     * Whether the reference comes from a dynamic scope (such as 'eval',
     * 'with', etc.), and may be trapped by dynamic scopes.
     * @member {boolean} Reference#tainted
     */
    this.tainted = false;

    /**
     * The variable this reference is resolved with.
     * @member {Variable} Reference#resolved
     */
    this.resolved = null;

    /**
     * The read-write mode of the reference. (Value is one of {@link
     * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).
     * @member {number} Reference#flag
     * @private
     */
    this.flag = flag;
    if (this.isWrite()) {
      /**
       * If reference is writeable, this is the tree being written to it.
       * @member {espreeNode} Reference#writeExpr
       */
      this.writeExpr = writeExpr;

      /**
       * Whether the Reference might refer to a partial value of writeExpr.
       * @member {boolean} Reference#partial
       */
      this.partial = partial;

      /**
       * Whether the Reference is to write of initialization.
       * @member {boolean} Reference#init
       */
      this.init = init;
    }
    this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }

  /**
   * Whether the reference is static.
   * @method Reference#isStatic
   * @returns {boolean} static
   */
  isStatic() {
    return !this.tainted && this.resolved && this.resolved.scope.isStatic();
  }

  /**
   * Whether the reference is writeable.
   * @method Reference#isWrite
   * @returns {boolean} write
   */
  isWrite() {
    return !!(this.flag & Reference.WRITE);
  }

  /**
   * Whether the reference is readable.
   * @method Reference#isRead
   * @returns {boolean} read
   */
  isRead() {
    return !!(this.flag & Reference.READ);
  }

  /**
   * Whether the reference is read-only.
   * @method Reference#isReadOnly
   * @returns {boolean} read only
   */
  isReadOnly() {
    return this.flag === Reference.READ;
  }

  /**
   * Whether the reference is write-only.
   * @method Reference#isWriteOnly
   * @returns {boolean} write only
   */
  isWriteOnly() {
    return this.flag === Reference.WRITE;
  }

  /**
   * Whether the reference is read-write.
   * @method Reference#isReadWrite
   * @returns {boolean} read write
   */
  isReadWrite() {
    return this.flag === Reference.RW;
  }
}

/**
 * @constant Reference.READ
 * @private
 */
Reference.READ = READ;

/**
 * @constant Reference.WRITE
 * @private
 */
Reference.WRITE = WRITE;

/**
 * @constant Reference.RW
 * @private
 */
Reference.RW = RW;
module.exports = Reference;

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 81 */
/***/ ((module) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/**
 * A Variable represents a locally scoped identifier. These include arguments to
 * functions.
 * @class Variable
 */
class Variable {
  constructor(name, scope) {
    /**
     * The variable name, as given in the source code.
     * @member {String} Variable#name
     */
    this.name = name;

    /**
     * List of defining occurrences of this variable (like in 'var ...'
     * statements or as parameter), as AST nodes.
     * @member {espree.Identifier[]} Variable#identifiers
     */
    this.identifiers = [];

    /**
     * List of {@link Reference|references} of this variable (excluding parameter entries)
     * in its defining scope and all nested scopes. For defining
     * occurrences only see {@link Variable#defs}.
     * @member {Reference[]} Variable#references
     */
    this.references = [];

    /**
     * List of defining occurrences of this variable (like in 'var ...'
     * statements or as parameter), as custom objects.
     * @member {Definition[]} Variable#defs
     */
    this.defs = [];
    this.tainted = false;

    /**
     * Whether this is a stack variable.
     * @member {boolean} Variable#stack
     */
    this.stack = true;

    /**
     * Reference to the enclosing Scope.
     * @member {Scope} Variable#scope
     */
    this.scope = scope;
  }
}
Variable.CatchClause = "CatchClause";
Variable.Parameter = "Parameter";
Variable.FunctionName = "FunctionName";
Variable.ClassName = "ClassName";
Variable.Variable = "Variable";
Variable.ImportBinding = "ImportBinding";
Variable.TDZ = "TDZ";
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
module.exports = Variable;

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 82 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


const Variable = __webpack_require__(81);

/**
 * @class Definition
 */
class Definition {
  constructor(type, name, node, parent, index, kind) {
    /**
     * @member {String} Definition#type - type of the occurrence (e.g. "Parameter", "Variable", ...).
     */
    this.type = type;

    /**
     * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.
     */
    this.name = name;

    /**
     * @member {espree.Node} Definition#node - the enclosing node of the identifier.
     */
    this.node = node;

    /**
     * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.
     */
    this.parent = parent;

    /**
     * @member {Number?} Definition#index - the index in the declaration statement.
     */
    this.index = index;

    /**
     * @member {String?} Definition#kind - the kind of the declaration statement.
     */
    this.kind = kind;
  }
}

/**
 * @class ParameterDefinition
 */
class ParameterDefinition extends Definition {
  constructor(name, node, index, rest) {
    super(Variable.Parameter, name, node, null, index, null);

    /**
     * Whether the parameter definition is a part of a rest parameter.
     * @member {boolean} ParameterDefinition#rest
     */
    this.rest = rest;
  }
}
module.exports = {
  ParameterDefinition,
  Definition
};

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 83 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* eslint-disable no-underscore-dangle */
/* eslint-disable no-undefined */
const Syntax = (__webpack_require__(78).Syntax);
const esrecurse = __webpack_require__(84);
const Reference = __webpack_require__(80);
const Variable = __webpack_require__(81);
const PatternVisitor = __webpack_require__(87);
const definition = __webpack_require__(82);
const assert = __webpack_require__(3);
const ParameterDefinition = definition.ParameterDefinition;
const Definition = definition.Definition;

/**
 * Traverse identifier in pattern
 * @param {Object} options - options
 * @param {pattern} rootPattern - root pattern
 * @param {Refencer} referencer - referencer
 * @param {callback} callback - callback
 * @returns {void}
 */
function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
  // Call the callback at left hand identifier nodes, and Collect right hand nodes.
  const visitor = new PatternVisitor(options, rootPattern, callback);
  visitor.visit(rootPattern);

  // Process the right hand nodes recursively.
  if (referencer !== null && referencer !== undefined) {
    visitor.rightHandNodes.forEach(referencer.visit, referencer);
  }
}

// Importing ImportDeclaration.
// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation
// https://github.com/estree/estree/blob/master/es6.md#importdeclaration
// FIXME: Now, we don't create module environment, because the context is
// implementation dependent.

class Importer extends esrecurse.Visitor {
  constructor(declaration, referencer) {
    super(null, referencer.options);
    this.declaration = declaration;
    this.referencer = referencer;
  }
  visitImport(id, specifier) {
    this.referencer.visitPattern(id, pattern => {
      this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null));
    });
  }
  ImportNamespaceSpecifier(node) {
    const local = node.local || node.id;
    if (local) {
      this.visitImport(local, node);
    }
  }
  ImportDefaultSpecifier(node) {
    const local = node.local || node.id;
    this.visitImport(local, node);
  }
  ImportSpecifier(node) {
    const local = node.local || node.id;
    if (node.name) {
      this.visitImport(node.name, node);
    } else {
      this.visitImport(local, node);
    }
  }
}

// Referencing variables and creating bindings.
class Referencer extends esrecurse.Visitor {
  constructor(options, scopeManager) {
    super(null, options);
    this.options = options;
    this.scopeManager = scopeManager;
    this.parent = null;
    this.isInnerMethodDefinition = false;
  }
  currentScope() {
    return this.scopeManager.__currentScope;
  }
  close(node) {
    while (this.currentScope() && node === this.currentScope().block) {
      this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
    }
  }
  pushInnerMethodDefinition(isInnerMethodDefinition) {
    const previous = this.isInnerMethodDefinition;
    this.isInnerMethodDefinition = isInnerMethodDefinition;
    return previous;
  }
  popInnerMethodDefinition(isInnerMethodDefinition) {
    this.isInnerMethodDefinition = isInnerMethodDefinition;
  }
  materializeTDZScope(node, iterationNode) {
    // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation
    // TDZ scope hides the declaration's names.
    this.scopeManager.__nestTDZScope(node, iterationNode);
    this.visitVariableDeclaration(this.currentScope(), Variable.TDZ, iterationNode.left, 0, true);
  }
  materializeIterationScope(node) {
    // Generate iteration scope for upper ForIn/ForOf Statements.
    const letOrConstDecl = node.left;
    this.scopeManager.__nestForScope(node);
    this.visitVariableDeclaration(this.currentScope(), Variable.Variable, letOrConstDecl, 0);
    this.visitPattern(letOrConstDecl.declarations[0].id, pattern => {
      this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
    });
  }
  referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
    const scope = this.currentScope();
    assignments.forEach(assignment => {
      scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
    });
  }
  visitPattern(node, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {
        processRightHandNodes: false
      };
    }
    traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
  }
  visitFunction(node) {
    let i, iz;

    // FunctionDeclaration name is defined in upper scope
    // NOTE: Not referring variableScope. It is intended.
    // Since
    //  in ES5, FunctionDeclaration should be in FunctionBody.
    //  in ES6, FunctionDeclaration should be block scoped.

    if (node.type === Syntax.FunctionDeclaration) {
      // id is defined in upper scope
      this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));
    }

    // FunctionExpression with name creates its special scope;
    // FunctionExpressionNameScope.
    if (node.type === Syntax.FunctionExpression && node.id) {
      this.scopeManager.__nestFunctionExpressionNameScope(node);
    }

    // Consider this function is in the MethodDefinition.
    this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
    const that = this;

    /**
     * Visit pattern callback
     * @param {pattern} pattern - pattern
     * @param {Object} info - info
     * @returns {void}
     */
    function visitPatternCallback(pattern, info) {
      that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));
      that.referencingDefaultValue(pattern, info.assignments, null, true);
    }

    // Process parameter declarations.
    for (i = 0, iz = node.params.length; i < iz; ++i) {
      this.visitPattern(node.params[i], {
        processRightHandNodes: true
      }, visitPatternCallback);
    }

    // if there's a rest argument, add that
    if (node.rest) {
      this.visitPattern({
        type: "RestElement",
        argument: node.rest
      }, pattern => {
        this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));
      });
    }

    // In TypeScript there are a number of function-like constructs which have no body,
    // so check it exists before traversing
    if (node.body) {
      // Skip BlockStatement to prevent creating BlockStatement scope.
      if (node.body.type === Syntax.BlockStatement) {
        this.visitChildren(node.body);
      } else {
        this.visit(node.body);
      }
    }
    this.close(node);
  }
  visitClass(node) {
    if (node.type === Syntax.ClassDeclaration) {
      this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));
    }

    // FIXME: Maybe consider TDZ.
    this.visit(node.superClass);
    this.scopeManager.__nestClassScope(node);
    if (node.id) {
      this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));
    }
    this.visit(node.body);
    this.close(node);
  }
  visitProperty(node) {
    let previous;
    if (node.computed) {
      this.visit(node.key);
    }
    const isMethodDefinition = node.type === Syntax.MethodDefinition;
    if (isMethodDefinition) {
      previous = this.pushInnerMethodDefinition(true);
    }
    this.visit(node.value);
    if (isMethodDefinition) {
      this.popInnerMethodDefinition(previous);
    }
  }
  visitForIn(node) {
    if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
      this.materializeTDZScope(node.right, node);
      this.visit(node.right);
      this.close(node.right);
      this.materializeIterationScope(node);
      this.visit(node.body);
      this.close(node);
    } else {
      if (node.left.type === Syntax.VariableDeclaration) {
        this.visit(node.left);
        this.visitPattern(node.left.declarations[0].id, pattern => {
          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
        });
      } else {
        this.visitPattern(node.left, {
          processRightHandNodes: true
        }, (pattern, info) => {
          let maybeImplicitGlobal = null;
          if (!this.currentScope().isStrict) {
            maybeImplicitGlobal = {
              pattern,
              node
            };
          }
          this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
        });
      }
      this.visit(node.right);
      this.visit(node.body);
    }
  }
  visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
    // If this was called to initialize a TDZ scope, this needs to make definitions, but doesn't make references.
    const decl = node.declarations[index];
    const init = decl.init;
    this.visitPattern(decl.id, {
      processRightHandNodes: !fromTDZ
    }, (pattern, info) => {
      variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));
      if (!fromTDZ) {
        this.referencingDefaultValue(pattern, info.assignments, null, true);
      }
      if (init) {
        this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
      }
    });
  }
  AssignmentExpression(node) {
    if (PatternVisitor.isPattern(node.left)) {
      if (node.operator === "=") {
        this.visitPattern(node.left, {
          processRightHandNodes: true
        }, (pattern, info) => {
          let maybeImplicitGlobal = null;
          if (!this.currentScope().isStrict) {
            maybeImplicitGlobal = {
              pattern,
              node
            };
          }
          this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
        });
      } else {
        this.currentScope().__referencing(node.left, Reference.RW, node.right);
      }
    } else {
      this.visit(node.left);
    }
    this.visit(node.right);
  }
  CatchClause(node) {
    this.scopeManager.__nestCatchScope(node);
    this.visitPattern(node.param, {
      processRightHandNodes: true
    }, (pattern, info) => {
      this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));
      this.referencingDefaultValue(pattern, info.assignments, null, true);
    });
    this.visit(node.body);
    this.close(node);
  }
  Program(node) {
    this.scopeManager.__nestGlobalScope(node);
    if (this.scopeManager.__isNodejsScope()) {
      // Force strictness of GlobalScope to false when using node.js scope.
      this.currentScope().isStrict = false;
      this.scopeManager.__nestFunctionScope(node, false);
    }
    if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
      this.scopeManager.__nestModuleScope(node);
    }
    if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
      this.currentScope().isStrict = true;
    }
    this.visitChildren(node);
    this.close(node);
  }
  Identifier(node) {
    this.currentScope().__referencing(node);
  }
  UpdateExpression(node) {
    if (PatternVisitor.isPattern(node.argument)) {
      this.currentScope().__referencing(node.argument, Reference.RW, null);
    } else {
      this.visitChildren(node);
    }
  }
  MemberExpression(node) {
    this.visit(node.object);
    if (node.computed) {
      this.visit(node.property);
    }
  }
  Property(node) {
    this.visitProperty(node);
  }
  MethodDefinition(node) {
    this.visitProperty(node);
  }
  BreakStatement() {} // eslint-disable-line class-methods-use-this

  ContinueStatement() {} // eslint-disable-line class-methods-use-this

  LabeledStatement(node) {
    this.visit(node.body);
  }
  ForStatement(node) {
    // Create ForStatement declaration.
    // NOTE: In ES6, ForStatement dynamically generates
    // per iteration environment. However, escope is
    // a static analyzer, we only generate one scope for ForStatement.
    if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
      this.scopeManager.__nestForScope(node);
    }
    this.visitChildren(node);
    this.close(node);
  }
  ClassExpression(node) {
    this.visitClass(node);
  }
  ClassDeclaration(node) {
    this.visitClass(node);
  }
  CallExpression(node) {
    // Check this is direct call to eval
    if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
      // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and
      // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.
      this.currentScope().variableScope.__detectEval();
    }
    this.visitChildren(node);
  }
  BlockStatement(node) {
    if (this.scopeManager.__isES6()) {
      this.scopeManager.__nestBlockScope(node);
    }
    this.visitChildren(node);
    this.close(node);
  }
  ThisExpression() {
    this.currentScope().variableScope.__detectThis();
  }
  WithStatement(node) {
    this.visit(node.object);

    // Then nest scope for WithStatement.
    this.scopeManager.__nestWithScope(node);
    this.visit(node.body);
    this.close(node);
  }
  VariableDeclaration(node) {
    const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
    for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
      const decl = node.declarations[i];
      this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
      if (decl.init) {
        this.visit(decl.init);
      }
    }
  }

  // sec 13.11.8
  SwitchStatement(node) {
    this.visit(node.discriminant);
    if (this.scopeManager.__isES6()) {
      this.scopeManager.__nestSwitchScope(node);
    }
    for (let i = 0, iz = node.cases.length; i < iz; ++i) {
      this.visit(node.cases[i]);
    }
    this.close(node);
  }
  FunctionDeclaration(node) {
    this.visitFunction(node);
  }
  FunctionExpression(node) {
    this.visitFunction(node);
  }
  ForOfStatement(node) {
    this.visitForIn(node);
  }
  ForInStatement(node) {
    this.visitForIn(node);
  }
  ArrowFunctionExpression(node) {
    this.visitFunction(node);
  }
  ImportDeclaration(node) {
    assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
    const importer = new Importer(node, this);
    importer.visit(node);
  }
  visitExportDeclaration(node) {
    if (node.source) {
      return;
    }
    if (node.declaration) {
      this.visit(node.declaration);
      return;
    }
    this.visitChildren(node);
  }
  ExportDeclaration(node) {
    this.visitExportDeclaration(node);
  }
  ExportNamedDeclaration(node) {
    this.visitExportDeclaration(node);
  }
  ExportSpecifier(node) {
    const local = node.id || node.local;
    this.visit(local);
  }
  MetaProperty() {// eslint-disable-line class-methods-use-this

    // do nothing.
  }
}
module.exports = Referencer;

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  var estraverse = __webpack_require__(85);
  function isNode(node) {
    if (node == null) {
      return false;
    }
    return typeof node === 'object' && typeof node.type === 'string';
  }
  function isProperty(nodeType, key) {
    return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
  }
  function Visitor(visitor, options) {
    options = options || {};
    this.__visitor = visitor || this;
    this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
    if (options.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof options.fallback === 'function') {
      this.__fallback = options.fallback;
    }
  }

  /* Default method for visiting children.
   * When you need to call default visiting operation inside custom visiting
   * operation, you can use it with `this.visitChildren(node)`.
   */
  Visitor.prototype.visitChildren = function (node) {
    var type, children, i, iz, j, jz, child;
    if (node == null) {
      return;
    }
    type = node.type || estraverse.Syntax.Property;
    children = this.__childVisitorKeys[type];
    if (!children) {
      if (this.__fallback) {
        children = this.__fallback(node);
      } else {
        throw new Error('Unknown node type ' + type + '.');
      }
    }
    for (i = 0, iz = children.length; i < iz; ++i) {
      child = node[children[i]];
      if (child) {
        if (Array.isArray(child)) {
          for (j = 0, jz = child.length; j < jz; ++j) {
            if (child[j]) {
              if (isNode(child[j]) || isProperty(type, children[i])) {
                this.visit(child[j]);
              }
            }
          }
        } else if (isNode(child)) {
          this.visit(child);
        }
      }
    }
  };

  /* Dispatching node. */
  Visitor.prototype.visit = function (node) {
    var type;
    if (node == null) {
      return;
    }
    type = node.type || estraverse.Syntax.Property;
    if (this.__visitor[type]) {
      this.__visitor[type].call(this, node);
      return;
    }
    this.visitChildren(node);
  };
  exports.version = __webpack_require__(86).version;
  exports.Visitor = Visitor;
  exports.visit = function (node, visitor, options) {
    var v = new Visitor(visitor, options);
    v.visit(node);
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports) => {

/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true*/
(function clone(exports) {
  'use strict';

  var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
  function deepCopy(obj) {
    var ret = {},
      key,
      val;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        val = obj[key];
        if (typeof val === 'object' && val !== null) {
          ret[key] = deepCopy(val);
        } else {
          ret[key] = val;
        }
      }
    }
    return ret;
  }

  // based on LLVM libc++ upper_bound / lower_bound
  // MIT License

  function upperBound(array, func) {
    var diff, len, i, current;
    len = array.length;
    i = 0;
    while (len) {
      diff = len >>> 1;
      current = i + diff;
      if (func(array[current])) {
        len = diff;
      } else {
        i = current + 1;
        len -= diff + 1;
      }
    }
    return i;
  }
  Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    // CAUTION: It's deferred to ES7.
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ChainExpression: 'ChainExpression',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ComprehensionBlock: 'ComprehensionBlock',
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: 'ComprehensionExpression',
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DebuggerStatement: 'DebuggerStatement',
    DirectiveStatement: 'DirectiveStatement',
    DoWhileStatement: 'DoWhileStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForInStatement: 'ForInStatement',
    ForOfStatement: 'ForOfStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    GeneratorExpression: 'GeneratorExpression',
    // CAUTION: It's deferred to ES7.
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    ImportExpression: 'ImportExpression',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    ModuleSpecifier: 'ModuleSpecifier',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    PrivateIdentifier: 'PrivateIdentifier',
    Program: 'Program',
    Property: 'Property',
    PropertyDefinition: 'PropertyDefinition',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchStatement: 'SwitchStatement',
    SwitchCase: 'SwitchCase',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
  };
  VisitorKeys = {
    AssignmentExpression: ['left', 'right'],
    AssignmentPattern: ['left', 'right'],
    ArrayExpression: ['elements'],
    ArrayPattern: ['elements'],
    ArrowFunctionExpression: ['params', 'body'],
    AwaitExpression: ['argument'],
    // CAUTION: It's deferred to ES7.
    BlockStatement: ['body'],
    BinaryExpression: ['left', 'right'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments'],
    CatchClause: ['param', 'body'],
    ChainExpression: ['expression'],
    ClassBody: ['body'],
    ClassDeclaration: ['id', 'superClass', 'body'],
    ClassExpression: ['id', 'superClass', 'body'],
    ComprehensionBlock: ['left', 'right'],
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ['body', 'test'],
    EmptyStatement: [],
    ExportAllDeclaration: ['source'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
    ExportSpecifier: ['exported', 'local'],
    ExpressionStatement: ['expression'],
    ForStatement: ['init', 'test', 'update', 'body'],
    ForInStatement: ['left', 'right', 'body'],
    ForOfStatement: ['left', 'right', 'body'],
    FunctionDeclaration: ['id', 'params', 'body'],
    FunctionExpression: ['id', 'params', 'body'],
    GeneratorExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    Identifier: [],
    IfStatement: ['test', 'consequent', 'alternate'],
    ImportExpression: ['source'],
    ImportDeclaration: ['specifiers', 'source'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['imported', 'local'],
    Literal: [],
    LabeledStatement: ['label', 'body'],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    MetaProperty: ['meta', 'property'],
    MethodDefinition: ['key', 'value'],
    ModuleSpecifier: [],
    NewExpression: ['callee', 'arguments'],
    ObjectExpression: ['properties'],
    ObjectPattern: ['properties'],
    PrivateIdentifier: [],
    Program: ['body'],
    Property: ['key', 'value'],
    PropertyDefinition: ['key', 'value'],
    RestElement: ['argument'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    SpreadElement: ['argument'],
    Super: [],
    SwitchStatement: ['discriminant', 'cases'],
    SwitchCase: ['test', 'consequent'],
    TaggedTemplateExpression: ['tag', 'quasi'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    YieldExpression: ['argument']
  };

  // unique id
  BREAK = {};
  SKIP = {};
  REMOVE = {};
  VisitorOption = {
    Break: BREAK,
    Skip: SKIP,
    Remove: REMOVE
  };
  function Reference(parent, key) {
    this.parent = parent;
    this.key = key;
  }
  Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
  };
  Reference.prototype.remove = function remove() {
    if (Array.isArray(this.parent)) {
      this.parent.splice(this.key, 1);
      return true;
    } else {
      this.replace(null);
      return false;
    }
  };
  function Element(node, path, wrap, ref) {
    this.node = node;
    this.path = path;
    this.wrap = wrap;
    this.ref = ref;
  }
  function Controller() {}

  // API:
  // return property path array from root to current node
  Controller.prototype.path = function path() {
    var i, iz, j, jz, result, element;
    function addToPath(result, path) {
      if (Array.isArray(path)) {
        for (j = 0, jz = path.length; j < jz; ++j) {
          result.push(path[j]);
        }
      } else {
        result.push(path);
      }
    }

    // root node
    if (!this.__current.path) {
      return null;
    }

    // first node is sentinel, second node is root element
    result = [];
    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
      element = this.__leavelist[i];
      addToPath(result, element.path);
    }
    addToPath(result, this.__current.path);
    return result;
  };

  // API:
  // return type of current node
  Controller.prototype.type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
  };

  // API:
  // return array of parent elements
  Controller.prototype.parents = function parents() {
    var i, iz, result;

    // first node is sentinel
    result = [];
    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
      result.push(this.__leavelist[i].node);
    }
    return result;
  };

  // API:
  // return current node
  Controller.prototype.current = function current() {
    return this.__current.node;
  };
  Controller.prototype.__execute = function __execute(callback, element) {
    var previous, result;
    result = undefined;
    previous = this.__current;
    this.__current = element;
    this.__state = null;
    if (callback) {
      result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }
    this.__current = previous;
    return result;
  };

  // API:
  // notify control skip / break
  Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
  };

  // API:
  // skip child nodes of current node
  Controller.prototype.skip = function () {
    this.notify(SKIP);
  };

  // API:
  // break traversals
  Controller.prototype['break'] = function () {
    this.notify(BREAK);
  };

  // API:
  // remove node
  Controller.prototype.remove = function () {
    this.notify(REMOVE);
  };
  Controller.prototype.__initialize = function (root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;
    if (visitor.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof visitor.fallback === 'function') {
      this.__fallback = visitor.fallback;
    }
    this.__keys = VisitorKeys;
    if (visitor.keys) {
      this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
    }
  };
  function isNode(node) {
    if (node == null) {
      return false;
    }
    return typeof node === 'object' && typeof node.type === 'string';
  }
  function isProperty(nodeType, key) {
    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
  }
  function candidateExistsInLeaveList(leavelist, candidate) {
    for (var i = leavelist.length - 1; i >= 0; --i) {
      if (leavelist[i].node === candidate) {
        return true;
      }
    }
    return false;
  }
  Controller.prototype.traverse = function traverse(root, visitor) {
    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
    this.__initialize(root, visitor);
    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));
    while (worklist.length) {
      element = worklist.pop();
      if (element === sentinel) {
        element = leavelist.pop();
        ret = this.__execute(visitor.leave, element);
        if (this.__state === BREAK || ret === BREAK) {
          return;
        }
        continue;
      }
      if (element.node) {
        ret = this.__execute(visitor.enter, element);
        if (this.__state === BREAK || ret === BREAK) {
          return;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || ret === SKIP) {
          continue;
        }
        node = element.node;
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', null);
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, null);
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            if (candidateExistsInLeaveList(leavelist, candidate)) {
              continue;
            }
            worklist.push(new Element(candidate, key, null, null));
          }
        }
      }
    }
  };
  Controller.prototype.replace = function replace(root, visitor) {
    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
    function removeElem(element) {
      var i, key, nextElem, parent;
      if (element.ref.remove()) {
        // When the reference is an element of an array.
        key = element.ref.key;
        parent = element.ref.parent;

        // If removed from array, then decrease following items' keys.
        i = worklist.length;
        while (i--) {
          nextElem = worklist[i];
          if (nextElem.ref && nextElem.ref.parent === parent) {
            if (nextElem.ref.key < key) {
              break;
            }
            --nextElem.ref.key;
          }
        }
      }
    }
    this.__initialize(root, visitor);
    sentinel = {};

    // reference
    worklist = this.__worklist;
    leavelist = this.__leavelist;

    // initialize
    outer = {
      root: root
    };
    element = new Element(root, null, null, new Reference(outer, 'root'));
    worklist.push(element);
    leavelist.push(element);
    while (worklist.length) {
      element = worklist.pop();
      if (element === sentinel) {
        element = leavelist.pop();
        target = this.__execute(visitor.leave, element);

        // node may be replaced with null,
        // so distinguish between undefined and null in this place
        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        continue;
      }
      target = this.__execute(visitor.enter, element);

      // node may be replaced with null,
      // so distinguish between undefined and null in this place
      if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
        // replace
        element.ref.replace(target);
        element.node = target;
      }
      if (this.__state === REMOVE || target === REMOVE) {
        removeElem(element);
        element.node = null;
      }
      if (this.__state === BREAK || target === BREAK) {
        return outer.root;
      }

      // node may be null
      node = element.node;
      if (!node) {
        continue;
      }
      worklist.push(sentinel);
      leavelist.push(element);
      if (this.__state === SKIP || target === SKIP) {
        continue;
      }
      nodeType = node.type || element.wrap;
      candidates = this.__keys[nodeType];
      if (!candidates) {
        if (this.__fallback) {
          candidates = this.__fallback(node);
        } else {
          throw new Error('Unknown node type ' + nodeType + '.');
        }
      }
      current = candidates.length;
      while ((current -= 1) >= 0) {
        key = candidates[current];
        candidate = node[key];
        if (!candidate) {
          continue;
        }
        if (Array.isArray(candidate)) {
          current2 = candidate.length;
          while ((current2 -= 1) >= 0) {
            if (!candidate[current2]) {
              continue;
            }
            if (isProperty(nodeType, candidates[current])) {
              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
            } else if (isNode(candidate[current2])) {
              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
            } else {
              continue;
            }
            worklist.push(element);
          }
        } else if (isNode(candidate)) {
          worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      }
    }
    return outer.root;
  };
  function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
  }
  function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
  }
  function extendCommentRange(comment, tokens) {
    var target;
    target = upperBound(tokens, function search(token) {
      return token.range[0] > comment.range[0];
    });
    comment.extendedRange = [comment.range[0], comment.range[1]];
    if (target !== tokens.length) {
      comment.extendedRange[1] = tokens[target].range[0];
    }
    target -= 1;
    if (target >= 0) {
      comment.extendedRange[0] = tokens[target].range[1];
    }
    return comment;
  }
  function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [],
      comment,
      len,
      i,
      cursor;
    if (!tree.range) {
      throw new Error('attachComments needs range information');
    }

    // tokens array is empty, we attach comments to tree as 'leadingComments'
    if (!tokens.length) {
      if (providedComments.length) {
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }
        tree.leadingComments = comments;
      }
      return tree;
    }
    for (i = 0, len = providedComments.length; i < len; i += 1) {
      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    }

    // This is based on John Freeman's implementation.
    cursor = 0;
    traverse(tree, {
      enter: function (node) {
        var comment;
        while (cursor < comments.length) {
          comment = comments[cursor];
          if (comment.extendedRange[1] > node.range[0]) {
            break;
          }
          if (comment.extendedRange[1] === node.range[0]) {
            if (!node.leadingComments) {
              node.leadingComments = [];
            }
            node.leadingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        }

        // already out of owned node
        if (cursor === comments.length) {
          return VisitorOption.Break;
        }
        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    cursor = 0;
    traverse(tree, {
      leave: function (node) {
        var comment;
        while (cursor < comments.length) {
          comment = comments[cursor];
          if (node.range[1] < comment.extendedRange[0]) {
            break;
          }
          if (node.range[1] === comment.extendedRange[0]) {
            if (!node.trailingComments) {
              node.trailingComments = [];
            }
            node.trailingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        }

        // already out of owned node
        if (cursor === comments.length) {
          return VisitorOption.Break;
        }
        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    return tree;
  }
  exports.Syntax = Syntax;
  exports.traverse = traverse;
  exports.replace = replace;
  exports.attachComments = attachComments;
  exports.VisitorKeys = VisitorKeys;
  exports.VisitorOption = VisitorOption;
  exports.Controller = Controller;
  exports.cloneEnvironment = function () {
    return clone({});
  };
  return exports;
})(exports);
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 86 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"esrecurse","description":"ECMAScript AST recursive visitor","homepage":"https://github.com/estools/esrecurse","main":"esrecurse.js","version":"4.3.0","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"https://github.com/Constellation"}],"repository":{"type":"git","url":"https://github.com/estools/esrecurse.git"},"dependencies":{"estraverse":"^5.2.0"},"devDependencies":{"babel-cli":"^6.24.1","babel-eslint":"^7.2.3","babel-preset-es2015":"^6.24.1","babel-register":"^6.24.1","chai":"^4.0.2","esprima":"^4.0.0","gulp":"^3.9.0","gulp-bump":"^2.7.0","gulp-eslint":"^4.0.0","gulp-filter":"^5.0.0","gulp-git":"^2.4.1","gulp-mocha":"^4.3.1","gulp-tag-version":"^1.2.1","jsdoc":"^3.3.0-alpha10","minimist":"^1.1.0"},"license":"BSD-2-Clause","scripts":{"test":"gulp travis","unit-test":"gulp test","lint":"gulp lint"},"babel":{"presets":["es2015"]}}');

/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* eslint-disable no-undefined */
const Syntax = (__webpack_require__(78).Syntax);
const esrecurse = __webpack_require__(84);

/**
 * Get last array element
 * @param {array} xs - array
 * @returns {any} Last elment
 */
function getLast(xs) {
  return xs[xs.length - 1] || null;
}
class PatternVisitor extends esrecurse.Visitor {
  static isPattern(node) {
    const nodeType = node.type;
    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
  }
  constructor(options, rootPattern, callback) {
    super(null, options);
    this.rootPattern = rootPattern;
    this.callback = callback;
    this.assignments = [];
    this.rightHandNodes = [];
    this.restElements = [];
  }
  Identifier(pattern) {
    const lastRestElement = getLast(this.restElements);
    this.callback(pattern, {
      topLevel: pattern === this.rootPattern,
      rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,
      assignments: this.assignments
    });
  }
  Property(property) {
    // Computed property's key is a right hand node.
    if (property.computed) {
      this.rightHandNodes.push(property.key);
    }

    // If it's shorthand, its key is same as its value.
    // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).
    // If it's not shorthand, the name of new variable is its value's.
    this.visit(property.value);
  }
  ArrayPattern(pattern) {
    for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
      const element = pattern.elements[i];
      this.visit(element);
    }
  }
  AssignmentPattern(pattern) {
    this.assignments.push(pattern);
    this.visit(pattern.left);
    this.rightHandNodes.push(pattern.right);
    this.assignments.pop();
  }
  RestElement(pattern) {
    this.restElements.push(pattern);
    this.visit(pattern.argument);
    this.restElements.pop();
  }
  MemberExpression(node) {
    // Computed property's key is a right hand node.
    if (node.computed) {
      this.rightHandNodes.push(node.property);
    }

    // the object is only read, write to its property.
    this.rightHandNodes.push(node.object);
  }

  //
  // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
  // By spec, LeftHandSideExpression is Pattern or MemberExpression.
  //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
  // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
  //

  SpreadElement(node) {
    this.visit(node.argument);
  }
  ArrayExpression(node) {
    node.elements.forEach(this.visit, this);
  }
  AssignmentExpression(node) {
    this.assignments.push(node);
    this.visit(node.left);
    this.rightHandNodes.push(node.right);
    this.assignments.pop();
  }
  CallExpression(node) {
    // arguments are right hand nodes.
    node.arguments.forEach(a => {
      this.rightHandNodes.push(a);
    });
    this.visit(node.callee);
  }
}
module.exports = PatternVisitor;

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 88 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"eslint-scope","description":"ECMAScript scope analyzer for ESLint","homepage":"http://github.com/eslint/eslint-scope","main":"lib/index.js","version":"3.7.1","engines":{"node":">=4.0.0"},"repository":"eslint/eslint-scope","bugs":{"url":"https://github.com/eslint/eslint-scope/issues"},"license":"BSD-2-Clause","scripts":{"test":"node Makefile.js test","lint":"node Makefile.js lint","release":"eslint-release","ci-release":"eslint-ci-release","gh-release":"eslint-gh-release","alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta"},"files":["LICENSE","README.md","lib"],"dependencies":{"esrecurse":"^4.1.0","estraverse":"^4.1.1"},"devDependencies":{"chai":"^3.4.1","eslint":"^3.15.0","eslint-config-eslint":"^4.0.0","eslint-release":"^0.10.1","espree":"^3.1.1","istanbul":"^0.4.5","mocha":"^3.2.0","npm-license":"^0.3.3","shelljs":"^0.7.6","typescript":"~2.0.10","typescript-eslint-parser":"^1.0.0"}}');

/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */


const KEYS = __webpack_require__(90);

// Types.
const NODE_TYPES = Object.freeze(Object.keys(KEYS));

// Freeze the keys.
for (const type of NODE_TYPES) {
  Object.freeze(KEYS[type]);
}
Object.freeze(KEYS);

// List to ignore keys.
const KEY_BLACKLIST = new Set(["parent", "leadingComments", "trailingComments"]);

/**
 * Check whether a given key should be used or not.
 * @param {string} key The key to check.
 * @returns {boolean} `true` if the key should be used.
 */
function filterKey(key) {
  return !KEY_BLACKLIST.has(key) && key[0] !== "_";
}

//------------------------------------------------------------------------------
// Public interfaces
//------------------------------------------------------------------------------

module.exports = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS,
  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(node) {
    return Object.keys(node).filter(filterKey);
  },
  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc
  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(additionalKeys) {
    const retv = Object.assign({}, KEYS);
    for (const type of Object.keys(additionalKeys)) {
      if (retv.hasOwnProperty(type)) {
        const keys = new Set(additionalKeys[type]);
        for (const key of retv[type]) {
          keys.add(key);
        }
        retv[type] = Object.freeze(Array.from(keys));
      } else {
        retv[type] = Object.freeze(Array.from(additionalKeys[type]));
      }
    }
    return Object.freeze(retv);
  }
});

/***/ }),
/* 90 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"AssignmentExpression":["left","right"],"AssignmentPattern":["left","right"],"ArrayExpression":["elements"],"ArrayPattern":["elements"],"ArrowFunctionExpression":["params","body"],"AwaitExpression":["argument"],"BlockStatement":["body"],"BinaryExpression":["left","right"],"BreakStatement":["label"],"CallExpression":["callee","arguments"],"CatchClause":["param","body"],"ChainExpression":["expression"],"ClassBody":["body"],"ClassDeclaration":["id","superClass","body"],"ClassExpression":["id","superClass","body"],"ConditionalExpression":["test","consequent","alternate"],"ContinueStatement":["label"],"DebuggerStatement":[],"DoWhileStatement":["body","test"],"EmptyStatement":[],"ExportAllDeclaration":["exported","source"],"ExportDefaultDeclaration":["declaration"],"ExportNamedDeclaration":["declaration","specifiers","source"],"ExportSpecifier":["exported","local"],"ExpressionStatement":["expression"],"ExperimentalRestProperty":["argument"],"ExperimentalSpreadProperty":["argument"],"ForStatement":["init","test","update","body"],"ForInStatement":["left","right","body"],"ForOfStatement":["left","right","body"],"FunctionDeclaration":["id","params","body"],"FunctionExpression":["id","params","body"],"Identifier":[],"IfStatement":["test","consequent","alternate"],"ImportDeclaration":["specifiers","source"],"ImportDefaultSpecifier":["local"],"ImportExpression":["source"],"ImportNamespaceSpecifier":["local"],"ImportSpecifier":["imported","local"],"JSXAttribute":["name","value"],"JSXClosingElement":["name"],"JSXElement":["openingElement","children","closingElement"],"JSXEmptyExpression":[],"JSXExpressionContainer":["expression"],"JSXIdentifier":[],"JSXMemberExpression":["object","property"],"JSXNamespacedName":["namespace","name"],"JSXOpeningElement":["name","attributes"],"JSXSpreadAttribute":["argument"],"JSXText":[],"JSXFragment":["openingFragment","children","closingFragment"],"Literal":[],"LabeledStatement":["label","body"],"LogicalExpression":["left","right"],"MemberExpression":["object","property"],"MetaProperty":["meta","property"],"MethodDefinition":["key","value"],"NewExpression":["callee","arguments"],"ObjectExpression":["properties"],"ObjectPattern":["properties"],"Program":["body"],"Property":["key","value"],"RestElement":["argument"],"ReturnStatement":["argument"],"SequenceExpression":["expressions"],"SpreadElement":["argument"],"Super":[],"SwitchStatement":["discriminant","cases"],"SwitchCase":["test","consequent"],"TaggedTemplateExpression":["tag","quasi"],"TemplateElement":[],"TemplateLiteral":["quasis","expressions"],"ThisExpression":[],"ThrowStatement":["argument"],"TryStatement":["block","handler","finalizer"],"UnaryExpression":["argument"],"UpdateExpression":["argument"],"VariableDeclaration":["declarations"],"VariableDeclarator":["id","init"],"WhileStatement":["test","body"],"WithStatement":["object","body"],"YieldExpression":["argument"]}');

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Main Espree file that converts Acorn into Esprima output.
 *
 * This file contains code from the following MIT-licensed projects:
 * 1. Acorn
 * 2. Babylon
 * 3. Babel-ESLint
 *
 * This file also contains code from Esprima, which is BSD licensed.
 *
 * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)
 * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)
 * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/* eslint no-undefined:0, no-use-before-define: 0 */



const acorn = __webpack_require__(92);
const jsx = __webpack_require__(93);
const astNodeTypes = __webpack_require__(95);
const espree = __webpack_require__(96);

// To initialize lazily.
const parsers = {
  _regular: null,
  _jsx: null,
  get regular() {
    if (this._regular === null) {
      this._regular = acorn.Parser.extend(espree());
    }
    return this._regular;
  },
  get jsx() {
    if (this._jsx === null) {
      this._jsx = acorn.Parser.extend(jsx(), espree());
    }
    return this._jsx;
  },
  get(options) {
    const useJsx = Boolean(options && options.ecmaFeatures && options.ecmaFeatures.jsx);
    return useJsx ? this.jsx : this.regular;
  }
};

//------------------------------------------------------------------------------
// Tokenizer
//------------------------------------------------------------------------------

/**
 * Tokenizes the given code.
 * @param {string} code The code to tokenize.
 * @param {Object} options Options defining how to tokenize.
 * @returns {Token[]} An array of tokens.
 * @throws {SyntaxError} If the input code is invalid.
 * @private
 */
function tokenize(code, options) {
  const Parser = parsers.get(options);

  // Ensure to collect tokens.
  if (!options || options.tokens !== true) {
    options = Object.assign({}, options, {
      tokens: true
    }); // eslint-disable-line no-param-reassign
  }
  return new Parser(options, code).tokenize();
}

//------------------------------------------------------------------------------
// Parser
//------------------------------------------------------------------------------

/**
 * Parses the given code.
 * @param {string} code The code to tokenize.
 * @param {Object} options Options defining how to tokenize.
 * @returns {ASTNode} The "Program" AST node.
 * @throws {SyntaxError} If the input code is invalid.
 */
function parse(code, options) {
  const Parser = parsers.get(options);
  return new Parser(options, code).parse();
}

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

exports.version = __webpack_require__(98).version;
exports.tokenize = tokenize;
exports.parse = parse;

// Deep copy.
/* istanbul ignore next */
exports.Syntax = function () {
  let name,
    types = {};
  if (typeof Object.create === "function") {
    types = Object.create(null);
  }
  for (name in astNodeTypes) {
    if (astNodeTypes.hasOwnProperty(name)) {
      types[name] = astNodeTypes[name];
    }
  }
  if (typeof Object.freeze === "function") {
    Object.freeze(types);
  }
  return types;
}();

/* istanbul ignore next */
exports.VisitorKeys = function () {
  return (__webpack_require__(89).KEYS);
}();

/***/ }),
/* 92 */
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  // Reserved word lists for various dialects of the language
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };
  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.
  // Generated by `bin/generate-identifier-regex.js`.
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

  // These are a run-length and offset encoded representation of the
  // >0xffff code points that are a valid part of identifiers. The
  // offset starts at 0x10000, and each pair of numbers represents an
  // offset to the next range, and then a size of the range. They were
  // generated by bin/generate-identifier-regex.js

  // eslint-disable-next-line comma-spacing
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];

  // eslint-disable-next-line comma-spacing
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) {
        return false;
      }
      pos += set[i + 1];
      if (pos >= code) {
        return true;
      }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) {
      return code === 36;
    }
    if (code < 91) {
      return true;
    }
    if (code < 97) {
      return code === 95;
    }
    if (code < 123) {
      return true;
    }
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) {
      return code === 36;
    }
    if (code < 58) {
      return true;
    }
    if (code < 65) {
      return false;
    }
    if (code < 91) {
      return true;
    }
    if (code < 97) {
      return code === 95;
    }
    if (code < 123) {
      return true;
    }
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    if (astral === false) {
      return false;
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if (conf === void 0) conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name, prec) {
    return new TokenType(name, {
      beforeExpr: true,
      binop: prec
    });
  }
  var beforeExpr = {
      beforeExpr: true
    },
    startsExpr = {
      startsExpr: true
    };

  // Map keyword names to token types.

  var keywords$1 = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if (options === void 0) options = {};
    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options);
  }
  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),
    // Punctuation token types.
    bracketL: new TokenType("[", {
      beforeExpr: true,
      startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
      beforeExpr: true,
      startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: true,
      startsExpr: true
    }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {
      beforeExpr: true,
      isAssign: true
    }),
    assign: new TokenType("_=", {
      beforeExpr: true,
      isAssign: true
    }),
    incDec: new TokenType("++/--", {
      prefix: true,
      postfix: true,
      startsExpr: true
    }),
    prefix: new TokenType("!/~", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: true,
      binop: 9,
      prefix: true,
      startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
      beforeExpr: true
    }),
    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
      isLoop: true,
      beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
      isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
      isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
      beforeExpr: true,
      startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
      beforeExpr: true,
      binop: 7
    }),
    _instanceof: kw("instanceof", {
      beforeExpr: true,
      binop: 7
    }),
    _typeof: kw("typeof", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _void: kw("void", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _delete: kw("delete", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    })
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  // Checks if an object has a property.

  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName);
  }
  var isArray = Array.isArray || function (obj) {
    return toString.call(obj) === "[object Array]";
  };
  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
  }

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };
  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };
  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) {
      this.source = p.sourceFile;
    }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur);
      }
    }
  }

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
    // (2019). This influences support for strict mode, the set of
    // reserved words, and support for new syntax features. The default
    // is 9.
    ecmaVersion: 9,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program.
    allowImportExportEverywhere: false,
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: false,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callbackthat will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callbackthat will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  function getOptions(opts) {
    var options = {};
    for (var opt in defaultOptions) {
      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    }
    if (options.ecmaVersion >= 2015) {
      options.ecmaVersion -= 2009;
    }
    if (options.allowReserved == null) {
      options.allowReserved = options.ecmaVersion < 5;
    }
    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    }
    if (isArray(options.onComment)) {
      options.onComment = pushComment(options, options.onComment);
    }
    return options;
  }
  function pushComment(options, array) {
    return function (block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations) {
        comment.loc = new SourceLocation(this, startLoc, endLoc);
      }
      if (options.ranges) {
        comment.range = [start, end];
      }
      array.push(comment);
    };
  }

  // Each scope gets a bitset that may contain these flags
  var SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;
  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }

  // Used in checkLVal and declareName to determine the type of a binding
  var BIND_NONE = 0,
    // Not a binding
    BIND_VAR = 1,
    // Var-style binding
    BIND_LEXICAL = 2,
    // Let- or const-style binding
    BIND_FUNCTION = 3,
    // Function declaration
    BIND_SIMPLE_CATCH = 4,
    // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--) {
        if (reserved = reservedWords[v]) {
          break;
        }
      }
      if (options.sourceType === "module") {
        reserved += " await";
      }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = {};

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
      this.skipLineComment(2);
    }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;
  };
  var prototypeAccessors = {
    inFunction: {
      configurable: true
    },
    inGenerator: {
      configurable: true
    },
    inAsync: {
      configurable: true
    },
    allowSuper: {
      configurable: true
    },
    allowDirectSuper: {
      configurable: true
    },
    treatFunctionsAsVar: {
      configurable: true
    }
  };
  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };
  prototypeAccessors.inFunction.get = function () {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  };
  prototypeAccessors.inGenerator.get = function () {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
  };
  prototypeAccessors.inAsync.get = function () {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
  };
  prototypeAccessors.allowSuper.get = function () {
    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
  };
  prototypeAccessors.allowDirectSuper.get = function () {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  };
  prototypeAccessors.treatFunctionsAsVar.get = function () {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };

  // Switch to a getter for 7.0.0.
  Parser.prototype.inNonArrowFunction = function inNonArrowFunction() {
    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
  };
  Parser.extend = function extend() {
    var plugins = [],
      len = arguments.length;
    while (len--) plugins[len] = arguments[len];
    var cls = this;
    for (var i = 0; i < plugins.length; i++) {
      cls = plugins[i](cls);
    }
    return cls;
  };
  Parser.parse = function parse(input, options) {
    return new this(options, input).parse();
  };
  Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression();
  };
  Parser.tokenizer = function tokenizer(input, options) {
    return new this(options, input);
  };
  Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp.strictDirective = function (start) {
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) {
        return false;
      }
      if ((match[1] || match[2]) === "use strict") {
        return true;
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";") {
        start++;
      }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp.eat = function (type) {
    if (this.type === type) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp.isContextual = function (name) {
    return this.type === types.name && this.value === name && !this.containsEsc;
  };

  // Consumes contextual keyword if possible.

  pp.eatContextual = function (name) {
    if (!this.isContextual(name)) {
      return false;
    }
    this.next();
    return true;
  };

  // Asserts that following token is given contextual keyword.

  pp.expectContextual = function (name) {
    if (!this.eatContextual(name)) {
      this.unexpected();
    }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp.canInsertSemicolon = function () {
    return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp.insertSemicolon = function () {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon) {
        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      }
      return true;
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp.semicolon = function () {
    if (!this.eat(types.semi) && !this.insertSemicolon()) {
      this.unexpected();
    }
  };
  pp.afterTrailingComma = function (tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma) {
        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      }
      if (!notNext) {
        this.next();
      }
      return true;
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp.expect = function (type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp.unexpected = function (pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };
  function DestructuringErrors() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
  pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) {
      return;
    }
    if (refDestructuringErrors.trailingComma > -1) {
      this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) {
      this.raiseRecoverable(parens, "Parenthesized pattern");
    }
  };
  pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) {
      return false;
    }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) {
      return shorthandAssign >= 0 || doubleProto >= 0;
    }
    if (shorthandAssign >= 0) {
      this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    }
    if (doubleProto >= 0) {
      this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
    }
  };
  pp.checkYieldAwaitInDefaultParams = function () {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
      this.raise(this.yieldPos, "Yield expression cannot be a default value");
    }
    if (this.awaitPos) {
      this.raise(this.awaitPos, "Await expression cannot be a default value");
    }
  };
  pp.isSimpleAssignTarget = function (expr) {
    if (expr.type === "ParenthesizedExpression") {
      return this.isSimpleAssignTarget(expr.expression);
    }
    return expr.type === "Identifier" || expr.type === "MemberExpression";
  };
  var pp$1 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$1.parseTopLevel = function (node) {
    var exports = {};
    if (!node.body) {
      node.body = [];
    }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule) {
      for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
        var name = list[i];
        this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
      }
    }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program");
  };
  var loopLabel = {
      kind: "loop"
    },
    switchLabel = {
      kind: "switch"
    };
  pp$1.isLet = function (context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91) {
      return true;
    } // '['
    if (context) {
      return false;
    }
    if (nextCh === 123) {
      return true;
    } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
        ++pos;
      }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) {
        return true;
      }
    }
    return false;
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$1.isAsyncFunction = function () {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
      return false;
    }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$1.parseStatement = function (context, topLevel, exports) {
    var starttype = this.type,
      node = this.startNode(),
      kind;
    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
      case types._break:
      case types._continue:
        return this.parseBreakContinueStatement(node, starttype.keyword);
      case types._debugger:
        return this.parseDebuggerStatement(node);
      case types._do:
        return this.parseDoStatement(node);
      case types._for:
        return this.parseForStatement(node);
      case types._function:
        // Function as sole body of either an if statement or a labeled statement
        // works, but not when it is part of a labeled statement that is the sole
        // body of an if statement.
        if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
          this.unexpected();
        }
        return this.parseFunctionStatement(node, false, !context);
      case types._class:
        if (context) {
          this.unexpected();
        }
        return this.parseClass(node, true);
      case types._if:
        return this.parseIfStatement(node);
      case types._return:
        return this.parseReturnStatement(node);
      case types._switch:
        return this.parseSwitchStatement(node);
      case types._throw:
        return this.parseThrowStatement(node);
      case types._try:
        return this.parseTryStatement(node);
      case types._const:
      case types._var:
        kind = kind || this.value;
        if (context && kind !== "var") {
          this.unexpected();
        }
        return this.parseVarStatement(node, kind);
      case types._while:
        return this.parseWhileStatement(node);
      case types._with:
        return this.parseWithStatement(node);
      case types.braceL:
        return this.parseBlock(true, node);
      case types.semi:
        return this.parseEmptyStatement(node);
      case types._export:
      case types._import:
        if (this.options.ecmaVersion > 10 && starttype === types._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length,
            nextCh = this.input.charCodeAt(next);
          if (nextCh === 40)
            // '('
            {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
        }
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel) {
            this.raise(this.start, "'import' and 'export' may only appear at the top level");
          }
          if (!this.inModule) {
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
          }
        }
        return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
      default:
        if (this.isAsyncFunction()) {
          if (context) {
            this.unexpected();
          }
          this.next();
          return this.parseFunctionStatement(node, true, !context);
        }
        var maybeName = this.value,
          expr = this.parseExpression();
        if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
          return this.parseLabeledStatement(node, maybeName, expr, context);
        } else {
          return this.parseExpressionStatement(node, expr);
        }
    }
  };
  pp$1.parseBreakContinueStatement = function (node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) {
      node.label = null;
    } else if (this.type !== types.name) {
      this.unexpected();
    } else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) {
          break;
        }
        if (node.label && isBreak) {
          break;
        }
      }
    }
    if (i === this.labels.length) {
      this.raise(node.start, "Unsyntactic " + keyword);
    }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp$1.parseDebuggerStatement = function (node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement");
  };
  pp$1.parseDoStatement = function (node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6) {
      this.eat(types.semi);
    } else {
      this.semicolon();
    }
    return this.finishNode(node, "DoWhileStatement");
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$1.parseForStatement = function (node) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, null);
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(),
        kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node.await = awaitAt > -1;
          }
        }
        return this.parseForIn(node, init$1);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init$1);
    }
    var refDestructuringErrors = new DestructuringErrors();
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node.await = awaitAt > -1;
        }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init);
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, init);
  };
  pp$1.parseFunctionStatement = function (node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
  };
  pp$1.parseIfStatement = function (node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement");
  };
  pp$1.parseReturnStatement = function (node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
      this.raise(this.start, "'return' outside of function");
    }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types.semi) || this.insertSemicolon()) {
      node.argument = null;
    } else {
      node.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node, "ReturnStatement");
  };
  pp$1.parseSwitchStatement = function (node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) {
            this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
          }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) {
          this.unexpected();
        }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) {
      this.finishNode(cur, "SwitchCase");
    }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement");
  };
  pp$1.parseThrowStatement = function (node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
      this.raise(this.lastTokEnd, "Illegal newline after throw");
    }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement");
  };

  // Reused empty array added for node fields that are always empty.

  var empty = [];
  pp$1.parseTryStatement = function (node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) {
          this.unexpected();
        }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer) {
      this.raise(node.start, "Missing catch or finally clause");
    }
    return this.finishNode(node, "TryStatement");
  };
  pp$1.parseVarStatement = function (node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration");
  };
  pp$1.parseWhileStatement = function (node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement");
  };
  pp$1.parseWithStatement = function (node) {
    if (this.strict) {
      this.raise(this.start, "'with' in strict mode");
    }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement");
  };
  pp$1.parseEmptyStatement = function (node) {
    this.next();
    return this.finishNode(node, "EmptyStatement");
  };
  pp$1.parseLabeledStatement = function (node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
      var label = list[i$1];
      if (label.name === maybeName) {
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
      }
    }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else {
        break;
      }
    }
    this.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.start
    });
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement");
  };
  pp$1.parseExpressionStatement = function (node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement");
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$1.parseBlock = function (createNewLexicalScope, node) {
    if (createNewLexicalScope === void 0) createNewLexicalScope = true;
    if (node === void 0) node = this.startNode();
    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) {
      this.enterScope(0);
    }
    while (!this.eat(types.braceR)) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (createNewLexicalScope) {
      this.exitScope();
    }
    return this.finishNode(node, "BlockStatement");
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$1.parseFor = function (node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement");
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$1.parseForIn = function (node, init) {
    var isForIn = this.type === types._in;
    this.next();
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
      this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  };

  // Parse a list of variable declarations.

  pp$1.parseVar = function (node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) {
        break;
      }
    }
    return node;
  };
  pp$1.parseVarId = function (decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };
  var FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$1.parseFunction = function (node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && statement & FUNC_HANGING_STATEMENT) {
        this.unexpected();
      }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8) {
      node.async = !!isAsync;
    }
    if (statement & FUNC_STATEMENT) {
      node.id = statement & FUNC_NULLABLE_ID && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        {
          this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
    }
    var oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));
    if (!(statement & FUNC_STATEMENT)) {
      node.id = this.type === types.name ? this.parseIdent() : null;
    }
    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp$1.parseFunctionParams = function (node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$1.parseClass = function (node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) {
            this.raise(element.start, "Duplicate constructor in the same class");
          }
          hadConstructor = true;
        }
      }
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp$1.parseClassElement = function (constructorAllowsSuper) {
    var this$1 = this;
    if (this.eat(types.semi)) {
      return null;
    }
    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if (noLineBreak === void 0) noLineBreak = false;
      var start = this$1.start,
        startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) {
        return false;
      }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {
        return true;
      }
      if (method.key) {
        this$1.unexpected();
      }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false;
    };
    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) {
      this.parsePropertyName(method);
    }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") {
        this.raise(key.start, "Constructor can't have get/set modifier");
      }
      if (isGenerator) {
        this.raise(key.start, "Constructor can't be a generator");
      }
      if (isAsync) {
        this.raise(key.start, "Constructor can't be an async method");
      }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0) {
      this.raiseRecoverable(method.value.start, "getter should have no params");
    }
    if (method.kind === "set" && method.value.params.length !== 1) {
      this.raiseRecoverable(method.value.start, "setter should have exactly one param");
    }
    if (method.kind === "set" && method.value.params[0].type === "RestElement") {
      this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
    }
    return method;
  };
  pp$1.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition");
  };
  pp$1.parseClassId = function (node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement) {
        this.checkLVal(node.id, BIND_LEXICAL, false);
      }
    } else {
      if (isStatement === true) {
        this.unexpected();
      }
      node.id = null;
    }
  };
  pp$1.parseClassSuper = function (node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };

  // Parses module export declaration.

  pp$1.parseExport = function (node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types.star)) {
      this.expectContextual("from");
      if (this.type !== types.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration");
    }
    if (this.eat(types._default)) {
      // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) {
          this.next();
        }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration");
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration") {
        this.checkVariableExport(exports, node.declaration.declarations);
      } else {
        this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
      }
      node.specifiers = [];
      node.source = null;
    } else {
      // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];
          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);
        }
        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration");
  };
  pp$1.checkExport = function (exports, name, pos) {
    if (!exports) {
      return;
    }
    if (has(exports, name)) {
      this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
    }
    exports[name] = true;
  };
  pp$1.checkPatternExport = function (exports, pat) {
    var type = pat.type;
    if (type === "Identifier") {
      this.checkExport(exports, pat.name, pat.start);
    } else if (type === "ObjectPattern") {
      for (var i = 0, list = pat.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkPatternExport(exports, prop);
      }
    } else if (type === "ArrayPattern") {
      for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];
        if (elt) {
          this.checkPatternExport(exports, elt);
        }
      }
    } else if (type === "Property") {
      this.checkPatternExport(exports, pat.value);
    } else if (type === "AssignmentPattern") {
      this.checkPatternExport(exports, pat.left);
    } else if (type === "RestElement") {
      this.checkPatternExport(exports, pat.argument);
    } else if (type === "ParenthesizedExpression") {
      this.checkPatternExport(exports, pat.expression);
    }
  };
  pp$1.checkVariableExport = function (exports, decls) {
    if (!exports) {
      return;
    }
    for (var i = 0, list = decls; i < list.length; i += 1) {
      var decl = list[i];
      this.checkPatternExport(exports, decl.id);
    }
  };
  pp$1.shouldParseExportStatement = function () {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
  };

  // Parses a comma-separated list of module exports.

  pp$1.parseExportSpecifiers = function (exports) {
    var nodes = [],
      first = true;
    // export { x, y as z } [from '...']
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes;
  };

  // Parses import declaration.

  pp$1.parseImport = function (node) {
    this.next();
    // import '...'
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration");
  };

  // Parses a comma-separated list of module imports.

  pp$1.parseImportSpecifiers = function () {
    var nodes = [],
      first = true;
    if (this.type === types.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) {
        return nodes;
      }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes;
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes;
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$1.adaptDirectivePrologue = function (statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function (statement) {
    return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (
    // Reject parenthesized strings.
    this.input[statement.start] === "\"" || this.input[statement.start] === "'");
  };
  var pp$2 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
        case "Identifier":
          if (this.inAsync && node.name === "await") {
            this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
          }
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node.type = "ObjectPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          for (var i = 0, list = node.properties; i < list.length; i += 1) {
            var prop = list[i];
            this.toAssignable(prop, isBinding);
            // Early error:
            //   AssignmentRestProperty[Yield, Await] :
            //     `...` DestructuringAssignmentTarget[Yield, Await]
            //
            //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
            if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
              this.raise(prop.argument.start, "Unexpected token");
            }
          }
          break;
        case "Property":
          // AssignmentProperty has type === "Property"
          if (node.kind !== "init") {
            this.raise(node.key.start, "Object pattern can't contain getter or setter");
          }
          this.toAssignable(node.value, isBinding);
          break;
        case "ArrayExpression":
          node.type = "ArrayPattern";
          if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
          }
          this.toAssignableList(node.elements, isBinding);
          break;
        case "SpreadElement":
          node.type = "RestElement";
          this.toAssignable(node.argument, isBinding);
          if (node.argument.type === "AssignmentPattern") {
            this.raise(node.argument.start, "Rest elements cannot have a default value");
          }
          break;
        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          }
          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern

        case "AssignmentPattern":
          break;
        case "ParenthesizedExpression":
          this.toAssignable(node.expression, isBinding, refDestructuringErrors);
          break;
        case "MemberExpression":
          if (!isBinding) {
            break;
          }
        default:
          this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) {
      this.checkPatternErrors(refDestructuringErrors, true);
    }
    return node;
  };

  // Convert list of expression atoms to binding list.

  pp$2.toAssignableList = function (exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) {
        this.toAssignable(elt, isBinding);
      }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
        this.unexpected(last.argument.start);
      }
    }
    return exprList;
  };

  // Parses spread element.

  pp$2.parseSpread = function (refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement");
  };
  pp$2.parseRestBinding = function () {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types.name) {
      this.unexpected();
    }
    node.argument = this.parseBindingAtom();
    return this.finishNode(node, "RestElement");
  };

  // Parses lvalue (assignable) atom.

  pp$2.parseBindingAtom = function () {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
        case types.bracketL:
          var node = this.startNode();
          this.next();
          node.elements = this.parseBindingList(types.bracketR, true, true);
          return this.finishNode(node, "ArrayPattern");
        case types.braceL:
          return this.parseObj(true);
      }
    }
    return this.parseIdent();
  };
  pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
    var elts = [],
      first = true;
    while (!this.eat(close)) {
      if (first) {
        first = false;
      } else {
        this.expect(types.comma);
      }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        this.expect(close);
        break;
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts;
  };
  pp$2.parseBindingListItem = function (param) {
    return param;
  };

  // Parses assignment pattern around given atom if possible.

  pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
      return left;
    }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern");
  };

  // Verify that a node is an lval  something that can be assigned
  // to.
  // bindingType can be either:
  // 'var' indicating that the lval creates a 'var' binding
  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding
  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

  pp$2.checkLVal = function (expr, bindingType, checkClashes) {
    if (bindingType === void 0) bindingType = BIND_NONE;
    switch (expr.type) {
      case "Identifier":
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
          this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        }
        if (checkClashes) {
          if (has(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
        break;
      case "MemberExpression":
        if (bindingType) {
          this.raiseRecoverable(expr.start, "Binding member expression");
        }
        break;
      case "ObjectPattern":
        for (var i = 0, list = expr.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.checkLVal(prop, bindingType, checkClashes);
        }
        break;
      case "Property":
        // AssignmentProperty has type === "Property"
        this.checkLVal(expr.value, bindingType, checkClashes);
        break;
      case "ArrayPattern":
        for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
          var elem = list$1[i$1];
          if (elem) {
            this.checkLVal(elem, bindingType, checkClashes);
          }
        }
        break;
      case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes);
        break;
      case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes);
        break;
      case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes);
        break;
      default:
        this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  // A recursive descent parser operates by defining functions for all

  var pp$3 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash 
  // either with each other or with an init property  and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
      return;
    }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
      return;
    }
    var key = prop.key;
    var name;
    switch (key.type) {
      case "Identifier":
        name = key.name;
        break;
      case "Literal":
        name = String(key.value);
        break;
      default:
        return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
          // Backwards-compat kludge. Can be removed in version 6.0
          else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return;
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition) {
        this.raiseRecoverable(key.start, "Redefinition of property");
      }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$3.parseExpression = function (noIn, refDestructuringErrors) {
    var startPos = this.start,
      startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) {
        node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
      }
      return this.finishNode(node, "SequenceExpression");
    }
    return expr;
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) {
        return this.parseYield(noIn);
      }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else {
        this.exprAllowed = false;
      }
    }
    var ownDestructuringErrors = false,
      oldParenAssign = -1,
      oldTrailingComma = -1,
      oldShorthandAssign = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldShorthandAssign = refDestructuringErrors.shorthandAssign;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors();
      ownDestructuringErrors = true;
    }
    var startPos = this.start,
      startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name) {
      this.potentialArrowAt = this.start;
    }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) {
      left = afterLeftParse.call(this, left, startPos, startLoc);
    }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        DestructuringErrors.call(refDestructuringErrors);
      }
      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression");
    } else {
      if (ownDestructuringErrors) {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
    }
    if (oldParenAssign > -1) {
      refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    }
    if (oldTrailingComma > -1) {
      refDestructuringErrors.trailingComma = oldTrailingComma;
    }
    if (oldShorthandAssign > -1) {
      refDestructuringErrors.shorthandAssign = oldShorthandAssign;
    }
    return left;
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
    var startPos = this.start,
      startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression");
    }
    return expr;
  };

  // Start the precedence parser.

  pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
    var startPos = this.start,
      startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var op = this.value;
        this.next();
        var startPos = this.start,
          startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
      }
    }
    return left;
  };
  pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
  };

  // Parse unary operators, both prefix and postfix.

  pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
    var startPos = this.start,
      startLoc = this.startLoc,
      expr;
    if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(),
        update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) {
        this.checkLVal(node.argument);
      } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
        this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
      } else {
        sawUnary = true;
      }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }
    if (!sawUnary && this.eat(types.starstar)) {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
    } else {
      return expr;
    }
  };

  // Parse call, dot, and `[]`-subscript expressions.

  pp$3.parseExprSubscripts = function (refDestructuringErrors) {
    var startPos = this.start,
      startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
      return expr;
    }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) {
        refDestructuringErrors.parenthesizedAssign = -1;
      }
      if (refDestructuringErrors.parenthesizedBind >= result.start) {
        refDestructuringErrors.parenthesizedBind = -1;
      }
    }
    return result;
  };
  pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || element.type === "ArrowFunctionExpression") {
        return element;
      }
      base = element;
    }
  };
  pp$3.parseSubscript = function (base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) {
        this.expect(types.bracketR);
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0) {
          this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (node$1.callee.type === "Import") {
        if (node$1.arguments.length !== 1) {
          this.raise(node$1.start, "import() requires exactly one argument");
        }
        var importArg = node$1.arguments[0];
        if (importArg && importArg.type === "SpreadElement") {
          this.raise(importArg.start, "... is not allowed in import()");
        }
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({
        isTagged: true
      });
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  };

  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$3.parseExprAtom = function (refDestructuringErrors) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types.slash) {
      this.readRegexp();
    }
    var node,
      canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
      case types._super:
        if (!this.allowSuper) {
          this.raise(this.start, "'super' keyword outside a method");
        }
        node = this.startNode();
        this.next();
        if (this.type === types.parenL && !this.allowDirectSuper) {
          this.raise(node.start, "super() call outside constructor of a subclass");
        }
        // The `super` keyword can appear at below:
        // SuperProperty:
        //     super [ Expression ]
        //     super . IdentifierName
        // SuperCall:
        //     super Arguments
        if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
          this.unexpected();
        }
        return this.finishNode(node, "Super");
      case types._this:
        node = this.startNode();
        this.next();
        return this.finishNode(node, "ThisExpression");
      case types.name:
        var startPos = this.start,
          startLoc = this.startLoc,
          containsEsc = this.containsEsc;
        var id = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true);
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types.arrow)) {
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
          }
          if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
            id = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
              this.unexpected();
            }
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
          }
        }
        return id;
      case types.regexp:
        var value = this.value;
        node = this.parseLiteral(value.value);
        node.regex = {
          pattern: value.pattern,
          flags: value.flags
        };
        return node;
      case types.num:
      case types.string:
        return this.parseLiteral(this.value);
      case types._null:
      case types._true:
      case types._false:
        node = this.startNode();
        node.value = this.type === types._null ? null : this.type === types._true;
        node.raw = this.type.keyword;
        this.next();
        return this.finishNode(node, "Literal");
      case types.parenL:
        var start = this.start,
          expr = this.parseParenAndDistinguishExpression(canBeArrow);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
            refDestructuringErrors.parenthesizedAssign = start;
          }
          if (refDestructuringErrors.parenthesizedBind < 0) {
            refDestructuringErrors.parenthesizedBind = start;
          }
        }
        return expr;
      case types.bracketL:
        node = this.startNode();
        this.next();
        node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node, "ArrayExpression");
      case types.braceL:
        return this.parseObj(false, refDestructuringErrors);
      case types._function:
        node = this.startNode();
        this.next();
        return this.parseFunction(node, 0);
      case types._class:
        return this.parseClass(this.startNode(), false);
      case types._new:
        return this.parseNew();
      case types.backQuote:
        return this.parseTemplate();
      case types._import:
        if (this.options.ecmaVersion > 10) {
          return this.parseDynamicImport();
        } else {
          return this.unexpected();
        }
      default:
        this.unexpected();
    }
  };
  pp$3.parseDynamicImport = function () {
    var node = this.startNode();
    this.next();
    if (this.type !== types.parenL) {
      this.unexpected();
    }
    return this.finishNode(node, "Import");
  };
  pp$3.parseLiteral = function (value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
      node.bigint = node.raw.slice(0, -1);
    }
    this.next();
    return this.finishNode(node, "Literal");
  };
  pp$3.parseParenExpression = function () {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val;
  };
  pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
    var startPos = this.start,
      startLoc = this.startLoc,
      val,
      allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
      var exprList = [],
        first = true,
        lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors(),
        oldYieldPos = this.yieldPos,
        oldAwaitPos = this.awaitPos,
        spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break;
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) {
            this.raise(this.start, "Comma is not permitted after the rest element");
          }
          break;
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
      this.expect(types.parenR);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList);
      }
      if (!exprList.length || lastIsComma) {
        this.unexpected(this.lastTokStart);
      }
      if (spreadStart) {
        this.unexpected(spreadStart);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression");
    } else {
      return val;
    }
  };
  pp$3.parseParenItem = function (item) {
    return item;
  };
  pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call  at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty$1 = [];
  pp$3.parseNew = function () {
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target" || containsEsc) {
        this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
      }
      if (!this.inNonArrowFunction()) {
        this.raiseRecoverable(node.start, "new.target can only be used in functions");
      }
      return this.finishNode(node, "MetaProperty");
    }
    var startPos = this.start,
      startLoc = this.startLoc;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
      this.raise(node.callee.start, "Cannot use new with import(...)");
    }
    if (this.eat(types.parenL)) {
      node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false);
    } else {
      node.arguments = empty$1;
    }
    return this.finishNode(node, "NewExpression");
  };

  // Parse template expression.

  pp$3.parseTemplateElement = function (ref) {
    var isTagged = ref.isTagged;
    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement");
  };
  pp$3.parseTemplate = function (ref) {
    if (ref === void 0) ref = {};
    var isTagged = ref.isTagged;
    if (isTagged === void 0) isTagged = false;
    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({
      isTagged: isTagged
    });
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) {
        this.raise(this.pos, "Unterminated template literal");
      }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({
        isTagged: isTagged
      }));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral");
  };
  pp$3.isAsyncProp = function (prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };

  // Parse an object literal or binding pattern.

  pp$3.parseObj = function (isPattern, refDestructuringErrors) {
    var node = this.startNode(),
      first = true,
      propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) {
          break;
        }
      } else {
        first = false;
      }
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) {
        this.checkPropClash(prop, propHash, refDestructuringErrors);
      }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
    var prop = this.startNode(),
      isGenerator,
      isAsync,
      startPos,
      startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement");
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
  };
  pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon) {
      this.unexpected();
    }
    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) {
        this.unexpected();
      }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types.comma && this.type !== types.braceR) {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get") {
          this.raiseRecoverable(start, "getter should have no params");
        } else {
          this.raiseRecoverable(start, "setter should have exactly one param");
        }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
          this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) {
        this.unexpected();
      }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = startPos;
      }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0) {
          refDestructuringErrors.shorthandAssign = this.start;
        }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else {
      this.unexpected();
    }
  };
  pp$3.parsePropertyName = function (prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key;
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  };

  // Initialize empty function node.

  pp$3.initFunction = function (node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) {
      node.generator = node.expression = false;
    }
    if (this.options.ecmaVersion >= 8) {
      node.async = false;
    }
  };

  // Parse object or class method.

  pp$3.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(),
      oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node);
    if (this.options.ecmaVersion >= 6) {
      node.generator = isGenerator;
    }
    if (this.options.ecmaVersion >= 8) {
      node.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression");
  };

  // Parse arrow function expression with given parameters.

  pp$3.parseArrowExpression = function (node, params, isAsync) {
    var oldYieldPos = this.yieldPos,
      oldAwaitPos = this.awaitPos,
      oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) {
      node.async = !!isAsync;
    }
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression");
  };

  // Parse function body and check parameters.

  pp$3.parseFunctionBody = function (node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict,
      useStrict = false;
    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple) {
          this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
        }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) {
        this.strict = true;
      }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      node.body = this.parseBlock(false);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();

    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) {
      this.checkLVal(node.id, BIND_OUTSIDE);
    }
    this.strict = oldStrict;
  };
  pp$3.isSimpleParamList = function (params) {
    for (var i = 0, list = params; i < list.length; i += 1) {
      var param = list[i];
      if (param.type !== "Identifier") {
        return false;
      }
    }
    return true;
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$3.checkParams = function (node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1) {
      var param = list[i];
      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [],
      first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        }
      } else {
        first = false;
      }
      var elt = void 0;
      if (allowEmpty && this.type === types.comma) {
        elt = null;
      } else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts;
  };
  pp$3.checkUnreserved = function (ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;
    if (this.inGenerator && name === "yield") {
      this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    }
    if (this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    }
    if (this.keywords.test(name)) {
      this.raise(start, "Unexpected keyword '" + name + "'");
    }
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
      return;
    }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
      }
      this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$3.parseIdent = function (liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos) {
        this.awaitIdentPos = node.start;
      }
    }
    return node;
  };

  // Parses yield expression inside generator.

  pp$3.parseYield = function (noIn) {
    if (!this.yieldPos) {
      this.yieldPos = this.start;
    }
    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression");
  };
  pp$3.parseAwait = function () {
    if (!this.awaitPos) {
      this.awaitPos = this.start;
    }
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    return this.finishNode(node, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function (pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
  };
  pp$4.raiseRecoverable = pp$4.raise;
  pp$4.curPosition = function () {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
  };
  var pp$5 = Parser.prototype;
  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$5.enterScope = function (flags) {
    this.scopeStack.push(new Scope(flags));
  };
  pp$5.exitScope = function () {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$5.treatFunctionsAsVarInScope = function (scope) {
    return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
  };
  pp$5.declareName = function (name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && scope.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar) {
        redeclared = scope$2.lexical.indexOf(name) > -1;
      } else {
        redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
      }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break;
        }
        scope$3.var.push(name);
        if (this.inModule && scope$3.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
        if (scope$3.flags & SCOPE_VAR) {
          break;
        }
      }
    }
    if (redeclared) {
      this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
    }
  };
  pp$5.checkLocalExport = function (id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };
  pp$5.currentScope = function () {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  pp$5.currentVarScope = function () {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) {
        return scope;
      }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$5.currentThisScope = function () {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
        return scope;
      }
    }
  };
  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations) {
      this.loc = new SourceLocation(parser, loc);
    }
    if (parser.options.directSourceFile) {
      this.sourceFile = parser.options.directSourceFile;
    }
    if (parser.options.ranges) {
      this.range = [pos, 0];
    }
  };

  // Start an AST node, attaching a start offset.

  var pp$6 = Parser.prototype;
  pp$6.startNode = function () {
    return new Node(this, this.start, this.startLoc);
  };
  pp$6.startNodeAt = function (pos, loc) {
    return new Node(this, pos, loc);
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations) {
      node.loc.end = loc;
    }
    if (this.options.ranges) {
      node.range[1] = pos;
    }
    return node;
  }
  pp$6.finishNode = function (node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
  };

  // Finish node at given position

  pp$6.finishNodeAt = function (node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc);
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };
  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) {
      return p.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };
  var pp$7 = Parser.prototype;
  pp$7.initialContext = function () {
    return [types$1.b_stat];
  };
  pp$7.braceIsBlock = function (prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat) {
      return true;
    }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
      return !parent.isExpr;
    }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types._return || prevType === types.name && this.exprAllowed) {
      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
      return true;
    }
    if (prevType === types.braceL) {
      return parent === types$1.b_stat;
    }
    if (prevType === types._var || prevType === types._const || prevType === types.name) {
      return false;
    }
    return !this.exprAllowed;
  };
  pp$7.inGeneratorContext = function () {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function") {
        return context.generator;
      }
    }
    return false;
  };
  pp$7.updateContext = function (prevType) {
    var update,
      type = this.type;
    if (type.keyword && prevType === types.dot) {
      this.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.exprAllowed = type.beforeExpr;
    }
  };

  // Token-specific context update code

  types.parenR.updateContext = types.braceR.updateContext = function () {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return;
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };
  types.braceL.updateContext = function (prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };
  types.dollarBraceL.updateContext = function () {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };
  types.parenL.updateContext = function (prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };
  types.incDec.updateContext = function () {
    // tokExprAllowed stays unchanged
  };
  types._function.updateContext = types._class.updateContext = function (prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
      this.context.push(types$1.f_expr);
    } else {
      this.context.push(types$1.f_stat);
    }
    this.exprAllowed = false;
  };
  types.backQuote.updateContext = function () {
    if (this.curContext() === types$1.q_tmpl) {
      this.context.pop();
    } else {
      this.context.push(types$1.q_tmpl);
    }
    this.exprAllowed = false;
  };
  types.star.updateContext = function (prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr) {
        this.context[index] = types$1.f_expr_gen;
      } else {
        this.context[index] = types$1.f_gen;
      }
    }
    this.exprAllowed = true;
  };
  types.name.updateContext = function (prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
        allowed = true;
      }
    }
    this.exprAllowed = allowed;
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };
  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);
  var pp$8 = Parser.prototype;
  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };
  RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };
  RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at(i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1;
    }
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c;
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
  };
  RegExpValidationState.prototype.nextIndex = function nextIndex(i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l;
    }
    var c = s.charCodeAt(i),
      next;
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1;
    }
    return i + 2;
  };
  RegExpValidationState.prototype.current = function current() {
    return this.at(this.pos);
  };
  RegExpValidationState.prototype.lookahead = function lookahead() {
    return this.at(this.nextIndex(this.pos));
  };
  RegExpValidationState.prototype.advance = function advance() {
    this.pos = this.nextIndex(this.pos);
  };
  RegExpValidationState.prototype.eat = function eat(ch) {
    if (this.current() === ch) {
      this.advance();
      return true;
    }
    return false;
  };
  function codePointToString(ch) {
    if (ch <= 0xFFFF) {
      return String.fromCharCode(ch);
    }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);
  }

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpFlags = function (state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$8.validateRegExpPattern = function (state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$8.regexp_pattern = function (state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];
      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$8.regexp_disjunction = function (state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$8.regexp_alternative = function (state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$8.regexp_eatTerm = function (state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$8.regexp_eatAssertion = function (state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true;
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true;
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true;
      }
    }
    state.pos = start;
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$8.regexp_eatQuantifier = function (state, noError) {
    if (noError === void 0) noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$8.regexp_eatQuantifierPrefix = function (state, noError) {
    return state.eat(0x2A /* * */) || state.eat(0x2B /* + */) || state.eat(0x3F /* ? */) || this.regexp_eatBracedQuantifier(state, noError);
  };
  pp$8.regexp_eatBracedQuantifier = function (state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0,
        max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true;
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$8.regexp_eatAtom = function (state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function (state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$8.regexp_eatUncapturingGroup = function (state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true;
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false;
  };
  pp$8.regexp_eatCapturingGroup = function (state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true;
      }
      state.raise("Unterminated group");
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$8.regexp_eatExtendedAtom = function (state) {
    return state.eat(0x2E /* . */) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$8.regexp_eatInvalidBracedQuantifier = function (state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$8.regexp_eatSyntaxCharacter = function (state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isSyntaxCharacter(ch) {
    return ch === 0x24 /* $ */ || ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ || ch === 0x2E /* . */ || ch === 0x3F /* ? */ || ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ || ch >= 0x7B /* { */ && ch <= 0x7D /* } */;
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$8.regexp_eatPatternCharacters = function (state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$8.regexp_eatExtendedPatternCharacter = function (state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 0x24 /* $ */ && !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) && ch !== 0x2E /* . */ && ch !== 0x3F /* ? */ && ch !== 0x5B /* [ */ && ch !== 0x5E /* ^ */ && ch !== 0x7C /* | */) {
      state.advance();
      return true;
    }
    return false;
  };

  // GroupSpecifier[U] ::
  //   [empty]
  //   `?` GroupName[?U]
  pp$8.regexp_groupSpecifier = function (state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return;
      }
      state.raise("Invalid group");
    }
  };

  // GroupName[U] ::
  //   `<` RegExpIdentifierName[?U] `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatGroupName = function (state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true;
      }
      state.raise("Invalid capture group name");
    }
    return false;
  };

  // RegExpIdentifierName[U] ::
  //   RegExpIdentifierStart[?U]
  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$8.regexp_eatRegExpIdentifierName = function (state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true;
    }
    return false;
  };

  // RegExpIdentifierStart[U] ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  pp$8.regexp_eatRegExpIdentifierStart = function (state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();
    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F; /* _ */
  }

  // RegExpIdentifierPart[U] ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[?U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$8.regexp_eatRegExpIdentifierPart = function (state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();
    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D; /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$8.regexp_eatAtomEscape = function (state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
      return true;
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false;
  };
  pp$8.regexp_eatBackReference = function (state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true;
      }
      if (n <= state.numCapturingParens) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$8.regexp_eatKGroupName = function (state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true;
      }
      state.raise("Invalid named reference");
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$8.regexp_eatCharacterEscape = function (state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  };
  pp$8.regexp_eatCControlLetter = function (state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return false;
  };
  pp$8.regexp_eatZero = function (state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$8.regexp_eatControlEscape = function (state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true;
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true;
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true;
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true;
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$8.regexp_eatControlLetter = function (state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true;
    }
    return false;
  };
  function isControlLetter(ch) {
    return ch >= 0x41 /* A */ && ch <= 0x5A /* Z */ || ch >= 0x61 /* a */ && ch <= 0x7A /* z */;
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function (state) {
    var start = state.pos;
    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true;
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true;
      }
      if (state.switchU && state.eat(0x7B /* { */) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */) && isValidUnicode(state.lastIntValue)) {
        return true;
      }
      if (state.switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }
    return false;
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF;
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$8.regexp_eatIdentityEscape = function (state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true;
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true;
      }
      return false;
    }
    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$8.regexp_eatDecimalEscape = function (state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */);
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$8.regexp_eatCharacterClassEscape = function (state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true;
    }
    if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50 /* P */ || ch === 0x70 /* p */)) {
      state.lastIntValue = -1;
      state.advance();
      if (state.eat(0x7B /* { */) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D /* } */)) {
        return true;
      }
      state.raise("Invalid property name");
    }
    return false;
  };
  function isCharacterClassEscape(ch) {
    return ch === 0x64 /* d */ || ch === 0x44 /* D */ || ch === 0x73 /* s */ || ch === 0x53 /* S */ || ch === 0x77 /* w */ || ch === 0x57 /* W */;
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$8.regexp_eatUnicodePropertyValueExpression = function (state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true;
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true;
    }
    return false;
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name)) {
      state.raise("Invalid property name");
    }
    if (!state.unicodeProperties.nonBinary[name].test(value)) {
      state.raise("Invalid property value");
    }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue)) {
      state.raise("Invalid property name");
    }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$8.regexp_eatUnicodePropertyName = function (state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F; /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatUnicodePropertyValue = function (state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
    return this.regexp_eatUnicodePropertyValue(state);
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$8.regexp_eatCharacterClass = function (state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* [ */)) {
        return true;
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$8.regexp_classRanges = function (state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$8.regexp_eatClassAtom = function (state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true;
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    var ch = state.current();
    if (ch !== 0x5D /* [ */) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$8.regexp_eatClassEscape = function (state) {
    var start = state.pos;
    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true;
    }
    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true;
    }
    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true;
      }
      state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$8.regexp_eatClassControlLetter = function (state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatHexEscapeSequence = function (state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true;
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$8.regexp_eatDecimalDigits = function (state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start;
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39; /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$8.regexp_eatHexDigits = function (state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start;
  };
  function isHexDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */ || ch >= 0x41 /* A */ && ch <= 0x46 /* F */ || ch >= 0x61 /* a */ && ch <= 0x66 /* f */;
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */);
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */);
    }
    return ch - 0x30; /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$8.regexp_eatLegacyOctalEscapeSequence = function (state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true;
    }
    return false;
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$8.regexp_eatOctalDigit = function (state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true;
    }
    state.lastIntValue = 0;
    return false;
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37; /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$8.regexp_eatFixedHexDigits = function (state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false;
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true;
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations) {
      this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
    }
    if (p.options.ranges) {
      this.range = [p.start, p.end];
    }
  };

  // ## Tokenizer

  var pp$9 = Parser.prototype;

  // Move to the next token

  pp$9.next = function () {
    if (this.options.onToken) {
      this.options.onToken(new Token(this));
    }
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  pp$9.getToken = function () {
    this.next();
    return new Token(this);
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined") {
    pp$9[Symbol.iterator] = function () {
      var this$1 = this;
      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          };
        }
      };
    };
  }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  pp$9.curContext = function () {
    return this.context[this.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  pp$9.nextToken = function () {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) {
      this.skipSpace();
    }
    this.start = this.pos;
    if (this.options.locations) {
      this.startLoc = this.curPosition();
    }
    if (this.pos >= this.input.length) {
      return this.finishToken(types.eof);
    }
    if (curContext.override) {
      return curContext.override(this);
    } else {
      this.readToken(this.fullCharCodeAtPos());
    }
  };
  pp$9.readToken = function (code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) {
      return this.readWord();
    }
    return this.getTokenFromCode(code);
  };
  pp$9.fullCharCodeAtPos = function () {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) {
      return code;
    }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };
  pp$9.skipBlockComment = function () {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) {
      this.raise(this.pos - 2, "Unterminated comment");
    }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment) {
      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
    }
  };
  pp$9.skipLineComment = function (startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment) {
      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
    }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp$9.skipSpace = function () {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          // ' '
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          // '/'
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp$9.finishToken = function (type, val) {
    this.end = this.pos;
    if (this.options.locations) {
      this.endLoc = this.curPosition();
    }
    var prevType = this.type;
    this.type = type;
    this.value = val;
    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp$9.readToken_dot = function () {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types.ellipsis);
    } else {
      ++this.pos;
      return this.finishToken(types.dot);
    }
  };
  pp$9.readToken_slash = function () {
    // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
      ++this.pos;
      return this.readRegexp();
    }
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    }
    return this.finishOp(types.slash, 1);
  };
  pp$9.readToken_mult_modulo_exp = function (code) {
    // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61) {
      return this.finishOp(types.assign, size + 1);
    }
    return this.finishOp(tokentype, size);
  };
  pp$9.readToken_pipe_amp = function (code) {
    // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    }
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  };
  pp$9.readToken_caret = function () {
    // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    }
    return this.finishOp(types.bitwiseXOR, 1);
  };
  pp$9.readToken_plus_min = function (code) {
    // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types.incDec, 2);
    }
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    }
    return this.finishOp(types.plusMin, 1);
  };
  pp$9.readToken_lt_gt = function (code) {
    // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) {
        return this.finishOp(types.assign, size + 1);
      }
      return this.finishOp(types.bitShift, size);
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }
    if (next === 61) {
      size = 2;
    }
    return this.finishOp(types.relational, size);
  };
  pp$9.readToken_eq_excl = function (code) {
    // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) {
      return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
      // '=>'
      this.pos += 2;
      return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
  };
  pp$9.getTokenFromCode = function (code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.pos;
        return this.finishToken(types.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(types.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(types.semi);
      case 44:
        ++this.pos;
        return this.finishToken(types.comma);
      case 91:
        ++this.pos;
        return this.finishToken(types.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(types.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(types.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(types.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(types.colon);
      case 63:
        ++this.pos;
        return this.finishToken(types.question);
      case 96:
        // '`'
        if (this.options.ecmaVersion < 6) {
          break;
        }
        ++this.pos;
        return this.finishToken(types.backQuote);
      case 48:
        // '0'
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88) {
          return this.readRadixNumber(16);
        } // '0x', '0X' - hex number
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79) {
            return this.readRadixNumber(8);
          } // '0o', '0O' - octal number
          if (next === 98 || next === 66) {
            return this.readRadixNumber(2);
          } // '0b', '0B' - binary number
        }

      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:
      case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();
      case 37:
      case 42:
        // '%*'
        return this.readToken_mult_modulo_exp(code);
      case 124:
      case 38:
        // '|&'
        return this.readToken_pipe_amp(code);
      case 94:
        // '^'
        return this.readToken_caret();
      case 43:
      case 45:
        // '+-'
        return this.readToken_plus_min(code);
      case 60:
      case 62:
        // '<>'
        return this.readToken_lt_gt(code);
      case 61:
      case 33:
        // '=!'
        return this.readToken_eq_excl(code);
      case 126:
        // '~'
        return this.finishOp(types.prefix, 1);
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };
  pp$9.finishOp = function (type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str);
  };
  pp$9.readRegexp = function () {
    var escaped,
      inClass,
      start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) {
        this.raise(start, "Unterminated regular expression");
      }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (!escaped) {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      } else {
        escaped = false;
      }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) {
      this.unexpected(flagsStart);
    }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }
    return this.finishToken(types.regexp, {
      pattern: pattern,
      flags: flags,
      value: value
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp$9.readInt = function (radix, len) {
    var start = this.pos,
      total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos),
        val = void 0;
      if (code >= 97) {
        val = code - 97 + 10;
      } // a
      else if (code >= 65) {
        val = code - 65 + 10;
      } // A
      else if (code >= 48 && code <= 57) {
        val = code - 48;
      } // 0-9
      else {
        val = Infinity;
      }
      if (val >= radix) {
        break;
      }
      ++this.pos;
      total = total * radix + val;
    }
    if (this.pos === start || len != null && this.pos - start !== len) {
      return null;
    }
    return total;
  };
  pp$9.readRadixNumber = function (radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) {
      this.raise(this.start + 2, "Expected number in radix " + radix);
    }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  pp$9.readNumber = function (startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) {
      this.raise(start, "Invalid number");
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
      octal = false;
    }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var str$1 = this.input.slice(start, this.pos);
      var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types.num, val$1);
    }
    if (next === 46 && !octal) {
      // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
      // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) {
        ++this.pos;
      } // '+-'
      if (this.readInt(10) === null) {
        this.raise(start, "Invalid number");
      }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    var str = this.input.slice(start, this.pos);
    var val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  pp$9.readCodePoint = function () {
    var ch = this.input.charCodeAt(this.pos),
      code;
    if (ch === 123) {
      // '{'
      if (this.options.ecmaVersion < 6) {
        this.unexpected();
      }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) {
        this.invalidStringToken(codePos, "Code point out of bounds");
      }
    } else {
      code = this.readHexChar(4);
    }
    return code;
  };
  function codePointToString$1(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) {
      return String.fromCharCode(code);
    }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
  }
  pp$9.readString = function (quote) {
    var out = "",
      chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated string constant");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) {
        break;
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) {
          this.raise(this.start, "Unterminated string constant");
        }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out);
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp$9.tryReadTemplateToken = function () {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err;
      }
    }
    this.inTemplateElement = false;
  };
  pp$9.invalidStringToken = function (position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR;
    } else {
      this.raise(position, message);
    }
  };
  pp$9.readTmplToken = function () {
    var out = "",
      chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) {
        this.raise(this.start, "Unterminated template");
      }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
        // '`', '${'
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL);
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp$9.readInvalidTemplateToken = function () {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{") {
            break;
          }
        // falls through

        case "`":
          return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));

        // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp$9.readEscapedChar = function (inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
      case 110:
        return "\n";
      // 'n' -> '\n'
      case 114:
        return "\r";
      // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      // 'x'
      case 117:
        return codePointToString$1(this.readCodePoint());
      // 'u'
      case 116:
        return "\t";
      // 't' -> '\t'
      case 98:
        return "\b";
      // 'b' -> '\b'
      case 118:
        return "\u000b";
      // 'v' -> '\u000b'
      case 102:
        return "\f";
      // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) {
          ++this.pos;
        }
      // '\r\n'
      case 10:
        // ' \n'
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
            this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
          }
          return String.fromCharCode(octal);
        }
        if (isNewLine(ch)) {
          // Unicode new line characters after \ get removed from output in both
          // template literals and strings
          return "";
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp$9.readHexChar = function (len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) {
      this.invalidStringToken(codePos, "Bad character escape sequence");
    }
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp$9.readWord1 = function () {
    this.containsEsc = false;
    var word = "",
      first = true,
      chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117)
          // "u"
          {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
          this.invalidStringToken(escStart, "Invalid Unicode escape");
        }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp$9.readWord = function () {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
      }
      type = keywords$1[word];
    }
    return this.finishToken(type, word);
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "6.4.2";
  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options);
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options);
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options);
  }
  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const XHTMLEntities = __webpack_require__(94);
const hexNumber = /^[\da-fA-F]+$/;
const decimalNumber = /^\d+$/;

// The map to `acorn-jsx` tokens from `acorn` namespace objects.
const acornJsxMap = new WeakMap();

// Get the original tokens for the given `acorn` namespace object.
function getJsxTokens(acorn) {
  acorn = acorn.Parser.acorn || acorn;
  let acornJsx = acornJsxMap.get(acorn);
  if (!acornJsx) {
    const tt = acorn.tokTypes;
    const TokContext = acorn.TokContext;
    const TokenType = acorn.TokenType;
    const tc_oTag = new TokContext('<tag', false);
    const tc_cTag = new TokContext('</tag', false);
    const tc_expr = new TokContext('<tag>...</tag>', true, true);
    const tokContexts = {
      tc_oTag: tc_oTag,
      tc_cTag: tc_cTag,
      tc_expr: tc_expr
    };
    const tokTypes = {
      jsxName: new TokenType('jsxName'),
      jsxText: new TokenType('jsxText', {
        beforeExpr: true
      }),
      jsxTagStart: new TokenType('jsxTagStart', {
        startsExpr: true
      }),
      jsxTagEnd: new TokenType('jsxTagEnd')
    };
    tokTypes.jsxTagStart.updateContext = function () {
      this.context.push(tc_expr); // treat as beginning of JSX expression
      this.context.push(tc_oTag); // start opening tag context
      this.exprAllowed = false;
    };
    tokTypes.jsxTagEnd.updateContext = function (prevType) {
      let out = this.context.pop();
      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
        this.context.pop();
        this.exprAllowed = this.curContext() === tc_expr;
      } else {
        this.exprAllowed = true;
      }
    };
    acornJsx = {
      tokContexts: tokContexts,
      tokTypes: tokTypes
    };
    acornJsxMap.set(acorn, acornJsx);
  }
  return acornJsx;
}

// Transforms JSX element name to string.

function getQualifiedJSXName(object) {
  if (!object) return object;
  if (object.type === 'JSXIdentifier') return object.name;
  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;
  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
}
module.exports = function (options) {
  options = options || {};
  return function (Parser) {
    return plugin({
      allowNamespaces: options.allowNamespaces !== false,
      allowNamespacedObjects: !!options.allowNamespacedObjects
    }, Parser);
  };
};

// This is `tokTypes` of the peer dep.
// This can be different instances from the actual `tokTypes` this plugin uses.
Object.defineProperty(module.exports, "tokTypes", ({
  get: function get_tokTypes() {
    return getJsxTokens(__webpack_require__(92)).tokTypes;
  },
  configurable: true,
  enumerable: true
}));
function plugin(options, Parser) {
  const acorn = Parser.acorn || __webpack_require__(92);
  const acornJsx = getJsxTokens(acorn);
  const tt = acorn.tokTypes;
  const tok = acornJsx.tokTypes;
  const tokContexts = acorn.tokContexts;
  const tc_oTag = acornJsx.tokContexts.tc_oTag;
  const tc_cTag = acornJsx.tokContexts.tc_cTag;
  const tc_expr = acornJsx.tokContexts.tc_expr;
  const isNewLine = acorn.isNewLine;
  const isIdentifierStart = acorn.isIdentifierStart;
  const isIdentifierChar = acorn.isIdentifierChar;
  return class extends Parser {
    // Expose actual `tokTypes` and `tokContexts` to other plugins.
    static get acornJsx() {
      return acornJsx;
    }

    // Reads inline JSX contents token.
    jsx_readToken() {
      let out = '',
        chunkStart = this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');
        let ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 60: // '<'
          case 123:
            // '{'
            if (this.pos === this.start) {
              if (ch === 60 && this.exprAllowed) {
                ++this.pos;
                return this.finishToken(tok.jsxTagStart);
              }
              return this.getTokenFromCode(ch);
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(tok.jsxText, out);
          case 38:
            // '&'
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readEntity();
            chunkStart = this.pos;
            break;
          case 62: // '>'
          case 125:
            // '}'
            this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + "` or " + "`{\"" + this.input[this.pos] + "\"}" + "`?");
          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(true);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
        }
      }
    }
    jsx_readNewLine(normalizeCRLF) {
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
        out = normalizeCRLF ? '\n' : '\r\n';
      } else {
        out = String.fromCharCode(ch);
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      return out;
    }
    jsx_readString(quote) {
      let out = '',
        chunkStart = ++this.pos;
      for (;;) {
        if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 38) {
          // '&'
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    }
    jsx_readEntity() {
      let str = '',
        count = 0,
        entity;
      let ch = this.input[this.pos];
      if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');
      let startPos = ++this.pos;
      while (this.pos < this.input.length && count++ < 10) {
        ch = this.input[this.pos++];
        if (ch === ';') {
          if (str[0] === '#') {
            if (str[1] === 'x') {
              str = str.substr(2);
              if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
            } else {
              str = str.substr(1);
              if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
            }
          } else {
            entity = XHTMLEntities[str];
          }
          break;
        }
        str += ch;
      }
      if (!entity) {
        this.pos = startPos;
        return '&';
      }
      return entity;
    }

    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.

    jsx_readWord() {
      let ch,
        start = this.pos;
      do {
        ch = this.input.charCodeAt(++this.pos);
      } while (isIdentifierChar(ch) || ch === 45); // '-'
      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
    }

    // Parse next token as JSX identifier

    jsx_parseIdentifier() {
      let node = this.startNode();
      if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();
      this.next();
      return this.finishNode(node, 'JSXIdentifier');
    }

    // Parse namespaced identifier.

    jsx_parseNamespacedName() {
      let startPos = this.start,
        startLoc = this.startLoc;
      let name = this.jsx_parseIdentifier();
      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, 'JSXNamespacedName');
    }

    // Parses element name in any form - namespaced, member
    // or single identifier.

    jsx_parseElementName() {
      if (this.type === tok.jsxTagEnd) return '';
      let startPos = this.start,
        startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();
      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {
        this.unexpected();
      }
      while (this.eat(tt.dot)) {
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, 'JSXMemberExpression');
      }
      return node;
    }

    // Parses any type of JSX attribute value.

    jsx_parseAttributeValue() {
      switch (this.type) {
        case tt.braceL:
          let node = this.jsx_parseExpressionContainer();
          if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
          return node;
        case tok.jsxTagStart:
        case tt.string:
          return this.parseExprAtom();
        default:
          this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
      }
    }

    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).

    jsx_parseEmptyExpression() {
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
    }

    // Parses JSX expression enclosed into curly brackets.

    jsx_parseExpressionContainer() {
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, 'JSXExpressionContainer');
    }

    // Parses following JSX attribute name-value pair.

    jsx_parseAttribute() {
      let node = this.startNode();
      if (this.eat(tt.braceL)) {
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, 'JSXSpreadAttribute');
      }
      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, 'JSXAttribute');
    }

    // Parses JSX opening tag starting after '<'.

    jsx_parseOpeningElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) node.attributes.push(this.jsx_parseAttribute());
      node.selfClosing = this.eat(tt.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');
    }

    // Parses JSX closing tag starting after '</'.

    jsx_parseClosingElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');
    }

    // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.

    jsx_parseElementAt(startPos, startLoc) {
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;
      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.type) {
            case tok.jsxTagStart:
              startPos = this.start;
              startLoc = this.startLoc;
              this.next();
              if (this.eat(tt.slash)) {
                closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                break contents;
              }
              children.push(this.jsx_parseElementAt(startPos, startLoc));
              break;
            case tok.jsxText:
              children.push(this.parseExprAtom());
              break;
            case tt.braceL:
              children.push(this.jsx_parseExpressionContainer());
              break;
            default:
              this.unexpected();
          }
        }
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
          this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
        }
      }
      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';
      node['opening' + fragmentOrElement] = openingElement;
      node['closing' + fragmentOrElement] = closingElement;
      node.children = children;
      if (this.type === tt.relational && this.value === "<") {
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      }
      return this.finishNode(node, 'JSX' + fragmentOrElement);
    }

    // Parse JSX text

    jsx_parseText() {
      let node = this.parseLiteral(this.value);
      node.type = "JSXText";
      return node;
    }

    // Parses entire JSX element from current position.

    jsx_parseElement() {
      let startPos = this.start,
        startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    }
    parseExprAtom(refShortHandDefaultPos) {
      if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return super.parseExprAtom(refShortHandDefaultPos);
    }
    readToken(code) {
      let context = this.curContext();
      if (context === tc_expr) return this.jsx_readToken();
      if (context === tc_oTag || context === tc_cTag) {
        if (isIdentifierStart(code)) return this.jsx_readWord();
        if (code == 62) {
          ++this.pos;
          return this.finishToken(tok.jsxTagEnd);
        }
        if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);
      }
      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
        ++this.pos;
        return this.finishToken(tok.jsxTagStart);
      }
      return super.readToken(code);
    }
    updateContext(prevType) {
      if (this.type == tt.braceL) {
        var curContext = this.curContext();
        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else super.updateContext(prevType);
        this.exprAllowed = true;
      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.context.push(tc_cTag); // reconsider as closing tag context
        this.exprAllowed = false;
      } else {
        return super.updateContext(prevType);
      }
    }
  };
}

/***/ }),
/* 94 */
/***/ ((module) => {

module.exports = {
  quot: '\u0022',
  amp: '&',
  apos: '\u0027',
  lt: '<',
  gt: '>',
  nbsp: '\u00A0',
  iexcl: '\u00A1',
  cent: '\u00A2',
  pound: '\u00A3',
  curren: '\u00A4',
  yen: '\u00A5',
  brvbar: '\u00A6',
  sect: '\u00A7',
  uml: '\u00A8',
  copy: '\u00A9',
  ordf: '\u00AA',
  laquo: '\u00AB',
  not: '\u00AC',
  shy: '\u00AD',
  reg: '\u00AE',
  macr: '\u00AF',
  deg: '\u00B0',
  plusmn: '\u00B1',
  sup2: '\u00B2',
  sup3: '\u00B3',
  acute: '\u00B4',
  micro: '\u00B5',
  para: '\u00B6',
  middot: '\u00B7',
  cedil: '\u00B8',
  sup1: '\u00B9',
  ordm: '\u00BA',
  raquo: '\u00BB',
  frac14: '\u00BC',
  frac12: '\u00BD',
  frac34: '\u00BE',
  iquest: '\u00BF',
  Agrave: '\u00C0',
  Aacute: '\u00C1',
  Acirc: '\u00C2',
  Atilde: '\u00C3',
  Auml: '\u00C4',
  Aring: '\u00C5',
  AElig: '\u00C6',
  Ccedil: '\u00C7',
  Egrave: '\u00C8',
  Eacute: '\u00C9',
  Ecirc: '\u00CA',
  Euml: '\u00CB',
  Igrave: '\u00CC',
  Iacute: '\u00CD',
  Icirc: '\u00CE',
  Iuml: '\u00CF',
  ETH: '\u00D0',
  Ntilde: '\u00D1',
  Ograve: '\u00D2',
  Oacute: '\u00D3',
  Ocirc: '\u00D4',
  Otilde: '\u00D5',
  Ouml: '\u00D6',
  times: '\u00D7',
  Oslash: '\u00D8',
  Ugrave: '\u00D9',
  Uacute: '\u00DA',
  Ucirc: '\u00DB',
  Uuml: '\u00DC',
  Yacute: '\u00DD',
  THORN: '\u00DE',
  szlig: '\u00DF',
  agrave: '\u00E0',
  aacute: '\u00E1',
  acirc: '\u00E2',
  atilde: '\u00E3',
  auml: '\u00E4',
  aring: '\u00E5',
  aelig: '\u00E6',
  ccedil: '\u00E7',
  egrave: '\u00E8',
  eacute: '\u00E9',
  ecirc: '\u00EA',
  euml: '\u00EB',
  igrave: '\u00EC',
  iacute: '\u00ED',
  icirc: '\u00EE',
  iuml: '\u00EF',
  eth: '\u00F0',
  ntilde: '\u00F1',
  ograve: '\u00F2',
  oacute: '\u00F3',
  ocirc: '\u00F4',
  otilde: '\u00F5',
  ouml: '\u00F6',
  divide: '\u00F7',
  oslash: '\u00F8',
  ugrave: '\u00F9',
  uacute: '\u00FA',
  ucirc: '\u00FB',
  uuml: '\u00FC',
  yacute: '\u00FD',
  thorn: '\u00FE',
  yuml: '\u00FF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};

/***/ }),
/* 95 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview The AST node types produced by the parser.
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

// None!

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------
module.exports = {
  AssignmentExpression: "AssignmentExpression",
  AssignmentPattern: "AssignmentPattern",
  ArrayExpression: "ArrayExpression",
  ArrayPattern: "ArrayPattern",
  ArrowFunctionExpression: "ArrowFunctionExpression",
  AwaitExpression: "AwaitExpression",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  CatchClause: "CatchClause",
  ClassBody: "ClassBody",
  ClassDeclaration: "ClassDeclaration",
  ClassExpression: "ClassExpression",
  ConditionalExpression: "ConditionalExpression",
  ContinueStatement: "ContinueStatement",
  DoWhileStatement: "DoWhileStatement",
  DebuggerStatement: "DebuggerStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  FunctionExpression: "FunctionExpression",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  Literal: "Literal",
  LabeledStatement: "LabeledStatement",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  MetaProperty: "MetaProperty",
  MethodDefinition: "MethodDefinition",
  NewExpression: "NewExpression",
  ObjectExpression: "ObjectExpression",
  ObjectPattern: "ObjectPattern",
  Program: "Program",
  Property: "Property",
  RestElement: "RestElement",
  ReturnStatement: "ReturnStatement",
  SequenceExpression: "SequenceExpression",
  SpreadElement: "SpreadElement",
  Super: "Super",
  SwitchCase: "SwitchCase",
  SwitchStatement: "SwitchStatement",
  TaggedTemplateExpression: "TaggedTemplateExpression",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  ThisExpression: "ThisExpression",
  ThrowStatement: "ThrowStatement",
  TryStatement: "TryStatement",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement",
  WithStatement: "WithStatement",
  YieldExpression: "YieldExpression",
  JSXIdentifier: "JSXIdentifier",
  JSXNamespacedName: "JSXNamespacedName",
  JSXMemberExpression: "JSXMemberExpression",
  JSXEmptyExpression: "JSXEmptyExpression",
  JSXExpressionContainer: "JSXExpressionContainer",
  JSXElement: "JSXElement",
  JSXClosingElement: "JSXClosingElement",
  JSXOpeningElement: "JSXOpeningElement",
  JSXAttribute: "JSXAttribute",
  JSXSpreadAttribute: "JSXSpreadAttribute",
  JSXText: "JSXText",
  ExportDefaultDeclaration: "ExportDefaultDeclaration",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ExportAllDeclaration: "ExportAllDeclaration",
  ExportSpecifier: "ExportSpecifier",
  ImportDeclaration: "ImportDeclaration",
  ImportSpecifier: "ImportSpecifier",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};

/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable no-param-reassign*/
const acorn = __webpack_require__(92);
const jsx = __webpack_require__(93);
const TokenTranslator = __webpack_require__(97);
const DEFAULT_ECMA_VERSION = 5;
const STATE = Symbol("espree's internal state");
const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");
const tokTypes = Object.assign({}, acorn.tokTypes, jsx.tokTypes);

/**
 * Normalize ECMAScript version from the initial config
 * @param {number} ecmaVersion ECMAScript version from the initial config
 * @returns {number} normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion) {
  if (typeof ecmaVersion === "number") {
    let version = ecmaVersion;

    // Calculate ECMAScript edition number from official year version starting with
    // ES2015, which corresponds with ES6 (or a difference of 2009).
    if (version >= 2015) {
      version -= 2009;
    }
    switch (version) {
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        return version;
      default:
        throw new Error("Invalid ecmaVersion.");
    }
  } else {
    return DEFAULT_ECMA_VERSION;
  }
}

/**
 * Converts an Acorn comment to a Esprima comment.
 * @param {boolean} block True if it's a block comment, false if not.
 * @param {string} text The text of the comment.
 * @param {int} start The index at which the comment starts.
 * @param {int} end The index at which the comment ends.
 * @param {Location} startLoc The location at which the comment starts.
 * @param {Location} endLoc The location at which the comment ends.
 * @returns {Object} The comment object.
 * @private
 */
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
  const comment = {
    type: block ? "Block" : "Line",
    value: text
  };
  if (typeof start === "number") {
    comment.start = start;
    comment.end = end;
    comment.range = [start, end];
  }
  if (typeof startLoc === "object") {
    comment.loc = {
      start: startLoc,
      end: endLoc
    };
  }
  return comment;
}
module.exports = () => Parser => class Espree extends Parser {
  constructor(options, code) {
    if (typeof options !== "object" || options === null) {
      options = {};
    }
    if (typeof code !== "string" && !(code instanceof String)) {
      code = String(code);
    }
    const ecmaFeatures = options.ecmaFeatures || {};
    const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
    const isModule = options.sourceType === "module";
    const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null;

    // Initialize acorn parser.
    super({
      ecmaVersion: isModule ? Math.max(6, ecmaVersion) : ecmaVersion,
      sourceType: isModule ? "module" : "script",
      ranges: options.range === true,
      locations: options.loc === true,
      // Truthy value is true for backward compatibility.
      allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),
      // Collect tokens
      onToken: token => {
        if (tokenTranslator) {
          // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
          tokenTranslator.onToken(token, this[STATE]);
        }
        if (token.type !== tokTypes.eof) {
          this[STATE].lastToken = token;
        }
      },
      // Collect comments
      onComment: (block, text, start, end, startLoc, endLoc) => {
        if (this[STATE].comments) {
          const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);
          this[STATE].comments.push(comment);
        }
      }
    }, code);

    // Initialize internal state.
    this[STATE] = {
      tokens: tokenTranslator ? [] : null,
      comments: options.comment === true ? [] : null,
      impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,
      ecmaVersion: this.options.ecmaVersion,
      jsxAttrValueToken: false,
      lastToken: null
    };
  }
  tokenize() {
    do {
      this.next();
    } while (this.type !== tokTypes.eof);
    const extra = this[STATE];
    const tokens = extra.tokens;
    if (extra.comments) {
      tokens.comments = extra.comments;
    }
    return tokens;
  }
  finishNode() {
    const result = super.finishNode(...arguments);
    return this[ESPRIMA_FINISH_NODE](result);
  }
  finishNodeAt() {
    const result = super.finishNodeAt(...arguments);
    return this[ESPRIMA_FINISH_NODE](result);
  }
  parse() {
    const extra = this[STATE];
    const program = super.parse();
    program.sourceType = this.options.sourceType;
    if (extra.comments) {
      program.comments = extra.comments;
    }
    if (extra.tokens) {
      program.tokens = extra.tokens;
    }

    /*
     * Adjust opening and closing position of program to match Esprima.
     * Acorn always starts programs at range 0 whereas Esprima starts at the
     * first AST node's start (the only real difference is when there's leading
     * whitespace or leading comments). Acorn also counts trailing whitespace
     * as part of the program whereas Esprima only counts up to the last token.
     */
    if (program.range) {
      program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
      program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];
    }
    if (program.loc) {
      program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
      program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;
    }
    return program;
  }
  parseTopLevel(node) {
    if (this[STATE].impliedStrict) {
      this.strict = true;
    }
    return super.parseTopLevel(node);
  }

  /**
   * Overwrites the default raise method to throw Esprima-style errors.
   * @param {int} pos The position of the error.
   * @param {string} message The error message.
   * @throws {SyntaxError} A syntax error.
   * @returns {void}
   */
  raise(pos, message) {
    const loc = acorn.getLineInfo(this.input, pos);
    const err = new SyntaxError(message);
    err.index = pos;
    err.lineNumber = loc.line;
    err.column = loc.column + 1; // acorn uses 0-based columns
    throw err;
  }

  /**
   * Overwrites the default raise method to throw Esprima-style errors.
   * @param {int} pos The position of the error.
   * @param {string} message The error message.
   * @throws {SyntaxError} A syntax error.
   * @returns {void}
   */
  raiseRecoverable(pos, message) {
    this.raise(pos, message);
  }

  /**
   * Overwrites the default unexpected method to throw Esprima-style errors.
   * @param {int} pos The position of the error.
   * @throws {SyntaxError} A syntax error.
   * @returns {void}
   */
  unexpected(pos) {
    let message = "Unexpected token";
    if (pos !== null && pos !== void 0) {
      this.pos = pos;
      if (this.options.locations) {
        while (this.pos < this.lineStart) {
          this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
          --this.curLine;
        }
      }
      this.nextToken();
    }
    if (this.end > this.start) {
      message += ` ${this.input.slice(this.start, this.end)}`;
    }
    this.raise(this.start, message);
  }

  /*
   * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
   * uses regular tt.string without any distinction between this and regular JS
   * strings. As such, we intercept an attempt to read a JSX string and set a flag
   * on extra so that when tokens are converted, the next token will be switched
   * to JSXText via onToken.
   */
  jsx_readString(quote) {
    // eslint-disable-line camelcase
    const result = super.jsx_readString(quote);
    if (this.type === tokTypes.string) {
      this[STATE].jsxAttrValueToken = true;
    }
    return result;
  }

  /**
   * Performs last-minute Esprima-specific compatibility checks and fixes.
   * @param {ASTNode} result The node to check.
   * @returns {ASTNode} The finished node.
   */
  [ESPRIMA_FINISH_NODE](result) {
    // Acorn doesn't count the opening and closing backticks as part of templates
    // so we have to adjust ranges/locations appropriately.
    if (result.type === "TemplateElement") {
      // additional adjustment needed if ${ is the last token
      const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";
      if (result.range) {
        result.range[0]--;
        result.range[1] += terminalDollarBraceL ? 2 : 1;
      }
      if (result.loc) {
        result.loc.start.column--;
        result.loc.end.column += terminalDollarBraceL ? 2 : 1;
      }
    }
    if (result.type.indexOf("Function") > -1 && !result.generator) {
      result.generator = false;
    }
    return result;
  }
};

/***/ }),
/* 97 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Translates tokens between Acorn format and Esprima format.
 * @author Nicholas C. Zakas
 */
/* eslint no-underscore-dangle: 0 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

// none!

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

// Esprima Token Types
const Token = {
  Boolean: "Boolean",
  EOF: "<end>",
  Identifier: "Identifier",
  Keyword: "Keyword",
  Null: "Null",
  Numeric: "Numeric",
  Punctuator: "Punctuator",
  String: "String",
  RegularExpression: "RegularExpression",
  Template: "Template",
  JSXIdentifier: "JSXIdentifier",
  JSXText: "JSXText"
};

/**
 * Converts part of a template into an Esprima token.
 * @param {AcornToken[]} tokens The Acorn tokens representing the template.
 * @param {string} code The source code.
 * @returns {EsprimaToken} The Esprima equivalent of the template token.
 * @private
 */
function convertTemplatePart(tokens, code) {
  const firstToken = tokens[0],
    lastTemplateToken = tokens[tokens.length - 1];
  const token = {
    type: Token.Template,
    value: code.slice(firstToken.start, lastTemplateToken.end)
  };
  if (firstToken.loc) {
    token.loc = {
      start: firstToken.loc.start,
      end: lastTemplateToken.loc.end
    };
  }
  if (firstToken.range) {
    token.start = firstToken.range[0];
    token.end = lastTemplateToken.range[1];
    token.range = [token.start, token.end];
  }
  return token;
}

/**
 * Contains logic to translate Acorn tokens into Esprima tokens.
 * @param {Object} acornTokTypes The Acorn token types.
 * @param {string} code The source code Acorn is parsing. This is necessary
 *      to correct the "value" property of some tokens.
 * @constructor
 */
function TokenTranslator(acornTokTypes, code) {
  // token types
  this._acornTokTypes = acornTokTypes;

  // token buffer for templates
  this._tokens = [];

  // track the last curly brace
  this._curlyBrace = null;

  // the source code
  this._code = code;
}
TokenTranslator.prototype = {
  constructor: TokenTranslator,
  /**
   * Translates a single Esprima token to a single Acorn token. This may be
   * inaccurate due to how templates are handled differently in Esprima and
   * Acorn, but should be accurate for all other tokens.
   * @param {AcornToken} token The Acorn token to translate.
   * @param {Object} extra Espree extra object.
   * @returns {EsprimaToken} The Esprima version of the token.
   */
  translate(token, extra) {
    const type = token.type,
      tt = this._acornTokTypes;
    if (type === tt.name) {
      token.type = Token.Identifier;

      // TODO: See if this is an Acorn bug
      if (token.value === "static") {
        token.type = Token.Keyword;
      }
      if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
        token.type = Token.Keyword;
      }
    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type.binop && !type.keyword || type.isAssign) {
      token.type = Token.Punctuator;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.jsxName) {
      token.type = Token.JSXIdentifier;
    } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
      token.type = Token.JSXText;
    } else if (type.keyword) {
      if (type.keyword === "true" || type.keyword === "false") {
        token.type = Token.Boolean;
      } else if (type.keyword === "null") {
        token.type = Token.Null;
      } else {
        token.type = Token.Keyword;
      }
    } else if (type === tt.num) {
      token.type = Token.Numeric;
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.string) {
      if (extra.jsxAttrValueToken) {
        extra.jsxAttrValueToken = false;
        token.type = Token.JSXText;
      } else {
        token.type = Token.String;
      }
      token.value = this._code.slice(token.start, token.end);
    } else if (type === tt.regexp) {
      token.type = Token.RegularExpression;
      const value = token.value;
      token.regex = {
        flags: value.flags,
        pattern: value.pattern
      };
      token.value = `/${value.pattern}/${value.flags}`;
    }
    return token;
  },
  /**
   * Function to call during Acorn's onToken handler.
   * @param {AcornToken} token The Acorn token.
   * @param {Object} extra The Espree extra object.
   * @returns {void}
   */
  onToken(token, extra) {
    const that = this,
      tt = this._acornTokTypes,
      tokens = extra.tokens,
      templateTokens = this._tokens;

    /**
     * Flushes the buffered template tokens and resets the template
     * tracking.
     * @returns {void}
     * @private
     */
    function translateTemplateTokens() {
      tokens.push(convertTemplatePart(that._tokens, that._code));
      that._tokens = [];
    }
    if (token.type === tt.eof) {
      // might be one last curlyBrace
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      }
      return;
    }
    if (token.type === tt.backQuote) {
      // if there's already a curly, it's not part of the template
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
        this._curlyBrace = null;
      }
      templateTokens.push(token);

      // it's the end
      if (templateTokens.length > 1) {
        translateTemplateTokens();
      }
      return;
    }
    if (token.type === tt.dollarBraceL) {
      templateTokens.push(token);
      translateTemplateTokens();
      return;
    }
    if (token.type === tt.braceR) {
      // if there's already a curly, it's not part of the template
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
      }

      // store new curly for later
      this._curlyBrace = token;
      return;
    }
    if (token.type === tt.template || token.type === tt.invalidTemplate) {
      if (this._curlyBrace) {
        templateTokens.push(this._curlyBrace);
        this._curlyBrace = null;
      }
      templateTokens.push(token);
      return;
    }
    if (this._curlyBrace) {
      tokens.push(this.translate(this._curlyBrace, extra));
      this._curlyBrace = null;
    }
    tokens.push(this.translate(token, extra));
  }
};

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

module.exports = TokenTranslator;

/***/ }),
/* 98 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"espree","description":"An Esprima-compatible JavaScript parser built on Acorn","author":"Nicholas C. Zakas <nicholas+npm@nczconsulting.com>","homepage":"https://github.com/eslint/espree","main":"espree.js","version":"5.0.1","files":["lib","espree.js"],"engines":{"node":">=6.0.0"},"repository":"eslint/espree","bugs":{"url":"http://github.com/eslint/espree.git"},"license":"BSD-2-Clause","dependencies":{"acorn":"^6.0.7","acorn-jsx":"^5.0.0","eslint-visitor-keys":"^1.0.0"},"devDependencies":{"browserify":"^7.0.0","chai":"^1.10.0","eslint":"^5.7.0","eslint-config-eslint":"^5.0.1","eslint-plugin-node":"^8.0.0","eslint-release":"^1.0.0","esprima":"latest","esprima-fb":"^8001.2001.0-dev-harmony-fb","json-diff":"~0.3.1","leche":"^1.0.1","mocha":"^2.0.1","nyc":"^13.0.1","regenerate":"~0.5.4","shelljs":"^0.3.0","shelljs-nodecli":"^0.1.1","unicode-6.3.0":"~0.1.0"},"keywords":["ast","ecmascript","javascript","parser","syntax","acorn"],"scripts":{"generate-regex":"node tools/generate-identifier-regex.js","test":"npm run-script lint && node Makefile.js test","lint":"node Makefile.js lint","browserify":"node Makefile.js browserify","generate-release":"eslint-generate-release","generate-alpharelease":"eslint-generate-prerelease alpha","generate-betarelease":"eslint-generate-prerelease beta","generate-rcrelease":"eslint-generate-prerelease rc","publish-release":"eslint-publish-release"}}');

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof __webpack_require__.g=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&"object"=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*//**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/// Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);

/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A class of the code path analyzer.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const assert = __webpack_require__(3),
  CodePath = __webpack_require__(101),
  CodePathSegment = __webpack_require__(103),
  IdGenerator = __webpack_require__(109),
  debug = __webpack_require__(104),
  astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a `case` node (not `default` node).
 *
 * @param {ASTNode} node - A `SwitchCase` node to check.
 * @returns {boolean} `true` if the node is a `case` node (not `default` node).
 */
function isCaseNode(node) {
  return Boolean(node.test);
}

/**
 * Checks whether the given logical operator is taken into account for the code
 * path analysis.
 *
 * @param {string} operator - The operator found in the LogicalExpression node
 * @returns {boolean} `true` if the operator is "&&" or "||"
 */
function isHandledLogicalOperator(operator) {
  return operator === "&&" || operator === "||";
}

/**
 * Checks whether or not a given logical expression node goes different path
 * between the `true` case and the `false` case.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a test of a choice statement.
 */
function isForkingByTrueOrFalse(node) {
  const parent = node.parent;
  switch (parent.type) {
    case "ConditionalExpression":
    case "IfStatement":
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
      return parent.test === node;
    case "LogicalExpression":
      return isHandledLogicalOperator(parent.operator);
    default:
      return false;
  }
}

/**
 * Gets the boolean value of a given literal node.
 *
 * This is used to detect infinity loops (e.g. `while (true) {}`).
 * Statements preceded by an infinity loop are unreachable if the loop didn't
 * have any `break` statement.
 *
 * @param {ASTNode} node - A node to get.
 * @returns {boolean|undefined} a boolean value if the node is a Literal node,
 *   otherwise `undefined`.
 */
function getBooleanValueIfSimpleConstant(node) {
  if (node.type === "Literal") {
    return Boolean(node.value);
  }
  return void 0;
}

/**
 * Checks that a given identifier node is a reference or not.
 *
 * This is used to detect the first throwable node in a `try` block.
 *
 * @param {ASTNode} node - An Identifier node to check.
 * @returns {boolean} `true` if the node is a reference.
 */
function isIdentifierReference(node) {
  const parent = node.parent;
  switch (parent.type) {
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ArrayPattern":
    case "RestElement":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "CatchClause":
      return false;
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassDeclaration":
    case "ClassExpression":
    case "VariableDeclarator":
      return parent.id !== node;
    case "Property":
    case "MethodDefinition":
      return parent.key !== node || parent.computed || parent.shorthand;
    case "AssignmentPattern":
      return parent.key !== node;
    default:
      return true;
  }
}

/**
 * Updates the current segment with the head segment.
 * This is similar to local branches and tracking branches of git.
 *
 * To separate the current and the head is in order to not make useless segments.
 *
 * In this process, both "onCodePathSegmentStart" and "onCodePathSegmentEnd"
 * events are fired.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function forwardCurrentToHead(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  const currentSegments = state.currentSegments;
  const headSegments = state.headSegments;
  const end = Math.max(currentSegments.length, headSegments.length);
  let i, currentSegment, headSegment;

  // Fires leaving events.
  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];
    if (currentSegment !== headSegment && currentSegment) {
      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
      if (currentSegment.reachable) {
        analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
      }
    }
  }

  // Update state.
  state.currentSegments = headSegments;

  // Fires entering events.
  for (i = 0; i < end; ++i) {
    currentSegment = currentSegments[i];
    headSegment = headSegments[i];
    if (currentSegment !== headSegment && headSegment) {
      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
      CodePathSegment.markUsed(headSegment);
      if (headSegment.reachable) {
        analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
      }
    }
  }
}

/**
 * Updates the current segment with empty.
 * This is called at the last of functions or the program.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function leaveFromCurrentSegment(analyzer, node) {
  const state = CodePath.getState(analyzer.codePath);
  const currentSegments = state.currentSegments;
  for (let i = 0; i < currentSegments.length; ++i) {
    const currentSegment = currentSegments[i];
    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
    if (currentSegment.reachable) {
      analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
    }
  }
  state.currentSegments = [];
}

/**
 * Updates the code path due to the position of a given node in the parent node
 * thereof.
 *
 * For example, if the node is `parent.consequent`, this creates a fork from the
 * current path.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function preprocess(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  const parent = node.parent;
  switch (parent.type) {
    case "LogicalExpression":
      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {
        state.makeLogicalRight();
      }
      break;
    case "ConditionalExpression":
    case "IfStatement":
      /*
       * Fork if this node is at `consequent`/`alternate`.
       * `popForkContext()` exists at `IfStatement:exit` and
       * `ConditionalExpression:exit`.
       */
      if (parent.consequent === node) {
        state.makeIfConsequent();
      } else if (parent.alternate === node) {
        state.makeIfAlternate();
      }
      break;
    case "SwitchCase":
      if (parent.consequent[0] === node) {
        state.makeSwitchCaseBody(false, !parent.test);
      }
      break;
    case "TryStatement":
      if (parent.handler === node) {
        state.makeCatchBlock();
      } else if (parent.finalizer === node) {
        state.makeFinallyBlock();
      }
      break;
    case "WhileStatement":
      if (parent.test === node) {
        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
      } else {
        assert(parent.body === node);
        state.makeWhileBody();
      }
      break;
    case "DoWhileStatement":
      if (parent.body === node) {
        state.makeDoWhileBody();
      } else {
        assert(parent.test === node);
        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
      }
      break;
    case "ForStatement":
      if (parent.test === node) {
        state.makeForTest(getBooleanValueIfSimpleConstant(node));
      } else if (parent.update === node) {
        state.makeForUpdate();
      } else if (parent.body === node) {
        state.makeForBody();
      }
      break;
    case "ForInStatement":
    case "ForOfStatement":
      if (parent.left === node) {
        state.makeForInOfLeft();
      } else if (parent.right === node) {
        state.makeForInOfRight();
      } else {
        assert(parent.body === node);
        state.makeForInOfBody();
      }
      break;
    case "AssignmentPattern":
      /*
       * Fork if this node is at `right`.
       * `left` is executed always, so it uses the current path.
       * `popForkContext()` exists at `AssignmentPattern:exit`.
       */
      if (parent.right === node) {
        state.pushForkContext();
        state.forkBypassPath();
        state.forkPath();
      }
      break;
    default:
      break;
  }
}

/**
 * Updates the code path due to the type of a given node in entering.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function processCodePathToEnter(analyzer, node) {
  let codePath = analyzer.codePath;
  let state = codePath && CodePath.getState(codePath);
  const parent = node.parent;
  switch (node.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      if (codePath) {
        // Emits onCodePathSegmentStart events if updated.
        forwardCurrentToHead(analyzer, node);
        debug.dumpState(node, state, false);
      }

      // Create the code path of this scope.
      codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);
      state = CodePath.getState(codePath);

      // Emits onCodePathStart events.
      debug.dump(`onCodePathStart ${codePath.id}`);
      analyzer.emitter.emit("onCodePathStart", codePath, node);
      break;
    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) {
        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
      }
      break;
    case "ConditionalExpression":
    case "IfStatement":
      state.pushChoiceContext("test", false);
      break;
    case "SwitchStatement":
      state.pushSwitchContext(node.cases.some(isCaseNode), astUtils.getLabel(node));
      break;
    case "TryStatement":
      state.pushTryContext(Boolean(node.finalizer));
      break;
    case "SwitchCase":
      /*
       * Fork if this node is after the 2st node in `cases`.
       * It's similar to `else` blocks.
       * The next `test` node is processed in this path.
       */
      if (parent.discriminant !== node && parent.cases[0] !== node) {
        state.forkPath();
      }
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.pushLoopContext(node.type, astUtils.getLabel(node));
      break;
    case "LabeledStatement":
      if (!astUtils.isBreakableStatement(node.body)) {
        state.pushBreakContext(false, node.label.name);
      }
      break;
    default:
      break;
  }

  // Emits onCodePathSegmentStart events if updated.
  forwardCurrentToHead(analyzer, node);
  debug.dumpState(node, state, false);
}

/**
 * Updates the code path due to the type of a given node in leaving.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function processCodePathToExit(analyzer, node) {
  const codePath = analyzer.codePath;
  const state = CodePath.getState(codePath);
  let dontForward = false;
  switch (node.type) {
    case "IfStatement":
    case "ConditionalExpression":
      state.popChoiceContext();
      break;
    case "LogicalExpression":
      if (isHandledLogicalOperator(node.operator)) {
        state.popChoiceContext();
      }
      break;
    case "SwitchStatement":
      state.popSwitchContext();
      break;
    case "SwitchCase":
      /*
       * This is the same as the process at the 1st `consequent` node in
       * `preprocess` function.
       * Must do if this `consequent` is empty.
       */
      if (node.consequent.length === 0) {
        state.makeSwitchCaseBody(true, !node.test);
      }
      if (state.forkContext.reachable) {
        dontForward = true;
      }
      break;
    case "TryStatement":
      state.popTryContext();
      break;
    case "BreakStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeBreak(node.label && node.label.name);
      dontForward = true;
      break;
    case "ContinueStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeContinue(node.label && node.label.name);
      dontForward = true;
      break;
    case "ReturnStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeReturn();
      dontForward = true;
      break;
    case "ThrowStatement":
      forwardCurrentToHead(analyzer, node);
      state.makeThrow();
      dontForward = true;
      break;
    case "Identifier":
      if (isIdentifierReference(node)) {
        state.makeFirstThrowablePathInTryBlock();
        dontForward = true;
      }
      break;
    case "CallExpression":
    case "MemberExpression":
    case "NewExpression":
      state.makeFirstThrowablePathInTryBlock();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      state.popLoopContext();
      break;
    case "AssignmentPattern":
      state.popForkContext();
      break;
    case "LabeledStatement":
      if (!astUtils.isBreakableStatement(node.body)) {
        state.popBreakContext();
      }
      break;
    default:
      break;
  }

  // Emits onCodePathSegmentStart events if updated.
  if (!dontForward) {
    forwardCurrentToHead(analyzer, node);
  }
  debug.dumpState(node, state, true);
}

/**
 * Updates the code path to finalize the current code path.
 *
 * @param {CodePathAnalyzer} analyzer - The instance.
 * @param {ASTNode} node - The current AST node.
 * @returns {void}
 */
function postprocess(analyzer, node) {
  switch (node.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      {
        let codePath = analyzer.codePath;

        // Mark the current path as the final node.
        CodePath.getState(codePath).makeFinal();

        // Emits onCodePathSegmentEnd event of the current segments.
        leaveFromCurrentSegment(analyzer, node);

        // Emits onCodePathEnd event of this code path.
        debug.dump(`onCodePathEnd ${codePath.id}`);
        analyzer.emitter.emit("onCodePathEnd", codePath, node);
        debug.dumpDot(codePath);
        codePath = analyzer.codePath = analyzer.codePath.upper;
        if (codePath) {
          debug.dumpState(node, CodePath.getState(codePath), true);
        }
        break;
      }
    default:
      break;
  }
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The class to analyze code paths.
 * This class implements the EventGenerator interface.
 */
class CodePathAnalyzer {
  /**
   * @param {EventGenerator} eventGenerator - An event generator to wrap.
   */
  constructor(eventGenerator) {
    this.original = eventGenerator;
    this.emitter = eventGenerator.emitter;
    this.codePath = null;
    this.idGenerator = new IdGenerator("s");
    this.currentNode = null;
    this.onLooped = this.onLooped.bind(this);
  }

  /**
   * Does the process to enter a given AST node.
   * This updates state of analysis and calls `enterNode` of the wrapped.
   *
   * @param {ASTNode} node - A node which is entering.
   * @returns {void}
   */
  enterNode(node) {
    this.currentNode = node;

    // Updates the code path due to node's position in its parent node.
    if (node.parent) {
      preprocess(this, node);
    }

    /*
     * Updates the code path.
     * And emits onCodePathStart/onCodePathSegmentStart events.
     */
    processCodePathToEnter(this, node);

    // Emits node events.
    this.original.enterNode(node);
    this.currentNode = null;
  }

  /**
   * Does the process to leave a given AST node.
   * This updates state of analysis and calls `leaveNode` of the wrapped.
   *
   * @param {ASTNode} node - A node which is leaving.
   * @returns {void}
   */
  leaveNode(node) {
    this.currentNode = node;

    /*
     * Updates the code path.
     * And emits onCodePathStart/onCodePathSegmentStart events.
     */
    processCodePathToExit(this, node);

    // Emits node events.
    this.original.leaveNode(node);

    // Emits the last onCodePathStart/onCodePathSegmentStart events.
    postprocess(this, node);
    this.currentNode = null;
  }

  /**
   * This is called on a code path looped.
   * Then this raises a looped event.
   *
   * @param {CodePathSegment} fromSegment - A segment of prev.
   * @param {CodePathSegment} toSegment - A segment of next.
   * @returns {void}
   */
  onLooped(fromSegment, toSegment) {
    if (fromSegment.reachable && toSegment.reachable) {
      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
      this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
    }
  }
}
module.exports = CodePathAnalyzer;

/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A class of the code path.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const CodePathState = __webpack_require__(102);
const IdGenerator = __webpack_require__(109);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path.
 */
class CodePath {
  /**
   * @param {string} id - An identifier.
   * @param {CodePath|null} upper - The code path of the upper function scope.
   * @param {Function} onLooped - A callback function to notify looping.
   */
  constructor(id, upper, onLooped) {
    /**
     * The identifier of this code path.
     * Rules use it to store additional information of each rule.
     * @type {string}
     */
    this.id = id;

    /**
     * The code path of the upper function scope.
     * @type {CodePath|null}
     */
    this.upper = upper;

    /**
     * The code paths of nested function scopes.
     * @type {CodePath[]}
     */
    this.childCodePaths = [];

    // Initializes internal state.
    Object.defineProperty(this, "internal", {
      value: new CodePathState(new IdGenerator(`${id}_`), onLooped)
    });

    // Adds this into `childCodePaths` of `upper`.
    if (upper) {
      upper.childCodePaths.push(this);
    }
  }

  /**
   * Gets the state of a given code path.
   *
   * @param {CodePath} codePath - A code path to get.
   * @returns {CodePathState} The state of the code path.
   */
  static getState(codePath) {
    return codePath.internal;
  }

  /**
   * The initial code path segment.
   * @type {CodePathSegment}
   */
  get initialSegment() {
    return this.internal.initialSegment;
  }

  /**
   * Final code path segments.
   * This array is a mix of `returnedSegments` and `thrownSegments`.
   * @type {CodePathSegment[]}
   */
  get finalSegments() {
    return this.internal.finalSegments;
  }

  /**
   * Final code path segments which is with `return` statements.
   * This array contains the last path segment if it's reachable.
   * Since the reachable last path returns `undefined`.
   * @type {CodePathSegment[]}
   */
  get returnedSegments() {
    return this.internal.returnedForkContext;
  }

  /**
   * Final code path segments which is with `throw` statements.
   * @type {CodePathSegment[]}
   */
  get thrownSegments() {
    return this.internal.thrownForkContext;
  }

  /**
   * Current code path segments.
   * @type {CodePathSegment[]}
   */
  get currentSegments() {
    return this.internal.currentSegments;
  }

  /**
   * Traverses all segments in this code path.
   *
   *     codePath.traverseSegments(function(segment, controller) {
   *         // do something.
   *     });
   *
   * This method enumerates segments in order from the head.
   *
   * The `controller` object has two methods.
   *
   * - `controller.skip()` - Skip the following segments in this branch.
   * - `controller.break()` - Skip all following segments.
   *
   * @param {Object} [options] - Omittable.
   * @param {CodePathSegment} [options.first] - The first segment to traverse.
   * @param {CodePathSegment} [options.last] - The last segment to traverse.
   * @param {Function} callback - A callback function.
   * @returns {void}
   */
  traverseSegments(options, callback) {
    let resolvedOptions;
    let resolvedCallback;
    if (typeof options === "function") {
      resolvedCallback = options;
      resolvedOptions = {};
    } else {
      resolvedOptions = options || {};
      resolvedCallback = callback;
    }
    const startSegment = resolvedOptions.first || this.internal.initialSegment;
    const lastSegment = resolvedOptions.last;
    let item = null;
    let index = 0;
    let end = 0;
    let segment = null;
    const visited = Object.create(null);
    const stack = [[startSegment, 0]];
    let skippedSegment = null;
    let broken = false;
    const controller = {
      skip() {
        if (stack.length <= 1) {
          broken = true;
        } else {
          skippedSegment = stack[stack.length - 2][0];
        }
      },
      break() {
        broken = true;
      }
    };

    /**
     * Checks a given previous segment has been visited.
     * @param {CodePathSegment} prevSegment - A previous segment to check.
     * @returns {boolean} `true` if the segment has been visited.
     */
    function isVisited(prevSegment) {
      return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
    }
    while (stack.length > 0) {
      item = stack[stack.length - 1];
      segment = item[0];
      index = item[1];
      if (index === 0) {
        // Skip if this segment has been visited already.
        if (visited[segment.id]) {
          stack.pop();
          continue;
        }

        // Skip if all previous segments have not been visited.
        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
          stack.pop();
          continue;
        }

        // Reset the flag of skipping if all branches have been skipped.
        if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
          skippedSegment = null;
        }
        visited[segment.id] = true;

        // Call the callback when the first time.
        if (!skippedSegment) {
          resolvedCallback.call(this, segment, controller);
          if (segment === lastSegment) {
            controller.skip();
          }
          if (broken) {
            break;
          }
        }
      }

      // Update the stack.
      end = segment.nextSegments.length - 1;
      if (index < end) {
        item[1] += 1;
        stack.push([segment.nextSegments[index], 0]);
      } else if (index === end) {
        item[0] = segment.nextSegments[index];
        item[1] = 0;
      } else {
        stack.pop();
      }
    }
  }
}
module.exports = CodePath;

/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A class to manage state of generating a code path.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const CodePathSegment = __webpack_require__(103),
  ForkContext = __webpack_require__(108);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Adds given segments into the `dest` array.
 * If the `others` array does not includes the given segments, adds to the `all`
 * array as well.
 *
 * This adds only reachable and used segments.
 *
 * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).
 * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).
 * @param {CodePathSegment[]} segments - Segments to add.
 * @returns {void}
 */
function addToReturnedOrThrown(dest, others, all, segments) {
  for (let i = 0; i < segments.length; ++i) {
    const segment = segments[i];
    dest.push(segment);
    if (others.indexOf(segment) === -1) {
      all.push(segment);
    }
  }
}

/**
 * Gets a loop-context for a `continue` statement.
 *
 * @param {CodePathState} state - A state to get.
 * @param {string} label - The label of a `continue` statement.
 * @returns {LoopContext} A loop-context for a `continue` statement.
 */
function getContinueContext(state, label) {
  if (!label) {
    return state.loopContext;
  }
  let context = state.loopContext;
  while (context) {
    if (context.label === label) {
      return context;
    }
    context = context.upper;
  }

  /* istanbul ignore next: foolproof (syntax error) */
  return null;
}

/**
 * Gets a context for a `break` statement.
 *
 * @param {CodePathState} state - A state to get.
 * @param {string} label - The label of a `break` statement.
 * @returns {LoopContext|SwitchContext} A context for a `break` statement.
 */
function getBreakContext(state, label) {
  let context = state.breakContext;
  while (context) {
    if (label ? context.label === label : context.breakable) {
      return context;
    }
    context = context.upper;
  }

  /* istanbul ignore next: foolproof (syntax error) */
  return null;
}

/**
 * Gets a context for a `return` statement.
 *
 * @param {CodePathState} state - A state to get.
 * @returns {TryContext|CodePathState} A context for a `return` statement.
 */
function getReturnContext(state) {
  let context = state.tryContext;
  while (context) {
    if (context.hasFinalizer && context.position !== "finally") {
      return context;
    }
    context = context.upper;
  }
  return state;
}

/**
 * Gets a context for a `throw` statement.
 *
 * @param {CodePathState} state - A state to get.
 * @returns {TryContext|CodePathState} A context for a `throw` statement.
 */
function getThrowContext(state) {
  let context = state.tryContext;
  while (context) {
    if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
      return context;
    }
    context = context.upper;
  }
  return state;
}

/**
 * Removes a given element from a given array.
 *
 * @param {any[]} xs - An array to remove the specific element.
 * @param {any} x - An element to be removed.
 * @returns {void}
 */
function remove(xs, x) {
  xs.splice(xs.indexOf(x), 1);
}

/**
 * Disconnect given segments.
 *
 * This is used in a process for switch statements.
 * If there is the "default" chunk before other cases, the order is different
 * between node's and running's.
 *
 * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.
 * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.
 * @returns {void}
 */
function removeConnection(prevSegments, nextSegments) {
  for (let i = 0; i < prevSegments.length; ++i) {
    const prevSegment = prevSegments[i];
    const nextSegment = nextSegments[i];
    remove(prevSegment.nextSegments, nextSegment);
    remove(prevSegment.allNextSegments, nextSegment);
    remove(nextSegment.prevSegments, prevSegment);
    remove(nextSegment.allPrevSegments, prevSegment);
  }
}

/**
 * Creates looping path.
 *
 * @param {CodePathState} state - The instance.
 * @param {CodePathSegment[]} unflattenedFromSegments - Segments which are source.
 * @param {CodePathSegment[]} unflattenedToSegments - Segments which are destination.
 * @returns {void}
 */
function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
  const end = Math.min(fromSegments.length, toSegments.length);
  for (let i = 0; i < end; ++i) {
    const fromSegment = fromSegments[i];
    const toSegment = toSegments[i];
    if (toSegment.reachable) {
      fromSegment.nextSegments.push(toSegment);
    }
    if (fromSegment.reachable) {
      toSegment.prevSegments.push(fromSegment);
    }
    fromSegment.allNextSegments.push(toSegment);
    toSegment.allPrevSegments.push(fromSegment);
    if (toSegment.allPrevSegments.length >= 2) {
      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
    }
    state.notifyLooped(fromSegment, toSegment);
  }
}

/**
 * Finalizes segments of `test` chunk of a ForStatement.
 *
 * - Adds `false` paths to paths which are leaving from the loop.
 * - Sets `true` paths to paths which go to the body.
 *
 * @param {LoopContext} context - A loop context to modify.
 * @param {ChoiceContext} choiceContext - A choice context of this loop.
 * @param {CodePathSegment[]} head - The current head paths.
 * @returns {void}
 */
function finalizeTestSegmentsOfFor(context, choiceContext, head) {
  if (!choiceContext.processed) {
    choiceContext.trueForkContext.add(head);
    choiceContext.falseForkContext.add(head);
  }
  if (context.test !== true) {
    context.brokenForkContext.addAll(choiceContext.falseForkContext);
  }
  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A class which manages state to analyze code paths.
 */
class CodePathState {
  /**
   * @param {IdGenerator} idGenerator - An id generator to generate id for code
   *   path segments.
   * @param {Function} onLooped - A callback function to notify looping.
   */
  constructor(idGenerator, onLooped) {
    this.idGenerator = idGenerator;
    this.notifyLooped = onLooped;
    this.forkContext = ForkContext.newRoot(idGenerator);
    this.choiceContext = null;
    this.switchContext = null;
    this.tryContext = null;
    this.loopContext = null;
    this.breakContext = null;
    this.currentSegments = [];
    this.initialSegment = this.forkContext.head[0];

    // returnedSegments and thrownSegments push elements into finalSegments also.
    const final = this.finalSegments = [];
    const returned = this.returnedForkContext = [];
    const thrown = this.thrownForkContext = [];
    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
  }

  /**
   * The head segments.
   * @type {CodePathSegment[]}
   */
  get headSegments() {
    return this.forkContext.head;
  }

  /**
   * The parent forking context.
   * This is used for the root of new forks.
   * @type {ForkContext}
   */
  get parentForkContext() {
    const current = this.forkContext;
    return current && current.upper;
  }

  /**
   * Creates and stacks new forking context.
   *
   * @param {boolean} forkLeavingPath - A flag which shows being in a
   *   "finally" block.
   * @returns {ForkContext} The created context.
   */
  pushForkContext(forkLeavingPath) {
    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);
    return this.forkContext;
  }

  /**
   * Pops and merges the last forking context.
   * @returns {ForkContext} The last context.
   */
  popForkContext() {
    const lastContext = this.forkContext;
    this.forkContext = lastContext.upper;
    this.forkContext.replaceHead(lastContext.makeNext(0, -1));
    return lastContext;
  }

  /**
   * Creates a new path.
   * @returns {void}
   */
  forkPath() {
    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
  }

  /**
   * Creates a bypass path.
   * This is used for such as IfStatement which does not have "else" chunk.
   *
   * @returns {void}
   */
  forkBypassPath() {
    this.forkContext.add(this.parentForkContext.head);
  }

  //--------------------------------------------------------------------------
  // ConditionalExpression, LogicalExpression, IfStatement
  //--------------------------------------------------------------------------

  /**
   * Creates a context for ConditionalExpression, LogicalExpression,
   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
   *
   * LogicalExpressions have cases that it goes different paths between the
   * `true` case and the `false` case.
   *
   * For Example:
   *
   *     if (a || b) {
   *         foo();
   *     } else {
   *         bar();
   *     }
   *
   * In this case, `b` is evaluated always in the code path of the `else`
   * block, but it's not so in the code path of the `if` block.
   * So there are 3 paths.
   *
   *     a -> foo();
   *     a -> b -> foo();
   *     a -> b -> bar();
   *
   * @param {string} kind - A kind string.
   *   If the new context is LogicalExpression's, this is `"&&"` or `"||"`.
   *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
   *   Otherwise, this is `"loop"`.
   * @param {boolean} isForkingAsResult - A flag that shows that goes different
   *   paths between `true` and `false`.
   * @returns {void}
   */
  pushChoiceContext(kind, isForkingAsResult) {
    this.choiceContext = {
      upper: this.choiceContext,
      kind,
      isForkingAsResult,
      trueForkContext: ForkContext.newEmpty(this.forkContext),
      falseForkContext: ForkContext.newEmpty(this.forkContext),
      processed: false
    };
  }

  /**
   * Pops the last choice context and finalizes it.
   *
   * @returns {ChoiceContext} The popped context.
   */
  popChoiceContext() {
    const context = this.choiceContext;
    this.choiceContext = context.upper;
    const forkContext = this.forkContext;
    const headSegments = forkContext.head;
    switch (context.kind) {
      case "&&":
      case "||":
        /*
         * If any result were not transferred from child contexts,
         * this sets the head segments to both cases.
         * The head segments are the path of the right-hand operand.
         */
        if (!context.processed) {
          context.trueForkContext.add(headSegments);
          context.falseForkContext.add(headSegments);
        }

        /*
         * Transfers results to upper context if this context is in
         * test chunk.
         */
        if (context.isForkingAsResult) {
          const parentContext = this.choiceContext;
          parentContext.trueForkContext.addAll(context.trueForkContext);
          parentContext.falseForkContext.addAll(context.falseForkContext);
          parentContext.processed = true;
          return context;
        }
        break;
      case "test":
        if (!context.processed) {
          /*
           * The head segments are the path of the `if` block here.
           * Updates the `true` path with the end of the `if` block.
           */
          context.trueForkContext.clear();
          context.trueForkContext.add(headSegments);
        } else {
          /*
           * The head segments are the path of the `else` block here.
           * Updates the `false` path with the end of the `else`
           * block.
           */
          context.falseForkContext.clear();
          context.falseForkContext.add(headSegments);
        }
        break;
      case "loop":
        /*
         * Loops are addressed in popLoopContext().
         * This is called from popLoopContext().
         */
        return context;

      /* istanbul ignore next */
      default:
        throw new Error("unreachable");
    }

    // Merges all paths.
    const prevForkContext = context.trueForkContext;
    prevForkContext.addAll(context.falseForkContext);
    forkContext.replaceHead(prevForkContext.makeNext(0, -1));
    return context;
  }

  /**
   * Makes a code path segment of the right-hand operand of a logical
   * expression.
   *
   * @returns {void}
   */
  makeLogicalRight() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;
    if (context.processed) {
      /*
       * This got segments already from the child choice context.
       * Creates the next path from own true/false fork context.
       */
      const prevForkContext = context.kind === "&&" ? context.trueForkContext
      /* kind === "||" */ : context.falseForkContext;
      forkContext.replaceHead(prevForkContext.makeNext(0, -1));
      prevForkContext.clear();
      context.processed = false;
    } else {
      /*
       * This did not get segments from the child choice context.
       * So addresses the head segments.
       * The head segments are the path of the left-hand operand.
       */
      if (context.kind === "&&") {
        // The path does short-circuit if false.
        context.falseForkContext.add(forkContext.head);
      } else {
        // The path does short-circuit if true.
        context.trueForkContext.add(forkContext.head);
      }
      forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }
  }

  /**
   * Makes a code path segment of the `if` block.
   *
   * @returns {void}
   */
  makeIfConsequent() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;

    /*
     * If any result were not transferred from child contexts,
     * this sets the head segments to both cases.
     * The head segments are the path of the test expression.
     */
    if (!context.processed) {
      context.trueForkContext.add(forkContext.head);
      context.falseForkContext.add(forkContext.head);
    }
    context.processed = false;

    // Creates new path from the `true` case.
    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
  }

  /**
   * Makes a code path segment of the `else` block.
   *
   * @returns {void}
   */
  makeIfAlternate() {
    const context = this.choiceContext;
    const forkContext = this.forkContext;

    /*
     * The head segments are the path of the `if` block.
     * Updates the `true` path with the end of the `if` block.
     */
    context.trueForkContext.clear();
    context.trueForkContext.add(forkContext.head);
    context.processed = true;

    // Creates new path from the `false` case.
    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
  }

  //--------------------------------------------------------------------------
  // SwitchStatement
  //--------------------------------------------------------------------------

  /**
   * Creates a context object of SwitchStatement and stacks it.
   *
   * @param {boolean} hasCase - `true` if the switch statement has one or more
   *   case parts.
   * @param {string|null} label - The label text.
   * @returns {void}
   */
  pushSwitchContext(hasCase, label) {
    this.switchContext = {
      upper: this.switchContext,
      hasCase,
      defaultSegments: null,
      defaultBodySegments: null,
      foundDefault: false,
      lastIsDefault: false,
      countForks: 0
    };
    this.pushBreakContext(true, label);
  }

  /**
   * Pops the last context of SwitchStatement and finalizes it.
   *
   * - Disposes all forking stack for `case` and `default`.
   * - Creates the next code path segment from `context.brokenForkContext`.
   * - If the last `SwitchCase` node is not a `default` part, creates a path
   *   to the `default` body.
   *
   * @returns {void}
   */
  popSwitchContext() {
    const context = this.switchContext;
    this.switchContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;
    if (context.countForks === 0) {
      /*
       * When there is only one `default` chunk and there is one or more
       * `break` statements, even if forks are nothing, it needs to merge
       * those.
       */
      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.makeNext(-1, -1));
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
      return;
    }
    const lastSegments = forkContext.head;
    this.forkBypassPath();
    const lastCaseSegments = forkContext.head;

    /*
     * `brokenForkContext` is used to make the next segment.
     * It must add the last segment into `brokenForkContext`.
     */
    brokenForkContext.add(lastSegments);

    /*
     * A path which is failed in all case test should be connected to path
     * of `default` chunk.
     */
    if (!context.lastIsDefault) {
      if (context.defaultBodySegments) {
        /*
         * Remove a link from `default` label to its chunk.
         * It's false route.
         */
        removeConnection(context.defaultSegments, context.defaultBodySegments);
        makeLooped(this, lastCaseSegments, context.defaultBodySegments);
      } else {
        /*
         * It handles the last case body as broken if `default` chunk
         * does not exist.
         */
        brokenForkContext.add(lastCaseSegments);
      }
    }

    // Pops the segment context stack until the entry segment.
    for (let i = 0; i < context.countForks; ++i) {
      this.forkContext = this.forkContext.upper;
    }

    /*
     * Creates a path from all brokenForkContext paths.
     * This is a path after switch statement.
     */
    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
  }

  /**
   * Makes a code path segment for a `SwitchCase` node.
   *
   * @param {boolean} isEmpty - `true` if the body is empty.
   * @param {boolean} isDefault - `true` if the body is the default case.
   * @returns {void}
   */
  makeSwitchCaseBody(isEmpty, isDefault) {
    const context = this.switchContext;
    if (!context.hasCase) {
      return;
    }

    /*
     * Merge forks.
     * The parent fork context has two segments.
     * Those are from the current case and the body of the previous case.
     */
    const parentForkContext = this.forkContext;
    const forkContext = this.pushForkContext();
    forkContext.add(parentForkContext.makeNext(0, -1));

    /*
     * Save `default` chunk info.
     * If the `default` label is not at the last, we must make a path from
     * the last `case` to the `default` chunk.
     */
    if (isDefault) {
      context.defaultSegments = parentForkContext.head;
      if (isEmpty) {
        context.foundDefault = true;
      } else {
        context.defaultBodySegments = forkContext.head;
      }
    } else {
      if (!isEmpty && context.foundDefault) {
        context.foundDefault = false;
        context.defaultBodySegments = forkContext.head;
      }
    }
    context.lastIsDefault = isDefault;
    context.countForks += 1;
  }

  //--------------------------------------------------------------------------
  // TryStatement
  //--------------------------------------------------------------------------

  /**
   * Creates a context object of TryStatement and stacks it.
   *
   * @param {boolean} hasFinalizer - `true` if the try statement has a
   *   `finally` block.
   * @returns {void}
   */
  pushTryContext(hasFinalizer) {
    this.tryContext = {
      upper: this.tryContext,
      position: "try",
      hasFinalizer,
      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,
      thrownForkContext: ForkContext.newEmpty(this.forkContext),
      lastOfTryIsReachable: false,
      lastOfCatchIsReachable: false
    };
  }

  /**
   * Pops the last context of TryStatement and finalizes it.
   *
   * @returns {void}
   */
  popTryContext() {
    const context = this.tryContext;
    this.tryContext = context.upper;
    if (context.position === "catch") {
      // Merges two paths from the `try` block and `catch` block merely.
      this.popForkContext();
      return;
    }

    /*
     * The following process is executed only when there is the `finally`
     * block.
     */

    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;
    if (returned.empty && thrown.empty) {
      return;
    }

    // Separate head to normal paths and leaving paths.
    const headSegments = this.forkContext.head;
    this.forkContext = this.forkContext.upper;
    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);

    // Forwards the leaving path to upper contexts.
    if (!returned.empty) {
      getReturnContext(this).returnedForkContext.add(leavingSegments);
    }
    if (!thrown.empty) {
      getThrowContext(this).thrownForkContext.add(leavingSegments);
    }

    // Sets the normal path as the next.
    this.forkContext.replaceHead(normalSegments);

    /*
     * If both paths of the `try` block and the `catch` block are
     * unreachable, the next path becomes unreachable as well.
     */
    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
      this.forkContext.makeUnreachable();
    }
  }

  /**
   * Makes a code path segment for a `catch` block.
   *
   * @returns {void}
   */
  makeCatchBlock() {
    const context = this.tryContext;
    const forkContext = this.forkContext;
    const thrown = context.thrownForkContext;

    // Update state.
    context.position = "catch";
    context.thrownForkContext = ForkContext.newEmpty(forkContext);
    context.lastOfTryIsReachable = forkContext.reachable;

    // Merge thrown paths.
    thrown.add(forkContext.head);
    const thrownSegments = thrown.makeNext(0, -1);

    // Fork to a bypass and the merged thrown path.
    this.pushForkContext();
    this.forkBypassPath();
    this.forkContext.add(thrownSegments);
  }

  /**
   * Makes a code path segment for a `finally` block.
   *
   * In the `finally` block, parallel paths are created. The parallel paths
   * are used as leaving-paths. The leaving-paths are paths from `return`
   * statements and `throw` statements in a `try` block or a `catch` block.
   *
   * @returns {void}
   */
  makeFinallyBlock() {
    const context = this.tryContext;
    let forkContext = this.forkContext;
    const returned = context.returnedForkContext;
    const thrown = context.thrownForkContext;
    const headOfLeavingSegments = forkContext.head;

    // Update state.
    if (context.position === "catch") {
      // Merges two paths from the `try` block and `catch` block.
      this.popForkContext();
      forkContext = this.forkContext;
      context.lastOfCatchIsReachable = forkContext.reachable;
    } else {
      context.lastOfTryIsReachable = forkContext.reachable;
    }
    context.position = "finally";
    if (returned.empty && thrown.empty) {
      // This path does not leave.
      return;
    }

    /*
     * Create a parallel segment from merging returned and thrown.
     * This segment will leave at the end of this finally block.
     */
    const segments = forkContext.makeNext(-1, -1);
    for (let i = 0; i < forkContext.count; ++i) {
      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
      for (let j = 0; j < returned.segmentsList.length; ++j) {
        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
      }
      for (let j = 0; j < thrown.segmentsList.length; ++j) {
        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
      }
      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
    }
    this.pushForkContext(true);
    this.forkContext.add(segments);
  }

  /**
   * Makes a code path segment from the first throwable node to the `catch`
   * block or the `finally` block.
   *
   * @returns {void}
   */
  makeFirstThrowablePathInTryBlock() {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) {
      return;
    }
    const context = getThrowContext(this);
    if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
      return;
    }
    context.thrownForkContext.add(forkContext.head);
    forkContext.replaceHead(forkContext.makeNext(-1, -1));
  }

  //--------------------------------------------------------------------------
  // Loop Statements
  //--------------------------------------------------------------------------

  /**
   * Creates a context object of a loop statement and stacks it.
   *
   * @param {string} type - The type of the node which was triggered. One of
   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
   *   and `ForStatement`.
   * @param {string|null} label - A label of the node which was triggered.
   * @returns {void}
   */
  pushLoopContext(type, label) {
    const forkContext = this.forkContext;
    const breakContext = this.pushBreakContext(true, label);
    switch (type) {
      case "WhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;
      case "DoWhileStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          entrySegments: null,
          continueForkContext: ForkContext.newEmpty(forkContext),
          brokenForkContext: breakContext.brokenForkContext
        };
        break;
      case "ForStatement":
        this.pushChoiceContext("loop", false);
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          test: void 0,
          endOfInitSegments: null,
          testSegments: null,
          endOfTestSegments: null,
          updateSegments: null,
          endOfUpdateSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;
      case "ForInStatement":
      case "ForOfStatement":
        this.loopContext = {
          upper: this.loopContext,
          type,
          label,
          prevSegments: null,
          leftSegments: null,
          endOfLeftSegments: null,
          continueDestSegments: null,
          brokenForkContext: breakContext.brokenForkContext
        };
        break;

      /* istanbul ignore next */
      default:
        throw new Error(`unknown type: "${type}"`);
    }
  }

  /**
   * Pops the last context of a loop statement and finalizes it.
   *
   * @returns {void}
   */
  popLoopContext() {
    const context = this.loopContext;
    this.loopContext = context.upper;
    const forkContext = this.forkContext;
    const brokenForkContext = this.popBreakContext().brokenForkContext;

    // Creates a looped path.
    switch (context.type) {
      case "WhileStatement":
      case "ForStatement":
        this.popChoiceContext();
        makeLooped(this, forkContext.head, context.continueDestSegments);
        break;
      case "DoWhileStatement":
        {
          const choiceContext = this.popChoiceContext();
          if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
          }
          if (context.test !== true) {
            brokenForkContext.addAll(choiceContext.falseForkContext);
          }

          // `true` paths go to looping.
          const segmentsList = choiceContext.trueForkContext.segmentsList;
          for (let i = 0; i < segmentsList.length; ++i) {
            makeLooped(this, segmentsList[i], context.entrySegments);
          }
          break;
        }
      case "ForInStatement":
      case "ForOfStatement":
        brokenForkContext.add(forkContext.head);
        makeLooped(this, forkContext.head, context.leftSegments);
        break;

      /* istanbul ignore next */
      default:
        throw new Error("unreachable");
    }

    // Go next.
    if (brokenForkContext.empty) {
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    } else {
      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }
  }

  /**
   * Makes a code path segment for the test part of a WhileStatement.
   *
   * @param {boolean|undefined} test - The test value (only when constant).
   * @returns {void}
   */
  makeWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const testSegments = forkContext.makeNext(0, -1);

    // Update state.
    context.test = test;
    context.continueDestSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }

  /**
   * Makes a code path segment for the body part of a WhileStatement.
   *
   * @returns {void}
   */
  makeWhileBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;
    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(forkContext.head);
      choiceContext.falseForkContext.add(forkContext.head);
    }

    // Update state.
    if (context.test !== true) {
      context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
  }

  /**
   * Makes a code path segment for the body part of a DoWhileStatement.
   *
   * @returns {void}
   */
  makeDoWhileBody() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const bodySegments = forkContext.makeNext(-1, -1);

    // Update state.
    context.entrySegments = bodySegments;
    forkContext.replaceHead(bodySegments);
  }

  /**
   * Makes a code path segment for the test part of a DoWhileStatement.
   *
   * @param {boolean|undefined} test - The test value (only when constant).
   * @returns {void}
   */
  makeDoWhileTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    context.test = test;

    // Creates paths of `continue` statements.
    if (!context.continueForkContext.empty) {
      context.continueForkContext.add(forkContext.head);
      const testSegments = context.continueForkContext.makeNext(0, -1);
      forkContext.replaceHead(testSegments);
    }
  }

  /**
   * Makes a code path segment for the test part of a ForStatement.
   *
   * @param {boolean|undefined} test - The test value (only when constant).
   * @returns {void}
   */
  makeForTest(test) {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const endOfInitSegments = forkContext.head;
    const testSegments = forkContext.makeNext(-1, -1);

    // Update state.
    context.test = test;
    context.endOfInitSegments = endOfInitSegments;
    context.continueDestSegments = context.testSegments = testSegments;
    forkContext.replaceHead(testSegments);
  }

  /**
   * Makes a code path segment for the update part of a ForStatement.
   *
   * @returns {void}
   */
  makeForUpdate() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;

    // Make the next paths of the test.
    if (context.testSegments) {
      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
    } else {
      context.endOfInitSegments = forkContext.head;
    }

    // Update state.
    const updateSegments = forkContext.makeDisconnected(-1, -1);
    context.continueDestSegments = context.updateSegments = updateSegments;
    forkContext.replaceHead(updateSegments);
  }

  /**
   * Makes a code path segment for the body part of a ForStatement.
   *
   * @returns {void}
   */
  makeForBody() {
    const context = this.loopContext;
    const choiceContext = this.choiceContext;
    const forkContext = this.forkContext;

    // Update state.
    if (context.updateSegments) {
      context.endOfUpdateSegments = forkContext.head;

      // `update` -> `test`
      if (context.testSegments) {
        makeLooped(this, context.endOfUpdateSegments, context.testSegments);
      }
    } else if (context.testSegments) {
      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
    } else {
      context.endOfInitSegments = forkContext.head;
    }
    let bodySegments = context.endOfTestSegments;
    if (!bodySegments) {
      /*
       * If there is not the `test` part, the `body` path comes from the
       * `init` part and the `update` part.
       */
      const prevForkContext = ForkContext.newEmpty(forkContext);
      prevForkContext.add(context.endOfInitSegments);
      if (context.endOfUpdateSegments) {
        prevForkContext.add(context.endOfUpdateSegments);
      }
      bodySegments = prevForkContext.makeNext(0, -1);
    }
    context.continueDestSegments = context.continueDestSegments || bodySegments;
    forkContext.replaceHead(bodySegments);
  }

  /**
   * Makes a code path segment for the left part of a ForInStatement and a
   * ForOfStatement.
   *
   * @returns {void}
   */
  makeForInOfLeft() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const leftSegments = forkContext.makeDisconnected(-1, -1);

    // Update state.
    context.prevSegments = forkContext.head;
    context.leftSegments = context.continueDestSegments = leftSegments;
    forkContext.replaceHead(leftSegments);
  }

  /**
   * Makes a code path segment for the right part of a ForInStatement and a
   * ForOfStatement.
   *
   * @returns {void}
   */
  makeForInOfRight() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const temp = ForkContext.newEmpty(forkContext);
    temp.add(context.prevSegments);
    const rightSegments = temp.makeNext(-1, -1);

    // Update state.
    context.endOfLeftSegments = forkContext.head;
    forkContext.replaceHead(rightSegments);
  }

  /**
   * Makes a code path segment for the body part of a ForInStatement and a
   * ForOfStatement.
   *
   * @returns {void}
   */
  makeForInOfBody() {
    const context = this.loopContext;
    const forkContext = this.forkContext;
    const temp = ForkContext.newEmpty(forkContext);
    temp.add(context.endOfLeftSegments);
    const bodySegments = temp.makeNext(-1, -1);

    // Make a path: `right` -> `left`.
    makeLooped(this, forkContext.head, context.leftSegments);

    // Update state.
    context.brokenForkContext.add(forkContext.head);
    forkContext.replaceHead(bodySegments);
  }

  //--------------------------------------------------------------------------
  // Control Statements
  //--------------------------------------------------------------------------

  /**
   * Creates new context for BreakStatement.
   *
   * @param {boolean} breakable - The flag to indicate it can break by
   *      an unlabeled BreakStatement.
   * @param {string|null} label - The label of this context.
   * @returns {Object} The new context.
   */
  pushBreakContext(breakable, label) {
    this.breakContext = {
      upper: this.breakContext,
      breakable,
      label,
      brokenForkContext: ForkContext.newEmpty(this.forkContext)
    };
    return this.breakContext;
  }

  /**
   * Removes the top item of the break context stack.
   *
   * @returns {Object} The removed context.
   */
  popBreakContext() {
    const context = this.breakContext;
    const forkContext = this.forkContext;
    this.breakContext = context.upper;

    // Process this context here for other than switches and loops.
    if (!context.breakable) {
      const brokenForkContext = context.brokenForkContext;
      if (!brokenForkContext.empty) {
        brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }
    return context;
  }

  /**
   * Makes a path for a `break` statement.
   *
   * It registers the head segment to a context of `break`.
   * It makes new unreachable segment, then it set the head with the segment.
   *
   * @param {string} label - A label of the break statement.
   * @returns {void}
   */
  makeBreak(label) {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) {
      return;
    }
    const context = getBreakContext(this, label);

    /* istanbul ignore else: foolproof (syntax error) */
    if (context) {
      context.brokenForkContext.add(forkContext.head);
    }
    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }

  /**
   * Makes a path for a `continue` statement.
   *
   * It makes a looping path.
   * It makes new unreachable segment, then it set the head with the segment.
   *
   * @param {string} label - A label of the continue statement.
   * @returns {void}
   */
  makeContinue(label) {
    const forkContext = this.forkContext;
    if (!forkContext.reachable) {
      return;
    }
    const context = getContinueContext(this, label);

    /* istanbul ignore else: foolproof (syntax error) */
    if (context) {
      if (context.continueDestSegments) {
        makeLooped(this, forkContext.head, context.continueDestSegments);

        // If the context is a for-in/of loop, this effects a break also.
        if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
          context.brokenForkContext.add(forkContext.head);
        }
      } else {
        context.continueForkContext.add(forkContext.head);
      }
    }
    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
  }

  /**
   * Makes a path for a `return` statement.
   *
   * It registers the head segment to a context of `return`.
   * It makes new unreachable segment, then it set the head with the segment.
   *
   * @returns {void}
   */
  makeReturn() {
    const forkContext = this.forkContext;
    if (forkContext.reachable) {
      getReturnContext(this).returnedForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }

  /**
   * Makes a path for a `throw` statement.
   *
   * It registers the head segment to a context of `throw`.
   * It makes new unreachable segment, then it set the head with the segment.
   *
   * @returns {void}
   */
  makeThrow() {
    const forkContext = this.forkContext;
    if (forkContext.reachable) {
      getThrowContext(this).thrownForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
  }

  /**
   * Makes the final path.
   * @returns {void}
   */
  makeFinal() {
    const segments = this.currentSegments;
    if (segments.length > 0 && segments[0].reachable) {
      this.returnedForkContext.add(segments);
    }
  }
}
module.exports = CodePathState;

/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A class of the code path segment.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const debug = __webpack_require__(104);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given segment is reachable.
 *
 * @param {CodePathSegment} segment - A segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path segment.
 */
class CodePathSegment {
  /**
   * @param {string} id - An identifier.
   * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
   *   This array includes unreachable segments.
   * @param {boolean} reachable - A flag which shows this is reachable.
   */
  constructor(id, allPrevSegments, reachable) {
    /**
     * The identifier of this code path.
     * Rules use it to store additional information of each rule.
     * @type {string}
     */
    this.id = id;

    /**
     * An array of the next segments.
     * @type {CodePathSegment[]}
     */
    this.nextSegments = [];

    /**
     * An array of the previous segments.
     * @type {CodePathSegment[]}
     */
    this.prevSegments = allPrevSegments.filter(isReachable);

    /**
     * An array of the next segments.
     * This array includes unreachable segments.
     * @type {CodePathSegment[]}
     */
    this.allNextSegments = [];

    /**
     * An array of the previous segments.
     * This array includes unreachable segments.
     * @type {CodePathSegment[]}
     */
    this.allPrevSegments = allPrevSegments;

    /**
     * A flag which shows this is reachable.
     * @type {boolean}
     */
    this.reachable = reachable;

    // Internal data.
    Object.defineProperty(this, "internal", {
      value: {
        used: false,
        loopedPrevSegments: []
      }
    });

    /* istanbul ignore if */
    if (debug.enabled) {
      this.internal.nodes = [];
      this.internal.exitNodes = [];
    }
  }

  /**
   * Checks a given previous segment is coming from the end of a loop.
   *
   * @param {CodePathSegment} segment - A previous segment to check.
   * @returns {boolean} `true` if the segment is coming from the end of a loop.
   */
  isLoopedPrevSegment(segment) {
    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
  }

  /**
   * Creates the root segment.
   *
   * @param {string} id - An identifier.
   * @returns {CodePathSegment} The created segment.
   */
  static newRoot(id) {
    return new CodePathSegment(id, [], true);
  }

  /**
   * Creates a segment that follows given segments.
   *
   * @param {string} id - An identifier.
   * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newNext(id, allPrevSegments) {
    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
  }

  /**
   * Creates an unreachable segment that follows given segments.
   *
   * @param {string} id - An identifier.
   * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newUnreachable(id, allPrevSegments) {
    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);

    /*
     * In `if (a) return a; foo();` case, the unreachable segment preceded by
     * the return statement is not used but must not be remove.
     */
    CodePathSegment.markUsed(segment);
    return segment;
  }

  /**
   * Creates a segment that follows given segments.
   * This factory method does not connect with `allPrevSegments`.
   * But this inherits `reachable` flag.
   *
   * @param {string} id - An identifier.
   * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
   * @returns {CodePathSegment} The created segment.
   */
  static newDisconnected(id, allPrevSegments) {
    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
  }

  /**
   * Makes a given segment being used.
   *
   * And this function registers the segment into the previous segments as a next.
   *
   * @param {CodePathSegment} segment - A segment to mark.
   * @returns {void}
   */
  static markUsed(segment) {
    if (segment.internal.used) {
      return;
    }
    segment.internal.used = true;
    let i;
    if (segment.reachable) {
      for (i = 0; i < segment.allPrevSegments.length; ++i) {
        const prevSegment = segment.allPrevSegments[i];
        prevSegment.allNextSegments.push(segment);
        prevSegment.nextSegments.push(segment);
      }
    } else {
      for (i = 0; i < segment.allPrevSegments.length; ++i) {
        segment.allPrevSegments[i].allNextSegments.push(segment);
      }
    }
  }

  /**
   * Marks a previous segment as looped.
   *
   * @param {CodePathSegment} segment - A segment.
   * @param {CodePathSegment} prevSegment - A previous segment to mark.
   * @returns {void}
   */
  static markPrevSegmentAsLooped(segment, prevSegment) {
    segment.internal.loopedPrevSegments.push(prevSegment);
  }

  /**
   * Replaces unused segments with the previous segments of each unused segment.
   *
   * @param {CodePathSegment[]} segments - An array of segments to replace.
   * @returns {CodePathSegment[]} The replaced array.
   */
  static flattenUnusedSegments(segments) {
    const done = Object.create(null);
    const retv = [];
    for (let i = 0; i < segments.length; ++i) {
      const segment = segments[i];

      // Ignores duplicated.
      if (done[segment.id]) {
        continue;
      }

      // Use previous segments if unused.
      if (!segment.internal.used) {
        for (let j = 0; j < segment.allPrevSegments.length; ++j) {
          const prevSegment = segment.allPrevSegments[j];
          if (!done[prevSegment.id]) {
            done[prevSegment.id] = true;
            retv.push(prevSegment);
          }
        }
      } else {
        done[segment.id] = true;
        retv.push(segment);
      }
    }
    return retv;
  }
}
module.exports = CodePathSegment;

/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Helpers to debug for code path analysis.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const debug = __webpack_require__(105)("eslint:code-path");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets id of a given segment.
 * @param {CodePathSegment} segment - A segment to get.
 * @returns {string} Id of the segment.
 */
/* istanbul ignore next */
function getId(segment) {
  // eslint-disable-line require-jsdoc
  return segment.id + (segment.reachable ? "" : "!");
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  /**
   * A flag that debug dumping is enabled or not.
   * @type {boolean}
   */
  enabled: debug.enabled,
  /**
   * Dumps given objects.
   *
   * @param {...any} args - objects to dump.
   * @returns {void}
   */
  dump: debug,
  /**
   * Dumps the current analyzing state.
   *
   * @param {ASTNode} node - A node to dump.
   * @param {CodePathState} state - A state to dump.
   * @param {boolean} leaving - A flag whether or not it's leaving
   * @returns {void}
   */
  dumpState: !debug.enabled ? debug : /* istanbul ignore next */function (node, state, leaving) {
    for (let i = 0; i < state.currentSegments.length; ++i) {
      const segInternal = state.currentSegments[i].internal;
      if (leaving) {
        segInternal.exitNodes.push(node);
      } else {
        segInternal.nodes.push(node);
      }
    }
    debug([`${state.currentSegments.map(getId).join(",")})`, `${node.type}${leaving ? ":exit" : ""}`].join(" "));
  },
  /**
   * Dumps a DOT code of a given code path.
   * The DOT code can be visialized with Graphvis.
   *
   * @param {CodePath} codePath - A code path to dump.
   * @returns {void}
   * @see http://www.graphviz.org
   * @see http://www.webgraphviz.com
   */
  dumpDot: !debug.enabled ? debug : /* istanbul ignore next */function (codePath) {
    let text = "\n" + "digraph {\n" + "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" + "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
    if (codePath.returnedSegments.length > 0) {
      text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
    }
    if (codePath.thrownSegments.length > 0) {
      text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
    }
    const traceMap = Object.create(null);
    const arrows = this.makeDotArrows(codePath, traceMap);
    for (const id in traceMap) {
      // eslint-disable-line guard-for-in
      const segment = traceMap[id];
      text += `${id}[`;
      if (segment.reachable) {
        text += "label=\"";
      } else {
        text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
      }
      if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {
        text += [].concat(segment.internal.nodes.map(node => {
          switch (node.type) {
            case "Identifier":
              return `${node.type} (${node.name})`;
            case "Literal":
              return `${node.type} (${node.value})`;
            default:
              return node.type;
          }
        }), segment.internal.exitNodes.map(node => {
          switch (node.type) {
            case "Identifier":
              return `${node.type}:exit (${node.name})`;
            case "Literal":
              return `${node.type}:exit (${node.value})`;
            default:
              return `${node.type}:exit`;
          }
        })).join("\\n");
      } else {
        text += "????";
      }
      text += "\"];\n";
    }
    text += `${arrows}\n`;
    text += "}";
    debug("DOT", text);
  },
  /**
   * Makes a DOT code of a given code path.
   * The DOT code can be visialized with Graphvis.
   *
   * @param {CodePath} codePath - A code path to make DOT.
   * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.
   * @returns {string} A DOT code of the code path.
   */
  makeDotArrows(codePath, traceMap) {
    const stack = [[codePath.initialSegment, 0]];
    const done = traceMap || Object.create(null);
    let lastId = codePath.initialSegment.id;
    let text = `initial->${codePath.initialSegment.id}`;
    while (stack.length > 0) {
      const item = stack.pop();
      const segment = item[0];
      const index = item[1];
      if (done[segment.id] && index === 0) {
        continue;
      }
      done[segment.id] = segment;
      const nextSegment = segment.allNextSegments[index];
      if (!nextSegment) {
        continue;
      }
      if (lastId === segment.id) {
        text += `->${nextSegment.id}`;
      } else {
        text += `;\n${segment.id}->${nextSegment.id}`;
      }
      lastId = nextSegment.id;
      stack.unshift([segment, 1 + index]);
      stack.push([nextSegment, 0]);
    }
    codePath.returnedSegments.forEach(finalSegment => {
      if (lastId === finalSegment.id) {
        text += "->final";
      } else {
        text += `;\n${finalSegment.id}->final`;
      }
      lastId = null;
    });
    codePath.thrownSegments.forEach(finalSegment => {
      if (lastId === finalSegment.id) {
        text += "->thrown";
      } else {
        text += `;\n${finalSegment.id}->thrown`;
      }
      lastId = null;
    });
    return `${text};`;
  }
};

/***/ }),
/* 105 */
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(6);
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
  let warned = false;
  return () => {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
})();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }
  let m;

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  // eslint-disable-next-line no-return-assign
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  let index = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, match => {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  let r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = __webpack_require__(106)(exports);
const {
  formatters
} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(107);
  createDebug.destroy = destroy;
  Object.keys(env).forEach(key => {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      const self = debug;

      // Set `diff` timestamp
      const curr = Number(new Date());
      const ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          const val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      const logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: v => {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
    for (const ns of split) {
      if (ns[0] === '-') {
        createDebug.skips.push(ns.slice(1));
      } else {
        createDebug.names.push(ns);
      }
    }
  }

  /**
   * Checks if the given string matches a namespace template, honoring
   * asterisks as wildcards.
   *
   * @param {String} search
   * @param {String} template
   * @return {Boolean}
   */
  function matchesTemplate(search, template) {
    let searchIndex = 0;
    let templateIndex = 0;
    let starIndex = -1;
    let matchIndex = 0;
    while (searchIndex < search.length) {
      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
        // Match character or proceed with wildcard
        if (template[templateIndex] === '*') {
          starIndex = templateIndex;
          matchIndex = searchIndex;
          templateIndex++; // Skip the '*'
        } else {
          searchIndex++;
          templateIndex++;
        }
      } else if (starIndex !== -1) {
        // eslint-disable-line no-negated-condition
        // Backtrack to the last '*' and try to match more characters
        templateIndex = starIndex + 1;
        matchIndex++;
        searchIndex = matchIndex;
      } else {
        return false; // No match
      }
    }

    // Handle trailing '*' in template
    while (templateIndex < template.length && template[templateIndex] === '*') {
      templateIndex++;
    }
    return templateIndex === template.length;
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    const namespaces = [...createDebug.names, ...createDebug.skips.map(namespace => '-' + namespace)].join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    for (const skip of createDebug.skips) {
      if (matchesTemplate(name, skip)) {
        return false;
      }
    }
    for (const ns of createDebug.names) {
      if (matchesTemplate(name, ns)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

/***/ }),
/* 107 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A class to operate forking.
 *
 * This is state of forking.
 * This has a fork list and manages it.
 *
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const assert = __webpack_require__(3),
  CodePathSegment = __webpack_require__(103);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets whether or not a given segment is reachable.
 *
 * @param {CodePathSegment} segment - A segment to get.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

/**
 * Creates new segments from the specific range of `context.segmentsList`.
 *
 * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and
 * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.
 * This `h` is from `b`, `d`, and `f`.
 *
 * @param {ForkContext} context - An instance.
 * @param {number} begin - The first index of the previous segments.
 * @param {number} end - The last index of the previous segments.
 * @param {Function} create - A factory function of new segments.
 * @returns {CodePathSegment[]} New segments.
 */
function makeSegments(context, begin, end, create) {
  const list = context.segmentsList;
  const normalizedBegin = begin >= 0 ? begin : list.length + begin;
  const normalizedEnd = end >= 0 ? end : list.length + end;
  const segments = [];
  for (let i = 0; i < context.count; ++i) {
    const allPrevSegments = [];
    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {
      allPrevSegments.push(list[j][i]);
    }
    segments.push(create(context.idGenerator.next(), allPrevSegments));
  }
  return segments;
}

/**
 * `segments` becomes doubly in a `finally` block. Then if a code path exits by a
 * control statement (such as `break`, `continue`) from the `finally` block, the
 * destination's segments may be half of the source segments. In that case, this
 * merges segments.
 *
 * @param {ForkContext} context - An instance.
 * @param {CodePathSegment[]} segments - Segments to merge.
 * @returns {CodePathSegment[]} The merged segments.
 */
function mergeExtraSegments(context, segments) {
  let currentSegments = segments;
  while (currentSegments.length > context.count) {
    const merged = [];
    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {
      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));
    }
    currentSegments = merged;
  }
  return currentSegments;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A class to manage forking.
 */
class ForkContext {
  /**
   * @param {IdGenerator} idGenerator - An identifier generator for segments.
   * @param {ForkContext|null} upper - An upper fork context.
   * @param {number} count - A number of parallel segments.
   */
  constructor(idGenerator, upper, count) {
    this.idGenerator = idGenerator;
    this.upper = upper;
    this.count = count;
    this.segmentsList = [];
  }

  /**
   * The head segments.
   * @type {CodePathSegment[]}
   */
  get head() {
    const list = this.segmentsList;
    return list.length === 0 ? [] : list[list.length - 1];
  }

  /**
   * A flag which shows empty.
   * @type {boolean}
   */
  get empty() {
    return this.segmentsList.length === 0;
  }

  /**
   * A flag which shows reachable.
   * @type {boolean}
   */
  get reachable() {
    const segments = this.head;
    return segments.length > 0 && segments.some(isReachable);
  }

  /**
   * Creates new segments from this context.
   *
   * @param {number} begin - The first index of previous segments.
   * @param {number} end - The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeNext(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newNext);
  }

  /**
   * Creates new segments from this context.
   * The new segments is always unreachable.
   *
   * @param {number} begin - The first index of previous segments.
   * @param {number} end - The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeUnreachable(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
  }

  /**
   * Creates new segments from this context.
   * The new segments don't have connections for previous segments.
   * But these inherit the reachable flag from this context.
   *
   * @param {number} begin - The first index of previous segments.
   * @param {number} end - The last index of previous segments.
   * @returns {CodePathSegment[]} New segments.
   */
  makeDisconnected(begin, end) {
    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
  }

  /**
   * Adds segments into this context.
   * The added segments become the head.
   *
   * @param {CodePathSegment[]} segments - Segments to add.
   * @returns {void}
   */
  add(segments) {
    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.push(mergeExtraSegments(this, segments));
  }

  /**
   * Replaces the head segments with given segments.
   * The current head segments are removed.
   *
   * @param {CodePathSegment[]} segments - Segments to add.
   * @returns {void}
   */
  replaceHead(segments) {
    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
  }

  /**
   * Adds all segments of a given fork context into this context.
   *
   * @param {ForkContext} context - A fork context to add.
   * @returns {void}
   */
  addAll(context) {
    assert(context.count === this.count);
    const source = context.segmentsList;
    for (let i = 0; i < source.length; ++i) {
      this.segmentsList.push(source[i]);
    }
  }

  /**
   * Clears all secments in this context.
   *
   * @returns {void}
   */
  clear() {
    this.segmentsList = [];
  }

  /**
   * Creates the root fork context.
   *
   * @param {IdGenerator} idGenerator - An identifier generator for segments.
   * @returns {ForkContext} New fork context.
   */
  static newRoot(idGenerator) {
    const context = new ForkContext(idGenerator, null, 1);
    context.add([CodePathSegment.newRoot(idGenerator.next())]);
    return context;
  }

  /**
   * Creates an empty fork context preceded by a given context.
   *
   * @param {ForkContext} parentContext - The parent fork context.
   * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.
   * @returns {ForkContext} New fork context.
   */
  static newEmpty(parentContext, forkLeavingPath) {
    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
  }
}
module.exports = ForkContext;

/***/ }),
/* 109 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A class of identifiers generator for code path segments.
 *
 * Each rule uses the identifier of code path segments to store additional
 * information of the code path.
 *
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A generator for unique ids.
 */
class IdGenerator {
  /**
   * @param {string} prefix - Optional. A prefix of generated ids.
   */
  constructor(prefix) {
    this.prefix = String(prefix);
    this.n = 0;
  }

  /**
   * Generates id.
   *
   * @returns {string} A generated id.
   */
  next() {
    this.n = 1 + this.n | 0;

    /* istanbul ignore if */
    if (this.n < 0) {
      this.n = 1;
    }
    return this.prefix + this.n;
  }
}
module.exports = IdGenerator;

/***/ }),
/* 110 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Common utils for AST.
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const esutils = __webpack_require__(111);
const espree = __webpack_require__(91);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
const anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;
const arrayOrTypedArrayPattern = /Array$/u;
const arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;
const bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;
const breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
const thisTagPattern = /^[\s*]*@this/mu;
const COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
const LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
const LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/u;
const SHEBANG_MATCHER = /^#!([^\r\n]+)/u;

// A set of node types that can contain a list of statements
const STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);

/**
 * Checks reference if is non initializer and writable.
 * @param {Reference} reference - A reference to check.
 * @param {int} index - The index of the reference in the references.
 * @param {Reference[]} references - The array that the reference belongs to.
 * @returns {boolean} Success/Failure
 * @private
 */
function isModifyingReference(reference, index, references) {
  const identifier = reference.identifier;

  /*
   * Destructuring assignments can have multiple default value, so
   * possibly there are multiple writeable references for the same
   * identifier.
   */
  const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
  return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
}

/**
 * Checks whether the given string starts with uppercase or not.
 *
 * @param {string} s - The string to check.
 * @returns {boolean} `true` if the string starts with uppercase.
 */
function startsWithUpperCase(s) {
  return s[0] !== s[0].toLocaleLowerCase();
}

/**
 * Checks whether or not a node is a constructor.
 * @param {ASTNode} node - A function node to check.
 * @returns {boolean} Wehether or not a node is a constructor.
 */
function isES5Constructor(node) {
  return node.id && startsWithUpperCase(node.id.name);
}

/**
 * Finds a function node from ancestors of a node.
 * @param {ASTNode} node - A start node to find.
 * @returns {Node|null} A found function node.
 */
function getUpperFunction(node) {
  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
    if (anyFunctionPattern.test(currentNode.type)) {
      return currentNode;
    }
  }
  return null;
}

/**
 * Checks whether a given node is a function node or not.
 * The following types are function nodes:
 *
 * - ArrowFunctionExpression
 * - FunctionDeclaration
 * - FunctionExpression
 *
 * @param {ASTNode|null} node - A node to check.
 * @returns {boolean} `true` if the node is a function node.
 */
function isFunction(node) {
  return Boolean(node && anyFunctionPattern.test(node.type));
}

/**
 * Checks whether a given node is a loop node or not.
 * The following types are loop nodes:
 *
 * - DoWhileStatement
 * - ForInStatement
 * - ForOfStatement
 * - ForStatement
 * - WhileStatement
 *
 * @param {ASTNode|null} node - A node to check.
 * @returns {boolean} `true` if the node is a loop node.
 */
function isLoop(node) {
  return Boolean(node && anyLoopPattern.test(node.type));
}

/**
 * Checks whether the given node is in a loop or not.
 *
 * @param {ASTNode} node - The node to check.
 * @returns {boolean} `true` if the node is in a loop.
 */
function isInLoop(node) {
  for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {
    if (isLoop(currentNode)) {
      return true;
    }
  }
  return false;
}

/**
 * Checks whether or not a node is `null` or `undefined`.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} Whether or not the node is a `null` or `undefined`.
 * @public
 */
function isNullOrUndefined(node) {
  return module.exports.isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
}

/**
 * Checks whether or not a node is callee.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} Whether or not the node is callee.
 */
function isCallee(node) {
  return node.parent.type === "CallExpression" && node.parent.callee === node;
}

/**
 * Checks whether or not a node is `Reflect.apply`.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} Whether or not the node is a `Reflect.apply`.
 */
function isReflectApply(node) {
  return node.type === "MemberExpression" && node.object.type === "Identifier" && node.object.name === "Reflect" && node.property.type === "Identifier" && node.property.name === "apply" && node.computed === false;
}

/**
 * Checks whether or not a node is `Array.from`.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} Whether or not the node is a `Array.from`.
 */
function isArrayFromMethod(node) {
  return node.type === "MemberExpression" && node.object.type === "Identifier" && arrayOrTypedArrayPattern.test(node.object.name) && node.property.type === "Identifier" && node.property.name === "from" && node.computed === false;
}

/**
 * Checks whether or not a node is a method which has `thisArg`.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} Whether or not the node is a method which has `thisArg`.
 */
function isMethodWhichHasThisArg(node) {
  for (let currentNode = node; currentNode.type === "MemberExpression" && !currentNode.computed; currentNode = currentNode.property) {
    if (currentNode.property.type === "Identifier") {
      return arrayMethodPattern.test(currentNode.property.name);
    }
  }
  return false;
}

/**
 * Creates the negate function of the given function.
 * @param {Function} f - The function to negate.
 * @returns {Function} Negated function.
 */
function negate(f) {
  return token => !f(token);
}

/**
 * Checks whether or not a node has a `@this` tag in its comments.
 * @param {ASTNode} node - A node to check.
 * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
 */
function hasJSDocThisTag(node, sourceCode) {
  const jsdocComment = sourceCode.getJSDocComment(node);
  if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
    return true;
  }

  // Checks `@this` in its leading comments for callbacks,
  // because callbacks don't have its JSDoc comment.
  // e.g.
  //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
  return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));
}

/**
 * Determines if a node is surrounded by parentheses.
 * @param {SourceCode} sourceCode The ESLint source code object
 * @param {ASTNode} node The node to be checked.
 * @returns {boolean} True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) {
  const previousToken = sourceCode.getTokenBefore(node),
    nextToken = sourceCode.getTokenAfter(node);
  return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
}

/**
 * Checks if the given token is an arrow token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an arrow token.
 */
function isArrowToken(token) {
  return token.value === "=>" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comma token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comma token.
 */
function isCommaToken(token) {
  return token.value === "," && token.type === "Punctuator";
}

/**
 * Checks if the given token is a semicolon token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a semicolon token.
 */
function isSemicolonToken(token) {
  return token.value === ";" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a colon token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a colon token.
 */
function isColonToken(token) {
  return token.value === ":" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening parenthesis token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening parenthesis token.
 */
function isOpeningParenToken(token) {
  return token.value === "(" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing parenthesis token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing parenthesis token.
 */
function isClosingParenToken(token) {
  return token.value === ")" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening square bracket token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening square bracket token.
 */
function isOpeningBracketToken(token) {
  return token.value === "[" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing square bracket token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing square bracket token.
 */
function isClosingBracketToken(token) {
  return token.value === "]" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening brace token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening brace token.
 */
function isOpeningBraceToken(token) {
  return token.value === "{" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing brace token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing brace token.
 */
function isClosingBraceToken(token) {
  return token.value === "}" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comment token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comment token.
 */
function isCommentToken(token) {
  return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}

/**
 * Checks if the given token is a keyword token or not.
 *
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a keyword token.
 */
function isKeywordToken(token) {
  return token.type === "Keyword";
}

/**
 * Gets the `(` token of the given function node.
 *
 * @param {ASTNode} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {Token} `(` token.
 */
function getOpeningParenOfParams(node, sourceCode) {
  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
}

/**
 * Creates a version of the LINEBREAK_MATCHER regex with the global flag.
 * Global regexes are mutable, so this needs to be a function instead of a constant.
 * @returns {RegExp} A global regular expression that matches line terminators
 */
function createGlobalLinebreakMatcher() {
  return new RegExp(LINEBREAK_MATCHER.source, "gu");
}

/**
 * Checks whether or not the tokens of two given nodes are same.
 * @param {ASTNode} left - A node 1 to compare.
 * @param {ASTNode} right - A node 2 to compare.
 * @param {SourceCode} sourceCode - The ESLint source code object.
 * @returns {boolean} the source code for the given node.
 */
function equalTokens(left, right, sourceCode) {
  const tokensL = sourceCode.getTokens(left);
  const tokensR = sourceCode.getTokens(right);
  if (tokensL.length !== tokensR.length) {
    return false;
  }
  for (let i = 0; i < tokensL.length; ++i) {
    if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
      return false;
    }
  }
  return true;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  COMMENTS_IGNORE_PATTERN,
  LINEBREAKS,
  LINEBREAK_MATCHER,
  SHEBANG_MATCHER,
  STATEMENT_LIST_PARENTS,
  /**
   * Determines whether two adjacent tokens are on the same line.
   * @param {Object} left - The left token object.
   * @param {Object} right - The right token object.
   * @returns {boolean} Whether or not the tokens are on the same line.
   * @public
   */
  isTokenOnSameLine(left, right) {
    return left.loc.end.line === right.loc.start.line;
  },
  isNullOrUndefined,
  isCallee,
  isES5Constructor,
  getUpperFunction,
  isFunction,
  isLoop,
  isInLoop,
  isArrayFromMethod,
  isParenthesised,
  createGlobalLinebreakMatcher,
  equalTokens,
  isArrowToken,
  isClosingBraceToken,
  isClosingBracketToken,
  isClosingParenToken,
  isColonToken,
  isCommaToken,
  isCommentToken,
  isKeywordToken,
  isNotClosingBraceToken: negate(isClosingBraceToken),
  isNotClosingBracketToken: negate(isClosingBracketToken),
  isNotClosingParenToken: negate(isClosingParenToken),
  isNotColonToken: negate(isColonToken),
  isNotCommaToken: negate(isCommaToken),
  isNotOpeningBraceToken: negate(isOpeningBraceToken),
  isNotOpeningBracketToken: negate(isOpeningBracketToken),
  isNotOpeningParenToken: negate(isOpeningParenToken),
  isNotSemicolonToken: negate(isSemicolonToken),
  isOpeningBraceToken,
  isOpeningBracketToken,
  isOpeningParenToken,
  isSemicolonToken,
  /**
   * Checks whether or not a given node is a string literal.
   * @param {ASTNode} node - A node to check.
   * @returns {boolean} `true` if the node is a string literal.
   */
  isStringLiteral(node) {
    return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
  },
  /**
   * Checks whether a given node is a breakable statement or not.
   * The node is breakable if the node is one of the following type:
   *
   * - DoWhileStatement
   * - ForInStatement
   * - ForOfStatement
   * - ForStatement
   * - SwitchStatement
   * - WhileStatement
   *
   * @param {ASTNode} node - A node to check.
   * @returns {boolean} `true` if the node is breakable.
   */
  isBreakableStatement(node) {
    return breakableTypePattern.test(node.type);
  },
  /**
   * Gets the label if the parent node of a given node is a LabeledStatement.
   *
   * @param {ASTNode} node - A node to get.
   * @returns {string|null} The label or `null`.
   */
  getLabel(node) {
    if (node.parent.type === "LabeledStatement") {
      return node.parent.label.name;
    }
    return null;
  },
  /**
   * Gets references which are non initializer and writable.
   * @param {Reference[]} references - An array of references.
   * @returns {Reference[]} An array of only references which are non initializer and writable.
   * @public
   */
  getModifyingReferences(references) {
    return references.filter(isModifyingReference);
  },
  /**
   * Validate that a string passed in is surrounded by the specified character
   * @param  {string} val The text to check.
   * @param  {string} character The character to see if it's surrounded by.
   * @returns {boolean} True if the text is surrounded by the character, false if not.
   * @private
   */
  isSurroundedBy(val, character) {
    return val[0] === character && val[val.length - 1] === character;
  },
  /**
   * Returns whether the provided node is an ESLint directive comment or not
   * @param {Line|Block} node The comment token to be checked
   * @returns {boolean} `true` if the node is an ESLint directive comment
   */
  isDirectiveComment(node) {
    const comment = node.value.trim();
    return node.type === "Line" && comment.indexOf("eslint-") === 0 || node.type === "Block" && (comment.indexOf("global ") === 0 || comment.indexOf("eslint ") === 0 || comment.indexOf("eslint-") === 0);
  },
  /**
   * Gets the trailing statement of a given node.
   *
   *     if (code)
   *         consequent;
   *
   * When taking this `IfStatement`, returns `consequent;` statement.
   *
   * @param {ASTNode} A node to get.
   * @returns {ASTNode|null} The trailing statement's node.
   */
  getTrailingStatement: esutils.ast.trailingStatement,
  /**
   * Finds the variable by a given name in a given scope and its upper scopes.
   *
   * @param {eslint-scope.Scope} initScope - A scope to start find.
   * @param {string} name - A variable name to find.
   * @returns {eslint-scope.Variable|null} A found variable or `null`.
   */
  getVariableByName(initScope, name) {
    let scope = initScope;
    while (scope) {
      const variable = scope.set.get(name);
      if (variable) {
        return variable;
      }
      scope = scope.upper;
    }
    return null;
  },
  /**
   * Checks whether or not a given function node is the default `this` binding.
   *
   * First, this checks the node:
   *
   * - The function name does not start with uppercase (it's a constructor).
   * - The function does not have a JSDoc comment that has a @this tag.
   *
   * Next, this checks the location of the node.
   * If the location is below, this judges `this` is valid.
   *
   * - The location is not on an object literal.
   * - The location is not assigned to a variable which starts with an uppercase letter.
   * - The location is not on an ES2015 class.
   * - Its `bind`/`call`/`apply` method is not called directly.
   * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
   *
   * @param {ASTNode} node - A function node to check.
   * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
   * @returns {boolean} The function node is the default `this` binding.
   */
  isDefaultThisBinding(node, sourceCode) {
    if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
      return false;
    }
    const isAnonymous = node.id === null;
    let currentNode = node;
    while (currentNode) {
      const parent = currentNode.parent;
      switch (parent.type) {
        /*
         * Looks up the destination.
         * e.g., obj.foo = nativeFoo || function foo() { ... };
         */
        case "LogicalExpression":
        case "ConditionalExpression":
          currentNode = parent;
          break;

        /*
         * If the upper function is IIFE, checks the destination of the return value.
         * e.g.
         *   obj.foo = (function() {
         *     // setup...
         *     return function foo() { ... };
         *   })();
         *   obj.foo = (() =>
         *     function foo() { ... }
         *   )();
         */
        case "ReturnStatement":
          {
            const func = getUpperFunction(parent);
            if (func === null || !isCallee(func)) {
              return true;
            }
            currentNode = func.parent;
            break;
          }
        case "ArrowFunctionExpression":
          if (currentNode !== parent.body || !isCallee(parent)) {
            return true;
          }
          currentNode = parent.parent;
          break;

        /*
         * e.g.
         *   var obj = { foo() { ... } };
         *   var obj = { foo: function() { ... } };
         *   class A { constructor() { ... } }
         *   class A { foo() { ... } }
         *   class A { get foo() { ... } }
         *   class A { set foo() { ... } }
         *   class A { static foo() { ... } }
         */
        case "Property":
        case "MethodDefinition":
          return parent.value !== currentNode;

        /*
         * e.g.
         *   obj.foo = function foo() { ... };
         *   Foo = function() { ... };
         *   [obj.foo = function foo() { ... }] = a;
         *   [Foo = function() { ... }] = a;
         */
        case "AssignmentExpression":
        case "AssignmentPattern":
          if (parent.left.type === "MemberExpression") {
            return false;
          }
          if (isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
            return false;
          }
          return true;

        /*
         * e.g.
         *   var Foo = function() { ... };
         */
        case "VariableDeclarator":
          return !(isAnonymous && parent.init === currentNode && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));

        /*
         * e.g.
         *   var foo = function foo() { ... }.bind(obj);
         *   (function foo() { ... }).call(obj);
         *   (function foo() { ... }).apply(obj, []);
         */
        case "MemberExpression":
          return parent.object !== currentNode || parent.property.type !== "Identifier" || !bindOrCallOrApplyPattern.test(parent.property.name) || !isCallee(parent) || parent.parent.arguments.length === 0 || isNullOrUndefined(parent.parent.arguments[0]);

        /*
         * e.g.
         *   Reflect.apply(function() {}, obj, []);
         *   Array.from([], function() {}, obj);
         *   list.forEach(function() {}, obj);
         */
        case "CallExpression":
          if (isReflectApply(parent.callee)) {
            return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
          }
          if (isArrayFromMethod(parent.callee)) {
            return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
          }
          if (isMethodWhichHasThisArg(parent.callee)) {
            return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
          }
          return true;

        // Otherwise `this` is default.
        default:
          return true;
      }
    }

    /* istanbul ignore next */
    return true;
  },
  /**
   * Get the precedence level based on the node type
   * @param {ASTNode} node node to evaluate
   * @returns {int} precedence level
   * @private
   */
  getPrecedence(node) {
    switch (node.type) {
      case "SequenceExpression":
        return 0;
      case "AssignmentExpression":
      case "ArrowFunctionExpression":
      case "YieldExpression":
        return 1;
      case "ConditionalExpression":
        return 3;
      case "LogicalExpression":
        switch (node.operator) {
          case "||":
            return 4;
          case "&&":
            return 5;

          // no default
        }

      /* falls through */

      case "BinaryExpression":
        switch (node.operator) {
          case "|":
            return 6;
          case "^":
            return 7;
          case "&":
            return 8;
          case "==":
          case "!=":
          case "===":
          case "!==":
            return 9;
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "in":
          case "instanceof":
            return 10;
          case "<<":
          case ">>":
          case ">>>":
            return 11;
          case "+":
          case "-":
            return 12;
          case "*":
          case "/":
          case "%":
            return 13;
          case "**":
            return 15;

          // no default
        }

      /* falls through */

      case "UnaryExpression":
      case "AwaitExpression":
        return 16;
      case "UpdateExpression":
        return 17;
      case "CallExpression":
        return 18;
      case "NewExpression":
        return 19;
      default:
        return 20;
    }
  },
  /**
   * Checks whether the given node is an empty block node or not.
   *
   * @param {ASTNode|null} node - The node to check.
   * @returns {boolean} `true` if the node is an empty block.
   */
  isEmptyBlock(node) {
    return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
  },
  /**
   * Checks whether the given node is an empty function node or not.
   *
   * @param {ASTNode|null} node - The node to check.
   * @returns {boolean} `true` if the node is an empty function.
   */
  isEmptyFunction(node) {
    return isFunction(node) && module.exports.isEmptyBlock(node.body);
  },
  /**
   * Gets the property name of a given node.
   * The node can be a MemberExpression, a Property, or a MethodDefinition.
   *
   * If the name is dynamic, this returns `null`.
   *
   * For examples:
   *
   *     a.b           // => "b"
   *     a["b"]        // => "b"
   *     a['b']        // => "b"
   *     a[`b`]        // => "b"
   *     a[100]        // => "100"
   *     a[b]          // => null
   *     a["a" + "b"]  // => null
   *     a[tag`b`]     // => null
   *     a[`${b}`]     // => null
   *
   *     let a = {b: 1}            // => "b"
   *     let a = {["b"]: 1}        // => "b"
   *     let a = {['b']: 1}        // => "b"
   *     let a = {[`b`]: 1}        // => "b"
   *     let a = {[100]: 1}        // => "100"
   *     let a = {[b]: 1}          // => null
   *     let a = {["a" + "b"]: 1}  // => null
   *     let a = {[tag`b`]: 1}     // => null
   *     let a = {[`${b}`]: 1}     // => null
   *
   * @param {ASTNode} node - The node to get.
   * @returns {string|null} The property name if static. Otherwise, null.
   */
  getStaticPropertyName(node) {
    let prop;
    switch (node && node.type) {
      case "Property":
      case "MethodDefinition":
        prop = node.key;
        break;
      case "MemberExpression":
        prop = node.property;
        break;

      // no default
    }
    switch (prop && prop.type) {
      case "Literal":
        return String(prop.value);
      case "TemplateLiteral":
        if (prop.expressions.length === 0 && prop.quasis.length === 1) {
          return prop.quasis[0].value.cooked;
        }
        break;
      case "Identifier":
        if (!node.computed) {
          return prop.name;
        }
        break;

      // no default
    }
    return null;
  },
  /**
   * Get directives from directive prologue of a Program or Function node.
   * @param {ASTNode} node - The node to check.
   * @returns {ASTNode[]} The directives found in the directive prologue.
   */
  getDirectivePrologue(node) {
    const directives = [];

    // Directive prologues only occur at the top of files or functions.
    if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || (
    /*
     * Do not check arrow functions with implicit return.
     * `() => "use strict";` returns the string `"use strict"`.
     */
    node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement")) {
      const statements = node.type === "Program" ? node.body : node.body.body;
      for (const statement of statements) {
        if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
          directives.push(statement);
        } else {
          break;
        }
      }
    }
    return directives;
  },
  /**
   * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
   * after the node will be parsed as a decimal point, rather than a property-access dot.
   * @param {ASTNode} node - The node to check.
   * @returns {boolean} `true` if this node is a decimal integer.
   * @example
   *
   * 5       // true
   * 5.      // false
   * 5.0     // false
   * 05      // false
   * 0x5     // false
   * 0b101   // false
   * 0o5     // false
   * 5e0     // false
   * '5'     // false
   */
  isDecimalInteger(node) {
    return node.type === "Literal" && typeof node.value === "number" && /^(0|[1-9]\d*)$/u.test(node.raw);
  },
  /**
   * Gets the name and kind of the given function node.
   *
   * - `function foo() {}`  .................... `function 'foo'`
   * - `(function foo() {})`  .................. `function 'foo'`
   * - `(function() {})`  ...................... `function`
   * - `function* foo() {}`  ................... `generator function 'foo'`
   * - `(function* foo() {})`  ................. `generator function 'foo'`
   * - `(function*() {})`  ..................... `generator function`
   * - `() => {}`  ............................. `arrow function`
   * - `async () => {}`  ....................... `async arrow function`
   * - `({ foo: function foo() {} })`  ......... `method 'foo'`
   * - `({ foo: function() {} })`  ............. `method 'foo'`
   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
   * - `({ [foo]: function() {} })`  ........... `method`
   * - `({ foo() {} })`  ....................... `method 'foo'`
   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
   * - `({ [foo]: function*() {} })`  .......... `generator method`
   * - `({ *foo() {} })`  ...................... `generator method 'foo'`
   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
   * - `({ foo: async function() {} })`  ....... `async method 'foo'`
   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
   * - `({ [foo]: async function() {} })`  ..... `async method`
   * - `({ async foo() {} })`  ................. `async method 'foo'`
   * - `({ get foo() {} })`  ................... `getter 'foo'`
   * - `({ set foo(a) {} })`  .................. `setter 'foo'`
   * - `class A { constructor() {} }`  ......... `constructor`
   * - `class A { foo() {} }`  ................. `method 'foo'`
   * - `class A { *foo() {} }`  ................ `generator method 'foo'`
   * - `class A { async foo() {} }`  ........... `async method 'foo'`
   * - `class A { ['foo']() {} }`  ............. `method 'foo'`
   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
   * - `class A { [foo]() {} }`  ............... `method`
   * - `class A { *[foo]() {} }`  .............. `generator method`
   * - `class A { async [foo]() {} }`  ......... `async method`
   * - `class A { get foo() {} }`  ............. `getter 'foo'`
   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
   * - `class A { static foo() {} }`  .......... `static method 'foo'`
   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
   * - `class A { static async foo() {} }`  .... `static async method 'foo'`
   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
   *
   * @param {ASTNode} node - The function node to get.
   * @returns {string} The name and kind of the function node.
   */
  getFunctionNameWithKind(node) {
    const parent = node.parent;
    const tokens = [];
    if (parent.type === "MethodDefinition" && parent.static) {
      tokens.push("static");
    }
    if (node.async) {
      tokens.push("async");
    }
    if (node.generator) {
      tokens.push("generator");
    }
    if (node.type === "ArrowFunctionExpression") {
      tokens.push("arrow", "function");
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
      if (parent.kind === "constructor") {
        return "constructor";
      }
      if (parent.kind === "get") {
        tokens.push("getter");
      } else if (parent.kind === "set") {
        tokens.push("setter");
      } else {
        tokens.push("method");
      }
    } else {
      tokens.push("function");
    }
    if (node.id) {
      tokens.push(`'${node.id.name}'`);
    } else {
      const name = module.exports.getStaticPropertyName(parent);
      if (name) {
        tokens.push(`'${name}'`);
      }
    }
    return tokens.join(" ");
  },
  /**
   * Gets the location of the given function node for reporting.
   *
   * - `function foo() {}`
   *    ^^^^^^^^^^^^
   * - `(function foo() {})`
   *     ^^^^^^^^^^^^
   * - `(function() {})`
   *     ^^^^^^^^
   * - `function* foo() {}`
   *    ^^^^^^^^^^^^^
   * - `(function* foo() {})`
   *     ^^^^^^^^^^^^^
   * - `(function*() {})`
   *     ^^^^^^^^^
   * - `() => {}`
   *       ^^
   * - `async () => {}`
   *             ^^
   * - `({ foo: function foo() {} })`
   *       ^^^^^^^^^^^^^^^^^
   * - `({ foo: function() {} })`
   *       ^^^^^^^^^^^^^
   * - `({ ['foo']: function() {} })`
   *       ^^^^^^^^^^^^^^^^^
   * - `({ [foo]: function() {} })`
   *       ^^^^^^^^^^^^^^^
   * - `({ foo() {} })`
   *       ^^^
   * - `({ foo: function* foo() {} })`
   *       ^^^^^^^^^^^^^^^^^^
   * - `({ foo: function*() {} })`
   *       ^^^^^^^^^^^^^^
   * - `({ ['foo']: function*() {} })`
   *       ^^^^^^^^^^^^^^^^^^
   * - `({ [foo]: function*() {} })`
   *       ^^^^^^^^^^^^^^^^
   * - `({ *foo() {} })`
   *       ^^^^
   * - `({ foo: async function foo() {} })`
   *       ^^^^^^^^^^^^^^^^^^^^^^^
   * - `({ foo: async function() {} })`
   *       ^^^^^^^^^^^^^^^^^^^
   * - `({ ['foo']: async function() {} })`
   *       ^^^^^^^^^^^^^^^^^^^^^^^
   * - `({ [foo]: async function() {} })`
   *       ^^^^^^^^^^^^^^^^^^^^^
   * - `({ async foo() {} })`
   *       ^^^^^^^^^
   * - `({ get foo() {} })`
   *       ^^^^^^^
   * - `({ set foo(a) {} })`
   *       ^^^^^^^
   * - `class A { constructor() {} }`
   *              ^^^^^^^^^^^
   * - `class A { foo() {} }`
   *              ^^^
   * - `class A { *foo() {} }`
   *              ^^^^
   * - `class A { async foo() {} }`
   *              ^^^^^^^^^
   * - `class A { ['foo']() {} }`
   *              ^^^^^^^
   * - `class A { *['foo']() {} }`
   *              ^^^^^^^^
   * - `class A { async ['foo']() {} }`
   *              ^^^^^^^^^^^^^
   * - `class A { [foo]() {} }`
   *              ^^^^^
   * - `class A { *[foo]() {} }`
   *              ^^^^^^
   * - `class A { async [foo]() {} }`
   *              ^^^^^^^^^^^
   * - `class A { get foo() {} }`
   *              ^^^^^^^
   * - `class A { set foo(a) {} }`
   *              ^^^^^^^
   * - `class A { static foo() {} }`
   *              ^^^^^^^^^^
   * - `class A { static *foo() {} }`
   *              ^^^^^^^^^^^
   * - `class A { static async foo() {} }`
   *              ^^^^^^^^^^^^^^^^
   * - `class A { static get foo() {} }`
   *              ^^^^^^^^^^^^^^
   * - `class A { static set foo(a) {} }`
   *              ^^^^^^^^^^^^^^
   *
   * @param {ASTNode} node - The function node to get.
   * @param {SourceCode} sourceCode - The source code object to get tokens.
   * @returns {string} The location of the function node for reporting.
   */
  getFunctionHeadLoc(node, sourceCode) {
    const parent = node.parent;
    let start = null;
    let end = null;
    if (node.type === "ArrowFunctionExpression") {
      const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
      start = arrowToken.loc.start;
      end = arrowToken.loc.end;
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
      start = parent.loc.start;
      end = getOpeningParenOfParams(node, sourceCode).loc.start;
    } else {
      start = node.loc.start;
      end = getOpeningParenOfParams(node, sourceCode).loc.start;
    }
    return {
      start: Object.assign({}, start),
      end: Object.assign({}, end)
    };
  },
  /**
   * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
   * surrounding the node.
   * @param {SourceCode} sourceCode The source code object
   * @param {ASTNode} node An expression node
   * @returns {string} The text representing the node, with all surrounding parentheses included
   */
  getParenthesisedText(sourceCode, node) {
    let leftToken = sourceCode.getFirstToken(node);
    let rightToken = sourceCode.getLastToken(node);
    while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
      leftToken = sourceCode.getTokenBefore(leftToken);
      rightToken = sourceCode.getTokenAfter(rightToken);
    }
    return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
  },
  /*
   * Determine if a node has a possiblity to be an Error object
   * @param  {ASTNode} node  ASTNode to check
   * @returns {boolean} True if there is a chance it contains an Error obj
   */
  couldBeError(node) {
    switch (node.type) {
      case "Identifier":
      case "CallExpression":
      case "NewExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "YieldExpression":
      case "AwaitExpression":
        return true;
      // possibly an error object.

      case "AssignmentExpression":
        return module.exports.couldBeError(node.right);
      case "SequenceExpression":
        {
          const exprs = node.expressions;
          return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
        }
      case "LogicalExpression":
        return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
      case "ConditionalExpression":
        return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);
      default:
        return false;
    }
  },
  /**
   * Determines whether the given node is a `null` literal.
   * @param {ASTNode} node The node to check
   * @returns {boolean} `true` if the node is a `null` literal
   */
  isNullLiteral(node) {
    /*
     * Checking `node.value === null` does not guarantee that a literal is a null literal.
     * When parsing values that cannot be represented in the current environment (e.g. unicode
     * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to
     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check
     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020
     */
    return node.type === "Literal" && node.value === null && !node.regex;
  },
  /**
   * Determines whether two tokens can safely be placed next to each other without merging into a single token
   * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
   * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
   * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
   * next to each other, behavior is undefined (although it should return `true` in most cases).
   */
  canTokensBeAdjacent(leftValue, rightValue) {
    let leftToken;
    if (typeof leftValue === "string") {
      const leftTokens = espree.tokenize(leftValue, {
        ecmaVersion: 2015
      });
      leftToken = leftTokens[leftTokens.length - 1];
    } else {
      leftToken = leftValue;
    }
    const rightToken = typeof rightValue === "string" ? espree.tokenize(rightValue, {
      ecmaVersion: 2015
    })[0] : rightValue;
    if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
      if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
        const PLUS_TOKENS = new Set(["+", "++"]);
        const MINUS_TOKENS = new Set(["-", "--"]);
        return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
      }
      return true;
    }
    if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
      return true;
    }
    if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
      return true;
    }
    return false;
  }
};

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
  'use strict';

  exports.ast = __webpack_require__(112);
  exports.code = __webpack_require__(113);
  exports.keyword = __webpack_require__(114);
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 112 */
/***/ ((module) => {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
  'use strict';

  function isExpression(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
      case 'ArrayExpression':
      case 'AssignmentExpression':
      case 'BinaryExpression':
      case 'CallExpression':
      case 'ConditionalExpression':
      case 'FunctionExpression':
      case 'Identifier':
      case 'Literal':
      case 'LogicalExpression':
      case 'MemberExpression':
      case 'NewExpression':
      case 'ObjectExpression':
      case 'SequenceExpression':
      case 'ThisExpression':
      case 'UnaryExpression':
      case 'UpdateExpression':
        return true;
    }
    return false;
  }
  function isIterationStatement(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
      case 'DoWhileStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'WhileStatement':
        return true;
    }
    return false;
  }
  function isStatement(node) {
    if (node == null) {
      return false;
    }
    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
        return true;
    }
    return false;
  }
  function isSourceElement(node) {
    return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
  }
  function trailingStatement(node) {
    switch (node.type) {
      case 'IfStatement':
        if (node.alternate != null) {
          return node.alternate;
        }
        return node.consequent;
      case 'LabeledStatement':
      case 'ForStatement':
      case 'ForInStatement':
      case 'WhileStatement':
      case 'WithStatement':
        return node.body;
    }
    return null;
  }
  function isProblematicIfStatement(node) {
    var current;
    if (node.type !== 'IfStatement') {
      return false;
    }
    if (node.alternate == null) {
      return false;
    }
    current = node.consequent;
    do {
      if (current.type === 'IfStatement') {
        if (current.alternate == null) {
          return true;
        }
      }
      current = trailingStatement(current);
    } while (current);
    return false;
  }
  module.exports = {
    isExpression: isExpression,
    isStatement: isStatement,
    isIterationStatement: isIterationStatement,
    isSourceElement: isSourceElement,
    isProblematicIfStatement: isProblematicIfStatement,
    trailingStatement: trailingStatement
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 113 */
/***/ ((module) => {

/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
  'use strict';

  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

  // See `tools/generate-identifier-regex.js`.
  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };
  function isDecimalDigit(ch) {
    return 0x30 <= ch && ch <= 0x39; // 0..9
  }
  function isHexDigit(ch) {
    return 0x30 <= ch && ch <= 0x39 ||
    // 0..9
    0x61 <= ch && ch <= 0x66 ||
    // a..f
    0x41 <= ch && ch <= 0x46; // A..F
  }
  function isOctalDigit(ch) {
    return ch >= 0x30 && ch <= 0x37; // 0..7
  }

  // 7.2 White Space

  NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];
  function isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
  }

  // 7.3 Line Terminators

  function isLineTerminator(ch) {
    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
  }

  // 7.6 Identifier Names and Identifiers

  function fromCodePoint(cp) {
    if (cp <= 0xFFFF) {
      return String.fromCharCode(cp);
    }
    var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
    var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
    return cu1 + cu2;
  }
  IDENTIFIER_START = new Array(0x80);
  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A ||
    // a..z
    ch >= 0x41 && ch <= 0x5A ||
    // A..Z
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }
  IDENTIFIER_PART = new Array(0x80);
  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A ||
    // a..z
    ch >= 0x41 && ch <= 0x5A ||
    // A..Z
    ch >= 0x30 && ch <= 0x39 ||
    // 0..9
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }
  function isIdentifierStartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }
  function isIdentifierPartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }
  function isIdentifierStartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }
  function isIdentifierPartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }
  module.exports = {
    isDecimalDigit: isDecimalDigit,
    isHexDigit: isHexDigit,
    isOctalDigit: isOctalDigit,
    isWhiteSpace: isWhiteSpace,
    isLineTerminator: isLineTerminator,
    isIdentifierStartES5: isIdentifierStartES5,
    isIdentifierPartES5: isIdentifierPartES5,
    isIdentifierStartES6: isIdentifierStartES6,
    isIdentifierPartES6: isIdentifierPartES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 114 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
  'use strict';

  var code = __webpack_require__(113);
  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'let':
        return true;
      default:
        return false;
    }
  }
  function isKeywordES5(id, strict) {
    // yield should not be treated as keyword under non-strict mode.
    if (!strict && id === 'yield') {
      return false;
    }
    return isKeywordES6(id, strict);
  }
  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }
    switch (id.length) {
      case 2:
        return id === 'if' || id === 'in' || id === 'do';
      case 3:
        return id === 'var' || id === 'for' || id === 'new' || id === 'try';
      case 4:
        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
      case 5:
        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
      case 6:
        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
      case 7:
        return id === 'default' || id === 'finally' || id === 'extends';
      case 8:
        return id === 'function' || id === 'continue' || id === 'debugger';
      case 10:
        return id === 'instanceof';
      default:
        return false;
    }
  }
  function isReservedWordES5(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
  }
  function isReservedWordES6(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
  }
  function isRestrictedWord(id) {
    return id === 'eval' || id === 'arguments';
  }
  function isIdentifierNameES5(id) {
    var i, iz, ch;
    if (id.length === 0) {
      return false;
    }
    ch = id.charCodeAt(0);
    if (!code.isIdentifierStartES5(ch)) {
      return false;
    }
    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (!code.isIdentifierPartES5(ch)) {
        return false;
      }
    }
    return true;
  }
  function decodeUtf16(lead, trail) {
    return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  }
  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;
    if (id.length === 0) {
      return false;
    }
    check = code.isIdentifierStartES6;
    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (0xD800 <= ch && ch <= 0xDBFF) {
        ++i;
        if (i >= iz) {
          return false;
        }
        lowCh = id.charCodeAt(i);
        if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
          return false;
        }
        ch = decodeUtf16(ch, lowCh);
      }
      if (!check(ch)) {
        return false;
      }
      check = code.isIdentifierPartES6;
    }
    return true;
  }
  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }
  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }
  module.exports = {
    isKeywordES5: isKeywordES5,
    isKeywordES6: isKeywordES6,
    isReservedWordES5: isReservedWordES5,
    isReservedWordES6: isReservedWordES6,
    isRestrictedWord: isRestrictedWord,
    isIdentifierNameES5: isIdentifierNameES5,
    isIdentifierNameES6: isIdentifierNameES6,
    isIdentifierES5: isIdentifierES5,
    isIdentifierES6: isIdentifierES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 115 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Config file operations. This file must be usable in the browser,
 * so no Node-specific code can be here.
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const minimatch = __webpack_require__(116),
  path = __webpack_require__(117);
const debug = __webpack_require__(105)("eslint:config-ops");

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

const RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
  RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
    map[value] = index;
    return map;
  }, {}),
  VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  /**
   * Creates an empty configuration object suitable for merging as a base.
   * @returns {Object} A configuration object.
   */
  createEmptyConfig() {
    return {
      globals: {},
      env: {},
      rules: {},
      parserOptions: {}
    };
  },
  /**
   * Creates an environment config based on the specified environments.
   * @param {Object<string,boolean>} env The environment settings.
   * @param {Environments} envContext The environment context.
   * @returns {Object} A configuration object with the appropriate rules and globals
   *      set.
   */
  createEnvironmentConfig(env, envContext) {
    const envConfig = this.createEmptyConfig();
    if (env) {
      envConfig.env = env;
      Object.keys(env).filter(name => env[name]).forEach(name => {
        const environment = envContext.get(name);
        if (environment) {
          debug(`Creating config for environment ${name}`);
          if (environment.globals) {
            Object.assign(envConfig.globals, environment.globals);
          }
          if (environment.parserOptions) {
            Object.assign(envConfig.parserOptions, environment.parserOptions);
          }
        }
      });
    }
    return envConfig;
  },
  /**
   * Given a config with environment settings, applies the globals and
   * ecmaFeatures to the configuration and returns the result.
   * @param {Object} config The configuration information.
   * @param {Environments} envContent env context.
   * @returns {Object} The updated configuration information.
   */
  applyEnvironments(config, envContent) {
    if (config.env && typeof config.env === "object") {
      debug("Apply environment settings to config");
      return this.merge(this.createEnvironmentConfig(config.env, envContent), config);
    }
    return config;
  },
  /**
   * Merges two config objects. This will not only add missing keys, but will also modify values to match.
   * @param {Object} target config object
   * @param {Object} src config object. Overrides in this config object will take priority over base.
   * @param {boolean} [combine] Whether to combine arrays or not
   * @param {boolean} [isRule] Whether its a rule
   * @returns {Object} merged config object.
   */
  merge: function deepmerge(target, src, combine, isRule) {
    /*
     * The MIT License (MIT)
     *
     * Copyright (c) 2012 Nicholas Fisher
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */

    /*
     * This code is taken from deepmerge repo
     * (https://github.com/KyleAMathews/deepmerge)
     * and modified to meet our needs.
     */
    const array = Array.isArray(src) || Array.isArray(target);
    let dst = array && [] || {};
    if (array) {
      const resolvedTarget = target || [];

      // src could be a string, so check for array
      if (isRule && Array.isArray(src) && src.length > 1) {
        dst = dst.concat(src);
      } else {
        dst = dst.concat(resolvedTarget);
      }
      const resolvedSrc = typeof src === "object" ? src : [src];
      Object.keys(resolvedSrc).forEach((_, i) => {
        const e = resolvedSrc[i];
        if (typeof dst[i] === "undefined") {
          dst[i] = e;
        } else if (typeof e === "object") {
          if (isRule) {
            dst[i] = e;
          } else {
            dst[i] = deepmerge(resolvedTarget[i], e, combine, isRule);
          }
        } else {
          if (!combine) {
            dst[i] = e;
          } else {
            if (dst.indexOf(e) === -1) {
              dst.push(e);
            }
          }
        }
      });
    } else {
      if (target && typeof target === "object") {
        Object.keys(target).forEach(key => {
          dst[key] = target[key];
        });
      }
      Object.keys(src).forEach(key => {
        if (key === "overrides") {
          dst[key] = (target[key] || []).concat(src[key] || []);
        } else if (Array.isArray(src[key]) || Array.isArray(target[key])) {
          dst[key] = deepmerge(target[key], src[key], key === "plugins" || key === "extends", isRule);
        } else if (typeof src[key] !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
          dst[key] = src[key];
        } else {
          dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
        }
      });
    }
    return dst;
  },
  /**
   * Normalizes the severity value of a rule's configuration to a number
   * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally
   * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
   * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
   * whose first element is one of the above values. Strings are matched case-insensitively.
   * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.
   */
  getRuleSeverity(ruleConfig) {
    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
      return severityValue;
    }
    if (typeof severityValue === "string") {
      return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
    }
    return 0;
  },
  /**
   * Converts old-style severity settings (0, 1, 2) into new-style
   * severity settings (off, warn, error) for all rules. Assumption is that severity
   * values have already been validated as correct.
   * @param {Object} config The config object to normalize.
   * @returns {void}
   */
  normalizeToStrings(config) {
    if (config.rules) {
      Object.keys(config.rules).forEach(ruleId => {
        const ruleConfig = config.rules[ruleId];
        if (typeof ruleConfig === "number") {
          config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
        } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
          ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
        }
      });
    }
  },
  /**
   * Determines if the severity for the given rule configuration represents an error.
   * @param {int|string|Array} ruleConfig The configuration for an individual rule.
   * @returns {boolean} True if the rule represents an error, false if not.
   */
  isErrorSeverity(ruleConfig) {
    return module.exports.getRuleSeverity(ruleConfig) === 2;
  },
  /**
   * Checks whether a given config has valid severity or not.
   * @param {number|string|Array} ruleConfig - The configuration for an individual rule.
   * @returns {boolean} `true` if the configuration has valid severity.
   */
  isValidSeverity(ruleConfig) {
    let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
    if (typeof severity === "string") {
      severity = severity.toLowerCase();
    }
    return VALID_SEVERITIES.indexOf(severity) !== -1;
  },
  /**
   * Checks whether every rule of a given config has valid severity or not.
   * @param {Object} config - The configuration for rules.
   * @returns {boolean} `true` if the configuration has valid severity.
   */
  isEverySeverityValid(config) {
    return Object.keys(config).every(ruleId => this.isValidSeverity(config[ruleId]));
  },
  /**
   * Merges all configurations in a given config vector. A vector is an array of objects, each containing a config
   * file path and a list of subconfig indices that match the current file path. All config data is assumed to be
   * cached.
   * @param {Array<Object>} vector list of config files and their subconfig indices that match the current file path
   * @param {Object} configCache the config cache
   * @returns {Object} config object
   */
  getConfigFromVector(vector, configCache) {
    const cachedConfig = configCache.getMergedVectorConfig(vector);
    if (cachedConfig) {
      return cachedConfig;
    }
    debug("Using config from partial cache");
    const subvector = Array.from(vector);
    let nearestCacheIndex = subvector.length - 1,
      partialCachedConfig;
    while (nearestCacheIndex >= 0) {
      partialCachedConfig = configCache.getMergedVectorConfig(subvector);
      if (partialCachedConfig) {
        break;
      }
      subvector.pop();
      nearestCacheIndex--;
    }
    if (!partialCachedConfig) {
      partialCachedConfig = {};
    }
    let finalConfig = partialCachedConfig;

    // Start from entry immediately following nearest cached config (first uncached entry)
    for (let i = nearestCacheIndex + 1; i < vector.length; i++) {
      finalConfig = this.mergeVectorEntry(finalConfig, vector[i], configCache);
      configCache.setMergedVectorConfig(vector.slice(0, i + 1), finalConfig);
    }
    return finalConfig;
  },
  /**
   * Merges the config options from a single vector entry into the supplied config.
   * @param {Object} config the base config to merge the vector entry's options into
   * @param {Object} vectorEntry a single entry from a vector, consisting of a config file path and an array of
   * matching override indices
   * @param {Object} configCache the config cache
   * @returns {Object} merged config object
   */
  mergeVectorEntry(config, vectorEntry, configCache) {
    const vectorEntryConfig = Object.assign({}, configCache.getConfig(vectorEntry.filePath));
    let mergedConfig = Object.assign({}, config),
      overrides;
    if (vectorEntryConfig.overrides) {
      overrides = vectorEntryConfig.overrides.filter((override, overrideIndex) => vectorEntry.matchingOverrides.indexOf(overrideIndex) !== -1);
    } else {
      overrides = [];
    }
    mergedConfig = this.merge(mergedConfig, vectorEntryConfig);
    delete mergedConfig.overrides;
    mergedConfig = overrides.reduce((lastConfig, override) => this.merge(lastConfig, override), mergedConfig);
    if (mergedConfig.filePath) {
      delete mergedConfig.filePath;
      delete mergedConfig.baseDirectory;
    } else if (mergedConfig.files) {
      delete mergedConfig.files;
    }
    return mergedConfig;
  },
  /**
   * Checks that the specified file path matches all of the supplied glob patterns.
   * @param {string} filePath The file path to test patterns against
   * @param {string|string[]} patterns One or more glob patterns, of which at least one should match the file path
   * @param {string|string[]} [excludedPatterns] One or more glob patterns, of which none should match the file path
   * @returns {boolean} True if all the supplied patterns match the file path, false otherwise
   */
  pathMatchesGlobs(filePath, patterns, excludedPatterns) {
    const patternList = [].concat(patterns);
    const excludedPatternList = [].concat(excludedPatterns || []);
    patternList.concat(excludedPatternList).forEach(pattern => {
      if (path.isAbsolute(pattern) || pattern.includes("..")) {
        throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);
      }
    });
    const opts = {
      matchBase: true
    };
    return patternList.some(pattern => minimatch(filePath, pattern, opts)) && !excludedPatternList.some(excludedPattern => minimatch(filePath, excludedPattern, opts));
  },
  /**
   * Normalizes a value for a global in a config
   * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in
   * a global directive comment
   * @returns {("readable"|"writeable"|"off")} The value normalized as a string
   */
  normalizeConfigGlobal(configuredValue) {
    switch (configuredValue) {
      case "off":
        return "off";
      case true:
      case "true":
      case "writeable":
      case "writable":
        return "writeable";
      case null:
      case false:
      case "false":
      case "readable":
      case "readonly":
        return "readable";

      // Fallback to minimize compatibility impact
      default:
        return "writeable";
    }
  }
};

/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch;
minimatch.Minimatch = Minimatch;
var path = function () {
  try {
    return __webpack_require__(117);
  } catch (e) {}
}() || {
  sep: '/'
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = __webpack_require__(118);
var plTypes = {
  '!': {
    open: '(?:(?!(?:',
    close: '))[^/]*?)'
  },
  '?': {
    open: '(?:',
    close: ')?'
  },
  '+': {
    open: '(?:',
    close: ')+'
  },
  '*': {
    open: '(?:',
    close: ')*'
  },
  '@': {
    open: '(?:',
    close: ')'
  }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet(s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set;
  }, {});
}

// normalizes slashes.
var slashSplit = /\/+/;
minimatch.filter = filter;
function filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch(p, pattern, options);
  };
}
function ext(a, b) {
  b = b || {};
  var t = {};
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  return t;
}
minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch;
  }
  var orig = minimatch;
  var m = function minimatch(p, pattern, options) {
    return orig(p, pattern, ext(def, options));
  };
  m.Minimatch = function Minimatch(pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options));
  };
  m.Minimatch.defaults = function defaults(options) {
    return orig.defaults(ext(def, options)).Minimatch;
  };
  m.filter = function filter(pattern, options) {
    return orig.filter(pattern, ext(def, options));
  };
  m.defaults = function defaults(options) {
    return orig.defaults(ext(def, options));
  };
  m.makeRe = function makeRe(pattern, options) {
    return orig.makeRe(pattern, ext(def, options));
  };
  m.braceExpand = function braceExpand(pattern, options) {
    return orig.braceExpand(pattern, ext(def, options));
  };
  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options));
  };
  return m;
};
Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
  assertValidPattern(pattern);
  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false;
  }
  return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options);
  }
  assertValidPattern(pattern);
  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/');
  }
  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.partial = !!options.partial;

  // make the set of regexps etc.
  this.make();
}
Minimatch.prototype.debug = function () {};
Minimatch.prototype.make = make;
function make() {
  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return;
  }
  if (!pattern) {
    this.empty = true;
    return;
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();
  if (options.debug) this.debug = function debug() {
    console.error.apply(console, arguments);
  };
  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit);
  });
  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this);
  }, this);
  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1;
  });
  this.debug(this.pattern, set);
  this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;
  if (options.nonegate) return;
  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
    negate = !negate;
    negateOffset++;
  }
  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options;
    } else {
      options = {};
    }
  }
  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
  assertValidPattern(pattern);

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern];
  }
  return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern');
  }
  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long');
  }
};

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  assertValidPattern(pattern);
  var options = this.options;

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar) return GLOBSTAR;else pattern = '*';
  }
  if (pattern === '') return '';
  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;
  function clearStateChar() {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
          break;
        case '?':
          re += qmark;
          hasMagic = true;
          break;
        default:
          re += '\\' + stateChar;
          break;
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }
  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue;
    }
    switch (c) {
      /* istanbul ignore next */
      case '/':
        {
          // completely not allowed, even escaped.
          // Should already be path-split by now.
          return false;
        }
      case '\\':
        clearStateChar();
        escaping = true;
        continue;

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue;
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
        continue;
      case '(':
        if (inClass) {
          re += '(';
          continue;
        }
        if (!stateChar) {
          re += '\\(';
          continue;
        }
        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
        continue;
      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue;
        }
        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
        continue;
      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue;
        }
        clearStateChar();
        re += '|';
        continue;

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();
        if (inClass) {
          re += '\\' + c;
          continue;
        }
        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
        continue;
      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue;
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i);
        try {
          RegExp('[' + cs + ']');
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
          hasMagic = hasMagic || sp[1];
          inClass = false;
          continue;
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
        continue;
      default:
        // swallow any state char that wasn't consumed
        clearStateChar();
        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c] && !(c === '^' && inClass)) {
          re += '\\';
        }
        re += c;
    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|';
    });
    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '[':
    case '.':
    case '(':
      addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];
    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);
    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;
    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }
  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic];
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern);
  }
  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) /* istanbul ignore next - should be impossible */{
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.');
  }
  regExp._glob = pattern;
  regExp._src = re;
  return regExp;
}
minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;
  if (!set.length) {
    this.regexp = false;
    return this.regexp;
  }
  var options = this.options;
  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';
  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
    }).join('\\\/');
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';
  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) /* istanbul ignore next - should be impossible */{
    this.regexp = false;
  }
  return this.regexp;
}
minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list;
};
Minimatch.prototype.match = function match(f, partial) {
  if (typeof partial === 'undefined') partial = this.partial;
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false;
  if (this.empty) return f === '';
  if (f === '/' && partial) return true;
  var options = this.options;

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break;
  }
  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true;
      return !this.negate;
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false;
  return this.negate;
};

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;
  this.debug('matchOne', {
    'this': this,
    file: file,
    pattern: pattern
  });
  this.debug('matchOne', file.length, pattern.length);
  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];
    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false;
    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
        }
        return true;
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];
        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true;
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
            this.debug('dot detected!', file, fr, pattern, pr);
            break;
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true;
      }
      return false;
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      hit = f === p;
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }
    if (!hit) return false;
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true;
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial;
  } else /* istanbul ignore else */if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return fi === fl - 1 && file[fi] === '';
    }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?');
};

// replace stuff like \* with *
function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}
function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

/***/ }),
/* 117 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(6);
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += '/..';else res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}
var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0) path = arguments[i];else {
        if (cwd === undefined) cwd = process.cwd();
        path = cwd;
      }
      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }
      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },
  normalize: function normalize(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';
    if (isAbsolute) return '/' + path;
    return path;
  },
  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },
  join: function join() {
    if (arguments.length === 0) return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined) joined = arg;else joined += '/' + arg;
      }
    }
    if (joined === undefined) return '.';
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return '';
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/) break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;
    }
    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0) out += '..';else out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path) {
    return path;
  },
  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }
    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },
  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) return '';
      return path.slice(start, end);
    }
  },
  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },
  parse: function parse(path) {
    assertPath(path);
    var ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
    return ret;
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};
posix.posix = posix;
module.exports = posix;

/***/ }),
/* 118 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(119);
var balanced = __webpack_require__(120);
module.exports = expandTop;
var escSlash = '\0SLASH' + Math.random() + '\0';
var escOpen = '\0OPEN' + Math.random() + '\0';
var escClose = '\0CLOSE' + Math.random() + '\0';
var escComma = '\0COMMA' + Math.random() + '\0';
var escPeriod = '\0PERIOD' + Math.random() + '\0';
function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
  return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
}
function unescapeBraces(str) {
  return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
}

// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str) return [''];
  var parts = [];
  var m = balanced('{', '}', str);
  if (!m) return str.split(',');
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');
  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str) {
  if (!str) return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }
  return expand(escapeBraces(str), true).map(unescapeBraces);
}
function identity(e) {
  return e;
}
function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand(str, isTop) {
  var expansions = [];
  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];
  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }
  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length ? expand(m.post, false) : [''];
        return post.map(function (p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length ? expand(m.post, false) : [''];
  var N;
  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);
    N = [];
    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\') c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function (el) {
      return expand(el, false);
    });
  }
  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion) expansions.push(expansion);
    }
  }
  return expansions;
}

/***/ }),
/* 119 */
/***/ ((module) => {

module.exports = function (xs, fn) {
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    var x = fn(xs[i], i);
    if (isArray(x)) res.push.apply(res, x);else res.push(x);
  }
  return res;
};
var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),
/* 120 */
/***/ ((module) => {

"use strict";


module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);
  var r = range(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}

/***/ }),
/* 121 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(6);
/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const path = __webpack_require__(117),
  ajv = __webpack_require__(122),
  lodash = __webpack_require__(99),
  configSchema = __webpack_require__(170),
  util = __webpack_require__(171);
const ruleValidators = new WeakMap();

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
let validateSchema;

// Defitions for deprecation warnings.
const deprecationWarningMessages = {
  ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated, and has no effect.",
  ESLINT_LEGACY_OBJECT_REST_SPREAD: "The 'parserOptions.ecmaFeatures.experimentalObjectRestSpread' option is deprecated. Use 'parserOptions.ecmaVersion' instead."
};
const severityMap = {
  error: 2,
  warn: 1,
  off: 0
};

/**
 * Gets a complete options schema for a rule.
 * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
 * @returns {Object} JSON Schema for the rule's options.
 */
function getRuleOptionsSchema(rule) {
  const schema = rule.schema || rule.meta && rule.meta.schema;

  // Given a tuple of schemas, insert warning level at the beginning
  if (Array.isArray(schema)) {
    if (schema.length) {
      return {
        type: "array",
        items: schema,
        minItems: 0,
        maxItems: schema.length
      };
    }
    return {
      type: "array",
      minItems: 0,
      maxItems: 0
    };
  }

  // Given a full schema, leave it alone
  return schema || null;
}

/**
 * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
 * @param {options} options The given options for the rule.
 * @returns {number|string} The rule's severity value
 */
function validateRuleSeverity(options) {
  const severity = Array.isArray(options) ? options[0] : options;
  const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;
  if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
    return normSeverity;
  }
  throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, "\"").replace(/\n/gu, "")}').\n`);
}

/**
 * Validates the non-severity options passed to a rule, based on its schema.
 * @param {{create: Function}} rule The rule to validate
 * @param {Array} localOptions The options for the rule, excluding severity
 * @returns {void}
 */
function validateRuleSchema(rule, localOptions) {
  if (!ruleValidators.has(rule)) {
    const schema = getRuleOptionsSchema(rule);
    if (schema) {
      ruleValidators.set(rule, ajv.compile(schema));
    }
  }
  const validateRule = ruleValidators.get(rule);
  if (validateRule) {
    validateRule(localOptions);
    if (validateRule.errors) {
      throw new Error(validateRule.errors.map(error => `\tValue ${JSON.stringify(error.data)} ${error.message}.\n`).join(""));
    }
  }
}

/**
 * Validates a rule's options against its schema.
 * @param {{create: Function}|null} rule The rule that the config is being validated for
 * @param {string} ruleId The rule's unique name.
 * @param {Array|number} options The given options for the rule.
 * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
 * no source is prepended to the message.
 * @returns {void}
 */
function validateRuleOptions(rule, ruleId, options) {
  let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  if (!rule) {
    return;
  }
  try {
    const severity = validateRuleSeverity(options);
    if (severity !== 0) {
      validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
    }
  } catch (err) {
    const enhancedMessage = `Configuration for rule "${ruleId}" is invalid:\n${err.message}`;
    if (typeof source === "string") {
      throw new Error(`${source}:\n\t${enhancedMessage}`);
    } else {
      throw new Error(enhancedMessage);
    }
  }
}

/**
 * Validates an environment object
 * @param {Object} environment The environment config object to validate.
 * @param {Environments} envContext Env context
 * @param {string} source The name of the configuration source to report in any errors.
 * @returns {void}
 */
function validateEnvironment(environment, envContext) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  // not having an environment is ok
  if (!environment) {
    return;
  }
  Object.keys(environment).forEach(env => {
    if (!envContext.get(env)) {
      const message = `${source}:\n\tEnvironment key "${env}" is unknown\n`;
      throw new Error(message);
    }
  });
}

/**
 * Validates a rules config object
 * @param {Object} rulesConfig The rules config object to validate.
 * @param {function(string): {create: Function}} ruleMapper A mapper function from strings to loaded rules
 * @param {string} source The name of the configuration source to report in any errors.
 * @returns {void}
 */
function validateRules(rulesConfig, ruleMapper) {
  let source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!rulesConfig) {
    return;
  }
  Object.keys(rulesConfig).forEach(id => {
    validateRuleOptions(ruleMapper(id), id, rulesConfig[id], source);
  });
}

/**
 * Formats an array of schema validation errors.
 * @param {Array} errors An array of error messages to format.
 * @returns {string} Formatted error message
 */
function formatErrors(errors) {
  return errors.map(error => {
    if (error.keyword === "additionalProperties") {
      const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;
      return `Unexpected top-level property "${formattedPropertyPath}"`;
    }
    if (error.keyword === "type") {
      const formattedField = error.dataPath.slice(1);
      const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
      const formattedValue = JSON.stringify(error.data);
      return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
    }
    const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
    return `"${field}" ${error.message}. Value: ${JSON.stringify(error.data)}`;
  }).map(message => `\t- ${message}.\n`).join("");
}

/**
 * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted
 * for each unique file path, but repeated invocations with the same file path have no effect.
 * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.
 * @param {string} source The name of the configuration source to report the warning for.
 * @param {string} errorCode The warning message to show.
 * @returns {void}
 */
const emitDeprecationWarning = lodash.memoize((source, errorCode) => {
  const rel = path.relative(process.cwd(), source);
  const message = deprecationWarningMessages[errorCode];
  process.emitWarning(`${message} (found in "${rel}")`, "DeprecationWarning", errorCode);
});

/**
 * Validates the top level properties of the config object.
 * @param {Object} config The config object to validate.
 * @param {string} source The name of the configuration source to report in any errors.
 * @returns {void}
 */
function validateConfigSchema(config) {
  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  validateSchema = validateSchema || ajv.compile(configSchema);
  if (!validateSchema(config)) {
    throw new Error(`ESLint configuration in ${source} is invalid:\n${formatErrors(validateSchema.errors)}`);
  }
  if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
    emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
  }
  if ((config.parser || "espree") === "espree" && config.parserOptions && config.parserOptions.ecmaFeatures && config.parserOptions.ecmaFeatures.experimentalObjectRestSpread) {
    emitDeprecationWarning(source, "ESLINT_LEGACY_OBJECT_REST_SPREAD");
  }
}

/**
 * Validates an entire config object.
 * @param {Object} config The config object to validate.
 * @param {function(string): {create: Function}} ruleMapper A mapper function from rule IDs to defined rules
 * @param {Environments} envContext The env context
 * @param {string} source The name of the configuration source to report in any errors.
 * @returns {void}
 */
function validate(config, ruleMapper, envContext) {
  let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  validateConfigSchema(config, source);
  validateRules(config.rules, ruleMapper, source);
  validateEnvironment(config.env, envContext, source);
  for (const override of config.overrides || []) {
    validateRules(override.rules, ruleMapper, source);
    validateEnvironment(override.env, envContext, source);
  }
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  getRuleOptionsSchema,
  validate,
  validateRuleOptions
};

/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview The instance of Ajv validator.
 * @author Evgeny Poberezkin
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Ajv = __webpack_require__(123),
  metaSchema = __webpack_require__(169);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

const ajv = new Ajv({
  meta: false,
  useDefaults: true,
  validateSchema: false,
  missingRefs: "ignore",
  verbose: true,
  schemaId: "auto"
});
ajv.addMetaSchema(metaSchema);
// eslint-disable-next-line no-underscore-dangle
ajv._opts.defaultMeta = metaSchema.id;
module.exports = ajv;

/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var compileSchema = __webpack_require__(124),
  resolve = __webpack_require__(125),
  Cache = __webpack_require__(135),
  SchemaObject = __webpack_require__(130),
  stableStringify = __webpack_require__(133),
  formats = __webpack_require__(136),
  rules = __webpack_require__(137),
  $dataMetaSchema = __webpack_require__(162),
  util = __webpack_require__(128);
module.exports = Ajv;
Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;
Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;
Ajv.prototype.compileAsync = __webpack_require__(163);
var customKeyword = __webpack_require__(164);
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.prototype.validateKeyword = customKeyword.validate;
var errorClasses = __webpack_require__(132);
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;
var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults'];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache();
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);
  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);
  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {
    metaSchema: {
      type: 'boolean'
    }
  });
  addInitialSchemas(this);
}

/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }
  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}

/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}

/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string') throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}

/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}

/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string') throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);else throw new Error(message);
  }
  return valid;
}
function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object' ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
  return self._opts.defaultMeta;
}

/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object':
      return schemaObj.validate || this._compile(schemaObj);
    case 'string':
      return this.getSchema(schemaObj);
    case 'undefined':
      return _getSchemaFragment(this, keyRef);
  }
}
function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, {
    schema: {}
  }, ref);
  if (res) {
    var schema = res.schema,
      root = res.root,
      baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}
function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}

/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}
function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}

/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean') throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;
  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);
  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);
  var localRefs = resolve.ids.call(this, schema);
  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });
  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);
  if (willValidate && recursiveMeta) this.validateSchema(schema, true);
  return schemaObj;
}

/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true) callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;
  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }
  var v;
  try {
    v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
  } catch (e) {
    delete schemaObj.validate;
    throw e;
  } finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }
  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}
function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto':
      return _get$IdOrId;
    case 'id':
      return _getId;
    default:
      return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}
function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id) throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}

/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;
  var text = '';
  for (var i = 0; i < errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}

/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}
function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(168);
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(167);
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}
function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}
function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}
function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}
function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
}
function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}
function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {
      log: noop,
      warn: noop,
      error: noop
    };
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error)) throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}
function noop() {}

/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var resolve = __webpack_require__(125),
  util = __webpack_require__(128),
  errorClasses = __webpack_require__(132),
  stableStringify = __webpack_require__(133);
var validateGenerator = __webpack_require__(134);

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(127);

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;
module.exports = compile;

/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this,
    opts = this._opts,
    refVal = [undefined],
    refs = {},
    patterns = [],
    patternsHash = {},
    defaults = [],
    defaultsHash = {},
    customRules = [];
  root = root || {
    schema: schema,
    refVal: refVal,
    refs: refs
  };
  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return compilation.callValidate = callValidate;
  var formats = this._formats;
  var RULES = this.RULES;
  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }
  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || _root && _root.schema == _schema;
    if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);
    var $async = _schema.$async === true;
    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });
    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function('self', 'RULES', 'formats', 'root', 'refVal', 'defaults', 'customRules', 'equal', 'ucs2length', 'ValidationError', sourceCode);
      validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
      refVal[0] = validate;
    } catch (e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }
    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }
    return validate;
  }
  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }
    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }
    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }
  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }
  function removeLocalRef(ref) {
    delete refs[ref];
  }
  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }
  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean' ? {
      code: code,
      schema: refVal,
      inline: true
    } : {
      code: code,
      $async: refVal && !!refVal.$async
    };
  }
  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }
  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }
  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function (keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      })) throw new Error('parent schema must have all required keywords: ' + deps.join(','));
      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);else throw new Error(message);
        }
      }
    }
    var compile = rule.definition.compile,
      inline = rule.definition.inline,
      macro = rule.definition.macro;
    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }
    if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
    var index = customRules.length;
    customRules[index] = validate;
    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}

/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return {
    index: index,
    compiling: true
  };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return {
    index: index,
    compiling: false
  };
}

/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}

/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i = 0; i < this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}
function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}
function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}
function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}
function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}
function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i = 0; i < arr.length; i++) code += statement(i, arr);
  return code;
}

/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var URI = __webpack_require__(126),
  equal = __webpack_require__(127),
  util = __webpack_require__(128),
  SchemaObject = __webpack_require__(130),
  traverse = __webpack_require__(131);
module.exports = resolve;
resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];else return resolve.call(this, compile, root, refVal);
  }
  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
  }
  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }
  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
  }
  return v;
}

/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref),
    refPath = _getFullPath(p),
    baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref)) return {
          schema: refVal,
          root: root,
          baseId: baseId
        };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}

/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}
var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0, 1) != '/') return;
  var parts = parsedRef.fragment.split('/');
  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema) return {
    schema: schema,
    root: root,
    baseId: baseId
  };
}
var SIMPLE_INLINED = util.toHash(['type', 'format', 'pattern', 'maxLength', 'minLength', 'maxProperties', 'minProperties', 'maxItems', 'minItems', 'maximum', 'minimum', 'uniqueItems', 'multipleOf', 'required', 'enum']);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);else if (limit) return countKeys(schema) <= limit;
}
function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}
function countKeys(schema) {
  var count = 0,
    item;
  if (Array.isArray(schema)) {
    for (var i = 0; i < schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}
function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}
function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}
var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}
function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}

/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {
    '': schemaId
  };
  var fullPaths = {
    '': getFullPath(schemaId, false)
  };
  var localRefs = {};
  var self = this;
  traverse(schema, {
    allKeys: true
  }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined) fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));
    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });
  return localRefs;
}

/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, exports) {

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict';

  function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
      sets[_key] = arguments[_key];
    }
    if (sets.length > 1) {
      sets[0] = sets[0].slice(0, -1);
      var xl = sets.length - 1;
      for (var x = 1; x < xl; ++x) {
        sets[x] = sets[x].slice(1, -1);
      }
      sets[xl] = sets[xl].slice(1);
      return sets.join('');
    } else {
      return sets[0];
    }
  }
  function subexp(str) {
    return "(?:" + str + ")";
  }
  function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
  }
  function toUpperCase(str) {
    return str.toUpperCase();
  }
  function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
  }
  function assign(target, source) {
    var obj = target;
    if (source) {
      for (var key in source) {
        obj[key] = source[key];
      }
    }
    return obj;
  }
  function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
      CR$ = "[\\x0D]",
      DIGIT$$ = "[0-9]",
      DQUOTE$$ = "[\\x22]",
      HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
      //case-insensitive
      LF$$ = "[\\x0A]",
      SP$$ = "[\\x20]",
      PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
      //expanded
      GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
      SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
      RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
      UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
      //subset, excludes bidi control characters
      IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
      //subset
      UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
      SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
      USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
      DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
      DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
      //relaxed parsing rules
      IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
      H16$ = subexp(HEXDIG$$ + "{1,4}"),
      LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
      IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
      //                           6( h16 ":" ) ls32
      IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
      //                      "::" 5( h16 ":" ) ls32
      IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
      //[               h16 ] "::" 4( h16 ":" ) ls32
      IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
      //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
      IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
      //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
      IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
      //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
      IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
      //[ *4( h16 ":" ) h16 ] "::"              ls32
      IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
      //[ *5( h16 ":" ) h16 ] "::"              h16
      IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
      //[ *6( h16 ":" ) h16 ] "::"
      IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
      ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
      //RFC 6874
      IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
      //RFC 6874
      IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
      //RFC 6874, with relaxed parsing rules
      IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
      IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
      //RFC 6874
      REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
      HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
      PORT$ = subexp(DIGIT$$ + "*"),
      AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
      PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
      SEGMENT$ = subexp(PCHAR$ + "*"),
      SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
      SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
      PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
      PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
      //simplified
      PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
      //simplified
      PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
      //simplified
      PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
      PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
      QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
      FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
      HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
      URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
      RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
      RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
      URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
      ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
      GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
      RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
      ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
      SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
      AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
      NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
      NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
      NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
      ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      UNRESERVED: new RegExp(UNRESERVED$$, "g"),
      OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
      PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
      IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
      IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
  }
  var URI_PROTOCOL = buildExps(false);
  var IRI_PROTOCOL = buildExps(true);
  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /** Highest positive signed 32-bit float value */

  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80
  var delimiter = '-'; // '\x2D'

  /** Regular expressions */
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */
  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };

  /** Convenience shortcuts */
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error$1(type) {
    throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map(array, fn) {
    var result = [];
    var length = array.length;
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */
  var ucs2encode = function ucs2encode(array) {
    return String.fromCodePoint.apply(String, toConsumableArray(array));
  };

  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */
  var basicToDigit = function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
      return codePoint - 0x16;
    }
    if (codePoint - 0x41 < 0x1A) {
      return codePoint - 0x41;
    }
    if (codePoint - 0x61 < 0x1A) {
      return codePoint - 0x61;
    }
    return base;
  };

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };

  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */
  var decode = function decode(input) {
    // Don't use UCS-2.
    var output = [];
    var inputLength = input.length;
    var i = 0;
    var n = initialN;
    var bias = initialBias;

    // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    var basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (var j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error$1('not-basic');
      }
      output.push(input.charCodeAt(j));
    }

    // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.

    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      var oldi = i;
      for (var w = 1, k = base;; /* no condition */k += base) {
        if (index >= inputLength) {
          error$1('invalid-input');
        }
        var digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error$1('overflow');
        }
        i += digit * w;
        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        var baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error$1('overflow');
        }
        w *= baseMinusT;
      }
      var out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);

      // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:
      if (floor(i / out) > maxInt - n) {
        error$1('overflow');
      }
      n += floor(i / out);
      i %= out;

      // Insert `n` at position `i` of the output.
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint.apply(String, output);
  };

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  var encode = function encode(input) {
    var output = [];

    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);

    // Cache the length.
    var inputLength = input.length;

    // Initialize the state.
    var n = initialN;
    var delta = 0;
    var bias = initialBias;

    // Handle the basic code points.
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _currentValue2 = _step.value;
        if (_currentValue2 < 0x80) {
          output.push(stringFromCharCode(_currentValue2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var basicLength = output.length;
    var handledCPCount = basicLength;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) {
      output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;
      try {
        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var currentValue = _step2.value;
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;
      try {
        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _currentValue = _step3.value;
          if (_currentValue < n && ++delta > maxInt) {
            error$1('overflow');
          }
          if (_currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;
            for (var k = base;; /* no condition */k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      ++delta;
      ++n;
    }
    return output.join('');
  };

  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */
  var toUnicode = function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  var toASCII = function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };

  /*--------------------------------------------------------------------------*/

  /** Define the public API */
  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '2.1.0',
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };

  /**
   * URI.js
   *
   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/uri-js
   */
  /**
   * Copyright 2011 Gary Court. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification, are
   * permitted provided that the following conditions are met:
   *
   *    1. Redistributions of source code must retain the above copyright notice, this list of
   *       conditions and the following disclaimer.
   *
   *    2. Redistributions in binary form must reproduce the above copyright notice, this list
   *       of conditions and the following disclaimer in the documentation and/or other materials
   *       provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The views and conclusions contained in the software and documentation are those of the
   * authors and should not be interpreted as representing official policies, either expressed
   * or implied, of Gary Court.
   */
  var SCHEMES = {};
  function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
  }
  function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
      var c = parseInt(str.substr(i + 1, 2), 16);
      if (c < 128) {
        newStr += String.fromCharCode(c);
        i += 3;
      } else if (c >= 194 && c < 224) {
        if (il - i >= 6) {
          var c2 = parseInt(str.substr(i + 4, 2), 16);
          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
        } else {
          newStr += str.substr(i, 6);
        }
        i += 6;
      } else if (c >= 224) {
        if (il - i >= 9) {
          var _c = parseInt(str.substr(i + 4, 2), 16);
          var c3 = parseInt(str.substr(i + 7, 2), 16);
          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
        } else {
          newStr += str.substr(i, 9);
        }
        i += 9;
      } else {
        newStr += str.substr(i, 3);
        i += 3;
      }
    }
    return newStr;
  }
  function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
  }
  function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
  }
  function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];
    var _matches = slicedToArray(matches, 2),
      address = _matches[1];
    if (address) {
      return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
      return host;
    }
  }
  function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];
    var _matches2 = slicedToArray(matches, 3),
      address = _matches2[1],
      zone = _matches2[2];
    if (address) {
      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
        _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
        last = _address$toLowerCase$2[0],
        first = _address$toLowerCase$2[1];
      var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
      var lastFields = last.split(":").map(_stripLeadingZeros);
      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
      var fieldCount = isLastFieldIPv4Address ? 7 : 8;
      var lastFieldsStart = lastFields.length - fieldCount;
      var fields = Array(fieldCount);
      for (var x = 0; x < fieldCount; ++x) {
        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
      }
      if (isLastFieldIPv4Address) {
        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
      }
      var allZeroFields = fields.reduce(function (acc, field, index) {
        if (!field || field === "0") {
          var lastLongest = acc[acc.length - 1];
          if (lastLongest && lastLongest.index + lastLongest.length === index) {
            lastLongest.length++;
          } else {
            acc.push({
              index: index,
              length: 1
            });
          }
        }
        return acc;
      }, []);
      var longestZeroFields = allZeroFields.sort(function (a, b) {
        return b.length - a.length;
      })[0];
      var newHost = void 0;
      if (longestZeroFields && longestZeroFields.length > 1) {
        var newFirst = fields.slice(0, longestZeroFields.index);
        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
        newHost = newFirst.join(":") + "::" + newLast.join(":");
      } else {
        newHost = fields.join(":");
      }
      if (zone) {
        newHost += "%" + zone;
      }
      return newHost;
    } else {
      return host;
    }
  }
  var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
  var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
  function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
      if (NO_MATCH_IS_UNDEFINED) {
        //store each component
        components.scheme = matches[1];
        components.userinfo = matches[3];
        components.host = matches[4];
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = matches[7];
        components.fragment = matches[8];
        //fix port number
        if (isNaN(components.port)) {
          components.port = matches[5];
        }
      } else {
        //IE FIX for improper RegExp matching
        //store each component
        components.scheme = matches[1] || undefined;
        components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
        components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
        components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
        //fix port number
        if (isNaN(components.port)) {
          components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
        }
      }
      if (components.host) {
        //normalize IP hosts
        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
      }
      //determine reference type
      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
        components.reference = "same-document";
      } else if (components.scheme === undefined) {
        components.reference = "relative";
      } else if (components.fragment === undefined) {
        components.reference = "absolute";
      } else {
        components.reference = "uri";
      }
      //check for reference errors
      if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
        components.error = components.error || "URI is not a " + options.reference + " reference.";
      }
      //find scheme handler
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      //check if scheme can't handle IRIs
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        //if host component is a domain name
        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
          //convert Unicode IDN -> ASCII IDN
          try {
            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
          }
        }
        //convert IRI -> URI
        _normalizeComponentEncoding(components, URI_PROTOCOL);
      } else {
        //normalize encodings
        _normalizeComponentEncoding(components, protocol);
      }
      //perform scheme specific parsing
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(components, options);
      }
    } else {
      components.error = components.error || "URI can not be parsed.";
    }
    return components;
  }
  function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }
    if (components.host !== undefined) {
      //normalize IP hosts, add brackets and escape zone separator for IPv6
      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
      }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
  }
  var RDS1 = /^\.\.?\//;
  var RDS2 = /^\/\.(\/|$)/;
  var RDS3 = /^\/\.\.(\/|$)/;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
  function removeDotSegments(input) {
    var output = [];
    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        var im = input.match(RDS5);
        if (im) {
          var s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }
    return output.join("");
  }
  function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
      //if host component is an IPv6 address
      if (protocol.IPV6ADDRESS.test(components.host)) {}
      //TODO: normalize IPv6 address as per RFC 5952

      //if host component is a domain name
      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
        //convert IDN via punycode
        try {
          components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
        } catch (e) {
          components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
        }
      }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }
    if (components.path !== undefined) {
      var s = components.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }
      if (authority === undefined) {
        s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
      }
      uriTokens.push(s);
    }
    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
  }
  function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];
    var target = {};
    if (!skipNormalization) {
      base = parse(serialize(base, options), options); //normalize base components
      relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      //target.authority = relative.authority;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        //target.authority = base.authority;
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({
      scheme: 'null'
    }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
  }
  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
      uri = parse(serialize(uri, options), options);
    }
    return uri;
  }
  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
      uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
      uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
      uriB = serialize(uriB, options);
    }
    return uriA === uriB;
  }
  function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
  }
  function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
  }
  var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
      //report missing host
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    },
    serialize: function serialize(components, options) {
      var secure = String(components.scheme).toLowerCase() === "https";
      //normalize the default port
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = undefined;
      }
      //normalize the empty path
      if (!components.path) {
        components.path = "/";
      }
      //NOTE: We do not parse query strings for HTTP URIs
      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
      //and not the HTTP spec.
      return components;
    }
  };
  var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
  };
  function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
  }
  //RFC 6455
  var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
      var wsComponents = components;
      //indicate if the secure flag is set
      wsComponents.secure = isSecure(wsComponents);
      //construct resouce name
      wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
      wsComponents.path = undefined;
      wsComponents.query = undefined;
      return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
      //normalize the default port
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = undefined;
      }
      //ensure scheme matches secure flag
      if (typeof wsComponents.secure === 'boolean') {
        wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
        wsComponents.secure = undefined;
      }
      //reconstruct path from resource name
      if (wsComponents.resourceName) {
        var _wsComponents$resourc = wsComponents.resourceName.split('?'),
          _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
          path = _wsComponents$resourc2[0],
          query = _wsComponents$resourc2[1];
        wsComponents.path = path && path !== '/' ? path : undefined;
        wsComponents.query = query;
        wsComponents.resourceName = undefined;
      }
      //forbid fragment component
      wsComponents.fragment = undefined;
      return wsComponents;
    }
  };
  var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
  };
  var O = {};
  var isIRI = true;
  //RFC 3986
  var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
  var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
  var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
  //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
  //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
  //const VCHAR$$ = "[\\x21-\\x7E]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
  //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
  //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
  //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
  var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
  var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
  var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
  var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
  var UNRESERVED = new RegExp(UNRESERVED$$, "g");
  var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
  var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
  var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
  var NOT_HFVALUE = NOT_HFNAME;
  function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
  }
  var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
      var mailtoComponents = components;
      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
      mailtoComponents.path = undefined;
      if (mailtoComponents.query) {
        var unknownHeaders = false;
        var headers = {};
        var hfields = mailtoComponents.query.split("&");
        for (var x = 0, xl = hfields.length; x < xl; ++x) {
          var hfield = hfields[x].split("=");
          switch (hfield[0]) {
            case "to":
              var toAddrs = hfield[1].split(",");
              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                to.push(toAddrs[_x]);
              }
              break;
            case "subject":
              mailtoComponents.subject = unescapeComponent(hfield[1], options);
              break;
            case "body":
              mailtoComponents.body = unescapeComponent(hfield[1], options);
              break;
            default:
              unknownHeaders = true;
              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
              break;
          }
        }
        if (unknownHeaders) mailtoComponents.headers = headers;
      }
      mailtoComponents.query = undefined;
      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
        var addr = to[_x2].split("@");
        addr[0] = unescapeComponent(addr[0]);
        if (!options.unicodeSupport) {
          //convert Unicode IDN -> ASCII IDN
          try {
            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
          } catch (e) {
            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
          }
        } else {
          addr[1] = unescapeComponent(addr[1], options).toLowerCase();
        }
        to[_x2] = addr.join("@");
      }
      return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
      var components = mailtoComponents;
      var to = toArray(mailtoComponents.to);
      if (to) {
        for (var x = 0, xl = to.length; x < xl; ++x) {
          var toAddr = String(to[x]);
          var atIdx = toAddr.lastIndexOf("@");
          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
          var domain = toAddr.slice(atIdx + 1);
          //convert IDN via punycode
          try {
            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
          } catch (e) {
            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
          to[x] = localPart + "@" + domain;
        }
        components.path = to.join(",");
      }
      var headers = mailtoComponents.headers = mailtoComponents.headers || {};
      if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
      if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
      var fields = [];
      for (var name in headers) {
        if (headers[name] !== O[name]) {
          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
        }
      }
      if (fields.length) {
        components.query = fields.join("&");
      }
      return components;
    }
  };
  var URN_PARSE = /^([^\:]+)\:(.*)/;
  //RFC 2141
  var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
      var matches = components.path && components.path.match(URN_PARSE);
      var urnComponents = components;
      if (matches) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = matches[1].toLowerCase();
        var nss = matches[2];
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        urnComponents.nid = nid;
        urnComponents.nss = nss;
        urnComponents.path = undefined;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
      var scheme = options.scheme || urnComponents.scheme || "urn";
      var nid = urnComponents.nid;
      var urnScheme = scheme + ":" + (options.nid || nid);
      var schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      var uriComponents = urnComponents;
      var nss = urnComponents.nss;
      uriComponents.path = (nid || options.nid) + ":" + nss;
      return uriComponents;
    }
  };
  var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
  //RFC 4122
  var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
      var uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = undefined;
      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
      var urnComponents = uuidComponents;
      //normalize UUID
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
  };
  SCHEMES[handler.scheme] = handler;
  SCHEMES[handler$1.scheme] = handler$1;
  SCHEMES[handler$2.scheme] = handler$2;
  SCHEMES[handler$3.scheme] = handler$3;
  SCHEMES[handler$4.scheme] = handler$4;
  SCHEMES[handler$5.scheme] = handler$5;
  SCHEMES[handler$6.scheme] = handler$6;
  exports.SCHEMES = SCHEMES;
  exports.pctEncChar = pctEncChar;
  exports.pctDecChars = pctDecChars;
  exports.parse = parse;
  exports.removeDotSegments = removeDotSegments;
  exports.serialize = serialize;
  exports.resolveComponents = resolveComponents;
  exports.resolve = resolve;
  exports.normalize = normalize;
  exports.equal = equal;
  exports.escapeComponent = escapeComponent;
  exports.unescapeComponent = unescapeComponent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),
/* 127 */
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
  if (a === b) return true;
  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;
    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;
      return true;
    }
    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    for (i = length; i-- !== 0;) {
      var key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }
    return true;
  }

  // true if both NaN, false otherwise
  return a !== a && b !== b;
};

/***/ }),
/* 128 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(127),
  ucs2length: __webpack_require__(129),
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};
function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}
function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? ' !== ' : ' === ',
    AND = negate ? ' || ' : ' && ',
    OK = negate ? '!' : '',
    NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null':
      return data + EQUAL + 'null';
    case 'array':
      return OK + 'Array.isArray(' + data + ')';
    case 'object':
      return '(' + OK + data + AND + 'typeof ' + data + EQUAL + '"object"' + AND + NOT + 'Array.isArray(' + data + '))';
    case 'integer':
      return '(typeof ' + data + EQUAL + '"number"' + AND + NOT + '(' + data + ' % 1)' + AND + data + EQUAL + data + (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') + ')';
    case 'number':
      return '(typeof ' + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') + ')';
    default:
      return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}
function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1:
      return checkDataType(dataTypes[0], data, strictNumbers, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(' : '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types) code += (code ? ' && ' : '') + checkDataType(t, data, strictNumbers, true);
      return code;
  }
}
var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i = 0; i < dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}
function toHash(arr) {
  var hash = {};
  for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
  return hash;
}
var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number' ? '[' + key + ']' : IDENTIFIER.test(key) ? '.' + key : "['" + escapeQuotes(key) + "']";
}
function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\f/g, '\\f').replace(/\t/g, '\\t');
}
function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}
function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}
function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}
function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}
function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}
function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}
function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
  ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')') : isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'';
  return joinPaths(currentPath, path);
}
function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
  ? toQuotedString('/' + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}
var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }
    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + (lvl - up || '');
    if (!jsonPointer) return data;
  }
  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}
function joinPaths(a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
}
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

/***/ }),
/* 129 */
/***/ ((module) => {

"use strict";


// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0,
    len = str.length,
    pos = 0,
    value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

/***/ }),
/* 130 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(128);
module.exports = SchemaObject;
function SchemaObject(obj) {
  util.copy(obj, this);
}

/***/ }),
/* 131 */
/***/ ((module) => {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == 'function' ? cb : cb.pre || function () {};
  var post = cb.post || function () {};
  _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};
traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i = 0; i < sch.length; i++) _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

/***/ }),
/* 132 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var resolve = __webpack_require__(125);
module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};
function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}
MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};
function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}
function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

/***/ }),
/* 133 */
/***/ ((module) => {

"use strict";


module.exports = function (data, opts) {
  if (!opts) opts = {};
  if (typeof opts === 'function') opts = {
    cmp: opts
  };
  var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
  var cmp = opts.cmp && function (f) {
    return function (node) {
      return function (a, b) {
        var aobj = {
          key: a,
          value: node[a]
        };
        var bobj = {
          key: b,
          value: node[b]
        };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON === 'function') {
      node = node.toJSON();
    }
    if (node === undefined) return;
    if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
    if (typeof node !== 'object') return JSON.stringify(node);
    var i, out;
    if (Array.isArray(node)) {
      out = '[';
      for (i = 0; i < node.length; i++) {
        if (i) out += ',';
        out += stringify(node[i]) || 'null';
      }
      return out + ']';
    }
    if (node === null) return 'null';
    if (seen.indexOf(node) !== -1) {
      if (cycles) return JSON.stringify('__cycle__');
      throw new TypeError('Converting circular structure to JSON');
    }
    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = '';
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify(node[key]);
      if (!value) continue;
      if (out) out += ',';
      out += JSON.stringify(key) + ':' + value;
    }
    seen.splice(seenIndex, 1);
    return '{' + out + '}';
  }(data);
};

/***/ }),
/* 134 */
/***/ ((module) => {

"use strict";


module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + $valid + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + $valid + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + $lvl + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + it.RULES.all.$comment.code(it, '$comment');
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + $dataType + ' = typeof ' + $data + '; var ' + $coerced + ' = undefined; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + $dataType + ' == \'object\' && Array.isArray(' + $data + ') && ' + $data + '.length == 1) { ' + $data + ' = ' + $data + '[0]; ' + $dataType + ' = typeof ' + $data + '; if (' + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ') ' + $coerced + ' = ' + $data + '; } ';
        }
        out += ' if (' + $coerced + ' !== undefined) ; ';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type,
            $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == 'string') {
              out += ' else if (' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\') ' + $coerced + ' = \'\' + ' + $data + '; else if (' + $data + ' === null) ' + $coerced + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' else if (' + $dataType + ' == \'boolean\' || ' + $data + ' === null || (' + $dataType + ' == \'string\' && ' + $data + ' && ' + $data + ' == +' + $data + ' ';
              if ($type == 'integer') {
                out += ' && !(' + $data + ' % 1)';
              }
              out += ')) ' + $coerced + ' = +' + $data + '; ';
            } else if ($type == 'boolean') {
              out += ' else if (' + $data + ' === \'false\' || ' + $data + ' === 0 || ' + $data + ' === null) ' + $coerced + ' = false; else if (' + $data + ' === \'true\' || ' + $data + ' === 1) ' + $coerced + ' = true; ';
            } else if ($type == 'null') {
              out += ' else if (' + $data + ' === \'\' || ' + $data + ' === 0 || ' + $data + ' === false) ' + $coerced + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' else if (' + $dataType + ' == \'string\' || ' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\' || ' + $data + ' == null) ' + $coerced + ' = [' + $data + ']; ';
            }
          }
        }
        out += ' else {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + $typeSchema.join(",");
          } else {
            out += '' + $typeSchema;
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + $typeSchema.join(",");
            } else {
              out += '' + $typeSchema;
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } if (' + $coerced + ' !== undefined) {  ';
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + $data + ' = ' + $coerced + '; ';
        if (!$dataLvl) {
          out += 'if (' + $parentData + ' !== undefined)';
        }
        out += ' ' + $parentData + '[' + $parentDataProperty + '] = ' + $coerced + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + $typeSchema.join(",");
          } else {
            out += '' + $typeSchema;
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + $typeSchema.join(",");
            } else {
              out += '' + $typeSchema;
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + $lvl;
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup,
        i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey,
                  i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + $passData + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + $passData + ' === null || ' + $passData + ' === \'\' ';
                      }
                      out += ' ) ' + $passData + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + it.useDefault($sch.default) + ' ';
                      } else {
                        out += ' ' + JSON.stringify($sch.default) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch,
                  $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + $passData + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + $passData + ' === null || ' + $passData + ' === \'\' ';
                      }
                      out += ' ) ' + $passData + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + it.useDefault($sch.default) + ' ';
                      } else {
                        out += ' ' + JSON.stringify($sch.default) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule,
              i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + $code + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + $closingBraces1 + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + $typeSchema.join(",");
                  } else {
                    out += '' + $typeSchema;
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + $lvl;
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + $closingBraces2 + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';
  }
  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return true;
  }
  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
  }
  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
};

/***/ }),
/* 135 */
/***/ ((module) => {

"use strict";


var Cache = module.exports = function Cache() {
  this._cache = {};
};
Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};
Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};
Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};
Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

/***/ }),
/* 136 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var util = __webpack_require__(128);
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
module.exports = formats;
function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}
formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};
formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};
function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;
  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;
  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}
var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),
/* 137 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ruleModules = __webpack_require__(138),
  toHash = (__webpack_require__(128).toHash);
module.exports = function rules() {
  var RULES = [{
    type: 'number',
    rules: [{
      'maximum': ['exclusiveMaximum']
    }, {
      'minimum': ['exclusiveMinimum']
    }, 'multipleOf', 'format']
  }, {
    type: 'string',
    rules: ['maxLength', 'minLength', 'pattern', 'format']
  }, {
    type: 'array',
    rules: ['maxItems', 'minItems', 'items', 'contains', 'uniqueItems']
  }, {
    type: 'object',
    rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames', {
      'properties': ['additionalProperties', 'patternProperties']
    }]
  }, {
    rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if']
  }];
  var ALL = ['type', '$comment'];
  var KEYWORDS = ['$schema', '$id', 'id', '$data', '$async', 'title', 'description', 'default', 'definitions', 'examples', 'readOnly', 'writeOnly', 'contentMediaType', 'contentEncoding', 'additionalItems', 'then', 'else'];
  var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);
  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });
    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };
    if (group.type) RULES.types[group.type] = group;
  });
  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};
  return RULES;
};

/***/ }),
/* 138 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(139),
  allOf: __webpack_require__(140),
  anyOf: __webpack_require__(141),
  '$comment': __webpack_require__(142),
  const: __webpack_require__(143),
  contains: __webpack_require__(144),
  dependencies: __webpack_require__(145),
  'enum': __webpack_require__(146),
  format: __webpack_require__(147),
  'if': __webpack_require__(148),
  items: __webpack_require__(149),
  maximum: __webpack_require__(150),
  minimum: __webpack_require__(150),
  maxItems: __webpack_require__(151),
  minItems: __webpack_require__(151),
  maxLength: __webpack_require__(152),
  minLength: __webpack_require__(152),
  maxProperties: __webpack_require__(153),
  minProperties: __webpack_require__(153),
  multipleOf: __webpack_require__(154),
  not: __webpack_require__(155),
  oneOf: __webpack_require__(156),
  pattern: __webpack_require__(157),
  properties: __webpack_require__(158),
  propertyNames: __webpack_require__(159),
  required: __webpack_require__(160),
  uniqueItems: __webpack_require__(161),
  validate: __webpack_require__(134)
};

/***/ }),
/* 139 */
/***/ ((module) => {

"use strict";


module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + '$ref' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { ref: \'' + it.util.escapeQuotes($schema) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + it.util.escapeQuotes($schema) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + it.util.toQuotedString($schema) + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + $code + ' ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
      }
    } else {
      $async = $refVal.$async === true || it.async && $refVal.$async !== false;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + $refCode + '.call(this, ';
    } else {
      out += ' ' + $refCode + '( ';
    }
    out += ' ' + $data + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + it.errorPath;
    }
    var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + $parentData + ' , ' + $parentDataProperty + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + $valid + '; ';
      }
      out += ' try { await ' + __callValidate + '; ';
      if ($breakOnError) {
        out += ' ' + $valid + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + $valid + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + $valid + ') { ';
      }
    } else {
      out += ' if (!' + __callValidate + ') { if (vErrors === null) vErrors = ' + $refCode + '.errors; else vErrors = vErrors.concat(' + $refCode + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
};

/***/ }),
/* 140 */
/***/ ((module) => {

"use strict";


module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch,
      $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + $closingBraces.slice(0, -1) + ' ';
    }
  }
  return out;
};

/***/ }),
/* 141 */
/***/ ((module) => {

"use strict";


module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function ($sch) {
    return it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch,
        $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + $valid + ' = ' + $valid + ' || ' + $nextValid + '; if (!' + $valid + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'anyOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

/***/ }),
/* 142 */
/***/ ((module) => {

"use strict";


module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + $comment + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + $comment + ', ' + it.util.toQuotedString($errSchemaPath) + ', validate.root.schema);';
  }
  return out;
};

/***/ }),
/* 143 */
/***/ ((module) => {

"use strict";


module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';';
  }
  out += 'var ' + $valid + ' = equal(' + $data + ', schema' + $lvl + '); if (!' + $valid + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'const' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValue: schema' + $lvl + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 144 */
/***/ ((module) => {

"use strict";


module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $nextValid + ' = false; for (var ' + $idx + ' = 0; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }
    out += ' if (' + $nextValid + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
  } else {
    out += ' if (' + $data + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'contains' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

/***/ }),
/* 145 */
/***/ ((module) => {

"use strict";


module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    if ($property == '__proto__') continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + $errs + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + $lvl + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey,
            $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + $useData + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }
            out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + it.util.escapeQuotes($deps[0]);
            } else {
              out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
            }
            out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey,
            i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + $useData + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + it.util.escapeQuotes($deps[0]);
                } else {
                  out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                }
                out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + $nextValid + ' = true; if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }
  return out;
};

/***/ }),
/* 146 */
/***/ ((module) => {

"use strict";


module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';';
  }
  out += 'var ' + $valid + ';';
  if ($isData) {
    out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
  }
  out += '' + $valid + ' = false;for (var ' + $i + '=0; ' + $i + '<' + $vSchema + '.length; ' + $i + '++) if (equal(' + $data + ', ' + $vSchema + '[' + $i + '])) { ' + $valid + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + $valid + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'enum' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValues: schema' + $lvl + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 147 */
/***/ ((module) => {

"use strict";


module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + $format + ' = formats[' + $schemaValue + ']; var ' + $isObject + ' = typeof ' + $format + ' == \'object\' && !(' + $format + ' instanceof RegExp) && ' + $format + '.validate; var ' + $formatType + ' = ' + $isObject + ' && ' + $format + '.type || \'string\'; if (' + $isObject + ') { ';
    if (it.async) {
      out += ' var async' + $lvl + ' = ' + $format + '.async; ';
    }
    out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + $schemaValue + ' && !' + $format + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + $schemaValue + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + $format + ' && ' + $formatType + ' == \'' + $ruleType + '\' && !(typeof ' + $format + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + $lvl + ' ? await ' + $format + '(' + $data + ') : ' + $format + '(' + $data + ')) ';
    } else {
      out += ' ' + $format + '(' + $data + ') ';
    }
    out += ' : ' + $format + '.test(' + $data + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + $formatRef + '(' + $data + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + $formatRef + '(' + $data + ') ';
      } else {
        out += ' ' + $formatRef + '.test(' + $data + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'format' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { format:  ';
    if ($isData) {
      out += '' + $schemaValue;
    } else {
      out += '' + it.util.toQuotedString($schema);
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + it.util.escapeQuotes($schema);
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 148 */
/***/ ((module) => {

"use strict";


module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $errs + ' = errors; var ' + $valid + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + it.validate($it) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + $nextValid + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + $valid + ' = ' + $nextValid + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + $ifClause + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + $nextValid + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + $valid + ' = ' + $nextValid + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + $ifClause + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'if' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { failingKeyword: ' + $ifClause + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + $ifClause + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

/***/ }),
/* 149 */
/***/ ((module) => {

"use strict";


module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'additionalItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schema.length + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + $schema.length + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch,
        $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $i + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $schema.length + ') {  for (var ' + $idx + ' = ' + $schema.length + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
      } else {
        out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + $nextValid + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + $idx + ' = ' + 0 + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + $nextValid + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }
  return out;
};

/***/ }),
/* 150 */
/***/ ((module) => {

"use strict";


module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
    throw new Error($keyword + ' must be number');
  }
  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
    throw new Error($exclusiveKeyword + ' must be number or boolean');
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + $exclusive + '; var ' + $exclType + ' = typeof ' + $schemaValueExcl + '; if (' + $exclType + ' != \'boolean\' && ' + $exclType + ' != \'undefined\' && ' + $exclType + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + $exclusiveKeyword + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
    }
    out += ' ' + $exclType + ' == \'number\' ? ( (' + $exclusive + ' = ' + $schemaValue + ' === undefined || ' + $schemaValueExcl + ' ' + $op + '= ' + $schemaValue + ') ? ' + $data + ' ' + $notOp + '= ' + $schemaValueExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) : ( (' + $exclusive + ' = ' + $schemaValueExcl + ' === true) ? ' + $data + ' ' + $notOp + '= ' + $schemaValue + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { var op' + $lvl + ' = ' + $exclusive + ' ? \'' + $op + '\' : \'' + $op + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' ( ' + $schemaValue + ' === undefined || ' + $schemaExcl + ' ' + $op + '= ' + $schemaValue + ' ? ' + $data + ' ' + $notOp + '= ' + $schemaExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' || ' + $data + ' !== ' + $data + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { comparison: ' + $opExpr + ', limit: ' + $schemaValue + ', exclusive: ' + $exclusive + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + $opStr + ' ';
      if ($isData) {
        out += '\' + ' + $schemaValue;
      } else {
        out += '' + $schemaValue + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 151 */
/***/ ((module) => {

"use strict";


module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }
  out += ' ' + $data + '.length ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 152 */
/***/ ((module) => {

"use strict";


module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + $data + '.length ';
  } else {
    out += ' ucs2length(' + $data + ') ';
  }
  out += ' ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 153 */
/***/ ((module) => {

"use strict";


module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
  }
  out += ' Object.keys(' + $data + ').length ' + $op + ' ' + $schemaValue + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + $schema;
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 154 */
/***/ ((module) => {

"use strict";


module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  out += 'var division' + $lvl + ';if (';
  if ($isData) {
    out += ' ' + $schemaValue + ' !== undefined && ( typeof ' + $schemaValue + ' != \'number\' || ';
  }
  out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + $lvl + ') - division' + $lvl + ') > 1e-' + it.opts.multipleOfPrecision + ' ';
  } else {
    out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'multipleOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { multipleOf: ' + $schemaValue + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + $schemaValue;
      } else {
        out += '' + $schemaValue + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + $schema;
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 155 */
/***/ ((module) => {

"use strict";


module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + $errs + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + it.validate($it) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + $nextValid + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
};

/***/ }),
/* 156 */
/***/ ((module) => {

"use strict";


module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + $errs + ' = errors , ' + $prevValid + ' = false , ' + $valid + ' = false , ' + $passingSchemas + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch,
      $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + $nextValid + ' = true; ';
      }
      if ($i) {
        out += ' if (' + $nextValid + ' && ' + $prevValid + ') { ' + $valid + ' = false; ' + $passingSchemas + ' = [' + $passingSchemas + ', ' + $i + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + $nextValid + ') { ' + $valid + ' = ' + $prevValid + ' = true; ' + $passingSchemas + ' = ' + $i + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + $closingBraces + 'if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'oneOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { passingSchemas: ' + $passingSchemas + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

/***/ }),
/* 157 */
/***/ ((module) => {

"use strict";


module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
  }
  out += ' !' + $regexp + '.test(' + $data + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + 'pattern' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + $schemaValue;
    } else {
      out += '' + it.util.toQuotedString($schema);
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + $schemaValue + ' + \'';
      } else {
        out += '' + it.util.escapeQuotes($schema);
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + $schemaPath;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }
      out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + __err + ']); ';
    } else {
      out += ' validate.errors = [' + __err + ']; return false; ';
    }
  } else {
    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

/***/ }),
/* 158 */
/***/ ((module) => {

"use strict";


module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }
  function notProto(p) {
    return p !== '__proto__';
  }
  out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';
  if ($ownProperties) {
    out += ' var ' + $dataProperties + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
    } else {
      out += ' for (var ' + $key + ' in ' + $data + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + $lvl + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + $schemaPath + '.hasOwnProperty(' + $key + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey,
              i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + $key + ' == ' + it.util.toQuotedString($propertyKey) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty,
            $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + $lvl + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + $data + '[' + $key + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + $data + '[' + $key + ']; ';
        } else {
          out += ' ' + $nextValid + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'additionalProperties' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { additionalProperty: \'' + $additionalProperty + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + $errs + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          out += ' if (!' + $nextValid + ') { errors = ' + $errs + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + $data + '[' + $key + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + $nextValid + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey,
        i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + $nextData + ' = ' + $passData + '; ';
          }
          if ($hasDefault) {
            out += ' ' + $code + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + $useData + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
              }
              out += ') { ' + $nextValid + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + $missingProperty + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') { ' + $nextValid + ' = true; } else { ';
              } else {
                out += ' if (' + $useData + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + $code + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty,
        i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
          } else {
            out += ' for (var ' + $key + ' in ' + $data + ') { ';
          }
          out += ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + $nextValid + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }
  return out;
};

/***/ }),
/* 159 */
/***/ ((module) => {

"use strict";


module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + $errs + ' = errors;';
  if (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + $dataProperties + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
    } else {
      out += ' for (var ' + $key + ' in ' + $data + ') { ';
    }
    out += ' var startErrs' + $lvl + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
    } else {
      out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + $nextValid + ') { for (var ' + $i + '=startErrs' + $lvl + '; ' + $i + '<errors; ' + $i + '++) { vErrors[' + $i + '].propertyName = ' + $key + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'propertyNames' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { propertyName: \'' + $invalidName + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + $invalidName + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
  }
  return out;
};

/***/ }),
/* 160 */
/***/ ((module) => {

"use strict";


module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property,
          i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + $lvl + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + $valid + ' = true; ';
        if ($isData) {
          out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
        }
        out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { ' + $valid + ' = ' + $data + '[' + $vSchema + '[' + $i + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
        }
        out += '; if (!' + $valid + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + $valid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey,
            $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + $useData + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }
            out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + $vSchema + ' && !Array.isArray(' + $vSchema + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + $missingProperty + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + $vSchema + ' !== undefined) { ';
        }
        out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { if (' + $data + '[' + $vSchema + '[' + $i + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + $missingProperty + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey,
            i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + $useData + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
};

/***/ }),
/* 161 */
/***/ ((module) => {

"use strict";


module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + $valid + '; if (' + $schemaValue + ' === false || ' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'boolean\') ' + $valid + ' = false; else { ';
    }
    out += ' var i = ' + $data + '.length , ' + $valid + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || $typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0)) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + $data + '[i], ' + $data + '[j])) { ' + $valid + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + $data + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + it.util[$method]($itemType, 'item', it.opts.strictNumbers, true) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + $valid + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + $valid + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + 'uniqueItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

/***/ }),
/* 162 */
/***/ ((module) => {

"use strict";


var KEYWORDS = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum', 'maxLength', 'minLength', 'pattern', 'additionalItems', 'maxItems', 'minItems', 'uniqueItems', 'maxProperties', 'minProperties', 'required', 'additionalProperties', 'enum', 'format', 'const'];
module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i = 0; i < keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];
    for (j = 0; j < KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [schema, {
            $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
          }]
        };
      }
    }
  }
  return metaSchema;
};

/***/ }),
/* 163 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var MissingRefError = (__webpack_require__(132).MissingRef);
module.exports = compileAsync;

/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');
  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }
  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });
  if (callback) {
    p.then(function (v) {
      callback(null, v);
    }, callback);
  }
  return p;
  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema) ? compileAsync.call(self, {
      $ref: $schema
    }, true) : Promise.resolve();
  }
  function _compileAsync(schemaObj) {
    try {
      return self._compile(schemaObj);
    } catch (e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }
    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');
      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }
      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function () {
        return _compileAsync(schemaObj);
      });
      function removePromise() {
        delete self._loadingSchemas[ref];
      }
      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

/***/ }),
/* 164 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(165);
var definitionSchema = __webpack_require__(166);
module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};

/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');
  if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');
  if (definition) {
    this.validateKeyword(definition, true);
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i = 0; i < dataType.length; i++) _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }
    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [metaSchema, {
            '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#'
          }]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }
  RULES.keywords[keyword] = RULES.all[keyword] = true;
  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i = 0; i < RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }
    if (!ruleGroup) {
      ruleGroup = {
        type: dataType,
        rules: []
      };
      RULES.push(ruleGroup);
    }
    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }
  return this;
}

/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}

/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i = 0; i < RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j = 0; j < rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}

/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError) throw new Error('custom keyword definition is invalid: ' + this.errorsText(v.errors));else return false;
}

/***/ }),
/* 165 */
/***/ ((module) => {

"use strict";


module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + $definition + ' = RULES.custom[\'' + $keyword + '\'].definition; var ' + $validateCode + ' = ' + $definition + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + $ruleErrs + ' = null;';
  }
  out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + $schemaValue + ' === undefined) { ' + $valid + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + $valid + ' = ' + $definition + '.validateSchema(' + $schemaValue + '); if (' + $valid + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + $ruleValidate.validate + ' ';
    } else {
      out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + $code;
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + $validateCode + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + $data + ' ';
    } else {
      out += ' , ' + $schemaValue + ' , ' + $data + ' , validate.schema' + it.schemaPath + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + it.errorPath;
    }
    var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + $valid + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + def_callRuleValidate + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + $ruleErrs + ' = null; try { ' + $valid + ' = await ' + def_callRuleValidate + '; } catch (e) { ' + $valid + ' = false; if (e instanceof ValidationError) ' + $ruleErrs + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + $ruleErrs + ' = null; ' + $valid + ' = ' + def_callRuleValidate + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + $parentData + ') ' + $data + ' = ' + $parentData + '[' + $parentDataProperty + '];';
  }
  out += '' + $closingBraces;
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + $nextValid;
      } else {
        out += '' + $valid;
      }
    } else {
      out += ' ' + !$rDef.valid + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + def_customError + ' ';
        } else {
          out += ' if (' + $errs + ' == errors) { ' + def_customError + ' } else {  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + def_customError + ' ';
      } else {
        out += ' if (Array.isArray(' + $ruleErrs + ')) { if (vErrors === null) vErrors = ' + $ruleErrs + '; else vErrors = vErrors.concat(' + $ruleErrs + '); errors = vErrors.length;  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + ';  ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
        if (it.opts.verbose) {
          out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
        }
        out += ' } } else { ' + def_customError + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
};

/***/ }),
/* 166 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var metaSchema = __webpack_require__(167);
module.exports = {
  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: metaSchema.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {
      not: {
        required: ['macro']
      }
    }
  },
  properties: {
    type: metaSchema.properties.type,
    schema: {
      type: 'boolean'
    },
    statements: {
      type: 'boolean'
    },
    dependencies: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    metaSchema: {
      type: 'object'
    },
    modifying: {
      type: 'boolean'
    },
    valid: {
      type: 'boolean'
    },
    $data: {
      type: 'boolean'
    },
    async: {
      type: 'boolean'
    },
    errors: {
      anyOf: [{
        type: 'boolean'
      }, {
        const: 'full'
      }]
    }
  }
};

/***/ }),
/* 167 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

/***/ }),
/* 168 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

/***/ }),
/* 169 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"id":"http://json-schema.org/draft-04/schema#","$schema":"http://json-schema.org/draft-04/schema#","description":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"positiveInteger":{"type":"integer","minimum":0},"positiveIntegerDefault0":{"allOf":[{"$ref":"#/definitions/positiveInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"minItems":1,"uniqueItems":true}},"type":"object","properties":{"id":{"type":"string"},"$schema":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"multipleOf":{"type":"number","minimum":0,"exclusiveMinimum":true},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"boolean","default":false},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"boolean","default":false},"maxLength":{"$ref":"#/definitions/positiveInteger"},"minLength":{"$ref":"#/definitions/positiveIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"$ref":"#/definitions/positiveInteger"},"minItems":{"$ref":"#/definitions/positiveIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxProperties":{"$ref":"#/definitions/positiveInteger"},"minProperties":{"$ref":"#/definitions/positiveIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"enum":{"type":"array","minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"dependencies":{"exclusiveMaximum":["maximum"],"exclusiveMinimum":["minimum"]},"default":{}}');

/***/ }),
/* 170 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Defines a schema for configs.
 * @author Sylvan Mably
 */



const baseConfigProperties = {
  env: {
    type: "object"
  },
  globals: {
    type: "object"
  },
  parser: {
    type: ["string", "null"]
  },
  parserOptions: {
    type: "object"
  },
  plugins: {
    type: "array"
  },
  rules: {
    type: "object"
  },
  settings: {
    type: "object"
  },
  ecmaFeatures: {
    type: "object"
  } // deprecated; logs a warning when used
};
const overrideProperties = Object.assign({}, baseConfigProperties, {
  files: {
    oneOf: [{
      type: "string"
    }, {
      type: "array",
      items: {
        type: "string"
      },
      minItems: 1
    }]
  },
  excludedFiles: {
    oneOf: [{
      type: "string"
    }, {
      type: "array",
      items: {
        type: "string"
      }
    }]
  }
});
const topLevelConfigProperties = Object.assign({}, baseConfigProperties, {
  extends: {
    type: ["string", "array"]
  },
  root: {
    type: "boolean"
  },
  overrides: {
    type: "array",
    items: {
      type: "object",
      properties: overrideProperties,
      required: ["files"],
      additionalProperties: false
    }
  }
});
const configSchema = {
  type: "object",
  properties: topLevelConfigProperties,
  additionalProperties: false
};
module.exports = configSchema;

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(6);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(__webpack_require__.g.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__(172);
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(173);
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/***/ }),
/* 172 */
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),
/* 173 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),
/* 174 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Environments manager
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const envs = __webpack_require__(175);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

class Environments {
  /**
   * create env context
   */
  constructor() {
    this._environments = new Map();
    this.load();
  }

  /**
   * Loads the default environments.
   * @returns {void}
   * @private
   */
  load() {
    Object.keys(envs).forEach(envName => {
      this._environments.set(envName, envs[envName]);
    });
  }

  /**
   * Gets the environment with the given name.
   * @param {string} name The name of the environment to retrieve.
   * @returns {Object?} The environment object or null if not found.
   */
  get(name) {
    return this._environments.get(name) || null;
  }

  /**
   * Gets all the environment present
   * @returns {Object} The environment object for each env name
   */
  getAll() {
    return Array.from(this._environments).reduce((coll, env) => {
      coll[env[0]] = env[1];
      return coll;
    }, {});
  }

  /**
   * Defines an environment.
   * @param {string} name The name of the environment.
   * @param {Object} env The environment settings.
   * @returns {void}
   */
  define(name, env) {
    this._environments.set(name, env);
  }

  /**
   * Imports all environments from a plugin.
   * @param {Object} plugin The plugin object.
   * @param {string} pluginName The name of the plugin.
   * @returns {void}
   */
  importPlugin(plugin, pluginName) {
    if (plugin.environments) {
      Object.keys(plugin.environments).forEach(envName => {
        this.define(`${pluginName}/${envName}`, plugin.environments[envName]);
      });
    }
  }
}
module.exports = Environments;

/***/ }),
/* 175 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Defines environment settings and globals.
 * @author Elan Shanker
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const globals = __webpack_require__(176);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  builtin: {
    globals: globals.es5
  },
  browser: {
    globals: globals.browser
  },
  node: {
    globals: globals.node,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: true
      }
    }
  },
  commonjs: {
    globals: globals.commonjs,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: true
      }
    }
  },
  "shared-node-browser": {
    globals: globals["shared-node-browser"]
  },
  worker: {
    globals: globals.worker
  },
  amd: {
    globals: globals.amd
  },
  mocha: {
    globals: globals.mocha
  },
  jasmine: {
    globals: globals.jasmine
  },
  jest: {
    globals: globals.jest
  },
  phantomjs: {
    globals: globals.phantomjs
  },
  jquery: {
    globals: globals.jquery
  },
  qunit: {
    globals: globals.qunit
  },
  prototypejs: {
    globals: globals.prototypejs
  },
  shelljs: {
    globals: globals.shelljs
  },
  meteor: {
    globals: globals.meteor
  },
  mongo: {
    globals: globals.mongo
  },
  protractor: {
    globals: globals.protractor
  },
  applescript: {
    globals: globals.applescript
  },
  nashorn: {
    globals: globals.nashorn
  },
  serviceworker: {
    globals: globals.serviceworker
  },
  atomtest: {
    globals: globals.atomtest
  },
  embertest: {
    globals: globals.embertest
  },
  webextensions: {
    globals: globals.webextensions
  },
  es6: {
    globals: globals.es2015,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  greasemonkey: {
    globals: globals.greasemonkey
  }
};

/***/ }),
/* 176 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(177);

/***/ }),
/* 177 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');

/***/ }),
/* 178 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments
 * @author Teddy Katz
 */



const lodash = __webpack_require__(99);

/**
 * Compares the locations of two objects in a source file
 * @param {{line: number, column: number}} itemA The first object
 * @param {{line: number, column: number}} itemB The second object
 * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if
 * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.
 */
function compareLocations(itemA, itemB) {
  return itemA.line - itemB.line || itemA.column - itemB.column;
}

/**
 * This is the same as the exported function, except that it
 * doesn't handle disable-line and disable-next-line directives, and it always reports unused
 * disable directives.
 * @param {Object} options options for applying directives. This is the same as the options
 * for the exported function, except that `reportUnusedDisableDirectives` is not supported
 * (this function always reports unused disable directives).
 * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list
 * of filtered problems and unused eslint-disable directives
 */
function applyDirectives(options) {
  const problems = [];
  let nextDirectiveIndex = 0;
  let currentGlobalDisableDirective = null;
  const disabledRuleMap = new Map();

  // enabledRules is only used when there is a current global disable directive.
  const enabledRules = new Set();
  const usedDisableDirectives = new Set();
  for (const problem of options.problems) {
    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
      const directive = options.directives[nextDirectiveIndex++];
      switch (directive.type) {
        case "disable":
          if (directive.ruleId === null) {
            currentGlobalDisableDirective = directive;
            disabledRuleMap.clear();
            enabledRules.clear();
          } else if (currentGlobalDisableDirective) {
            enabledRules.delete(directive.ruleId);
            disabledRuleMap.set(directive.ruleId, directive);
          } else {
            disabledRuleMap.set(directive.ruleId, directive);
          }
          break;
        case "enable":
          if (directive.ruleId === null) {
            currentGlobalDisableDirective = null;
            disabledRuleMap.clear();
          } else if (currentGlobalDisableDirective) {
            enabledRules.add(directive.ruleId);
            disabledRuleMap.delete(directive.ruleId);
          } else {
            disabledRuleMap.delete(directive.ruleId);
          }
          break;

        // no default
      }
    }
    if (disabledRuleMap.has(problem.ruleId)) {
      usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
    } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {
      usedDisableDirectives.add(currentGlobalDisableDirective);
    } else {
      problems.push(problem);
    }
  }
  const unusedDisableDirectives = options.directives.filter(directive => directive.type === "disable" && !usedDisableDirectives.has(directive)).map(directive => ({
    ruleId: null,
    message: directive.ruleId ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').` : "Unused eslint-disable directive (no problems were reported).",
    line: directive.unprocessedDirective.line,
    column: directive.unprocessedDirective.column,
    severity: 2,
    nodeType: null
  }));
  return {
    problems,
    unusedDisableDirectives
  };
}

/**
 * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list
 * of reported problems, determines which problems should be reported.
 * @param {Object} options Information about directives and problems
 * @param {{
 *      type: ("disable"|"enable"|"disable-line"|"disable-next-line"),
 *      ruleId: (string|null),
 *      line: number,
 *      column: number
 * }} options.directives Directive comments found in the file, with one-based columns.
 * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable
 * comment for two different rules is represented as two directives).
 * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems
 * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.
 * @param {boolean} options.reportUnusedDisableDirectives If `true`, adds additional problems for unused directives
 * @returns {{ruleId: (string|null), line: number, column: number}[]}
 * A list of reported problems that were not disabled by the directive comments.
 */
module.exports = options => {
  const blockDirectives = options.directives.filter(directive => directive.type === "disable" || directive.type === "enable").map(directive => Object.assign({}, directive, {
    unprocessedDirective: directive
  })).sort(compareLocations);
  const lineDirectives = lodash.flatMap(options.directives, directive => {
    switch (directive.type) {
      case "disable":
      case "enable":
        return [];
      case "disable-line":
        return [{
          type: "disable",
          line: directive.line,
          column: 1,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }, {
          type: "enable",
          line: directive.line + 1,
          column: 0,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }];
      case "disable-next-line":
        return [{
          type: "disable",
          line: directive.line + 1,
          column: 1,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }, {
          type: "enable",
          line: directive.line + 2,
          column: 0,
          ruleId: directive.ruleId,
          unprocessedDirective: directive
        }];
      default:
        throw new TypeError(`Unrecognized directive type '${directive.type}'`);
    }
  }).sort(compareLocations);
  const blockDirectivesResult = applyDirectives({
    problems: options.problems,
    directives: blockDirectives
  });
  const lineDirectivesResult = applyDirectives({
    problems: blockDirectivesResult.problems,
    directives: lineDirectives
  });
  return options.reportUnusedDisableDirectives ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
};

/***/ }),
/* 179 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A variant of EventEmitter which does not give listeners information about each other
 * @author Teddy Katz
 */



//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An event emitter
 * @typedef {Object} SafeEmitter
 * @property {function(eventName: string, listenerFunc: Function): void} on Adds a listener for a given event name
 * @property {function(eventName: string, arg1?: any, arg2?: any, arg3?: any)} emit Emits an event with a given name.
 * This calls all the listeners that were listening for that name, with `arg1`, `arg2`, and `arg3` as arguments.
 * @property {function(): string[]} eventNames Gets the list of event names that have registered listeners.
 */

/**
 * Creates an object which can listen for and emit events.
 * This is similar to the EventEmitter API in Node's standard library, but it has a few differences.
 * The goal is to allow multiple modules to attach arbitrary listeners to the same emitter, without
 * letting the modules know about each other at all.
 * 1. It has no special keys like `error` and `newListener`, which would allow modules to detect when
 * another module throws an error or registers a listener.
 * 2. It calls listener functions without any `this` value. (`EventEmitter` calls listeners with a
 * `this` value of the emitter instance, which would give listeners access to other listeners.)
 * @returns {SafeEmitter} An emitter
 */
module.exports = () => {
  const listeners = Object.create(null);
  return Object.freeze({
    on(eventName, listener) {
      if (eventName in listeners) {
        listeners[eventName].push(listener);
      } else {
        listeners[eventName] = [listener];
      }
    },
    emit(eventName) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (eventName in listeners) {
        listeners[eventName].forEach(listener => listener(...args));
      }
    },
    eventNames() {
      return Object.keys(listeners);
    }
  });
};

/***/ }),
/* 180 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview The event generator for AST nodes.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const esquery = __webpack_require__(181);
const lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An object describing an AST selector
 * @typedef {Object} ASTSelector
 * @property {string} rawSelector The string that was parsed into this selector
 * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering
 * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector
 * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,
 * or `null` if all node types could cause a match
 * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector
 * @property {number} identifierCount The total number of identifier queries in this selector
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the possible types of a selector
 * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector
 * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it
 */
function getPossibleTypes(parsedSelector) {
  switch (parsedSelector.type) {
    case "identifier":
      return [parsedSelector.value];
    case "matches":
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);
        if (typesForComponents.every(Boolean)) {
          return lodash.union(...typesForComponents);
        }
        return null;
      }
    case "compound":
      {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);

        // If all of the components could match any type, then the compound could also match any type.
        if (!typesForComponents.length) {
          return null;
        }

        /*
         * If at least one of the components could only match a particular type, the compound could only match
         * the intersection of those types.
         */
        return lodash.intersection(...typesForComponents);
      }
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return getPossibleTypes(parsedSelector.right);
    default:
      return null;
  }
}

/**
 * Counts the number of class, pseudo-class, and attribute queries in this selector
 * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns {number} The number of class, pseudo-class, and attribute queries in this selector
 */
function countClassAttributes(parsedSelector) {
  switch (parsedSelector.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);
    case "compound":
    case "not":
    case "matches":
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);
    case "attribute":
    case "field":
    case "nth-child":
    case "nth-last-child":
      return 1;
    default:
      return 0;
  }
}

/**
 * Counts the number of identifier queries in this selector
 * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns {number} The number of identifier queries
 */
function countIdentifiers(parsedSelector) {
  switch (parsedSelector.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);
    case "compound":
    case "not":
    case "matches":
      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);
    case "identifier":
      return 1;
    default:
      return 0;
  }
}

/**
 * Compares the specificity of two selector objects, with CSS-like rules.
 * @param {ASTSelector} selectorA An AST selector descriptor
 * @param {ASTSelector} selectorB Another AST selector descriptor
 * @returns {number}
 * a value less than 0 if selectorA is less specific than selectorB
 * a value greater than 0 if selectorA is more specific than selectorB
 * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically
 * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically
 */
function compareSpecificity(selectorA, selectorB) {
  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
}

/**
 * Parses a raw selector string, and throws a useful error if parsing fails.
 * @param {string} rawSelector A raw AST selector
 * @returns {Object} An object (from esquery) describing the matching behavior of this selector
 * @throws {Error} An error if the selector is invalid
 */
function tryParseSelector(rawSelector) {
  try {
    return esquery.parse(rawSelector.replace(/:exit$/u, ""));
  } catch (err) {
    if (typeof err.offset === "number") {
      throw new SyntaxError(`Syntax error in selector "${rawSelector}" at position ${err.offset}: ${err.message}`);
    }
    throw err;
  }
}

/**
 * Parses a raw selector string, and returns the parsed selector along with specificity and type information.
 * @param {string} rawSelector A raw AST selector
 * @returns {ASTSelector} A selector descriptor
 */
const parseSelector = lodash.memoize(rawSelector => {
  const parsedSelector = tryParseSelector(rawSelector);
  return {
    rawSelector,
    isExit: rawSelector.endsWith(":exit"),
    parsedSelector,
    listenerTypes: getPossibleTypes(parsedSelector),
    attributeCount: countClassAttributes(parsedSelector),
    identifierCount: countIdentifiers(parsedSelector)
  };
});

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The event generator for AST nodes.
 * This implements below interface.
 *
 * ```ts
 * interface EventGenerator {
 *     emitter: SafeEmitter;
 *     enterNode(node: ASTNode): void;
 *     leaveNode(node: ASTNode): void;
 * }
 * ```
 */
class NodeEventGenerator {
  /**
   * @param {SafeEmitter} emitter
   * An SafeEmitter which is the destination of events. This emitter must already
   * have registered listeners for all of the events that it needs to listen for.
   * (See lib/util/safe-emitter.js for more details on `SafeEmitter`.)
   * @returns {NodeEventGenerator} new instance
   */
  constructor(emitter) {
    this.emitter = emitter;
    this.currentAncestry = [];
    this.enterSelectorsByNodeType = new Map();
    this.exitSelectorsByNodeType = new Map();
    this.anyTypeEnterSelectors = [];
    this.anyTypeExitSelectors = [];
    emitter.eventNames().forEach(rawSelector => {
      const selector = parseSelector(rawSelector);
      if (selector.listenerTypes) {
        selector.listenerTypes.forEach(nodeType => {
          const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
          if (!typeMap.has(nodeType)) {
            typeMap.set(nodeType, []);
          }
          typeMap.get(nodeType).push(selector);
        });
      } else {
        (selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(selector);
      }
    });
    this.anyTypeEnterSelectors.sort(compareSpecificity);
    this.anyTypeExitSelectors.sort(compareSpecificity);
    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
  }

  /**
   * Checks a selector against a node, and emits it if it matches
   * @param {ASTNode} node The node to check
   * @param {ASTSelector} selector An AST selector descriptor
   * @returns {void}
   */
  applySelector(node, selector) {
    if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {
      this.emitter.emit(selector.rawSelector, node);
    }
  }

  /**
   * Applies all appropriate selectors to a node, in specificity order
   * @param {ASTNode} node The node to check
   * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited
   * @returns {void}
   */
  applySelectors(node, isExit) {
    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;

    /*
     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.
     * Iterate through each of them, applying selectors in the right order.
     */
    let selectorsByTypeIndex = 0;
    let anyTypeSelectorsIndex = 0;
    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
      } else {
        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
      }
    }
  }

  /**
   * Emits an event of entering AST node.
   * @param {ASTNode} node - A node which was entered.
   * @returns {void}
   */
  enterNode(node) {
    if (node.parent) {
      this.currentAncestry.unshift(node.parent);
    }
    this.applySelectors(node, false);
  }

  /**
   * Emits an event of leaving AST node.
   * @param {ASTNode} node - A node which was left.
   * @returns {void}
   */
  leaveNode(node) {
    this.applySelectors(node, true);
    this.currentAncestry.shift();
  }
}
module.exports = NodeEventGenerator;

/***/ }),
/* 181 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

!function (e, t) {
   true ? module.exports = t() : 0;
}(this, function () {
  "use strict";

  function e(t) {
    return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e;
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    })(t);
  }
  function t(e, t) {
    return function (e) {
      if (Array.isArray(e)) return e;
    }(e) || function (e, t) {
      var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
      if (null != r) {
        var n,
          o,
          a,
          i,
          s = [],
          u = !0,
          l = !1;
        try {
          if (a = (r = r.call(e)).next, 0 === t) {
            if (Object(r) !== r) return;
            u = !1;
          } else for (; !(u = (n = a.call(r)).done) && (s.push(n.value), s.length !== t); u = !0);
        } catch (e) {
          l = !0, o = e;
        } finally {
          try {
            if (!u && null != r.return && (i = r.return(), Object(i) !== i)) return;
          } finally {
            if (l) throw o;
          }
        }
        return s;
      }
    }(e, t) || n(e, t) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function r(e) {
    return function (e) {
      if (Array.isArray(e)) return o(e);
    }(e) || function (e) {
      if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
    }(e) || n(e) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function n(e, t) {
    if (e) {
      if ("string" == typeof e) return o(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? o(e, t) : void 0;
    }
  }
  function o(e, t) {
    (null == t || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n;
  }
  "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self && self;
  function a(e, t) {
    return e(t = {
      exports: {}
    }, t.exports), t.exports;
  }
  var i = a(function (e, t) {
      !function e(t) {
        var r, n, o, a, i, s;
        function u(e) {
          var t,
            r,
            n = {};
          for (t in e) e.hasOwnProperty(t) && (r = e[t], n[t] = "object" == typeof r && null !== r ? u(r) : r);
          return n;
        }
        function l(e, t) {
          this.parent = e, this.key = t;
        }
        function c(e, t, r, n) {
          this.node = e, this.path = t, this.wrap = r, this.ref = n;
        }
        function f() {}
        function p(e) {
          return null != e && "object" == typeof e && "string" == typeof e.type;
        }
        function h(e, t) {
          return (e === r.ObjectExpression || e === r.ObjectPattern) && "properties" === t;
        }
        function y(e, t) {
          for (var r = e.length - 1; r >= 0; --r) if (e[r].node === t) return !0;
          return !1;
        }
        function d(e, t) {
          return new f().traverse(e, t);
        }
        function m(e, t) {
          var r;
          return r = function (e, t) {
            var r, n, o, a;
            for (n = e.length, o = 0; n;) t(e[a = o + (r = n >>> 1)]) ? n = r : (o = a + 1, n -= r + 1);
            return o;
          }(t, function (t) {
            return t.range[0] > e.range[0];
          }), e.extendedRange = [e.range[0], e.range[1]], r !== t.length && (e.extendedRange[1] = t[r].range[0]), (r -= 1) >= 0 && (e.extendedRange[0] = t[r].range[1]), e;
        }
        return r = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ChainExpression: "ChainExpression",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ComprehensionBlock: "ComprehensionBlock",
          ComprehensionExpression: "ComprehensionExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DebuggerStatement: "DebuggerStatement",
          DirectiveStatement: "DirectiveStatement",
          DoWhileStatement: "DoWhileStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForInStatement: "ForInStatement",
          ForOfStatement: "ForOfStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          GeneratorExpression: "GeneratorExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportExpression: "ImportExpression",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          ModuleSpecifier: "ModuleSpecifier",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          PrivateIdentifier: "PrivateIdentifier",
          Program: "Program",
          Property: "Property",
          PropertyDefinition: "PropertyDefinition",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          Super: "Super",
          SwitchStatement: "SwitchStatement",
          SwitchCase: "SwitchCase",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        }, o = {
          AssignmentExpression: ["left", "right"],
          AssignmentPattern: ["left", "right"],
          ArrayExpression: ["elements"],
          ArrayPattern: ["elements"],
          ArrowFunctionExpression: ["params", "body"],
          AwaitExpression: ["argument"],
          BlockStatement: ["body"],
          BinaryExpression: ["left", "right"],
          BreakStatement: ["label"],
          CallExpression: ["callee", "arguments"],
          CatchClause: ["param", "body"],
          ChainExpression: ["expression"],
          ClassBody: ["body"],
          ClassDeclaration: ["id", "superClass", "body"],
          ClassExpression: ["id", "superClass", "body"],
          ComprehensionBlock: ["left", "right"],
          ComprehensionExpression: ["blocks", "filter", "body"],
          ConditionalExpression: ["test", "consequent", "alternate"],
          ContinueStatement: ["label"],
          DebuggerStatement: [],
          DirectiveStatement: [],
          DoWhileStatement: ["body", "test"],
          EmptyStatement: [],
          ExportAllDeclaration: ["source"],
          ExportDefaultDeclaration: ["declaration"],
          ExportNamedDeclaration: ["declaration", "specifiers", "source"],
          ExportSpecifier: ["exported", "local"],
          ExpressionStatement: ["expression"],
          ForStatement: ["init", "test", "update", "body"],
          ForInStatement: ["left", "right", "body"],
          ForOfStatement: ["left", "right", "body"],
          FunctionDeclaration: ["id", "params", "body"],
          FunctionExpression: ["id", "params", "body"],
          GeneratorExpression: ["blocks", "filter", "body"],
          Identifier: [],
          IfStatement: ["test", "consequent", "alternate"],
          ImportExpression: ["source"],
          ImportDeclaration: ["specifiers", "source"],
          ImportDefaultSpecifier: ["local"],
          ImportNamespaceSpecifier: ["local"],
          ImportSpecifier: ["imported", "local"],
          Literal: [],
          LabeledStatement: ["label", "body"],
          LogicalExpression: ["left", "right"],
          MemberExpression: ["object", "property"],
          MetaProperty: ["meta", "property"],
          MethodDefinition: ["key", "value"],
          ModuleSpecifier: [],
          NewExpression: ["callee", "arguments"],
          ObjectExpression: ["properties"],
          ObjectPattern: ["properties"],
          PrivateIdentifier: [],
          Program: ["body"],
          Property: ["key", "value"],
          PropertyDefinition: ["key", "value"],
          RestElement: ["argument"],
          ReturnStatement: ["argument"],
          SequenceExpression: ["expressions"],
          SpreadElement: ["argument"],
          Super: [],
          SwitchStatement: ["discriminant", "cases"],
          SwitchCase: ["test", "consequent"],
          TaggedTemplateExpression: ["tag", "quasi"],
          TemplateElement: [],
          TemplateLiteral: ["quasis", "expressions"],
          ThisExpression: [],
          ThrowStatement: ["argument"],
          TryStatement: ["block", "handler", "finalizer"],
          UnaryExpression: ["argument"],
          UpdateExpression: ["argument"],
          VariableDeclaration: ["declarations"],
          VariableDeclarator: ["id", "init"],
          WhileStatement: ["test", "body"],
          WithStatement: ["object", "body"],
          YieldExpression: ["argument"]
        }, n = {
          Break: a = {},
          Skip: i = {},
          Remove: s = {}
        }, l.prototype.replace = function (e) {
          this.parent[this.key] = e;
        }, l.prototype.remove = function () {
          return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
        }, f.prototype.path = function () {
          var e, t, r, n, o;
          function a(e, t) {
            if (Array.isArray(t)) for (r = 0, n = t.length; r < n; ++r) e.push(t[r]);else e.push(t);
          }
          if (!this.__current.path) return null;
          for (o = [], e = 2, t = this.__leavelist.length; e < t; ++e) a(o, this.__leavelist[e].path);
          return a(o, this.__current.path), o;
        }, f.prototype.type = function () {
          return this.current().type || this.__current.wrap;
        }, f.prototype.parents = function () {
          var e, t, r;
          for (r = [], e = 1, t = this.__leavelist.length; e < t; ++e) r.push(this.__leavelist[e].node);
          return r;
        }, f.prototype.current = function () {
          return this.__current.node;
        }, f.prototype.__execute = function (e, t) {
          var r, n;
          return n = void 0, r = this.__current, this.__current = t, this.__state = null, e && (n = e.call(this, t.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r, n;
        }, f.prototype.notify = function (e) {
          this.__state = e;
        }, f.prototype.skip = function () {
          this.notify(i);
        }, f.prototype.break = function () {
          this.notify(a);
        }, f.prototype.remove = function () {
          this.notify(s);
        }, f.prototype.__initialize = function (e, t) {
          this.visitor = t, this.root = e, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, "iteration" === t.fallback ? this.__fallback = Object.keys : "function" == typeof t.fallback && (this.__fallback = t.fallback), this.__keys = o, t.keys && (this.__keys = Object.assign(Object.create(this.__keys), t.keys));
        }, f.prototype.traverse = function (e, t) {
          var r, n, o, s, u, l, f, d, m, x, v, g;
          for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, r.push(new c(e, null, null, null)), n.push(new c(null, null, null, null)); r.length;) if ((o = r.pop()) !== g) {
            if (o.node) {
              if (l = this.__execute(t.enter, o), this.__state === a || l === a) return;
              if (r.push(g), n.push(o), this.__state === i || l === i) continue;
              if (u = (s = o.node).type || o.wrap, !(x = this.__keys[u])) {
                if (!this.__fallback) throw new Error("Unknown node type " + u + ".");
                x = this.__fallback(s);
              }
              for (d = x.length; (d -= 1) >= 0;) if (v = s[f = x[d]]) if (Array.isArray(v)) {
                for (m = v.length; (m -= 1) >= 0;) if (v[m] && !y(n, v[m])) {
                  if (h(u, x[d])) o = new c(v[m], [f, m], "Property", null);else {
                    if (!p(v[m])) continue;
                    o = new c(v[m], [f, m], null, null);
                  }
                  r.push(o);
                }
              } else if (p(v)) {
                if (y(n, v)) continue;
                r.push(new c(v, f, null, null));
              }
            }
          } else if (o = n.pop(), l = this.__execute(t.leave, o), this.__state === a || l === a) return;
        }, f.prototype.replace = function (e, t) {
          var r, n, o, u, f, y, d, m, x, v, g, A, E;
          function b(e) {
            var t, n, o, a;
            if (e.ref.remove()) for (n = e.ref.key, a = e.ref.parent, t = r.length; t--;) if ((o = r[t]).ref && o.ref.parent === a) {
              if (o.ref.key < n) break;
              --o.ref.key;
            }
          }
          for (this.__initialize(e, t), g = {}, r = this.__worklist, n = this.__leavelist, y = new c(e, null, null, new l(A = {
            root: e
          }, "root")), r.push(y), n.push(y); r.length;) if ((y = r.pop()) !== g) {
            if (void 0 !== (f = this.__execute(t.enter, y)) && f !== a && f !== i && f !== s && (y.ref.replace(f), y.node = f), this.__state !== s && f !== s || (b(y), y.node = null), this.__state === a || f === a) return A.root;
            if ((o = y.node) && (r.push(g), n.push(y), this.__state !== i && f !== i)) {
              if (u = o.type || y.wrap, !(x = this.__keys[u])) {
                if (!this.__fallback) throw new Error("Unknown node type " + u + ".");
                x = this.__fallback(o);
              }
              for (d = x.length; (d -= 1) >= 0;) if (v = o[E = x[d]]) if (Array.isArray(v)) {
                for (m = v.length; (m -= 1) >= 0;) if (v[m]) {
                  if (h(u, x[d])) y = new c(v[m], [E, m], "Property", new l(v, m));else {
                    if (!p(v[m])) continue;
                    y = new c(v[m], [E, m], null, new l(v, m));
                  }
                  r.push(y);
                }
              } else p(v) && r.push(new c(v, E, null, new l(o, E)));
            }
          } else if (y = n.pop(), void 0 !== (f = this.__execute(t.leave, y)) && f !== a && f !== i && f !== s && y.ref.replace(f), this.__state !== s && f !== s || b(y), this.__state === a || f === a) return A.root;
          return A.root;
        }, t.Syntax = r, t.traverse = d, t.replace = function (e, t) {
          return new f().replace(e, t);
        }, t.attachComments = function (e, t, r) {
          var o,
            a,
            i,
            s,
            l = [];
          if (!e.range) throw new Error("attachComments needs range information");
          if (!r.length) {
            if (t.length) {
              for (i = 0, a = t.length; i < a; i += 1) (o = u(t[i])).extendedRange = [0, e.range[0]], l.push(o);
              e.leadingComments = l;
            }
            return e;
          }
          for (i = 0, a = t.length; i < a; i += 1) l.push(m(u(t[i]), r));
          return s = 0, d(e, {
            enter: function (e) {
              for (var t; s < l.length && !((t = l[s]).extendedRange[1] > e.range[0]);) t.extendedRange[1] === e.range[0] ? (e.leadingComments || (e.leadingComments = []), e.leadingComments.push(t), l.splice(s, 1)) : s += 1;
              return s === l.length ? n.Break : l[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
            }
          }), s = 0, d(e, {
            leave: function (e) {
              for (var t; s < l.length && (t = l[s], !(e.range[1] < t.extendedRange[0]));) e.range[1] === t.extendedRange[0] ? (e.trailingComments || (e.trailingComments = []), e.trailingComments.push(t), l.splice(s, 1)) : s += 1;
              return s === l.length ? n.Break : l[s].extendedRange[0] > e.range[1] ? n.Skip : void 0;
            }
          }), e;
        }, t.VisitorKeys = o, t.VisitorOption = n, t.Controller = f, t.cloneEnvironment = function () {
          return e({});
        }, t;
      }(t);
    }),
    s = a(function (e) {
      e.exports && (e.exports = function () {
        function e(t, r, n, o) {
          this.message = t, this.expected = r, this.found = n, this.location = o, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, e);
        }
        return function (e, t) {
          function r() {
            this.constructor = e;
          }
          r.prototype = t.prototype, e.prototype = new r();
        }(e, Error), e.buildMessage = function (e, t) {
          var r = {
            literal: function (e) {
              return '"' + o(e.text) + '"';
            },
            class: function (e) {
              var t,
                r = "";
              for (t = 0; t < e.parts.length; t++) r += e.parts[t] instanceof Array ? a(e.parts[t][0]) + "-" + a(e.parts[t][1]) : a(e.parts[t]);
              return "[" + (e.inverted ? "^" : "") + r + "]";
            },
            any: function (e) {
              return "any character";
            },
            end: function (e) {
              return "end of input";
            },
            other: function (e) {
              return e.description;
            }
          };
          function n(e) {
            return e.charCodeAt(0).toString(16).toUpperCase();
          }
          function o(e) {
            return e.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (e) {
              return "\\x0" + n(e);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (e) {
              return "\\x" + n(e);
            });
          }
          function a(e) {
            return e.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (e) {
              return "\\x0" + n(e);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (e) {
              return "\\x" + n(e);
            });
          }
          return "Expected " + function (e) {
            var t,
              n,
              o,
              a = new Array(e.length);
            for (t = 0; t < e.length; t++) a[t] = (o = e[t], r[o.type](o));
            if (a.sort(), a.length > 0) {
              for (t = 1, n = 1; t < a.length; t++) a[t - 1] !== a[t] && (a[n] = a[t], n++);
              a.length = n;
            }
            switch (a.length) {
              case 1:
                return a[0];
              case 2:
                return a[0] + " or " + a[1];
              default:
                return a.slice(0, -1).join(", ") + ", or " + a[a.length - 1];
            }
          }(e) + " but " + function (e) {
            return e ? '"' + o(e) + '"' : "end of input";
          }(t) + " found.";
        }, {
          SyntaxError: e,
          parse: function (t, r) {
            r = void 0 !== r ? r : {};
            var n,
              o,
              a,
              i,
              s = {},
              u = {
                start: me
              },
              l = me,
              c = fe(" ", !1),
              f = /^[^ [\],():#!=><~+.]/,
              p = pe([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], !0, !1),
              h = fe(">", !1),
              y = fe("~", !1),
              d = fe("+", !1),
              m = fe(",", !1),
              x = function (e, t) {
                return [e].concat(t.map(function (e) {
                  return e[3];
                }));
              },
              v = fe("!", !1),
              g = fe("*", !1),
              A = fe("#", !1),
              E = fe("[", !1),
              b = fe("]", !1),
              S = /^[><!]/,
              _ = pe([">", "<", "!"], !1, !1),
              C = fe("=", !1),
              w = function (e) {
                return (e || "") + "=";
              },
              P = /^[><]/,
              k = pe([">", "<"], !1, !1),
              D = fe(".", !1),
              I = function (e, t, r) {
                return {
                  type: "attribute",
                  name: e,
                  operator: t,
                  value: r
                };
              },
              j = fe('"', !1),
              T = /^[^\\"]/,
              F = pe(["\\", '"'], !0, !1),
              R = fe("\\", !1),
              O = {
                type: "any"
              },
              L = function (e, t) {
                return e + t;
              },
              M = function (e) {
                return {
                  type: "literal",
                  value: (t = e.join(""), t.replace(/\\(.)/g, function (e, t) {
                    switch (t) {
                      case "b":
                        return "\b";
                      case "f":
                        return "\f";
                      case "n":
                        return "\n";
                      case "r":
                        return "\r";
                      case "t":
                        return "\t";
                      case "v":
                        return "\v";
                      default:
                        return t;
                    }
                  }))
                };
                var t;
              },
              B = fe("'", !1),
              U = /^[^\\']/,
              K = pe(["\\", "'"], !0, !1),
              N = /^[0-9]/,
              W = pe([["0", "9"]], !1, !1),
              q = fe("type(", !1),
              V = /^[^ )]/,
              G = pe([" ", ")"], !0, !1),
              z = fe(")", !1),
              H = /^[imsu]/,
              Y = pe(["i", "m", "s", "u"], !1, !1),
              $ = fe("/", !1),
              J = /^[^\/]/,
              Q = pe(["/"], !0, !1),
              X = fe(":not(", !1),
              Z = fe(":matches(", !1),
              ee = fe(":has(", !1),
              te = fe(":first-child", !1),
              re = fe(":last-child", !1),
              ne = fe(":nth-child(", !1),
              oe = fe(":nth-last-child(", !1),
              ae = fe(":", !1),
              ie = 0,
              se = [{
                line: 1,
                column: 1
              }],
              ue = 0,
              le = [],
              ce = {};
            if ("startRule" in r) {
              if (!(r.startRule in u)) throw new Error("Can't start parsing from rule \"" + r.startRule + '".');
              l = u[r.startRule];
            }
            function fe(e, t) {
              return {
                type: "literal",
                text: e,
                ignoreCase: t
              };
            }
            function pe(e, t, r) {
              return {
                type: "class",
                parts: e,
                inverted: t,
                ignoreCase: r
              };
            }
            function he(e) {
              var r,
                n = se[e];
              if (n) return n;
              for (r = e - 1; !se[r];) r--;
              for (n = {
                line: (n = se[r]).line,
                column: n.column
              }; r < e;) 10 === t.charCodeAt(r) ? (n.line++, n.column = 1) : n.column++, r++;
              return se[e] = n, n;
            }
            function ye(e, t) {
              var r = he(e),
                n = he(t);
              return {
                start: {
                  offset: e,
                  line: r.line,
                  column: r.column
                },
                end: {
                  offset: t,
                  line: n.line,
                  column: n.column
                }
              };
            }
            function de(e) {
              ie < ue || (ie > ue && (ue = ie, le = []), le.push(e));
            }
            function me() {
              var e,
                t,
                r,
                n,
                o = 32 * ie + 0,
                a = ce[o];
              return a ? (ie = a.nextPos, a.result) : (e = ie, (t = xe()) !== s && (r = Ae()) !== s && xe() !== s ? e = t = 1 === (n = r).length ? n[0] : {
                type: "matches",
                selectors: n
              } : (ie = e, e = s), e === s && (e = ie, (t = xe()) !== s && (t = void 0), e = t), ce[o] = {
                nextPos: ie,
                result: e
              }, e);
            }
            function xe() {
              var e,
                r,
                n = 32 * ie + 1,
                o = ce[n];
              if (o) return ie = o.nextPos, o.result;
              for (e = [], 32 === t.charCodeAt(ie) ? (r = " ", ie++) : (r = s, de(c)); r !== s;) e.push(r), 32 === t.charCodeAt(ie) ? (r = " ", ie++) : (r = s, de(c));
              return ce[n] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function ve() {
              var e,
                r,
                n,
                o = 32 * ie + 2,
                a = ce[o];
              if (a) return ie = a.nextPos, a.result;
              if (r = [], f.test(t.charAt(ie)) ? (n = t.charAt(ie), ie++) : (n = s, de(p)), n !== s) for (; n !== s;) r.push(n), f.test(t.charAt(ie)) ? (n = t.charAt(ie), ie++) : (n = s, de(p));else r = s;
              return r !== s && (r = r.join("")), e = r, ce[o] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function ge() {
              var e,
                r,
                n,
                o = 32 * ie + 3,
                a = ce[o];
              return a ? (ie = a.nextPos, a.result) : (e = ie, (r = xe()) !== s ? (62 === t.charCodeAt(ie) ? (n = ">", ie++) : (n = s, de(h)), n !== s && xe() !== s ? e = r = "child" : (ie = e, e = s)) : (ie = e, e = s), e === s && (e = ie, (r = xe()) !== s ? (126 === t.charCodeAt(ie) ? (n = "~", ie++) : (n = s, de(y)), n !== s && xe() !== s ? e = r = "sibling" : (ie = e, e = s)) : (ie = e, e = s), e === s && (e = ie, (r = xe()) !== s ? (43 === t.charCodeAt(ie) ? (n = "+", ie++) : (n = s, de(d)), n !== s && xe() !== s ? e = r = "adjacent" : (ie = e, e = s)) : (ie = e, e = s), e === s && (e = ie, 32 === t.charCodeAt(ie) ? (r = " ", ie++) : (r = s, de(c)), r !== s && (n = xe()) !== s ? e = r = "descendant" : (ie = e, e = s)))), ce[o] = {
                nextPos: ie,
                result: e
              }, e);
            }
            function Ae() {
              var e,
                r,
                n,
                o,
                a,
                i,
                u,
                l,
                c = 32 * ie + 5,
                f = ce[c];
              if (f) return ie = f.nextPos, f.result;
              if (e = ie, (r = be()) !== s) {
                for (n = [], o = ie, (a = xe()) !== s ? (44 === t.charCodeAt(ie) ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = be()) !== s ? o = a = [a, i, u, l] : (ie = o, o = s)) : (ie = o, o = s); o !== s;) n.push(o), o = ie, (a = xe()) !== s ? (44 === t.charCodeAt(ie) ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = be()) !== s ? o = a = [a, i, u, l] : (ie = o, o = s)) : (ie = o, o = s);
                n !== s ? e = r = x(r, n) : (ie = e, e = s);
              } else ie = e, e = s;
              return ce[c] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function Ee() {
              var e,
                t,
                r,
                n,
                o,
                a = 32 * ie + 6,
                i = ce[a];
              return i ? (ie = i.nextPos, i.result) : (e = ie, (t = ge()) === s && (t = null), t !== s && (r = be()) !== s ? (o = r, e = t = (n = t) ? {
                type: n,
                left: {
                  type: "exactNode"
                },
                right: o
              } : o) : (ie = e, e = s), ce[a] = {
                nextPos: ie,
                result: e
              }, e);
            }
            function be() {
              var e,
                t,
                r,
                n,
                o,
                a,
                i,
                u = 32 * ie + 7,
                l = ce[u];
              if (l) return ie = l.nextPos, l.result;
              if (e = ie, (t = Se()) !== s) {
                for (r = [], n = ie, (o = ge()) !== s && (a = Se()) !== s ? n = o = [o, a] : (ie = n, n = s); n !== s;) r.push(n), n = ie, (o = ge()) !== s && (a = Se()) !== s ? n = o = [o, a] : (ie = n, n = s);
                r !== s ? (i = t, e = t = r.reduce(function (e, t) {
                  return {
                    type: t[0],
                    left: e,
                    right: t[1]
                  };
                }, i)) : (ie = e, e = s);
              } else ie = e, e = s;
              return ce[u] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function Se() {
              var e,
                r,
                n,
                o,
                a,
                i,
                u,
                l = 32 * ie + 8,
                c = ce[l];
              if (c) return ie = c.nextPos, c.result;
              if (e = ie, 33 === t.charCodeAt(ie) ? (r = "!", ie++) : (r = s, de(v)), r === s && (r = null), r !== s) {
                if (n = [], (o = _e()) !== s) for (; o !== s;) n.push(o), o = _e();else n = s;
                n !== s ? (a = r, u = 1 === (i = n).length ? i[0] : {
                  type: "compound",
                  selectors: i
                }, a && (u.subject = !0), e = r = u) : (ie = e, e = s);
              } else ie = e, e = s;
              return ce[l] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function _e() {
              var e,
                r = 32 * ie + 9,
                n = ce[r];
              return n ? (ie = n.nextPos, n.result) : ((e = function () {
                var e,
                  r,
                  n = 32 * ie + 10,
                  o = ce[n];
                return o ? (ie = o.nextPos, o.result) : (42 === t.charCodeAt(ie) ? (r = "*", ie++) : (r = s, de(g)), r !== s && (r = {
                  type: "wildcard",
                  value: r
                }), e = r, ce[n] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o = 32 * ie + 11,
                  a = ce[o];
                return a ? (ie = a.nextPos, a.result) : (e = ie, 35 === t.charCodeAt(ie) ? (r = "#", ie++) : (r = s, de(A)), r === s && (r = null), r !== s && (n = ve()) !== s ? e = r = {
                  type: "identifier",
                  value: n
                } : (ie = e, e = s), ce[o] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a = 32 * ie + 12,
                  i = ce[a];
                return i ? (ie = i.nextPos, i.result) : (e = ie, 91 === t.charCodeAt(ie) ? (r = "[", ie++) : (r = s, de(E)), r !== s && xe() !== s && (n = function () {
                  var e,
                    r,
                    n,
                    o,
                    a = 32 * ie + 16,
                    i = ce[a];
                  return i ? (ie = i.nextPos, i.result) : (e = ie, (r = Ce()) !== s && xe() !== s && (n = function () {
                    var e,
                      r,
                      n,
                      o = 32 * ie + 14,
                      a = ce[o];
                    return a ? (ie = a.nextPos, a.result) : (e = ie, 33 === t.charCodeAt(ie) ? (r = "!", ie++) : (r = s, de(v)), r === s && (r = null), r !== s ? (61 === t.charCodeAt(ie) ? (n = "=", ie++) : (n = s, de(C)), n !== s ? (r = w(r), e = r) : (ie = e, e = s)) : (ie = e, e = s), ce[o] = {
                      nextPos: ie,
                      result: e
                    }, e);
                  }()) !== s && xe() !== s ? ((o = function () {
                    var e,
                      r,
                      n,
                      o,
                      a,
                      i = 32 * ie + 20,
                      u = ce[i];
                    if (u) return ie = u.nextPos, u.result;
                    if (e = ie, "type(" === t.substr(ie, 5) ? (r = "type(", ie += 5) : (r = s, de(q)), r !== s) {
                      if (xe() !== s) {
                        if (n = [], V.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(G)), o !== s) for (; o !== s;) n.push(o), V.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(G));else n = s;
                        n !== s && (o = xe()) !== s ? (41 === t.charCodeAt(ie) ? (a = ")", ie++) : (a = s, de(z)), a !== s ? (r = {
                          type: "type",
                          value: n.join("")
                        }, e = r) : (ie = e, e = s)) : (ie = e, e = s);
                      } else ie = e, e = s;
                    } else ie = e, e = s;
                    return ce[i] = {
                      nextPos: ie,
                      result: e
                    }, e;
                  }()) === s && (o = function () {
                    var e,
                      r,
                      n,
                      o,
                      a,
                      i,
                      u = 32 * ie + 22,
                      l = ce[u];
                    if (l) return ie = l.nextPos, l.result;
                    if (e = ie, 47 === t.charCodeAt(ie) ? (r = "/", ie++) : (r = s, de($)), r !== s) {
                      if (n = [], J.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(Q)), o !== s) for (; o !== s;) n.push(o), J.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(Q));else n = s;
                      n !== s ? (47 === t.charCodeAt(ie) ? (o = "/", ie++) : (o = s, de($)), o !== s ? ((a = function () {
                        var e,
                          r,
                          n = 32 * ie + 21,
                          o = ce[n];
                        if (o) return ie = o.nextPos, o.result;
                        if (e = [], H.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(Y)), r !== s) for (; r !== s;) e.push(r), H.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(Y));else e = s;
                        return ce[n] = {
                          nextPos: ie,
                          result: e
                        }, e;
                      }()) === s && (a = null), a !== s ? (i = a, r = {
                        type: "regexp",
                        value: new RegExp(n.join(""), i ? i.join("") : "")
                      }, e = r) : (ie = e, e = s)) : (ie = e, e = s)) : (ie = e, e = s);
                    } else ie = e, e = s;
                    return ce[u] = {
                      nextPos: ie,
                      result: e
                    }, e;
                  }()), o !== s ? (r = I(r, n, o), e = r) : (ie = e, e = s)) : (ie = e, e = s), e === s && (e = ie, (r = Ce()) !== s && xe() !== s && (n = function () {
                    var e,
                      r,
                      n,
                      o = 32 * ie + 13,
                      a = ce[o];
                    return a ? (ie = a.nextPos, a.result) : (e = ie, S.test(t.charAt(ie)) ? (r = t.charAt(ie), ie++) : (r = s, de(_)), r === s && (r = null), r !== s ? (61 === t.charCodeAt(ie) ? (n = "=", ie++) : (n = s, de(C)), n !== s ? (r = w(r), e = r) : (ie = e, e = s)) : (ie = e, e = s), e === s && (P.test(t.charAt(ie)) ? (e = t.charAt(ie), ie++) : (e = s, de(k))), ce[o] = {
                      nextPos: ie,
                      result: e
                    }, e);
                  }()) !== s && xe() !== s ? ((o = function () {
                    var e,
                      r,
                      n,
                      o,
                      a,
                      i,
                      u = 32 * ie + 17,
                      l = ce[u];
                    if (l) return ie = l.nextPos, l.result;
                    if (e = ie, 34 === t.charCodeAt(ie) ? (r = '"', ie++) : (r = s, de(j)), r !== s) {
                      for (n = [], T.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(F)), o === s && (o = ie, 92 === t.charCodeAt(ie) ? (a = "\\", ie++) : (a = s, de(R)), a !== s ? (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i !== s ? (a = L(a, i), o = a) : (ie = o, o = s)) : (ie = o, o = s)); o !== s;) n.push(o), T.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(F)), o === s && (o = ie, 92 === t.charCodeAt(ie) ? (a = "\\", ie++) : (a = s, de(R)), a !== s ? (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i !== s ? (a = L(a, i), o = a) : (ie = o, o = s)) : (ie = o, o = s));
                      n !== s ? (34 === t.charCodeAt(ie) ? (o = '"', ie++) : (o = s, de(j)), o !== s ? (r = M(n), e = r) : (ie = e, e = s)) : (ie = e, e = s);
                    } else ie = e, e = s;
                    if (e === s) if (e = ie, 39 === t.charCodeAt(ie) ? (r = "'", ie++) : (r = s, de(B)), r !== s) {
                      for (n = [], U.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(K)), o === s && (o = ie, 92 === t.charCodeAt(ie) ? (a = "\\", ie++) : (a = s, de(R)), a !== s ? (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i !== s ? (a = L(a, i), o = a) : (ie = o, o = s)) : (ie = o, o = s)); o !== s;) n.push(o), U.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(K)), o === s && (o = ie, 92 === t.charCodeAt(ie) ? (a = "\\", ie++) : (a = s, de(R)), a !== s ? (t.length > ie ? (i = t.charAt(ie), ie++) : (i = s, de(O)), i !== s ? (a = L(a, i), o = a) : (ie = o, o = s)) : (ie = o, o = s));
                      n !== s ? (39 === t.charCodeAt(ie) ? (o = "'", ie++) : (o = s, de(B)), o !== s ? (r = M(n), e = r) : (ie = e, e = s)) : (ie = e, e = s);
                    } else ie = e, e = s;
                    return ce[u] = {
                      nextPos: ie,
                      result: e
                    }, e;
                  }()) === s && (o = function () {
                    var e,
                      r,
                      n,
                      o,
                      a,
                      i,
                      u,
                      l = 32 * ie + 18,
                      c = ce[l];
                    if (c) return ie = c.nextPos, c.result;
                    for (e = ie, r = ie, n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)); o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));
                    if (n !== s ? (46 === t.charCodeAt(ie) ? (o = ".", ie++) : (o = s, de(D)), o !== s ? r = n = [n, o] : (ie = r, r = s)) : (ie = r, r = s), r === s && (r = null), r !== s) {
                      if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));else n = s;
                      n !== s ? (i = n, u = (a = r) ? [].concat.apply([], a).join("") : "", r = {
                        type: "literal",
                        value: parseFloat(u + i.join(""))
                      }, e = r) : (ie = e, e = s);
                    } else ie = e, e = s;
                    return ce[l] = {
                      nextPos: ie,
                      result: e
                    }, e;
                  }()) === s && (o = function () {
                    var e,
                      t,
                      r = 32 * ie + 19,
                      n = ce[r];
                    return n ? (ie = n.nextPos, n.result) : ((t = ve()) !== s && (t = {
                      type: "literal",
                      value: t
                    }), e = t, ce[r] = {
                      nextPos: ie,
                      result: e
                    }, e);
                  }()), o !== s ? (r = I(r, n, o), e = r) : (ie = e, e = s)) : (ie = e, e = s), e === s && (e = ie, (r = Ce()) !== s && (r = {
                    type: "attribute",
                    name: r
                  }), e = r)), ce[a] = {
                    nextPos: ie,
                    result: e
                  }, e);
                }()) !== s && xe() !== s ? (93 === t.charCodeAt(ie) ? (o = "]", ie++) : (o = s, de(b)), o !== s ? e = r = n : (ie = e, e = s)) : (ie = e, e = s), ce[a] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a,
                  i,
                  u,
                  l,
                  c = 32 * ie + 23,
                  f = ce[c];
                if (f) return ie = f.nextPos, f.result;
                if (e = ie, 46 === t.charCodeAt(ie) ? (r = ".", ie++) : (r = s, de(D)), r !== s) {
                  if ((n = ve()) !== s) {
                    for (o = [], a = ie, 46 === t.charCodeAt(ie) ? (i = ".", ie++) : (i = s, de(D)), i !== s && (u = ve()) !== s ? a = i = [i, u] : (ie = a, a = s); a !== s;) o.push(a), a = ie, 46 === t.charCodeAt(ie) ? (i = ".", ie++) : (i = s, de(D)), i !== s && (u = ve()) !== s ? a = i = [i, u] : (ie = a, a = s);
                    o !== s ? (l = n, r = {
                      type: "field",
                      name: o.reduce(function (e, t) {
                        return e + t[0] + t[1];
                      }, l)
                    }, e = r) : (ie = e, e = s);
                  } else ie = e, e = s;
                } else ie = e, e = s;
                return ce[c] = {
                  nextPos: ie,
                  result: e
                }, e;
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a = 32 * ie + 24,
                  i = ce[a];
                return i ? (ie = i.nextPos, i.result) : (e = ie, ":not(" === t.substr(ie, 5) ? (r = ":not(", ie += 5) : (r = s, de(X)), r !== s && xe() !== s && (n = Ae()) !== s && xe() !== s ? (41 === t.charCodeAt(ie) ? (o = ")", ie++) : (o = s, de(z)), o !== s ? e = r = {
                  type: "not",
                  selectors: n
                } : (ie = e, e = s)) : (ie = e, e = s), ce[a] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a = 32 * ie + 25,
                  i = ce[a];
                return i ? (ie = i.nextPos, i.result) : (e = ie, ":matches(" === t.substr(ie, 9) ? (r = ":matches(", ie += 9) : (r = s, de(Z)), r !== s && xe() !== s && (n = Ae()) !== s && xe() !== s ? (41 === t.charCodeAt(ie) ? (o = ")", ie++) : (o = s, de(z)), o !== s ? e = r = {
                  type: "matches",
                  selectors: n
                } : (ie = e, e = s)) : (ie = e, e = s), ce[a] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a = 32 * ie + 26,
                  i = ce[a];
                return i ? (ie = i.nextPos, i.result) : (e = ie, ":has(" === t.substr(ie, 5) ? (r = ":has(", ie += 5) : (r = s, de(ee)), r !== s && xe() !== s && (n = function () {
                  var e,
                    r,
                    n,
                    o,
                    a,
                    i,
                    u,
                    l,
                    c = 32 * ie + 4,
                    f = ce[c];
                  if (f) return ie = f.nextPos, f.result;
                  if (e = ie, (r = Ee()) !== s) {
                    for (n = [], o = ie, (a = xe()) !== s ? (44 === t.charCodeAt(ie) ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = Ee()) !== s ? o = a = [a, i, u, l] : (ie = o, o = s)) : (ie = o, o = s); o !== s;) n.push(o), o = ie, (a = xe()) !== s ? (44 === t.charCodeAt(ie) ? (i = ",", ie++) : (i = s, de(m)), i !== s && (u = xe()) !== s && (l = Ee()) !== s ? o = a = [a, i, u, l] : (ie = o, o = s)) : (ie = o, o = s);
                    n !== s ? e = r = x(r, n) : (ie = e, e = s);
                  } else ie = e, e = s;
                  return ce[c] = {
                    nextPos: ie,
                    result: e
                  }, e;
                }()) !== s && xe() !== s ? (41 === t.charCodeAt(ie) ? (o = ")", ie++) : (o = s, de(z)), o !== s ? e = r = {
                  type: "has",
                  selectors: n
                } : (ie = e, e = s)) : (ie = e, e = s), ce[a] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n = 32 * ie + 27,
                  o = ce[n];
                return o ? (ie = o.nextPos, o.result) : (":first-child" === t.substr(ie, 12) ? (r = ":first-child", ie += 12) : (r = s, de(te)), r !== s && (r = we(1)), e = r, ce[n] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n = 32 * ie + 28,
                  o = ce[n];
                return o ? (ie = o.nextPos, o.result) : (":last-child" === t.substr(ie, 11) ? (r = ":last-child", ie += 11) : (r = s, de(re)), r !== s && (r = Pe(1)), e = r, ce[n] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a,
                  i = 32 * ie + 29,
                  u = ce[i];
                if (u) return ie = u.nextPos, u.result;
                if (e = ie, ":nth-child(" === t.substr(ie, 11) ? (r = ":nth-child(", ie += 11) : (r = s, de(ne)), r !== s) {
                  if (xe() !== s) {
                    if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));else n = s;
                    n !== s && (o = xe()) !== s ? (41 === t.charCodeAt(ie) ? (a = ")", ie++) : (a = s, de(z)), a !== s ? (r = we(parseInt(n.join(""), 10)), e = r) : (ie = e, e = s)) : (ie = e, e = s);
                  } else ie = e, e = s;
                } else ie = e, e = s;
                return ce[i] = {
                  nextPos: ie,
                  result: e
                }, e;
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o,
                  a,
                  i = 32 * ie + 30,
                  u = ce[i];
                if (u) return ie = u.nextPos, u.result;
                if (e = ie, ":nth-last-child(" === t.substr(ie, 16) ? (r = ":nth-last-child(", ie += 16) : (r = s, de(oe)), r !== s) {
                  if (xe() !== s) {
                    if (n = [], N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W)), o !== s) for (; o !== s;) n.push(o), N.test(t.charAt(ie)) ? (o = t.charAt(ie), ie++) : (o = s, de(W));else n = s;
                    n !== s && (o = xe()) !== s ? (41 === t.charCodeAt(ie) ? (a = ")", ie++) : (a = s, de(z)), a !== s ? (r = Pe(parseInt(n.join(""), 10)), e = r) : (ie = e, e = s)) : (ie = e, e = s);
                  } else ie = e, e = s;
                } else ie = e, e = s;
                return ce[i] = {
                  nextPos: ie,
                  result: e
                }, e;
              }()) === s && (e = function () {
                var e,
                  r,
                  n,
                  o = 32 * ie + 31,
                  a = ce[o];
                return a ? (ie = a.nextPos, a.result) : (e = ie, 58 === t.charCodeAt(ie) ? (r = ":", ie++) : (r = s, de(ae)), r !== s && (n = ve()) !== s ? e = r = {
                  type: "class",
                  name: n
                } : (ie = e, e = s), ce[o] = {
                  nextPos: ie,
                  result: e
                }, e);
              }()), ce[r] = {
                nextPos: ie,
                result: e
              }, e);
            }
            function Ce() {
              var e,
                r,
                n,
                o,
                a,
                i,
                u,
                l,
                c = 32 * ie + 15,
                f = ce[c];
              if (f) return ie = f.nextPos, f.result;
              if (e = ie, (r = ve()) !== s) {
                for (n = [], o = ie, 46 === t.charCodeAt(ie) ? (a = ".", ie++) : (a = s, de(D)), a !== s && (i = ve()) !== s ? o = a = [a, i] : (ie = o, o = s); o !== s;) n.push(o), o = ie, 46 === t.charCodeAt(ie) ? (a = ".", ie++) : (a = s, de(D)), a !== s && (i = ve()) !== s ? o = a = [a, i] : (ie = o, o = s);
                n !== s ? (u = r, l = n, e = r = [].concat.apply([u], l).join("")) : (ie = e, e = s);
              } else ie = e, e = s;
              return ce[c] = {
                nextPos: ie,
                result: e
              }, e;
            }
            function we(e) {
              return {
                type: "nth-child",
                index: {
                  type: "literal",
                  value: e
                }
              };
            }
            function Pe(e) {
              return {
                type: "nth-last-child",
                index: {
                  type: "literal",
                  value: e
                }
              };
            }
            if ((n = l()) !== s && ie === t.length) return n;
            throw n !== s && ie < t.length && de({
              type: "end"
            }), o = le, a = ue < t.length ? t.charAt(ue) : null, i = ue < t.length ? ye(ue, ue + 1) : ye(ue, ue), new e(e.buildMessage(o, a), o, a, i);
          }
        };
      }());
    });
  function u(e, t) {
    for (var r = 0; r < t.length; ++r) {
      if (null == e) return e;
      e = e[t[r]];
    }
    return e;
  }
  var l = "function" == typeof WeakMap ? new WeakMap() : null;
  function c(e) {
    if (null == e) return function () {
      return !0;
    };
    if (null != l) {
      var t = l.get(e);
      return null != t || (t = f(e), l.set(e, t)), t;
    }
    return f(e);
  }
  function f(t) {
    switch (t.type) {
      case "wildcard":
        return function () {
          return !0;
        };
      case "identifier":
        var r = t.value.toLowerCase();
        return function (e, t, n) {
          var o = n && n.nodeTypeKey || "type";
          return r === e[o].toLowerCase();
        };
      case "exactNode":
        return function (e, t) {
          return 0 === t.length;
        };
      case "field":
        var n = t.name.split(".");
        return function (e, t) {
          return function e(t, r, n, o) {
            for (var a = r, i = o; i < n.length; ++i) {
              if (null == a) return !1;
              var s = a[n[i]];
              if (Array.isArray(s)) {
                for (var u = 0; u < s.length; ++u) if (e(t, s[u], n, i + 1)) return !0;
                return !1;
              }
              a = s;
            }
            return t === a;
          }(e, t[n.length - 1], n, 0);
        };
      case "matches":
        var o = t.selectors.map(c);
        return function (e, t, r) {
          for (var n = 0; n < o.length; ++n) if (o[n](e, t, r)) return !0;
          return !1;
        };
      case "compound":
        var a = t.selectors.map(c);
        return function (e, t, r) {
          for (var n = 0; n < a.length; ++n) if (!a[n](e, t, r)) return !1;
          return !0;
        };
      case "not":
        var s = t.selectors.map(c);
        return function (e, t, r) {
          for (var n = 0; n < s.length; ++n) if (s[n](e, t, r)) return !1;
          return !0;
        };
      case "has":
        var l = t.selectors.map(c);
        return function (e, t, r) {
          var n = !1,
            o = [];
          return i.traverse(e, {
            enter: function (e, t) {
              null != t && o.unshift(t);
              for (var a = 0; a < l.length; ++a) if (l[a](e, o, r)) return n = !0, void this.break();
            },
            leave: function () {
              o.shift();
            },
            keys: r && r.visitorKeys,
            fallback: r && r.fallback || "iteration"
          }), n;
        };
      case "child":
        var f = c(t.left),
          p = c(t.right);
        return function (e, t, r) {
          return !!(t.length > 0 && p(e, t, r)) && f(t[0], t.slice(1), r);
        };
      case "descendant":
        var h = c(t.left),
          x = c(t.right);
        return function (e, t, r) {
          if (x(e, t, r)) for (var n = 0, o = t.length; n < o; ++n) if (h(t[n], t.slice(n + 1), r)) return !0;
          return !1;
        };
      case "attribute":
        var v = t.name.split(".");
        switch (t.operator) {
          case void 0:
            return function (e) {
              return null != u(e, v);
            };
          case "=":
            switch (t.value.type) {
              case "regexp":
                return function (e) {
                  var r = u(e, v);
                  return "string" == typeof r && t.value.value.test(r);
                };
              case "literal":
                var g = "".concat(t.value.value);
                return function (e) {
                  return g === "".concat(u(e, v));
                };
              case "type":
                return function (r) {
                  return t.value.value === e(u(r, v));
                };
            }
            throw new Error("Unknown selector value type: ".concat(t.value.type));
          case "!=":
            switch (t.value.type) {
              case "regexp":
                return function (e) {
                  return !t.value.value.test(u(e, v));
                };
              case "literal":
                var A = "".concat(t.value.value);
                return function (e) {
                  return A !== "".concat(u(e, v));
                };
              case "type":
                return function (r) {
                  return t.value.value !== e(u(r, v));
                };
            }
            throw new Error("Unknown selector value type: ".concat(t.value.type));
          case "<=":
            return function (e) {
              return u(e, v) <= t.value.value;
            };
          case "<":
            return function (e) {
              return u(e, v) < t.value.value;
            };
          case ">":
            return function (e) {
              return u(e, v) > t.value.value;
            };
          case ">=":
            return function (e) {
              return u(e, v) >= t.value.value;
            };
        }
        throw new Error("Unknown operator: ".concat(t.operator));
      case "sibling":
        var E = c(t.left),
          b = c(t.right);
        return function (e, r, n) {
          return b(e, r, n) && y(e, E, r, "LEFT_SIDE", n) || t.left.subject && E(e, r, n) && y(e, b, r, "RIGHT_SIDE", n);
        };
      case "adjacent":
        var S = c(t.left),
          _ = c(t.right);
        return function (e, r, n) {
          return _(e, r, n) && d(e, S, r, "LEFT_SIDE", n) || t.right.subject && S(e, r, n) && d(e, _, r, "RIGHT_SIDE", n);
        };
      case "nth-child":
        var C = t.index.value,
          w = c(t.right);
        return function (e, t, r) {
          return w(e, t, r) && m(e, t, C, r);
        };
      case "nth-last-child":
        var P = -t.index.value,
          k = c(t.right);
        return function (e, t, r) {
          return k(e, t, r) && m(e, t, P, r);
        };
      case "class":
        var D = t.name.toLowerCase();
        return function (e, r, n) {
          if (n && n.matchClass) return n.matchClass(t.name, e, r);
          if (n && n.nodeTypeKey) return !1;
          switch (D) {
            case "statement":
              if ("Statement" === e.type.slice(-9)) return !0;
            case "declaration":
              return "Declaration" === e.type.slice(-11);
            case "pattern":
              if ("Pattern" === e.type.slice(-7)) return !0;
            case "expression":
              return "Expression" === e.type.slice(-10) || "Literal" === e.type.slice(-7) || "Identifier" === e.type && (0 === r.length || "MetaProperty" !== r[0].type) || "MetaProperty" === e.type;
            case "function":
              return "FunctionDeclaration" === e.type || "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type;
          }
          throw new Error("Unknown class name: ".concat(t.name));
        };
    }
    throw new Error("Unknown selector type: ".concat(t.type));
  }
  function p(e, t) {
    var r = t && t.nodeTypeKey || "type",
      n = e[r];
    return t && t.visitorKeys && t.visitorKeys[n] ? t.visitorKeys[n] : i.VisitorKeys[n] ? i.VisitorKeys[n] : t && "function" == typeof t.fallback ? t.fallback(e) : Object.keys(e).filter(function (e) {
      return e !== r;
    });
  }
  function h(t, r) {
    var n = r && r.nodeTypeKey || "type";
    return null !== t && "object" === e(t) && "string" == typeof t[n];
  }
  function y(e, r, n, o, a) {
    var i = t(n, 1)[0];
    if (!i) return !1;
    for (var s = p(i, a), u = 0; u < s.length; ++u) {
      var l = i[s[u]];
      if (Array.isArray(l)) {
        var c = l.indexOf(e);
        if (c < 0) continue;
        var f = void 0,
          y = void 0;
        "LEFT_SIDE" === o ? (f = 0, y = c) : (f = c + 1, y = l.length);
        for (var d = f; d < y; ++d) if (h(l[d], a) && r(l[d], n, a)) return !0;
      }
    }
    return !1;
  }
  function d(e, r, n, o, a) {
    var i = t(n, 1)[0];
    if (!i) return !1;
    for (var s = p(i, a), u = 0; u < s.length; ++u) {
      var l = i[s[u]];
      if (Array.isArray(l)) {
        var c = l.indexOf(e);
        if (c < 0) continue;
        if ("LEFT_SIDE" === o && c > 0 && h(l[c - 1], a) && r(l[c - 1], n, a)) return !0;
        if ("RIGHT_SIDE" === o && c < l.length - 1 && h(l[c + 1], a) && r(l[c + 1], n, a)) return !0;
      }
    }
    return !1;
  }
  function m(e, r, n, o) {
    if (0 === n) return !1;
    var a = t(r, 1)[0];
    if (!a) return !1;
    for (var i = p(a, o), s = 0; s < i.length; ++s) {
      var u = a[i[s]];
      if (Array.isArray(u)) {
        var l = n < 0 ? u.length + n : n - 1;
        if (l >= 0 && l < u.length && u[l] === e) return !0;
      }
    }
    return !1;
  }
  function x(t, n, o, a) {
    if (n) {
      var s = [],
        u = c(n),
        l = function t(n, o) {
          if (null == n || "object" != e(n)) return [];
          null == o && (o = n);
          for (var a = n.subject ? [o] : [], i = Object.keys(n), s = 0; s < i.length; ++s) {
            var u = i[s],
              l = n[u];
            a.push.apply(a, r(t(l, "left" === u ? l : o)));
          }
          return a;
        }(n).map(c);
      i.traverse(t, {
        enter: function (e, t) {
          if (null != t && s.unshift(t), u(e, s, a)) if (l.length) for (var r = 0, n = l.length; r < n; ++r) {
            l[r](e, s, a) && o(e, t, s);
            for (var i = 0, c = s.length; i < c; ++i) {
              var f = s.slice(i + 1);
              l[r](s[i], f, a) && o(s[i], t, f);
            }
          } else o(e, t, s);
        },
        leave: function () {
          s.shift();
        },
        keys: a && a.visitorKeys,
        fallback: a && a.fallback || "iteration"
      });
    }
  }
  function v(e, t, r) {
    var n = [];
    return x(e, t, function (e) {
      n.push(e);
    }, r), n;
  }
  function g(e) {
    return s.parse(e);
  }
  function A(e, t, r) {
    return v(e, g(t), r);
  }
  return A.parse = g, A.match = v, A.traverse = x, A.matches = function (e, t, r, n) {
    return !t || !!e && (r || (r = []), c(t)(e, r, n));
  }, A.query = A, A;
});

/***/ }),
/* 182 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Abstraction of JavaScript source code.
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const TokenStore = __webpack_require__(183),
  Traverser = __webpack_require__(196),
  astUtils = __webpack_require__(110),
  lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

/**
 * Validates that the given AST has the required information.
 * @param {ASTNode} ast The Program node of the AST to check.
 * @throws {Error} If the AST doesn't contain the correct information.
 * @returns {void}
 * @private
 */
function validate(ast) {
  if (!ast.tokens) {
    throw new Error("AST is missing the tokens array.");
  }
  if (!ast.comments) {
    throw new Error("AST is missing the comments array.");
  }
  if (!ast.loc) {
    throw new Error("AST is missing location information.");
  }
  if (!ast.range) {
    throw new Error("AST is missing range information");
  }
}

/**
 * Check to see if its a ES6 export declaration.
 * @param {ASTNode} astNode An AST node.
 * @returns {boolean} whether the given node represents an export declaration.
 * @private
 */
function looksLikeExport(astNode) {
  return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}

/**
 * Merges two sorted lists into a larger sorted list in O(n) time.
 * @param {Token[]} tokens The list of tokens.
 * @param {Token[]} comments The list of comments.
 * @returns {Token[]} A sorted list of tokens and comments.
 * @private
 */
function sortedMerge(tokens, comments) {
  const result = [];
  let tokenIndex = 0;
  let commentIndex = 0;
  while (tokenIndex < tokens.length || commentIndex < comments.length) {
    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
      result.push(tokens[tokenIndex++]);
    } else {
      result.push(comments[commentIndex++]);
    }
  }
  return result;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

class SourceCode extends TokenStore {
  /**
   * Represents parsed source code.
   * @param {string|Object} textOrConfig - The source code text or config object.
   * @param {string} textOrConfig.text - The source code text.
   * @param {ASTNode} textOrConfig.ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
   * @param {Object|null} textOrConfig.parserServices - The parser services.
   * @param {ScopeManager|null} textOrConfig.scopeManager - The scope of this source code.
   * @param {Object|null} textOrConfig.visitorKeys - The visitor keys to traverse AST.
   * @param {ASTNode} [astIfNoConfig] - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
   * @constructor
   */
  constructor(textOrConfig, astIfNoConfig) {
    let text, ast, parserServices, scopeManager, visitorKeys;

    // Process overloading.
    if (typeof textOrConfig === "string") {
      text = textOrConfig;
      ast = astIfNoConfig;
    } else if (typeof textOrConfig === "object" && textOrConfig !== null) {
      text = textOrConfig.text;
      ast = textOrConfig.ast;
      parserServices = textOrConfig.parserServices;
      scopeManager = textOrConfig.scopeManager;
      visitorKeys = textOrConfig.visitorKeys;
    }
    validate(ast);
    super(ast.tokens, ast.comments);

    /**
     * The flag to indicate that the source code has Unicode BOM.
     * @type boolean
     */
    this.hasBOM = text.charCodeAt(0) === 0xFEFF;

    /**
     * The original text source code.
     * BOM was stripped from this text.
     * @type string
     */
    this.text = this.hasBOM ? text.slice(1) : text;

    /**
     * The parsed AST for the source code.
     * @type ASTNode
     */
    this.ast = ast;

    /**
     * The parser services of this source code.
     * @type {Object}
     */
    this.parserServices = parserServices || {};

    /**
     * The scope of this source code.
     * @type {ScopeManager|null}
     */
    this.scopeManager = scopeManager || null;

    /**
     * The visitor keys to traverse AST.
     * @type {Object}
     */
    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;

    // Check the source text for the presence of a shebang since it is parsed as a standard line comment.
    const shebangMatched = this.text.match(astUtils.SHEBANG_MATCHER);
    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];
    if (hasShebang) {
      ast.comments[0].type = "Shebang";
    }
    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

    /**
     * The source code split into lines according to ECMA-262 specification.
     * This is done to avoid each rule needing to do so separately.
     * @type string[]
     */
    this.lines = [];
    this.lineStartIndices = [0];
    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
    let match;

    /*
     * Previously, this was implemented using a regex that
     * matched a sequence of non-linebreak characters followed by a
     * linebreak, then adding the lengths of the matches. However,
     * this caused a catastrophic backtracking issue when the end
     * of a file contained a large number of non-newline characters.
     * To avoid this, the current implementation just matches newlines
     * and uses match.index to get the correct line start indices.
     */
    while (match = lineEndingPattern.exec(this.text)) {
      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
      this.lineStartIndices.push(match.index + match[0].length);
    }
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

    // Cache for comments found using getComments().
    this._commentCache = new WeakMap();

    // don't allow modification of this object
    Object.freeze(this);
    Object.freeze(this.lines);
  }

  /**
   * Split the source code into multiple lines based on the line delimiters.
   * @param {string} text Source code as a string.
   * @returns {string[]} Array of source code lines.
   * @public
   */
  static splitLines(text) {
    return text.split(astUtils.createGlobalLinebreakMatcher());
  }

  /**
   * Gets the source code for the given node.
   * @param {ASTNode=} node The AST node to get the text for.
   * @param {int=} beforeCount The number of characters before the node to retrieve.
   * @param {int=} afterCount The number of characters after the node to retrieve.
   * @returns {string} The text representing the AST node.
   * @public
   */
  getText(node, beforeCount, afterCount) {
    if (node) {
      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));
    }
    return this.text;
  }

  /**
   * Gets the entire source text split into an array of lines.
   * @returns {Array} The source text as an array of lines.
   * @public
   */
  getLines() {
    return this.lines;
  }

  /**
   * Retrieves an array containing all comments in the source code.
   * @returns {ASTNode[]} An array of comment nodes.
   * @public
   */
  getAllComments() {
    return this.ast.comments;
  }

  /**
   * Gets all comments for the given node.
   * @param {ASTNode} node The AST node to get the comments for.
   * @returns {Object} An object containing a leading and trailing array
   *      of comments indexed by their position.
   * @public
   */
  getComments(node) {
    if (this._commentCache.has(node)) {
      return this._commentCache.get(node);
    }
    const comments = {
      leading: [],
      trailing: []
    };

    /*
     * Return all comments as leading comments of the Program node when
     * there is no executable code.
     */
    if (node.type === "Program") {
      if (node.body.length === 0) {
        comments.leading = node.comments;
      }
    } else {
      /*
       * Return comments as trailing comments of nodes that only contain
       * comments (to mimic the comment attachment behavior present in Espree).
       */
      if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
        comments.trailing = this.getTokens(node, {
          includeComments: true,
          filter: astUtils.isCommentToken
        });
      }

      /*
       * Iterate over tokens before and after node and collect comment tokens.
       * Do not include comments that exist outside of the parent node
       * to avoid duplication.
       */
      let currentToken = this.getTokenBefore(node, {
        includeComments: true
      });
      while (currentToken && astUtils.isCommentToken(currentToken)) {
        if (node.parent && currentToken.start < node.parent.start) {
          break;
        }
        comments.leading.push(currentToken);
        currentToken = this.getTokenBefore(currentToken, {
          includeComments: true
        });
      }
      comments.leading.reverse();
      currentToken = this.getTokenAfter(node, {
        includeComments: true
      });
      while (currentToken && astUtils.isCommentToken(currentToken)) {
        if (node.parent && currentToken.end > node.parent.end) {
          break;
        }
        comments.trailing.push(currentToken);
        currentToken = this.getTokenAfter(currentToken, {
          includeComments: true
        });
      }
    }
    this._commentCache.set(node, comments);
    return comments;
  }

  /**
   * Retrieves the JSDoc comment for a given node.
   * @param {ASTNode} node The AST node to get the comment for.
   * @returns {Token|null} The Block comment token containing the JSDoc comment
   *      for the given node or null if not found.
   * @public
   * @deprecated
   */
  getJSDocComment(node) {
    /**
     * Checks for the presence of a JSDoc comment for the given node and returns it.
     * @param {ASTNode} astNode The AST node to get the comment for.
     * @returns {Token|null} The Block comment token containing the JSDoc comment
     *      for the given node or null if not found.
     * @private
     */
    const findJSDocComment = astNode => {
      const tokenBefore = this.getTokenBefore(astNode, {
        includeComments: true
      });
      if (tokenBefore && astUtils.isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
        return tokenBefore;
      }
      return null;
    };
    let parent = node.parent;
    switch (node.type) {
      case "ClassDeclaration":
      case "FunctionDeclaration":
        return findJSDocComment(looksLikeExport(parent) ? parent : node);
      case "ClassExpression":
        return findJSDocComment(parent.parent);
      case "ArrowFunctionExpression":
      case "FunctionExpression":
        if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
            parent = parent.parent;
            if (!parent) {
              break;
            }
          }
          if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
            return findJSDocComment(parent);
          }
        }
        return findJSDocComment(node);

      // falls through
      default:
        return null;
    }
  }

  /**
   * Gets the deepest node containing a range index.
   * @param {int} index Range index of the desired node.
   * @returns {ASTNode} The node if found or null if not found.
   * @public
   */
  getNodeByRangeIndex(index) {
    let result = null;
    Traverser.traverse(this.ast, {
      visitorKeys: this.visitorKeys,
      enter(node) {
        if (node.range[0] <= index && index < node.range[1]) {
          result = node;
        } else {
          this.skip();
        }
      },
      leave(node) {
        if (node === result) {
          this.break();
        }
      }
    });
    return result;
  }

  /**
   * Determines if two tokens have at least one whitespace character
   * between them. This completely disregards comments in making the
   * determination, so comments count as zero-length substrings.
   * @param {Token} first The token to check after.
   * @param {Token} second The token to check before.
   * @returns {boolean} True if there is only space between tokens, false
   *  if there is anything other than whitespace between tokens.
   * @public
   */
  isSpaceBetweenTokens(first, second) {
    const text = this.text.slice(first.range[1], second.range[0]);
    return /\s/u.test(text.replace(/\/\*.*?\*\//gu, ""));
  }

  /**
   * Converts a source text index into a (line, column) pair.
   * @param {number} index The index of a character in a file
   * @returns {Object} A {line, column} location object with a 0-indexed column
   * @public
   */
  getLocFromIndex(index) {
    if (typeof index !== "number") {
      throw new TypeError("Expected `index` to be a number.");
    }
    if (index < 0 || index > this.text.length) {
      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
    }

    /*
     * For an argument of this.text.length, return the location one "spot" past the last character
     * of the file. If the last character is a linebreak, the location will be column 0 of the next
     * line; otherwise, the location will be in the next column on the same line.
     *
     * See getIndexFromLoc for the motivation for this special case.
     */
    if (index === this.text.length) {
      return {
        line: this.lines.length,
        column: this.lines[this.lines.length - 1].length
      };
    }

    /*
     * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could
     * be inserted into lineIndices to keep the list sorted.
     */
    const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);
    return {
      line: lineNumber,
      column: index - this.lineStartIndices[lineNumber - 1]
    };
  }

  /**
   * Converts a (line, column) pair into a range index.
   * @param {Object} loc A line/column location
   * @param {number} loc.line The line number of the location (1-indexed)
   * @param {number} loc.column The column number of the location (0-indexed)
   * @returns {number} The range index of the location in the file.
   * @public
   */
  getIndexFromLoc(loc) {
    if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
      throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
    }
    if (loc.line <= 0) {
      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
    }
    if (loc.line > this.lineStartIndices.length) {
      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);
    }
    const lineStartIndex = this.lineStartIndices[loc.line - 1];
    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
    const positionIndex = lineStartIndex + loc.column;

    /*
     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of
     * the given line, provided that the line number is valid element of this.lines. Since the
     * last element of this.lines is an empty string for files with trailing newlines, add a
     * special case where getting the index for the first location after the end of the file
     * will return the length of the file, rather than throwing an error. This allows rules to
     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.
     */
    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);
    }
    return positionIndex;
  }
}
module.exports = SourceCode;

/***/ }),
/* 183 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Object to handle access and retrieval of tokens.
 * @author Brandon Mills
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const assert = __webpack_require__(3);
const cursors = __webpack_require__(184);
const ForwardTokenCursor = __webpack_require__(192);
const PaddedTokenCursor = __webpack_require__(195);
const utils = __webpack_require__(187);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const TOKENS = Symbol("tokens");
const COMMENTS = Symbol("comments");
const INDEX_MAP = Symbol("indexMap");

/**
 * Creates the map from locations to indices in `tokens`.
 *
 * The first/last location of tokens is mapped to the index of the token.
 * The first/last location of comments is mapped to the index of the next token of each comment.
 *
 * @param {Token[]} tokens - The array of tokens.
 * @param {Comment[]} comments - The array of comments.
 * @returns {Object} The map from locations to indices in `tokens`.
 * @private
 */
function createIndexMap(tokens, comments) {
  const map = Object.create(null);
  let tokenIndex = 0;
  let commentIndex = 0;
  let nextStart = 0;
  let range = null;
  while (tokenIndex < tokens.length || commentIndex < comments.length) {
    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
      map[range[0]] = tokenIndex;
      map[range[1] - 1] = tokenIndex;
      tokenIndex += 1;
    }
    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
      map[range[0]] = tokenIndex;
      map[range[1] - 1] = tokenIndex;
      commentIndex += 1;
    }
  }
  return map;
}

/**
 * Creates the cursor iterates tokens with options.
 *
 * @param {CursorFactory} factory - The cursor factory to initialize cursor.
 * @param {Token[]} tokens - The array of tokens.
 * @param {Comment[]} comments - The array of comments.
 * @param {Object} indexMap - The map from locations to indices in `tokens`.
 * @param {number} startLoc - The start location of the iteration range.
 * @param {number} endLoc - The end location of the iteration range.
 * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.
 * @param {boolean} [opts.includeComments=false] - The flag to iterate comments as well.
 * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
 * @param {number} [opts.skip=0] - The count of tokens the cursor skips.
 * @returns {Cursor} The created cursor.
 * @private
 */
function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
  let includeComments = false;
  let skip = 0;
  let filter = null;
  if (typeof opts === "number") {
    skip = opts | 0;
  } else if (typeof opts === "function") {
    filter = opts;
  } else if (opts) {
    includeComments = !!opts.includeComments;
    skip = opts.skip | 0;
    filter = opts.filter || null;
  }
  assert(skip >= 0, "options.skip should be zero or a positive integer.");
  assert(!filter || typeof filter === "function", "options.filter should be a function.");
  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
}

/**
 * Creates the cursor iterates tokens with options.
 *
 * @param {CursorFactory} factory - The cursor factory to initialize cursor.
 * @param {Token[]} tokens - The array of tokens.
 * @param {Comment[]} comments - The array of comments.
 * @param {Object} indexMap - The map from locations to indices in `tokens`.
 * @param {number} startLoc - The start location of the iteration range.
 * @param {number} endLoc - The end location of the iteration range.
 * @param {number|Function|Object} [opts=0] - The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.
 * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.
 * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
 * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
 * @returns {Cursor} The created cursor.
 * @private
 */
function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
  let includeComments = false;
  let count = 0;
  let countExists = false;
  let filter = null;
  if (typeof opts === "number") {
    count = opts | 0;
    countExists = true;
  } else if (typeof opts === "function") {
    filter = opts;
  } else if (opts) {
    includeComments = !!opts.includeComments;
    count = opts.count | 0;
    countExists = typeof opts.count === "number";
    filter = opts.filter || null;
  }
  assert(count >= 0, "options.count should be zero or a positive integer.");
  assert(!filter || typeof filter === "function", "options.filter should be a function.");
  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
}

/**
 * Creates the cursor iterates tokens with options.
 * This is overload function of the below.
 *
 * @param {Token[]} tokens - The array of tokens.
 * @param {Comment[]} comments - The array of comments.
 * @param {Object} indexMap - The map from locations to indices in `tokens`.
 * @param {number} startLoc - The start location of the iteration range.
 * @param {number} endLoc - The end location of the iteration range.
 * @param {Function|Object} opts - The option object. If this is a function then it's `opts.filter`.
 * @param {boolean} [opts.includeComments] - The flag to iterate comments as well.
 * @param {Function|null} [opts.filter=null] - The predicate function to choose tokens.
 * @param {number} [opts.count=0] - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
 * @returns {Cursor} The created cursor.
 * @private
 */
/**
 * Creates the cursor iterates tokens with options.
 *
 * @param {Token[]} tokens - The array of tokens.
 * @param {Comment[]} comments - The array of comments.
 * @param {Object} indexMap - The map from locations to indices in `tokens`.
 * @param {number} startLoc - The start location of the iteration range.
 * @param {number} endLoc - The end location of the iteration range.
 * @param {number} [beforeCount=0] - The number of tokens before the node to retrieve.
 * @param {boolean} [afterCount=0] - The number of tokens after the node to retrieve.
 * @returns {Cursor} The created cursor.
 * @private
 */
function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
  if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
    return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
  }
  if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
    return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
  }
  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
}

/**
 * Gets comment tokens that are adjacent to the current cursor position.
 * @param {Cursor} cursor - A cursor instance.
 * @returns {Array} An array of comment tokens adjacent to the current cursor position.
 * @private
 */
function getAdjacentCommentTokensFromCursor(cursor) {
  const tokens = [];
  let currentToken = cursor.getOneToken();
  while (currentToken && astUtils.isCommentToken(currentToken)) {
    tokens.push(currentToken);
    currentToken = cursor.getOneToken();
  }
  return tokens;
}

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The token store.
 *
 * This class provides methods to get tokens by locations as fast as possible.
 * The methods are a part of public API, so we should be careful if it changes this class.
 *
 * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.
 * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.
 * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.
 * This uses binary-searching instead for comments.
 */
module.exports = class TokenStore {
  /**
   * Initializes this token store.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   */
  constructor(tokens, comments) {
    this[TOKENS] = tokens;
    this[COMMENTS] = comments;
    this[INDEX_MAP] = createIndexMap(tokens, comments);
  }

  //--------------------------------------------------------------------------
  // Gets single token.
  //--------------------------------------------------------------------------

  /**
   * Gets the token starting at the specified index.
   * @param {number} offset - Index of the start of the token's range.
   * @param {Object} [options=0] - The option object.
   * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
   * @returns {Token|null} The token starting at index, or null if no such token.
   */
  getTokenByRangeStart(offset, options) {
    const includeComments = options && options.includeComments;
    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();
    if (token && token.range[0] === offset) {
      return token;
    }
    return null;
  }

  /**
   * Gets the first token of the given node.
   * @param {ASTNode} node - The AST node.
   * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.
   * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
   * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
   * @param {number} [options.skip=0] - The count of tokens the cursor skips.
   * @returns {Token|null} An object representing the token.
   */
  getFirstToken(node, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
  }

  /**
   * Gets the last token of the given node.
   * @param {ASTNode} node - The AST node.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
   * @returns {Token|null} An object representing the token.
   */
  getLastToken(node, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
  }

  /**
   * Gets the token that precedes a given node or token.
   * @param {ASTNode|Token|Comment} node - The AST node or token.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
   * @returns {Token|null} An object representing the token.
   */
  getTokenBefore(node, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();
  }

  /**
   * Gets the token that follows a given node or token.
   * @param {ASTNode|Token|Comment} node - The AST node or token.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
   * @returns {Token|null} An object representing the token.
   */
  getTokenAfter(node, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();
  }

  /**
   * Gets the first token between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left - Node before the desired token range.
   * @param {ASTNode|Token|Comment} right - Node after the desired token range.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
   * @returns {Token|null} An object representing the token.
   */
  getFirstTokenBetween(left, right, options) {
    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
  }

  /**
   * Gets the last token between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left Node before the desired token range.
   * @param {ASTNode|Token|Comment} right Node after the desired token range.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstToken()
   * @returns {Token|null} An object representing the token.
   */
  getLastTokenBetween(left, right, options) {
    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
  }

  /**
   * Gets the token that precedes a given node or token in the token stream.
   * This is defined for backward compatibility. Use `includeComments` option instead.
   * TODO: We have a plan to remove this in a future major version.
   * @param {ASTNode|Token|Comment} node The AST node or token.
   * @param {number} [skip=0] A number of tokens to skip.
   * @returns {Token|null} An object representing the token.
   * @deprecated
   */
  getTokenOrCommentBefore(node, skip) {
    return this.getTokenBefore(node, {
      includeComments: true,
      skip
    });
  }

  /**
   * Gets the token that follows a given node or token in the token stream.
   * This is defined for backward compatibility. Use `includeComments` option instead.
   * TODO: We have a plan to remove this in a future major version.
   * @param {ASTNode|Token|Comment} node The AST node or token.
   * @param {number} [skip=0] A number of tokens to skip.
   * @returns {Token|null} An object representing the token.
   * @deprecated
   */
  getTokenOrCommentAfter(node, skip) {
    return this.getTokenAfter(node, {
      includeComments: true,
      skip
    });
  }

  //--------------------------------------------------------------------------
  // Gets multiple tokens.
  //--------------------------------------------------------------------------

  /**
   * Gets the first `count` tokens of the given node.
   * @param {ASTNode} node - The AST node.
   * @param {number|Function|Object} [options=0] - The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.
   * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
   * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
   * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
   * @returns {Token[]} Tokens.
   */
  getFirstTokens(node, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();
  }

  /**
   * Gets the last `count` tokens of the given node.
   * @param {ASTNode} node - The AST node.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
   * @returns {Token[]} Tokens.
   */
  getLastTokens(node, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();
  }

  /**
   * Gets the `count` tokens that precedes a given node or token.
   * @param {ASTNode|Token|Comment} node - The AST node or token.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
   * @returns {Token[]} Tokens.
   */
  getTokensBefore(node, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();
  }

  /**
   * Gets the `count` tokens that follows a given node or token.
   * @param {ASTNode|Token|Comment} node - The AST node or token.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
   * @returns {Token[]} Tokens.
   */
  getTokensAfter(node, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();
  }

  /**
   * Gets the first `count` tokens between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left - Node before the desired token range.
   * @param {ASTNode|Token|Comment} right - Node after the desired token range.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
   * @returns {Token[]} Tokens between left and right.
   */
  getFirstTokensBetween(left, right, options) {
    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();
  }

  /**
   * Gets the last `count` tokens between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left Node before the desired token range.
   * @param {ASTNode|Token|Comment} right Node after the desired token range.
   * @param {number|Function|Object} [options=0] - The option object. Same options as getFirstTokens()
   * @returns {Token[]} Tokens between left and right.
   */
  getLastTokensBetween(left, right, options) {
    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();
  }

  /**
   * Gets all tokens that are related to the given node.
   * @param {ASTNode} node - The AST node.
   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
   * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
   * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
   * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
   * @returns {Token[]} Array of objects representing tokens.
   */
  /**
   * Gets all tokens that are related to the given node.
   * @param {ASTNode} node - The AST node.
   * @param {int} [beforeCount=0] - The number of tokens before the node to retrieve.
   * @param {int} [afterCount=0] - The number of tokens after the node to retrieve.
   * @returns {Token[]} Array of objects representing tokens.
   */
  getTokens(node, beforeCount, afterCount) {
    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();
  }

  /**
   * Gets all of the tokens between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left Node before the desired token range.
   * @param {ASTNode|Token|Comment} right Node after the desired token range.
   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
   * @param {boolean} [options.includeComments=false] - The flag to iterate comments as well.
   * @param {Function|null} [options.filter=null] - The predicate function to choose tokens.
   * @param {number} [options.count=0] - The maximum count of tokens the cursor iterates.
   * @returns {Token[]} Tokens between left and right.
   */
  /**
   * Gets all of the tokens between two non-overlapping nodes.
   * @param {ASTNode|Token|Comment} left Node before the desired token range.
   * @param {ASTNode|Token|Comment} right Node after the desired token range.
   * @param {int} [padding=0] Number of extra tokens on either side of center.
   * @returns {Token[]} Tokens between left and right.
   */
  getTokensBetween(left, right, padding) {
    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();
  }

  //--------------------------------------------------------------------------
  // Others.
  //--------------------------------------------------------------------------

  /**
   * Checks whether any comments exist or not between the given 2 nodes.
   *
   * @param {ASTNode} left - The node to check.
   * @param {ASTNode} right - The node to check.
   * @returns {boolean} `true` if one or more comments exist.
   */
  commentsExistBetween(left, right) {
    const index = utils.search(this[COMMENTS], left.range[1]);
    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
  }

  /**
   * Gets all comment tokens directly before the given node or token.
   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
   * @returns {Array} An array of comments in occurrence order.
   */
  getCommentsBefore(nodeOrToken) {
    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {
      includeComments: true
    });
    return getAdjacentCommentTokensFromCursor(cursor).reverse();
  }

  /**
   * Gets all comment tokens directly after the given node or token.
   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
   * @returns {Array} An array of comments in occurrence order.
   */
  getCommentsAfter(nodeOrToken) {
    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {
      includeComments: true
    });
    return getAdjacentCommentTokensFromCursor(cursor);
  }

  /**
   * Gets all comment tokens inside the given node.
   * @param {ASTNode} node The AST node to get the comments for.
   * @returns {Array} An array of comments in occurrence order.
   */
  getCommentsInside(node) {
    return this.getTokens(node, {
      includeComments: true,
      filter: astUtils.isCommentToken
    });
  }
};

/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define 2 token factories; forward and backward.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const BackwardTokenCommentCursor = __webpack_require__(185);
const BackwardTokenCursor = __webpack_require__(188);
const FilterCursor = __webpack_require__(189);
const ForwardTokenCommentCursor = __webpack_require__(191);
const ForwardTokenCursor = __webpack_require__(192);
const LimitCursor = __webpack_require__(193);
const SkipCursor = __webpack_require__(194);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * The cursor factory.
 * @private
 */
class CursorFactory {
  /**
   * Initializes this cursor.
   * @param {Function} TokenCursor - The class of the cursor which iterates tokens only.
   * @param {Function} TokenCommentCursor - The class of the cursor which iterates the mix of tokens and comments.
   */
  constructor(TokenCursor, TokenCommentCursor) {
    this.TokenCursor = TokenCursor;
    this.TokenCommentCursor = TokenCommentCursor;
  }

  /**
   * Creates a base cursor instance that can be decorated by createCursor.
   *
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   * @param {boolean} includeComments - The flag to iterate comments as well.
   * @returns {Cursor} The created base cursor.
   */
  createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
    const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
    return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
  }

  /**
   * Creates a cursor that iterates tokens with normalized options.
   *
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   * @param {boolean} includeComments - The flag to iterate comments as well.
   * @param {Function|null} filter - The predicate function to choose tokens.
   * @param {number} skip - The count of tokens the cursor skips.
   * @param {number} count - The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
   * @returns {Cursor} The created cursor.
   */
  createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
    let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);
    if (filter) {
      cursor = new FilterCursor(cursor, filter);
    }
    if (skip >= 1) {
      cursor = new SkipCursor(cursor, skip);
    }
    if (count >= 0) {
      cursor = new LimitCursor(cursor, count);
    }
    return cursor;
  }
}

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

exports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
exports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);

/***/ }),
/* 185 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which iterates tokens and comments in reverse.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Cursor = __webpack_require__(186);
const utils = __webpack_require__(187);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The cursor which iterates tokens and comments in reverse.
 */
module.exports = class BackwardTokenCommentCursor extends Cursor {
  /**
   * Initializes this cursor.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   */
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.comments = comments;
    this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
    this.commentIndex = utils.search(comments, endLoc) - 1;
    this.border = startLoc;
  }

  /** @inheritdoc */
  moveNext() {
    const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
    const comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
    if (token && (!comment || token.range[1] > comment.range[1])) {
      this.current = token;
      this.tokenIndex -= 1;
    } else if (comment) {
      this.current = comment;
      this.commentIndex -= 1;
    } else {
      this.current = null;
    }
    return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
  }
};

/***/ }),
/* 186 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Define the abstract class about cursors which iterate tokens.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The abstract class about cursors which iterate tokens.
 *
 * This class has 2 abstract methods.
 *
 * - `current: Token | Comment | null` ... The current token.
 * - `moveNext(): boolean` ... Moves this cursor to the next token. If the next token didn't exist, it returns `false`.
 *
 * This is similar to ES2015 Iterators.
 * However, Iterators were slow (at 2017-01), so I created this class as similar to C# IEnumerable.
 *
 * There are the following known sub classes.
 *
 * - ForwardTokenCursor .......... The cursor which iterates tokens only.
 * - BackwardTokenCursor ......... The cursor which iterates tokens only in reverse.
 * - ForwardTokenCommentCursor ... The cursor which iterates tokens and comments.
 * - BackwardTokenCommentCursor .. The cursor which iterates tokens and comments in reverse.
 * - DecorativeCursor
 *     - FilterCursor ............ The cursor which ignores the specified tokens.
 *     - SkipCursor .............. The cursor which ignores the first few tokens.
 *     - LimitCursor ............. The cursor which limits the count of tokens.
 *
 */
module.exports = class Cursor {
  /**
   * Initializes this cursor.
   */
  constructor() {
    this.current = null;
  }

  /**
   * Gets the first token.
   * This consumes this cursor.
   * @returns {Token|Comment} The first token or null.
   */
  getOneToken() {
    return this.moveNext() ? this.current : null;
  }

  /**
   * Gets the first tokens.
   * This consumes this cursor.
   * @returns {(Token|Comment)[]} All tokens.
   */
  getAllTokens() {
    const tokens = [];
    while (this.moveNext()) {
      tokens.push(this.current);
    }
    return tokens;
  }

  /**
   * Moves this cursor to the next token.
   * @returns {boolean} `true` if the next token exists.
   * @abstract
   */
  /* istanbul ignore next */
  moveNext() {
    // eslint-disable-line class-methods-use-this
    throw new Error("Not implemented.");
  }
};

/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define utilify functions for token store.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets `token.range[0]` from the given token.
 *
 * @param {Node|Token|Comment} token - The token to get.
 * @returns {number} The start location.
 * @private
 */
function getStartLocation(token) {
  return token.range[0];
}

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * Binary-searches the index of the first token which is after the given location.
 * If it was not found, this returns `tokens.length`.
 *
 * @param {(Token|Comment)[]} tokens - It searches the token in this list.
 * @param {number} location - The location to search.
 * @returns {number} The found index or `tokens.length`.
 */
exports.search = function search(tokens, location) {
  return lodash.sortedIndexBy(tokens, {
    range: [location]
  }, getStartLocation);
};

/**
 * Gets the index of the `startLoc` in `tokens`.
 * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.
 *
 * @param {(Token|Comment)[]} tokens - The tokens to find an index.
 * @param {Object} indexMap - The map from locations to indices.
 * @param {number} startLoc - The location to get an index.
 * @returns {number} The index.
 */
exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
  if (startLoc in indexMap) {
    return indexMap[startLoc];
  }
  if (startLoc - 1 in indexMap) {
    const index = indexMap[startLoc - 1];
    const token = index >= 0 && index < tokens.length ? tokens[index] : null;

    /*
     * For the map of "comment's location -> token's index", it points the next token of a comment.
     * In that case, +1 is unnecessary.
     */
    if (token && token.range[0] >= startLoc) {
      return index;
    }
    return index + 1;
  }
  return 0;
};

/**
 * Gets the index of the `endLoc` in `tokens`.
 * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.
 *
 * @param {(Token|Comment)[]} tokens - The tokens to find an index.
 * @param {Object} indexMap - The map from locations to indices.
 * @param {number} endLoc - The location to get an index.
 * @returns {number} The index.
 */
exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
  if (endLoc in indexMap) {
    return indexMap[endLoc] - 1;
  }
  if (endLoc - 1 in indexMap) {
    const index = indexMap[endLoc - 1];
    const token = index >= 0 && index < tokens.length ? tokens[index] : null;

    /*
     * For the map of "comment's location -> token's index", it points the next token of a comment.
     * In that case, -1 is necessary.
     */
    if (token && token.range[1] > endLoc) {
      return index - 1;
    }
    return index;
  }
  return tokens.length - 1;
};

/***/ }),
/* 188 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which iterates tokens only in reverse.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Cursor = __webpack_require__(186);
const utils = __webpack_require__(187);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The cursor which iterates tokens only in reverse.
 */
module.exports = class BackwardTokenCursor extends Cursor {
  /**
   * Initializes this cursor.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   */
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.index = utils.getLastIndex(tokens, indexMap, endLoc);
    this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
  }

  /** @inheritdoc */
  moveNext() {
    if (this.index >= this.indexEnd) {
      this.current = this.tokens[this.index];
      this.index -= 1;
      return true;
    }
    return false;
  }

  /*
   *
   * Shorthand for performance.
   *
   */

  /** @inheritdoc */
  getOneToken() {
    return this.index >= this.indexEnd ? this.tokens[this.index] : null;
  }
};

/***/ }),
/* 189 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which ignores specified tokens.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const DecorativeCursor = __webpack_require__(190);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The decorative cursor which ignores specified tokens.
 */
module.exports = class FilterCursor extends DecorativeCursor {
  /**
   * Initializes this cursor.
   * @param {Cursor} cursor - The cursor to be decorated.
   * @param {Function} predicate - The predicate function to decide tokens this cursor iterates.
   */
  constructor(cursor, predicate) {
    super(cursor);
    this.predicate = predicate;
  }

  /** @inheritdoc */
  moveNext() {
    const predicate = this.predicate;
    while (super.moveNext()) {
      if (predicate(this.current)) {
        return true;
      }
    }
    return false;
  }
};

/***/ }),
/* 190 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the abstract class about cursors which manipulate another cursor.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Cursor = __webpack_require__(186);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The abstract class about cursors which manipulate another cursor.
 */
module.exports = class DecorativeCursor extends Cursor {
  /**
   * Initializes this cursor.
   * @param {Cursor} cursor - The cursor to be decorated.
   */
  constructor(cursor) {
    super();
    this.cursor = cursor;
  }

  /** @inheritdoc */
  moveNext() {
    const retv = this.cursor.moveNext();
    this.current = this.cursor.current;
    return retv;
  }
};

/***/ }),
/* 191 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which iterates tokens and comments.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Cursor = __webpack_require__(186);
const utils = __webpack_require__(187);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The cursor which iterates tokens and comments.
 */
module.exports = class ForwardTokenCommentCursor extends Cursor {
  /**
   * Initializes this cursor.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   */
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.comments = comments;
    this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
    this.commentIndex = utils.search(comments, startLoc);
    this.border = endLoc;
  }

  /** @inheritdoc */
  moveNext() {
    const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
    const comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
    if (token && (!comment || token.range[0] < comment.range[0])) {
      this.current = token;
      this.tokenIndex += 1;
    } else if (comment) {
      this.current = comment;
      this.commentIndex += 1;
    } else {
      this.current = null;
    }
    return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
  }
};

/***/ }),
/* 192 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which iterates tokens only.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Cursor = __webpack_require__(186);
const utils = __webpack_require__(187);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The cursor which iterates tokens only.
 */
module.exports = class ForwardTokenCursor extends Cursor {
  /**
   * Initializes this cursor.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   */
  constructor(tokens, comments, indexMap, startLoc, endLoc) {
    super();
    this.tokens = tokens;
    this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
    this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
  }

  /** @inheritdoc */
  moveNext() {
    if (this.index <= this.indexEnd) {
      this.current = this.tokens[this.index];
      this.index += 1;
      return true;
    }
    return false;
  }

  /*
   *
   * Shorthand for performance.
   *
   */

  /** @inheritdoc */
  getOneToken() {
    return this.index <= this.indexEnd ? this.tokens[this.index] : null;
  }

  /** @inheritdoc */
  getAllTokens() {
    return this.tokens.slice(this.index, this.indexEnd + 1);
  }
};

/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which limits the number of tokens.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const DecorativeCursor = __webpack_require__(190);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The decorative cursor which limits the number of tokens.
 */
module.exports = class LimitCursor extends DecorativeCursor {
  /**
   * Initializes this cursor.
   * @param {Cursor} cursor - The cursor to be decorated.
   * @param {number} count - The count of tokens this cursor iterates.
   */
  constructor(cursor, count) {
    super(cursor);
    this.count = count;
  }

  /** @inheritdoc */
  moveNext() {
    if (this.count > 0) {
      this.count -= 1;
      return super.moveNext();
    }
    return false;
  }
};

/***/ }),
/* 194 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which ignores the first few tokens.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const DecorativeCursor = __webpack_require__(190);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The decorative cursor which ignores the first few tokens.
 */
module.exports = class SkipCursor extends DecorativeCursor {
  /**
   * Initializes this cursor.
   * @param {Cursor} cursor - The cursor to be decorated.
   * @param {number} count - The count of tokens this cursor skips.
   */
  constructor(cursor, count) {
    super(cursor);
    this.count = count;
  }

  /** @inheritdoc */
  moveNext() {
    while (this.count > 0) {
      this.count -= 1;
      if (!super.moveNext()) {
        return false;
      }
    }
    return super.moveNext();
  }
};

/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Define the cursor which iterates tokens only, with inflated range.
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const ForwardTokenCursor = __webpack_require__(192);

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * The cursor which iterates tokens only, with inflated range.
 * This is for the backward compatibility of padding options.
 */
module.exports = class PaddedTokenCursor extends ForwardTokenCursor {
  /**
   * Initializes this cursor.
   * @param {Token[]} tokens - The array of tokens.
   * @param {Comment[]} comments - The array of comments.
   * @param {Object} indexMap - The map from locations to indices in `tokens`.
   * @param {number} startLoc - The start location of the iteration range.
   * @param {number} endLoc - The end location of the iteration range.
   * @param {number} beforeCount - The number of tokens this cursor iterates before start.
   * @param {number} afterCount - The number of tokens this cursor iterates after end.
   */
  constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
    super(tokens, comments, indexMap, startLoc, endLoc);
    this.index = Math.max(0, this.index - beforeCount);
    this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
  }
};

/***/ }),
/* 196 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Traverser to traverse AST trees.
 * @author Nicholas C. Zakas
 * @author Toru Nagashima
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const vk = __webpack_require__(89);
const debug = __webpack_require__(105)("eslint:traverser");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Do nothing.
 * @returns {void}
 */
function noop() {

  // do nothing.
}

/**
 * Check whether the given value is an ASTNode or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an ASTNode.
 */
function isNode(x) {
  return x !== null && typeof x === "object" && typeof x.type === "string";
}

/**
 * Get the visitor keys of a given node.
 * @param {Object} visitorKeys The map of visitor keys.
 * @param {ASTNode} node The node to get their visitor keys.
 * @returns {string[]} The visitor keys of the node.
 */
function getVisitorKeys(visitorKeys, node) {
  let keys = visitorKeys[node.type];
  if (!keys) {
    keys = vk.getKeys(node);
    debug("Unknown node type \"%s\": Estimated visitor keys %j", node.type, keys);
  }
  return keys;
}

/**
 * The traverser class to traverse AST trees.
 */
class Traverser {
  constructor() {
    this._current = null;
    this._parents = [];
    this._skipped = false;
    this._broken = false;
    this._visitorKeys = null;
    this._enter = null;
    this._leave = null;
  }

  /**
   * @returns {ASTNode} The current node.
   */
  current() {
    return this._current;
  }

  /**
   * @returns {ASTNode[]} The ancestor nodes.
   */
  parents() {
    return this._parents.slice(0);
  }

  /**
   * Break the current traversal.
   * @returns {void}
   */
  break() {
    this._broken = true;
  }

  /**
   * Skip child nodes for the current traversal.
   * @returns {void}
   */
  skip() {
    this._skipped = true;
  }

  /**
   * Traverse the given AST tree.
   * @param {ASTNode} node The root node to traverse.
   * @param {Object} options The option object.
   * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
   * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
   * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
   * @returns {void}
   */
  traverse(node, options) {
    this._current = null;
    this._parents = [];
    this._skipped = false;
    this._broken = false;
    this._visitorKeys = options.visitorKeys || vk.KEYS;
    this._enter = options.enter || noop;
    this._leave = options.leave || noop;
    this._traverse(node, null);
  }

  /**
   * Traverse the given AST tree recursively.
   * @param {ASTNode} node The current node.
   * @param {ASTNode|null} parent The parent node.
   * @returns {void}
   * @private
   */
  _traverse(node, parent) {
    if (!isNode(node)) {
      return;
    }
    this._current = node;
    this._skipped = false;
    this._enter(node, parent);
    if (!this._skipped && !this._broken) {
      const keys = getVisitorKeys(this._visitorKeys, node);
      if (keys.length >= 1) {
        this._parents.push(node);
        for (let i = 0; i < keys.length && !this._broken; ++i) {
          const child = node[keys[i]];
          if (Array.isArray(child)) {
            for (let j = 0; j < child.length && !this._broken; ++j) {
              this._traverse(child[j], node);
            }
          } else {
            this._traverse(child, node);
          }
        }
        this._parents.pop();
      }
    }
    if (!this._broken) {
      this._leave(node, parent);
    }
    this._current = parent;
  }

  /**
   * Calculates the keys to use for traversal.
   * @param {ASTNode} node The node to read keys from.
   * @returns {string[]} An array of keys to visit on the node.
   * @private
   */
  static getKeys(node) {
    return vk.getKeys(node);
  }

  /**
   * Traverse the given AST tree.
   * @param {ASTNode} node The root node to traverse.
   * @param {Object} options The option object.
   * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
   * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
   * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
   * @returns {void}
   */
  static traverse(node, options) {
    new Traverser().traverse(node, options);
  }

  /**
   * The default visitor keys.
   * @type {Object}
   */
  static get DEFAULT_VISITOR_KEYS() {
    return vk.KEYS;
  }
}
module.exports = Traverser;

/***/ }),
/* 197 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects
 * @author Teddy Katz
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const assert = __webpack_require__(3);
const ruleFixer = __webpack_require__(198);
const interpolate = __webpack_require__(199);

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An error message description
 * @typedef {Object} MessageDescriptor
 * @property {ASTNode} [node] The reported node
 * @property {Location} loc The location of the problem.
 * @property {string} message The problem message.
 * @property {Object} [data] Optional data to use to fill in placeholders in the
 *      message.
 * @property {Function} [fix] The function to call that creates a fix command.
 */

/**
 * Information about the report
 * @typedef {Object} ReportInfo
 * @property {string} ruleId
 * @property {(0|1|2)} severity
 * @property {(string|undefined)} message
 * @property {(string|undefined)} messageId
 * @property {number} line
 * @property {number} column
 * @property {(number|undefined)} endLine
 * @property {(number|undefined)} endColumn
 * @property {(string|null)} nodeType
 * @property {string} source
 * @property {({text: string, range: (number[]|null)}|null)} fix
 */

//------------------------------------------------------------------------------
// Module Definition
//------------------------------------------------------------------------------

/**
 * Translates a multi-argument context.report() call into a single object argument call
 * @param {...*} args A list of arguments passed to `context.report`
 * @returns {MessageDescriptor} A normalized object containing report information
 */
function normalizeMultiArgReportCall() {
  // If there is one argument, it is considered to be a new-style call already.
  if (arguments.length === 1) {
    // Shallow clone the object to avoid surprises if reusing the descriptor
    return Object.assign({}, arguments.length <= 0 ? undefined : arguments[0]);
  }

  // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].
  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === "string") {
    return {
      node: arguments.length <= 0 ? undefined : arguments[0],
      message: arguments.length <= 1 ? undefined : arguments[1],
      data: arguments.length <= 2 ? undefined : arguments[2],
      fix: arguments.length <= 3 ? undefined : arguments[3]
    };
  }

  // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].
  return {
    node: arguments.length <= 0 ? undefined : arguments[0],
    loc: arguments.length <= 1 ? undefined : arguments[1],
    message: arguments.length <= 2 ? undefined : arguments[2],
    data: arguments.length <= 3 ? undefined : arguments[3],
    fix: arguments.length <= 4 ? undefined : arguments[4]
  };
}

/**
 * Asserts that either a loc or a node was provided, and the node is valid if it was provided.
 * @param {MessageDescriptor} descriptor A descriptor to validate
 * @returns {void}
 * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object
 */
function assertValidNodeInfo(descriptor) {
  if (descriptor.node) {
    assert(typeof descriptor.node === "object", "Node must be an object");
  } else {
    assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
  }
}

/**
 * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties
 * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.
 * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties
 * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.
 */
function normalizeReportLoc(descriptor) {
  if (descriptor.loc) {
    if (descriptor.loc.start) {
      return descriptor.loc;
    }
    return {
      start: descriptor.loc,
      end: null
    };
  }
  return descriptor.node.loc;
}

/**
 * Compares items in a fixes array by range.
 * @param {Fix} a The first message.
 * @param {Fix} b The second message.
 * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareFixesByRange(a, b) {
  return a.range[0] - b.range[0] || a.range[1] - b.range[1];
}

/**
 * Merges the given fixes array into one.
 * @param {Fix[]} fixes The fixes to merge.
 * @param {SourceCode} sourceCode The source code object to get the text between fixes.
 * @returns {{text: string, range: number[]}} The merged fixes
 */
function mergeFixes(fixes, sourceCode) {
  if (fixes.length === 0) {
    return null;
  }
  if (fixes.length === 1) {
    return fixes[0];
  }
  fixes.sort(compareFixesByRange);
  const originalText = sourceCode.text;
  const start = fixes[0].range[0];
  const end = fixes[fixes.length - 1].range[1];
  let text = "";
  let lastPos = Number.MIN_SAFE_INTEGER;
  for (const fix of fixes) {
    assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");
    if (fix.range[0] >= 0) {
      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
    }
    text += fix.text;
    lastPos = fix.range[1];
  }
  text += originalText.slice(Math.max(0, start, lastPos), end);
  return {
    range: [start, end],
    text
  };
}

/**
 * Gets one fix object from the given descriptor.
 * If the descriptor retrieves multiple fixes, this merges those to one.
 * @param {MessageDescriptor} descriptor The report descriptor.
 * @param {SourceCode} sourceCode The source code object to get text between fixes.
 * @returns {({text: string, range: number[]}|null)} The fix for the descriptor
 */
function normalizeFixes(descriptor, sourceCode) {
  if (typeof descriptor.fix !== "function") {
    return null;
  }

  // @type {null | Fix | Fix[] | IterableIterator<Fix>}
  const fix = descriptor.fix(ruleFixer);

  // Merge to one.
  if (fix && Symbol.iterator in fix) {
    return mergeFixes(Array.from(fix), sourceCode);
  }
  return fix;
}

/**
 * Creates information about the report from a descriptor
 * @param {Object} options Information about the problem
 * @param {string} options.ruleId Rule ID
 * @param {(0|1|2)} options.severity Rule severity
 * @param {(ASTNode|null)} options.node Node
 * @param {string} options.message Error message
 * @param {string} [options.messageId] The error message ID.
 * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location
 * @param {{text: string, range: (number[]|null)}} options.fix The fix object
 * @returns {function(...args): ReportInfo} Function that returns information about the report
 */
function createProblem(options) {
  const problem = {
    ruleId: options.ruleId,
    severity: options.severity,
    message: options.message,
    line: options.loc.start.line,
    column: options.loc.start.column + 1,
    nodeType: options.node && options.node.type || null
  };

  /*
   * If this isnt in the conditional, some of the tests fail
   * because `messageId` is present in the problem object
   */
  if (options.messageId) {
    problem.messageId = options.messageId;
  }
  if (options.loc.end) {
    problem.endLine = options.loc.end.line;
    problem.endColumn = options.loc.end.column + 1;
  }
  if (options.fix) {
    problem.fix = options.fix;
  }
  return problem;
}

/**
 * Returns a function that converts the arguments of a `context.report` call from a rule into a reported
 * problem for the Node.js API.
 * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object}} metadata Metadata for the reported problem
 * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted
 * @returns {function(...args): ReportInfo} Function that returns information about the report
 */

module.exports = function createReportTranslator(metadata) {
  /*
   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.
   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets
   * called every time a rule reports a problem, which happens much less frequently (usually, the vast
   * majority of rules don't report any problems for a given file).
   */
  return function () {
    const descriptor = normalizeMultiArgReportCall(...arguments);
    assertValidNodeInfo(descriptor);
    let computedMessage;
    if (descriptor.messageId) {
      if (!metadata.messageIds) {
        throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
      }
      const id = descriptor.messageId;
      const messages = metadata.messageIds;
      if (descriptor.message) {
        throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
      }
      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {
        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
      }
      computedMessage = messages[id];
    } else if (descriptor.message) {
      computedMessage = descriptor.message;
    } else {
      throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
    }
    return createProblem({
      ruleId: metadata.ruleId,
      severity: metadata.severity,
      node: descriptor.node,
      message: interpolate(computedMessage, descriptor.data),
      messageId: descriptor.messageId,
      loc: normalizeReportLoc(descriptor),
      fix: normalizeFixes(descriptor, metadata.sourceCode)
    });
  };
};

/***/ }),
/* 198 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview An object that creates fix commands for rules.
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

// none!

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Creates a fix command that inserts text at the specified index in the source text.
 * @param {int} index The 0-based index at which to insert the new text.
 * @param {string} text The text to insert.
 * @returns {Object} The fix command.
 * @private
 */
function insertTextAt(index, text) {
  return {
    range: [index, index],
    text
  };
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Creates code fixing commands for rules.
 */

const ruleFixer = Object.freeze({
  /**
   * Creates a fix command that inserts text after the given node or token.
   * The fix is not applied until applyFixes() is called.
   * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  insertTextAfter(nodeOrToken, text) {
    return this.insertTextAfterRange(nodeOrToken.range, text);
  },
  /**
   * Creates a fix command that inserts text after the specified range in the source text.
   * The fix is not applied until applyFixes() is called.
   * @param {int[]} range The range to replace, first item is start of range, second
   *      is end of range.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  insertTextAfterRange(range, text) {
    return insertTextAt(range[1], text);
  },
  /**
   * Creates a fix command that inserts text before the given node or token.
   * The fix is not applied until applyFixes() is called.
   * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  insertTextBefore(nodeOrToken, text) {
    return this.insertTextBeforeRange(nodeOrToken.range, text);
  },
  /**
   * Creates a fix command that inserts text before the specified range in the source text.
   * The fix is not applied until applyFixes() is called.
   * @param {int[]} range The range to replace, first item is start of range, second
   *      is end of range.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  insertTextBeforeRange(range, text) {
    return insertTextAt(range[0], text);
  },
  /**
   * Creates a fix command that replaces text at the node or token.
   * The fix is not applied until applyFixes() is called.
   * @param {ASTNode|Token} nodeOrToken The node or token to remove.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  replaceText(nodeOrToken, text) {
    return this.replaceTextRange(nodeOrToken.range, text);
  },
  /**
   * Creates a fix command that replaces text at the specified range in the source text.
   * The fix is not applied until applyFixes() is called.
   * @param {int[]} range The range to replace, first item is start of range, second
   *      is end of range.
   * @param {string} text The text to insert.
   * @returns {Object} The fix command.
   */
  replaceTextRange(range, text) {
    return {
      range,
      text
    };
  },
  /**
   * Creates a fix command that removes the node or token from the source.
   * The fix is not applied until applyFixes() is called.
   * @param {ASTNode|Token} nodeOrToken The node or token to remove.
   * @returns {Object} The fix command.
   */
  remove(nodeOrToken) {
    return this.removeRange(nodeOrToken.range);
  },
  /**
   * Creates a fix command that removes the specified range of text from the source.
   * The fix is not applied until applyFixes() is called.
   * @param {int[]} range The range to remove, first item is start of range, second
   *      is end of range.
   * @returns {Object} The fix command.
   */
  removeRange(range) {
    return {
      range,
      text: ""
    };
  }
});
module.exports = ruleFixer;

/***/ }),
/* 199 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Interpolate keys from an object into a string with {{ }} markers.
 * @author Jed Fox
 */



//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------
module.exports = (text, data) => {
  if (!data) {
    return text;
  }

  // Substitution content for any {{ }} markers.
  return text.replace(/\{\{([^{}]+?)\}\}/gu, (fullMatch, termWithWhitespace) => {
    const term = termWithWhitespace.trim();
    if (term in data) {
      return data[term];
    }

    // Preserve old behavior: If parameter name not provided, don't replace it.
    return fullMatch;
  });
};

/***/ }),
/* 200 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Defines a storage for rules.
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const ruleReplacements = (__webpack_require__(201).rules);
const builtInRules = __webpack_require__(202);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Creates a stub rule that gets used when a rule with a given ID is not found.
 * @param {string} ruleId The ID of the missing rule
 * @returns {{create: function(RuleContext): Object}} A rule that reports an error at the first location
 * in the program. The report has the message `Definition for rule '${ruleId}' was not found` if the rule is unknown,
 * or `Rule '${ruleId}' was removed and replaced by: ${replacements.join(", ")}` if the rule is known to have been
 * replaced.
 */
const createMissingRule = lodash.memoize(ruleId => {
  const message = Object.prototype.hasOwnProperty.call(ruleReplacements, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements[ruleId].join(", ")}` : `Definition for rule '${ruleId}' was not found`;
  return {
    create: context => ({
      Program() {
        context.report({
          loc: {
            line: 1,
            column: 0
          },
          message
        });
      }
    })
  };
});

/**
 * Normalizes a rule module to the new-style API
 * @param {(Function|{create: Function})} rule A rule object, which can either be a function
 * ("old-style") or an object with a `create` method ("new-style")
 * @returns {{create: Function}} A new-style rule.
 */
function normalizeRule(rule) {
  return typeof rule === "function" ? Object.assign({
    create: rule
  }, rule) : rule;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

class Rules {
  constructor() {
    this._rules = Object.create(null);
    Object.keys(builtInRules).forEach(ruleId => {
      this.define(ruleId, builtInRules[ruleId]);
    });
  }

  /**
   * Registers a rule module for rule id in storage.
   * @param {string} ruleId Rule id (file name).
   * @param {Function} ruleModule Rule handler.
   * @returns {void}
   */
  define(ruleId, ruleModule) {
    this._rules[ruleId] = normalizeRule(ruleModule);
  }

  /**
   * Access rule handler by id (file name).
   * @param {string} ruleId Rule id (file name).
   * @returns {{create: Function, schema: JsonSchema[]}}
   * A rule. This is normalized to always have the new-style shape with a `create` method.
   */
  get(ruleId) {
    if (!Object.prototype.hasOwnProperty.call(this._rules, ruleId)) {
      return createMissingRule(ruleId);
    }
    if (typeof this._rules[ruleId] === "string") {
      return normalizeRule();
    }
    return this._rules[ruleId];
  }

  /**
   * Get an object with all currently loaded rules
   * @returns {Map} All loaded rules
   */
  getAllLoadedRules() {
    const allRules = new Map();
    Object.keys(this._rules).forEach(name => {
      const rule = this.get(name);
      allRules.set(name, rule);
    });
    return allRules;
  }
}
module.exports = Rules;

/***/ }),
/* 201 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"rules":{"generator-star":["generator-star-spacing"],"global-strict":["strict"],"no-arrow-condition":["no-confusing-arrow","no-constant-condition"],"no-comma-dangle":["comma-dangle"],"no-empty-class":["no-empty-character-class"],"no-empty-label":["no-labels"],"no-extra-strict":["strict"],"no-reserved-keys":["quote-props"],"no-space-before-semi":["semi-spacing"],"no-wrap-func":["no-extra-parens"],"space-after-function-name":["space-before-function-paren"],"space-after-keywords":["keyword-spacing"],"space-before-function-parentheses":["space-before-function-paren"],"space-before-keywords":["keyword-spacing"],"space-in-brackets":["object-curly-spacing","array-bracket-spacing","computed-property-spacing"],"space-return-throw-case":["keyword-spacing"],"space-unary-word-ops":["space-unary-ops"],"spaced-line-comment":["spaced-comment"]}}');

/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Collects the built-in rules into a map structure so that they can be imported all at once and without
 * using the file-system directly.
 * @author Peter (Somogyvari) Metz
 */



/* eslint sort-keys: ["error", "asc"] */
module.exports = {
  "accessor-pairs": __webpack_require__(203),
  "array-bracket-newline": __webpack_require__(204),
  "array-bracket-spacing": __webpack_require__(205),
  "array-callback-return": __webpack_require__(206),
  "array-element-newline": __webpack_require__(207),
  "arrow-body-style": __webpack_require__(208),
  "arrow-parens": __webpack_require__(209),
  "arrow-spacing": __webpack_require__(210),
  "block-scoped-var": __webpack_require__(211),
  "block-spacing": __webpack_require__(212),
  "brace-style": __webpack_require__(213),
  "callback-return": __webpack_require__(214),
  camelcase: __webpack_require__(215),
  "capitalized-comments": __webpack_require__(216),
  "class-methods-use-this": __webpack_require__(218),
  "comma-dangle": __webpack_require__(219),
  "comma-spacing": __webpack_require__(220),
  "comma-style": __webpack_require__(221),
  complexity: __webpack_require__(222),
  "computed-property-spacing": __webpack_require__(223),
  "consistent-return": __webpack_require__(224),
  "consistent-this": __webpack_require__(225),
  "constructor-super": __webpack_require__(226),
  curly: __webpack_require__(227),
  "default-case": __webpack_require__(228),
  "dot-location": __webpack_require__(229),
  "dot-notation": __webpack_require__(230),
  "eol-last": __webpack_require__(232),
  eqeqeq: __webpack_require__(233),
  "for-direction": __webpack_require__(234),
  "func-call-spacing": __webpack_require__(235),
  "func-name-matching": __webpack_require__(236),
  "func-names": __webpack_require__(237),
  "func-style": __webpack_require__(238),
  "function-paren-newline": __webpack_require__(239),
  "generator-star-spacing": __webpack_require__(240),
  "getter-return": __webpack_require__(241),
  "global-require": __webpack_require__(242),
  "guard-for-in": __webpack_require__(243),
  "handle-callback-err": __webpack_require__(244),
  "id-blacklist": __webpack_require__(245),
  "id-length": __webpack_require__(246),
  "id-match": __webpack_require__(247),
  "implicit-arrow-linebreak": __webpack_require__(248),
  indent: __webpack_require__(249),
  "indent-legacy": __webpack_require__(251),
  "init-declarations": __webpack_require__(252),
  "jsx-quotes": __webpack_require__(253),
  "key-spacing": __webpack_require__(254),
  "keyword-spacing": __webpack_require__(255),
  "line-comment-position": __webpack_require__(256),
  "linebreak-style": __webpack_require__(257),
  "lines-around-comment": __webpack_require__(258),
  "lines-around-directive": __webpack_require__(259),
  "lines-between-class-members": __webpack_require__(260),
  "max-classes-per-file": __webpack_require__(261),
  "max-depth": __webpack_require__(262),
  "max-len": __webpack_require__(263),
  "max-lines": __webpack_require__(264),
  "max-lines-per-function": __webpack_require__(265),
  "max-nested-callbacks": __webpack_require__(266),
  "max-params": __webpack_require__(267),
  "max-statements": __webpack_require__(268),
  "max-statements-per-line": __webpack_require__(269),
  "multiline-comment-style": __webpack_require__(270),
  "multiline-ternary": __webpack_require__(271),
  "new-cap": __webpack_require__(272),
  "new-parens": __webpack_require__(273),
  "newline-after-var": __webpack_require__(274),
  "newline-before-return": __webpack_require__(275),
  "newline-per-chained-call": __webpack_require__(276),
  "no-alert": __webpack_require__(277),
  "no-array-constructor": __webpack_require__(278),
  "no-async-promise-executor": __webpack_require__(279),
  "no-await-in-loop": __webpack_require__(280),
  "no-bitwise": __webpack_require__(281),
  "no-buffer-constructor": __webpack_require__(282),
  "no-caller": __webpack_require__(283),
  "no-case-declarations": __webpack_require__(284),
  "no-catch-shadow": __webpack_require__(285),
  "no-class-assign": __webpack_require__(286),
  "no-compare-neg-zero": __webpack_require__(287),
  "no-cond-assign": __webpack_require__(288),
  "no-confusing-arrow": __webpack_require__(289),
  "no-console": __webpack_require__(290),
  "no-const-assign": __webpack_require__(291),
  "no-constant-condition": __webpack_require__(292),
  "no-continue": __webpack_require__(293),
  "no-control-regex": __webpack_require__(294),
  "no-debugger": __webpack_require__(296),
  "no-delete-var": __webpack_require__(297),
  "no-div-regex": __webpack_require__(298),
  "no-dupe-args": __webpack_require__(299),
  "no-dupe-class-members": __webpack_require__(300),
  "no-dupe-keys": __webpack_require__(301),
  "no-duplicate-case": __webpack_require__(302),
  "no-duplicate-imports": __webpack_require__(303),
  "no-else-return": __webpack_require__(304),
  "no-empty": __webpack_require__(306),
  "no-empty-character-class": __webpack_require__(307),
  "no-empty-function": __webpack_require__(308),
  "no-empty-pattern": __webpack_require__(309),
  "no-eq-null": __webpack_require__(310),
  "no-eval": __webpack_require__(311),
  "no-ex-assign": __webpack_require__(312),
  "no-extend-native": __webpack_require__(313),
  "no-extra-bind": __webpack_require__(314),
  "no-extra-boolean-cast": __webpack_require__(315),
  "no-extra-label": __webpack_require__(316),
  "no-extra-parens": __webpack_require__(317),
  "no-extra-semi": __webpack_require__(318),
  "no-fallthrough": __webpack_require__(319),
  "no-floating-decimal": __webpack_require__(320),
  "no-func-assign": __webpack_require__(321),
  "no-global-assign": __webpack_require__(322),
  "no-implicit-coercion": __webpack_require__(323),
  "no-implicit-globals": __webpack_require__(324),
  "no-implied-eval": __webpack_require__(325),
  "no-inline-comments": __webpack_require__(326),
  "no-inner-declarations": __webpack_require__(327),
  "no-invalid-regexp": __webpack_require__(328),
  "no-invalid-this": __webpack_require__(329),
  "no-irregular-whitespace": __webpack_require__(330),
  "no-iterator": __webpack_require__(331),
  "no-label-var": __webpack_require__(332),
  "no-labels": __webpack_require__(333),
  "no-lone-blocks": __webpack_require__(334),
  "no-lonely-if": __webpack_require__(335),
  "no-loop-func": __webpack_require__(336),
  "no-magic-numbers": __webpack_require__(337),
  "no-misleading-character-class": __webpack_require__(338),
  "no-mixed-operators": __webpack_require__(345),
  "no-mixed-requires": __webpack_require__(346),
  "no-mixed-spaces-and-tabs": __webpack_require__(347),
  "no-multi-assign": __webpack_require__(348),
  "no-multi-spaces": __webpack_require__(349),
  "no-multi-str": __webpack_require__(350),
  "no-multiple-empty-lines": __webpack_require__(351),
  "no-native-reassign": __webpack_require__(352),
  "no-negated-condition": __webpack_require__(353),
  "no-negated-in-lhs": __webpack_require__(354),
  "no-nested-ternary": __webpack_require__(355),
  "no-new": __webpack_require__(356),
  "no-new-func": __webpack_require__(357),
  "no-new-object": __webpack_require__(358),
  "no-new-require": __webpack_require__(359),
  "no-new-symbol": __webpack_require__(360),
  "no-new-wrappers": __webpack_require__(361),
  "no-obj-calls": __webpack_require__(362),
  "no-octal": __webpack_require__(363),
  "no-octal-escape": __webpack_require__(364),
  "no-param-reassign": __webpack_require__(365),
  "no-path-concat": __webpack_require__(366),
  "no-plusplus": __webpack_require__(367),
  "no-process-env": __webpack_require__(368),
  "no-process-exit": __webpack_require__(369),
  "no-proto": __webpack_require__(370),
  "no-prototype-builtins": __webpack_require__(371),
  "no-redeclare": __webpack_require__(372),
  "no-regex-spaces": __webpack_require__(373),
  "no-restricted-globals": __webpack_require__(374),
  "no-restricted-imports": __webpack_require__(375),
  "no-restricted-modules": __webpack_require__(377),
  "no-restricted-properties": __webpack_require__(378),
  "no-restricted-syntax": __webpack_require__(379),
  "no-return-assign": __webpack_require__(380),
  "no-return-await": __webpack_require__(381),
  "no-script-url": __webpack_require__(382),
  "no-self-assign": __webpack_require__(383),
  "no-self-compare": __webpack_require__(384),
  "no-sequences": __webpack_require__(385),
  "no-shadow": __webpack_require__(386),
  "no-shadow-restricted-names": __webpack_require__(387),
  "no-spaced-func": __webpack_require__(388),
  "no-sparse-arrays": __webpack_require__(389),
  "no-sync": __webpack_require__(390),
  "no-tabs": __webpack_require__(391),
  "no-template-curly-in-string": __webpack_require__(392),
  "no-ternary": __webpack_require__(393),
  "no-this-before-super": __webpack_require__(394),
  "no-throw-literal": __webpack_require__(395),
  "no-trailing-spaces": __webpack_require__(396),
  "no-undef": __webpack_require__(397),
  "no-undef-init": __webpack_require__(398),
  "no-undefined": __webpack_require__(399),
  "no-underscore-dangle": __webpack_require__(400),
  "no-unexpected-multiline": __webpack_require__(401),
  "no-unmodified-loop-condition": __webpack_require__(402),
  "no-unneeded-ternary": __webpack_require__(403),
  "no-unreachable": __webpack_require__(404),
  "no-unsafe-finally": __webpack_require__(405),
  "no-unsafe-negation": __webpack_require__(406),
  "no-unused-expressions": __webpack_require__(407),
  "no-unused-labels": __webpack_require__(408),
  "no-unused-vars": __webpack_require__(409),
  "no-use-before-define": __webpack_require__(410),
  "no-useless-call": __webpack_require__(411),
  "no-useless-catch": __webpack_require__(412),
  "no-useless-computed-key": __webpack_require__(413),
  "no-useless-concat": __webpack_require__(414),
  "no-useless-constructor": __webpack_require__(415),
  "no-useless-escape": __webpack_require__(416),
  "no-useless-rename": __webpack_require__(417),
  "no-useless-return": __webpack_require__(418),
  "no-var": __webpack_require__(419),
  "no-void": __webpack_require__(420),
  "no-warning-comments": __webpack_require__(421),
  "no-whitespace-before-property": __webpack_require__(422),
  "no-with": __webpack_require__(423),
  "nonblock-statement-body-position": __webpack_require__(424),
  "object-curly-newline": __webpack_require__(425),
  "object-curly-spacing": __webpack_require__(426),
  "object-property-newline": __webpack_require__(427),
  "object-shorthand": __webpack_require__(428),
  "one-var": __webpack_require__(429),
  "one-var-declaration-per-line": __webpack_require__(430),
  "operator-assignment": __webpack_require__(431),
  "operator-linebreak": __webpack_require__(432),
  "padded-blocks": __webpack_require__(433),
  "padding-line-between-statements": __webpack_require__(434),
  "prefer-arrow-callback": __webpack_require__(435),
  "prefer-const": __webpack_require__(436),
  "prefer-destructuring": __webpack_require__(437),
  "prefer-named-capture-group": __webpack_require__(438),
  "prefer-numeric-literals": __webpack_require__(439),
  "prefer-object-spread": __webpack_require__(440),
  "prefer-promise-reject-errors": __webpack_require__(441),
  "prefer-reflect": __webpack_require__(442),
  "prefer-rest-params": __webpack_require__(443),
  "prefer-spread": __webpack_require__(444),
  "prefer-template": __webpack_require__(445),
  "quote-props": __webpack_require__(446),
  quotes: __webpack_require__(447),
  radix: __webpack_require__(448),
  "require-atomic-updates": __webpack_require__(449),
  "require-await": __webpack_require__(450),
  "require-jsdoc": __webpack_require__(451),
  "require-unicode-regexp": __webpack_require__(452),
  "require-yield": __webpack_require__(453),
  "rest-spread-spacing": __webpack_require__(454),
  semi: __webpack_require__(455),
  "semi-spacing": __webpack_require__(456),
  "semi-style": __webpack_require__(457),
  "sort-imports": __webpack_require__(458),
  "sort-keys": __webpack_require__(459),
  "sort-vars": __webpack_require__(461),
  "space-before-blocks": __webpack_require__(462),
  "space-before-function-paren": __webpack_require__(463),
  "space-in-parens": __webpack_require__(464),
  "space-infix-ops": __webpack_require__(465),
  "space-unary-ops": __webpack_require__(466),
  "spaced-comment": __webpack_require__(467),
  strict: __webpack_require__(468),
  "switch-colon-spacing": __webpack_require__(469),
  "symbol-description": __webpack_require__(470),
  "template-curly-spacing": __webpack_require__(471),
  "template-tag-spacing": __webpack_require__(472),
  "unicode-bom": __webpack_require__(473),
  "use-isnan": __webpack_require__(474),
  "valid-jsdoc": __webpack_require__(475),
  "valid-typeof": __webpack_require__(480),
  "vars-on-top": __webpack_require__(481),
  "wrap-iife": __webpack_require__(482),
  "wrap-regex": __webpack_require__(483),
  "yield-star-spacing": __webpack_require__(484),
  yoda: __webpack_require__(485)
};

/***/ }),
/* 203 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag wrapping non-iife in parens
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is an `Identifier` node which was named a given name.
 * @param {ASTNode} node - A node to check.
 * @param {string} name - An expected name of the node.
 * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
 */
function isIdentifier(node, name) {
  return node.type === "Identifier" && node.name === name;
}

/**
 * Checks whether or not a given node is an argument of a specified method call.
 * @param {ASTNode} node - A node to check.
 * @param {number} index - An expected index of the node in arguments.
 * @param {string} object - An expected name of the object of the method.
 * @param {string} property - An expected name of the method.
 * @returns {boolean} `true` if the node is an argument of the specified method call.
 */
function isArgumentOfMethodCall(node, index, object, property) {
  const parent = node.parent;
  return parent.type === "CallExpression" && parent.callee.type === "MemberExpression" && parent.callee.computed === false && isIdentifier(parent.callee.object, object) && isIdentifier(parent.callee.property, property) && parent.arguments[index] === node;
}

/**
 * Checks whether or not a given node is a property descriptor.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a property descriptor.
 */
function isPropertyDescriptor(node) {
  // Object.defineProperty(obj, "foo", {set: ...})
  if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
    return true;
  }

  /*
   * Object.defineProperties(obj, {foo: {set: ...}})
   * Object.create(proto, {foo: {set: ...}})
   */
  const grandparent = node.parent.parent;
  return grandparent.type === "ObjectExpression" && (isArgumentOfMethodCall(grandparent, 1, "Object", "create") || isArgumentOfMethodCall(grandparent, 1, "Object", "defineProperties"));
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce getter and setter pairs in objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/accessor-pairs"
    },
    schema: [{
      type: "object",
      properties: {
        getWithoutSet: {
          type: "boolean",
          default: false
        },
        setWithoutGet: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      getter: "Getter is not present.",
      setter: "Setter is not present."
    }
  },
  create(context) {
    const config = context.options[0] || {};
    const checkGetWithoutSet = config.getWithoutSet === true;
    const checkSetWithoutGet = config.setWithoutGet !== false;

    /**
     * Checks a object expression to see if it has setter and getter both present or none.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */
    function checkLonelySetGet(node) {
      let isSetPresent = false;
      let isGetPresent = false;
      const isDescriptor = isPropertyDescriptor(node);
      for (let i = 0, end = node.properties.length; i < end; i++) {
        const property = node.properties[i];
        let propToCheck = "";
        if (property.kind === "init") {
          if (isDescriptor && !property.computed) {
            propToCheck = property.key.name;
          }
        } else {
          propToCheck = property.kind;
        }
        switch (propToCheck) {
          case "set":
            isSetPresent = true;
            break;
          case "get":
            isGetPresent = true;
            break;
          default:

          // Do nothing
        }
        if (isSetPresent && isGetPresent) {
          break;
        }
      }
      if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
        context.report({
          node,
          messageId: "getter"
        });
      } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
        context.report({
          node,
          messageId: "setter"
        });
      }
    }
    return {
      ObjectExpression(node) {
        if (checkSetWithoutGet || checkGetWithoutSet) {
          checkLonelySetGet(node);
        }
      }
    };
  }
};

/***/ }),
/* 204 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce linebreaks after open and before close array brackets
 * @author Jan Peer Stcklmair <https://github.com/JPeer264>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce linebreaks after opening and before closing array brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-bracket-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent"]
      }, {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
      unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
      missingOpeningLinebreak: "A linebreak is required after '['.",
      missingClosingLinebreak: "A linebreak is required before ']'."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Normalizes a given option value.
     *
     * @param {string|Object|undefined} option - An option value to parse.
     * @returns {{multiline: boolean, minItems: number}} Normalized option object.
     */
    function normalizeOptionValue(option) {
      let consistent = false;
      let multiline = false;
      let minItems = 0;
      if (option) {
        if (option === "consistent") {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === "always" || option.minItems === 0) {
          minItems = 0;
        } else if (option === "never") {
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
      } else {
        consistent = false;
        multiline = true;
        minItems = Number.POSITIVE_INFINITY;
      }
      return {
        consistent,
        multiline,
        minItems
      };
    }

    /**
     * Normalizes a given option value.
     *
     * @param {string|Object|undefined} options - An option value to parse.
     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
     */
    function normalizeOptions(options) {
      const value = normalizeOptionValue(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }

    /**
     * Reports that there shouldn't be a linebreak after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedOpeningLinebreak",
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token, {
            includeComments: true
          });
          if (astUtils.isCommentToken(nextToken)) {
            return null;
          }
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }

    /**
     * Reports that there shouldn't be a linebreak before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "unexpectedClosingLinebreak",
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token, {
            includeComments: true
          });
          if (astUtils.isCommentToken(previousToken)) {
            return null;
          }
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }

    /**
     * Reports that there should be a linebreak after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredBeginningLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingOpeningLinebreak",
        fix(fixer) {
          return fixer.insertTextAfter(token, "\n");
        }
      });
    }

    /**
     * Reports that there should be a linebreak before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredEndingLinebreak(node, token) {
      context.report({
        node,
        loc: token.loc,
        messageId: "missingClosingLinebreak",
        fix(fixer) {
          return fixer.insertTextBefore(token, "\n");
        }
      });
    }

    /**
     * Reports a given node if it violated this rule.
     *
     * @param {ASTNode} node - A node to check. This is an ArrayExpression node or an ArrayPattern node.
     * @returns {void}
     */
    function check(node) {
      const elements = node.elements;
      const normalizedOptions = normalizeOptions(context.options[0]);
      const options = normalizedOptions[node.type];
      const openBracket = sourceCode.getFirstToken(node);
      const closeBracket = sourceCode.getLastToken(node);
      const firstIncComment = sourceCode.getTokenAfter(openBracket, {
        includeComments: true
      });
      const lastIncComment = sourceCode.getTokenBefore(closeBracket, {
        includeComments: true
      });
      const first = sourceCode.getTokenAfter(openBracket);
      const last = sourceCode.getTokenBefore(closeBracket);
      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && firstIncComment.loc.start.line !== openBracket.loc.end.line;

      /*
       * Use tokens or comments to check multiline or not.
       * But use only tokens to check whether linebreaks are needed.
       * This allows:
       *     var arr = [ // eslint-disable-line foo
       *         'a'
       *     ]
       */

      if (needsLinebreaks) {
        if (astUtils.isTokenOnSameLine(openBracket, first)) {
          reportRequiredBeginningLinebreak(node, openBracket);
        }
        if (astUtils.isTokenOnSameLine(last, closeBracket)) {
          reportRequiredEndingLinebreak(node, closeBracket);
        }
      } else {
        if (!astUtils.isTokenOnSameLine(openBracket, first)) {
          reportNoBeginningLinebreak(node, openBracket);
        }
        if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
          reportNoEndingLinebreak(node, closeBracket);
        }
      }
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
};

/***/ }),
/* 205 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside of array brackets.
 * @author Jamund Ferguson
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside array brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-bracket-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        singleValue: {
          type: "boolean"
        },
        objectsInArrays: {
          type: "boolean"
        },
        arraysInArrays: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'."
    }
  },
  create(context) {
    const spaced = context.options[0] === "always",
      sourceCode = context.getSourceCode();

    /**
     * Determines whether an option is set, relative to the spacing option.
     * If spaced is "always", then check whether option is set to false.
     * If spaced is "never", then check whether option is set to true.
     * @param {Object} option - The option to exclude.
     * @returns {boolean} Whether or not the property is excluded.
     */
    function isOptionSet(option) {
      return context.options[1] ? context.options[1][option] === !spaced : false;
    }
    const options = {
      spaced,
      singleElementException: isOptionSet("singleValue"),
      objectsInArraysException: isOptionSet("objectsInArrays"),
      arraysInArraysException: isOptionSet("arraysInArrays")
    };

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports that there shouldn't be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          const nextToken = sourceCode.getTokenAfter(token);
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }

    /**
     * Reports that there shouldn't be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(token);
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }

    /**
     * Reports that there should be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }

    /**
     * Reports that there should be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }

    /**
     * Determines if a node is an object type
     * @param {ASTNode} node - The node to check.
     * @returns {boolean} Whether or not the node is an object type.
     */
    function isObjectType(node) {
      return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
    }

    /**
     * Determines if a node is an array type
     * @param {ASTNode} node - The node to check.
     * @returns {boolean} Whether or not the node is an array type.
     */
    function isArrayType(node) {
      return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
    }

    /**
     * Validates the spacing around array brackets
     * @param {ASTNode} node - The node we're checking for spacing
     * @returns {void}
     */
    function validateArraySpacing(node) {
      if (options.spaced && node.elements.length === 0) {
        return;
      }
      const first = sourceCode.getFirstToken(node),
        second = sourceCode.getFirstToken(node, 1),
        last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node),
        penultimate = sourceCode.getTokenBefore(last),
        firstElement = node.elements[0],
        lastElement = node.elements[node.elements.length - 1];
      const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
      const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
      if (astUtils.isTokenOnSameLine(first, second)) {
        if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
          reportRequiredBeginningSpace(node, first);
        }
        if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
          reportNoBeginningSpace(node, first);
        }
      }
      if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
        if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
          reportRequiredEndingSpace(node, last);
        }
        if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
          reportNoEndingSpace(node, last);
        }
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ArrayPattern: validateArraySpacing,
      ArrayExpression: validateArraySpacing
    };
  }
};

/***/ }),
/* 206 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce return statements in callbacks of array's methods
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
const TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/u;

/**
 * Checks a given code path segment is reachable.
 *
 * @param {CodePathSegment} segment - A segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

/**
 * Gets a readable location.
 *
 * - FunctionExpression -> the function name or `function` keyword.
 * - ArrowFunctionExpression -> `=>` token.
 *
 * @param {ASTNode} node - A function node to get.
 * @param {SourceCode} sourceCode - A source code to get tokens.
 * @returns {ASTNode|Token} The node or the token of a location.
 */
function getLocation(node, sourceCode) {
  if (node.type === "ArrowFunctionExpression") {
    return sourceCode.getTokenBefore(node.body);
  }
  return node.id || node;
}

/**
 * Checks a given node is a MemberExpression node which has the specified name's
 * property.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a MemberExpression node which has
 *      the specified name's property
 */
function isTargetMethod(node) {
  return node.type === "MemberExpression" && TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || "");
}

/**
 * Checks whether or not a given node is a function expression which is the
 * callback of an array method.
 *
 * @param {ASTNode} node - A node to check. This is one of
 *      FunctionExpression or ArrowFunctionExpression.
 * @returns {boolean} `true` if the node is the callback of an array method.
 */
function isCallbackOfArrayMethod(node) {
  let currentNode = node;
  while (currentNode) {
    const parent = currentNode.parent;
    switch (parent.type) {
      /*
       * Looks up the destination. e.g.,
       * foo.every(nativeFoo || function foo() { ... });
       */
      case "LogicalExpression":
      case "ConditionalExpression":
        currentNode = parent;
        break;

      /*
       * If the upper function is IIFE, checks the destination of the return value.
       * e.g.
       *   foo.every((function() {
       *     // setup...
       *     return function callback() { ... };
       *   })());
       */
      case "ReturnStatement":
        {
          const func = astUtils.getUpperFunction(parent);
          if (func === null || !astUtils.isCallee(func)) {
            return false;
          }
          currentNode = func.parent;
          break;
        }

      /*
       * e.g.
       *   Array.from([], function() {});
       *   list.every(function() {});
       */
      case "CallExpression":
        if (astUtils.isArrayFromMethod(parent.callee)) {
          return parent.arguments.length >= 2 && parent.arguments[1] === currentNode;
        }
        if (isTargetMethod(parent.callee)) {
          return parent.arguments.length >= 1 && parent.arguments[0] === currentNode;
        }
        return false;

      // Otherwise this node is not target.
      default:
        return false;
    }
  }

  /* istanbul ignore next: unreachable */
  return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in callbacks of array methods",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-callback-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedAtEnd: "Expected to return a value at the end of {{name}}.",
      expectedInside: "Expected to return a value in {{name}}.",
      expectedReturnValue: "{{name}} expected a return value."
    }
  },
  create(context) {
    const options = context.options[0] || {
      allowImplicit: false
    };
    let funcInfo = {
      upper: null,
      codePath: null,
      hasReturn: false,
      shouldCheck: false,
      node: null
    };

    /**
     * Checks whether or not the last code path segment is reachable.
     * Then reports this function if the segment is reachable.
     *
     * If the last code path segment is reachable, there are paths which are not
     * returned or thrown.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function checkLastSegment(node) {
      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
        context.report({
          node,
          loc: getLocation(node, context.getSourceCode()).loc.start,
          messageId: funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside",
          data: {
            name: astUtils.getFunctionNameWithKind(funcInfo.node)
          }
        });
      }
    }
    return {
      // Stacks this function's information.
      onCodePathStart(codePath, node) {
        funcInfo = {
          upper: funcInfo,
          codePath,
          hasReturn: false,
          shouldCheck: TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement" && isCallbackOfArrayMethod(node) && !node.async && !node.generator,
          node
        };
      },
      // Pops this function's information.
      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },
      // Checks the return statement is valid.
      ReturnStatement(node) {
        if (funcInfo.shouldCheck) {
          funcInfo.hasReturn = true;

          // if allowImplicit: false, should also check node.argument
          if (!options.allowImplicit && !node.argument) {
            context.report({
              node,
              messageId: "expectedReturnValue",
              data: {
                name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
              }
            });
          }
        }
      },
      // Reports a given function if the last path is reachable.
      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }
};

/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce line breaks after each array element
 * @author Jan Peer Stcklmair <https://github.com/JPeer264>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks after each array element",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/array-element-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent"]
      }, {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedLineBreak: "There should be no linebreak here.",
      missingLineBreak: "There should be a linebreak after this element."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Normalizes a given option value.
     *
     * @param {string|Object|undefined} providedOption - An option value to parse.
     * @returns {{multiline: boolean, minItems: number}} Normalized option object.
     */
    function normalizeOptionValue(providedOption) {
      let consistent = false;
      let multiline = false;
      let minItems;
      const option = providedOption || "always";
      if (!option || option === "always" || option.minItems === 0) {
        minItems = 0;
      } else if (option === "never") {
        minItems = Number.POSITIVE_INFINITY;
      } else if (option === "consistent") {
        consistent = true;
        minItems = Number.POSITIVE_INFINITY;
      } else {
        multiline = Boolean(option.multiline);
        minItems = option.minItems || Number.POSITIVE_INFINITY;
      }
      return {
        consistent,
        multiline,
        minItems
      };
    }

    /**
     * Normalizes a given option value.
     *
     * @param {string|Object|undefined} options - An option value to parse.
     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
     */
    function normalizeOptions(options) {
      const value = normalizeOptionValue(options);
      return {
        ArrayExpression: value,
        ArrayPattern: value
      };
    }

    /**
     * Reports that there shouldn't be a line break after the first token
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "unexpectedLineBreak",
        fix(fixer) {
          if (astUtils.isCommentToken(tokenBefore)) {
            return null;
          }
          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
          }

          /*
           * This will check if the comma is on the same line as the next element
           * Following array:
           * [
           *     1
           *     , 2
           *     , 3
           * ]
           *
           * will be fixed to:
           * [
           *     1, 2, 3
           * ]
           */
          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {
            includeComments: true
          });
          if (astUtils.isCommentToken(twoTokensBefore)) {
            return null;
          }
          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
        }
      });
    }

    /**
     * Reports that there should be a line break after the first token
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredLineBreak(token) {
      const tokenBefore = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      context.report({
        loc: {
          start: tokenBefore.loc.end,
          end: token.loc.start
        },
        messageId: "missingLineBreak",
        fix(fixer) {
          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
        }
      });
    }

    /**
     * Reports a given node if it violated this rule.
     *
     * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
     * @returns {void}
     */
    function check(node) {
      const elements = node.elements;
      const normalizedOptions = normalizeOptions(context.options[0]);
      const options = normalizedOptions[node.type];
      let elementBreak = false;

      /*
       * MULTILINE: true
       * loop through every element and check
       * if at least one element has linebreaks inside
       * this ensures that following is not valid (due to elements are on the same line):
       *
       * [
       *      1,
       *      2,
       *      3
       * ]
       */
      if (options.multiline) {
        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);
      }
      const linebreaksCount = node.elements.map((element, i) => {
        const previousElement = elements[i - 1];
        if (i === 0 || element === null || previousElement === null) {
          return false;
        }
        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
      }).filter(isBreak => isBreak === true).length;
      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
      elements.forEach((element, i) => {
        const previousElement = elements[i - 1];
        if (i === 0 || element === null || previousElement === null) {
          return;
        }
        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
        if (needsLinebreaks) {
          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportRequiredLineBreak(firstTokenOfCurrentElement);
          }
        } else {
          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            reportNoLineBreak(firstTokenOfCurrentElement);
          }
        }
      });
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      ArrayPattern: check,
      ArrayExpression: check
    };
  }
};

/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require braces in arrow function body.
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require braces around arrow function bodies",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-body-style"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["as-needed"]
        }, {
          type: "object",
          properties: {
            requireReturnForObjectLiteral: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
      unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
      unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
      unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
      expectedBlock: "Expected block statement surrounding arrow body."
    }
  },
  create(context) {
    const options = context.options;
    const always = options[0] === "always";
    const asNeeded = !options[0] || options[0] === "as-needed";
    const never = options[0] === "never";
    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
    const sourceCode = context.getSourceCode();

    /**
     * Checks whether the given node has ASI problem or not.
     * @param {Token} token The token to check.
     * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.
     */
    function hasASIProblem(token) {
      return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
    }

    /**
     * Gets the closing parenthesis which is the pair of the given opening parenthesis.
     * @param {Token} token The opening parenthesis token to get.
     * @returns {Token} The found closing parenthesis token.
     */
    function findClosingParen(token) {
      let node = sourceCode.getNodeByRangeIndex(token.range[1]);
      while (!astUtils.isParenthesised(sourceCode, node)) {
        node = node.parent;
      }
      return sourceCode.getTokenAfter(node);
    }

    /**
     * Determines whether a arrow function body needs braces
     * @param {ASTNode} node The arrow function node.
     * @returns {void}
     */
    function validate(node) {
      const arrowBody = node.body;
      if (arrowBody.type === "BlockStatement") {
        const blockBody = arrowBody.body;
        if (blockBody.length !== 1 && !never) {
          return;
        }
        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
          return;
        }
        if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
          let messageId;
          if (blockBody.length === 0) {
            messageId = "unexpectedEmptyBlock";
          } else if (blockBody.length > 1) {
            messageId = "unexpectedOtherBlock";
          } else if (blockBody[0].argument === null) {
            messageId = "unexpectedSingleBlock";
          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {
            skip: 1
          }))) {
            messageId = "unexpectedObjectBlock";
          } else {
            messageId = "unexpectedSingleBlock";
          }
          context.report({
            node,
            loc: arrowBody.loc.start,
            messageId,
            fix(fixer) {
              const fixes = [];
              if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
                return fixes;
              }
              const openingBrace = sourceCode.getFirstToken(arrowBody);
              const closingBrace = sourceCode.getLastToken(arrowBody);
              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
              const lastValueToken = sourceCode.getLastToken(blockBody[0]);
              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);

              /*
               * Remove tokens around the return value.
               * If comments don't exist, remove extra spaces as well.
               */
              if (commentsExist) {
                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword
                );
              } else {
                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));
              }

              /*
               * If the first token of the reutrn value is `{`,
               * enclose the return value by parentheses to avoid syntax error.
               */
              if (astUtils.isOpeningBraceToken(firstValueToken)) {
                fixes.push(fixer.insertTextBefore(firstValueToken, "("), fixer.insertTextAfter(lastValueToken, ")"));
              }

              /*
               * If the last token of the return statement is semicolon, remove it.
               * Non-block arrow body is an expression, not a statement.
               */
              if (astUtils.isSemicolonToken(lastValueToken)) {
                fixes.push(fixer.remove(lastValueToken));
              }
              return fixes;
            }
          });
        }
      } else {
        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
          context.report({
            node,
            loc: arrowBody.loc.start,
            messageId: "expectedBlock",
            fix(fixer) {
              const fixes = [];
              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
              const firstBodyToken = sourceCode.getTokenAfter(arrowToken);
              const lastBodyToken = sourceCode.getLastToken(node);
              const isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstBodyToken) && astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));

              // Wrap the value by a block and a return statement.
              fixes.push(fixer.insertTextBefore(firstBodyToken, "{return "), fixer.insertTextAfter(lastBodyToken, "}"));

              // If the value is object literal, remove parentheses which were forced by syntax.
              if (isParenthesisedObjectLiteral) {
                fixes.push(fixer.remove(firstBodyToken), fixer.remove(findClosingParen(firstBodyToken)));
              }
              return fixes;
            }
          });
        }
      }
    }
    return {
      "ArrowFunctionExpression:exit": validate
    };
  }
};

/***/ }),
/* 209 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require parens in arrow function arguments.
 * @author Jxck
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around arrow function arguments",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-parens"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "as-needed"]
    }, {
      type: "object",
      properties: {
        requireForBlockBody: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedParens: "Unexpected parentheses around single function argument.",
      expectedParens: "Expected parentheses around arrow function argument.",
      unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
      expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
    }
  },
  create(context) {
    const asNeeded = context.options[0] === "as-needed";
    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
    const sourceCode = context.getSourceCode();

    /**
     * Determines whether a arrow function argument end with `)`
     * @param {ASTNode} node The arrow function node.
     * @returns {void}
     */
    function parens(node) {
      const isAsync = node.async;
      const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);

      /**
       * Remove the parenthesis around a parameter
       * @param {Fixer} fixer Fixer
       * @returns {string} fixed parameter
       */
      function fixParamsWithParenthesis(fixer) {
        const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);

        /*
         * ES8 allows Trailing commas in function parameter lists and calls
         * https://github.com/eslint/eslint/issues/8834
         */
        const closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);
        const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;
        const shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];
        return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], `${shouldAddSpaceForAsync ? " " : ""}${paramToken.value}`);
      }

      // "as-needed", { "requireForBlockBody": true }: x => x
      if (requireForBlockBody && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && node.body.type !== "BlockStatement" && !node.returnType) {
        if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
          context.report({
            node,
            messageId: "unexpectedParensInline",
            fix: fixParamsWithParenthesis
          });
        }
        return;
      }
      if (requireForBlockBody && node.body.type === "BlockStatement") {
        if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {
          context.report({
            node,
            messageId: "expectedParensBlock",
            fix(fixer) {
              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
            }
          });
        }
        return;
      }

      // "as-needed": x => x
      if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.returnType) {
        if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
          context.report({
            node,
            messageId: "unexpectedParens",
            fix: fixParamsWithParenthesis
          });
        }
        return;
      }
      if (firstTokenOfParam.type === "Identifier") {
        const after = sourceCode.getTokenAfter(firstTokenOfParam);

        // (x) => x
        if (after.value !== ")") {
          context.report({
            node,
            messageId: "expectedParens",
            fix(fixer) {
              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);
            }
          });
        }
      }
    }
    return {
      ArrowFunctionExpression: parens
    };
  }
};

/***/ }),
/* 210 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to define spacing before/after arrow function's arrow.
 * @author Jxck
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after the arrow in arrow functions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/arrow-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: true
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedBefore: "Missing space before =>.",
      unexpectedBefore: "Unexpected space before =>.",
      expectedAfter: "Missing space after =>.",
      unexpectedAfter: "Unexpected space after =>."
    }
  },
  create(context) {
    // merge rules with default
    const rule = Object.assign({}, context.options[0]);
    rule.before = rule.before !== false;
    rule.after = rule.after !== false;
    const sourceCode = context.getSourceCode();

    /**
     * Get tokens of arrow(`=>`) and before/after arrow.
     * @param {ASTNode} node The arrow function node.
     * @returns {Object} Tokens of arrow and before/after arrow.
     */
    function getTokens(node) {
      const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);
      return {
        before: sourceCode.getTokenBefore(arrow),
        arrow,
        after: sourceCode.getTokenAfter(arrow)
      };
    }

    /**
     * Count spaces before/after arrow(`=>`) token.
     * @param {Object} tokens Tokens before/after arrow.
     * @returns {Object} count of space before/after arrow.
     */
    function countSpaces(tokens) {
      const before = tokens.arrow.range[0] - tokens.before.range[1];
      const after = tokens.after.range[0] - tokens.arrow.range[1];
      return {
        before,
        after
      };
    }

    /**
     * Determines whether space(s) before after arrow(`=>`) is satisfy rule.
     * if before/after value is `true`, there should be space(s).
     * if before/after value is `false`, there should be no space.
     * @param {ASTNode} node The arrow function node.
     * @returns {void}
     */
    function spaces(node) {
      const tokens = getTokens(node);
      const countSpace = countSpaces(tokens);
      if (rule.before) {
        // should be space(s) before arrow
        if (countSpace.before === 0) {
          context.report({
            node: tokens.before,
            messageId: "expectedBefore",
            fix(fixer) {
              return fixer.insertTextBefore(tokens.arrow, " ");
            }
          });
        }
      } else {
        // should be no space before arrow
        if (countSpace.before > 0) {
          context.report({
            node: tokens.before,
            messageId: "unexpectedBefore",
            fix(fixer) {
              return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
            }
          });
        }
      }
      if (rule.after) {
        // should be space(s) after arrow
        if (countSpace.after === 0) {
          context.report({
            node: tokens.after,
            messageId: "expectedAfter",
            fix(fixer) {
              return fixer.insertTextAfter(tokens.arrow, " ");
            }
          });
        }
      } else {
        // should be no space after arrow
        if (countSpace.after > 0) {
          context.report({
            node: tokens.after,
            messageId: "unexpectedAfter",
            fix(fixer) {
              return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
            }
          });
        }
      }
    }
    return {
      ArrowFunctionExpression: spaces
    };
  }
};

/***/ }),
/* 211 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for "block scoped" variables by binding context
 * @author Matt DuVall <http://www.mattduvall.com>
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of variables within the scope they are defined",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/block-scoped-var"
    },
    schema: [],
    messages: {
      outOfScope: "'{{name}}' used outside of binding context."
    }
  },
  create(context) {
    let stack = [];

    /**
     * Makes a block scope.
     * @param {ASTNode} node - A node of a scope.
     * @returns {void}
     */
    function enterScope(node) {
      stack.push(node.range);
    }

    /**
     * Pops the last block scope.
     * @returns {void}
     */
    function exitScope() {
      stack.pop();
    }

    /**
     * Reports a given reference.
     * @param {eslint-scope.Reference} reference - A reference to report.
     * @returns {void}
     */
    function report(reference) {
      const identifier = reference.identifier;
      context.report({
        node: identifier,
        messageId: "outOfScope",
        data: {
          name: identifier.name
        }
      });
    }

    /**
     * Finds and reports references which are outside of valid scopes.
     * @param {ASTNode} node - A node to get variables.
     * @returns {void}
     */
    function checkForVariables(node) {
      if (node.kind !== "var") {
        return;
      }

      // Defines a predicate to check whether or not a given reference is outside of valid scope.
      const scopeRange = stack[stack.length - 1];

      /**
       * Check if a reference is out of scope
       * @param {ASTNode} reference node to examine
       * @returns {boolean} True is its outside the scope
       * @private
       */
      function isOutsideOfScope(reference) {
        const idRange = reference.identifier.range;
        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
      }

      // Gets declared variables, and checks its references.
      const variables = context.getDeclaredVariables(node);
      for (let i = 0; i < variables.length; ++i) {
        // Reports.
        variables[i].references.filter(isOutsideOfScope).forEach(report);
      }
    }
    return {
      Program(node) {
        stack = [node.range];
      },
      // Manages scopes.
      BlockStatement: enterScope,
      "BlockStatement:exit": exitScope,
      ForStatement: enterScope,
      "ForStatement:exit": exitScope,
      ForInStatement: enterScope,
      "ForInStatement:exit": exitScope,
      ForOfStatement: enterScope,
      "ForOfStatement:exit": exitScope,
      SwitchStatement: enterScope,
      "SwitchStatement:exit": exitScope,
      CatchClause: enterScope,
      "CatchClause:exit": exitScope,
      // Finds and reports references which are outside of valid scope.
      VariableDeclaration: checkForVariables
    };
  }
};

/***/ }),
/* 212 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.
 * @author Toru Nagashima
 */



const util = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/block-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      missing: "Requires a space {{location}} '{{token}}'.",
      extra: "Unexpected space(s) {{location}} '{{token}}'."
    }
  },
  create(context) {
    const always = context.options[0] !== "never",
      messageId = always ? "missing" : "extra",
      sourceCode = context.getSourceCode();

    /**
     * Gets the open brace token from a given node.
     * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
     * @returns {Token} The token of the open brace.
     */
    function getOpenBrace(node) {
      if (node.type === "SwitchStatement") {
        if (node.cases.length > 0) {
          return sourceCode.getTokenBefore(node.cases[0]);
        }
        return sourceCode.getLastToken(node, 1);
      }
      return sourceCode.getFirstToken(node);
    }

    /**
     * Checks whether or not:
     *   - given tokens are on same line.
     *   - there is/isn't a space between given tokens.
     * @param {Token} left - A token to check.
     * @param {Token} right - The token which is next to `left`.
     * @returns {boolean}
     *    When the option is `"always"`, `true` if there are one or more spaces between given tokens.
     *    When the option is `"never"`, `true` if there are not any spaces between given tokens.
     *    If given tokens are not on same line, it's always `true`.
     */
    function isValid(left, right) {
      return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
    }

    /**
     * Reports invalid spacing style inside braces.
     * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
     * @returns {void}
     */
    function checkSpacingInsideBraces(node) {
      // Gets braces and the first/last token of content.
      const openBrace = getOpenBrace(node);
      const closeBrace = sourceCode.getLastToken(node);
      const firstToken = sourceCode.getTokenAfter(openBrace, {
        includeComments: true
      });
      const lastToken = sourceCode.getTokenBefore(closeBrace, {
        includeComments: true
      });

      // Skip if the node is invalid or empty.
      if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
        return;
      }

      // Skip line comments for option never
      if (!always && firstToken.type === "Line") {
        return;
      }

      // Check.
      if (!isValid(openBrace, firstToken)) {
        context.report({
          node,
          loc: openBrace.loc.start,
          messageId,
          data: {
            location: "after",
            token: openBrace.value
          },
          fix(fixer) {
            if (always) {
              return fixer.insertTextBefore(firstToken, " ");
            }
            return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
          }
        });
      }
      if (!isValid(lastToken, closeBrace)) {
        context.report({
          node,
          loc: closeBrace.loc.start,
          messageId,
          data: {
            location: "before",
            token: closeBrace.value
          },
          fix(fixer) {
            if (always) {
              return fixer.insertTextAfter(lastToken, " ");
            }
            return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
          }
        });
      }
    }
    return {
      BlockStatement: checkSpacingInsideBraces,
      SwitchStatement: checkSpacingInsideBraces
    };
  }
};

/***/ }),
/* 213 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag block statements that do not use the one true brace style
 * @author Ian Christian Myers
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent brace style for blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/brace-style"
    },
    schema: [{
      enum: ["1tbs", "stroustrup", "allman"]
    }, {
      type: "object",
      properties: {
        allowSingleLine: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace",
    messages: {
      nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
      sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
      blockSameLine: "Statement inside of curly braces should be on next line.",
      nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
      singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
      sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
    }
  },
  create(context) {
    const style = context.options[0] || "1tbs",
      params = context.options[1] || {},
      sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Fixes a place where a newline unexpectedly appears
     * @param {Token} firstToken The token before the unexpected newline
     * @param {Token} secondToken The token after the unexpected newline
     * @returns {Function} A fixer function to remove the newlines between the tokens
     */
    function removeNewlineBetween(firstToken, secondToken) {
      const textRange = [firstToken.range[1], secondToken.range[0]];
      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);

      // Don't do a fix if there is a comment between the tokens
      if (textBetween.trim()) {
        return null;
      }
      return fixer => fixer.replaceTextRange(textRange, " ");
    }

    /**
     * Validates a pair of curly brackets based on the user's config
     * @param {Token} openingCurly The opening curly bracket
     * @param {Token} closingCurly The closing curly bracket
     * @returns {void}
     */
    function validateCurlyPair(openingCurly, closingCurly) {
      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);
      if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
        context.report({
          node: openingCurly,
          messageId: "nextLineOpen",
          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
        });
      }
      if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
        context.report({
          node: openingCurly,
          messageId: "sameLineOpen",
          fix: fixer => fixer.insertTextBefore(openingCurly, "\n")
        });
      }
      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
        context.report({
          node: openingCurly,
          messageId: "blockSameLine",
          fix: fixer => fixer.insertTextAfter(openingCurly, "\n")
        });
      }
      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
        context.report({
          node: closingCurly,
          messageId: "singleLineClose",
          fix: fixer => fixer.insertTextBefore(closingCurly, "\n")
        });
      }
    }

    /**
     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)
     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).
     * @returns {void}
     */
    function validateCurlyBeforeKeyword(curlyToken) {
      const keywordToken = sourceCode.getTokenAfter(curlyToken);
      if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
        context.report({
          node: curlyToken,
          messageId: "nextLineClose",
          fix: removeNewlineBetween(curlyToken, keywordToken)
        });
      }
      if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
        context.report({
          node: curlyToken,
          messageId: "sameLineClose",
          fix: fixer => fixer.insertTextAfter(curlyToken, "\n")
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      BlockStatement(node) {
        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
        }
      },
      ClassBody(node) {
        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
      },
      SwitchStatement(node) {
        const closingCurly = sourceCode.getLastToken(node);
        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);
        validateCurlyPair(openingCurly, closingCurly);
      },
      IfStatement(node) {
        if (node.consequent.type === "BlockStatement" && node.alternate) {
          // Handle the keyword after the `if` block (before `else`)
          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
        }
      },
      TryStatement(node) {
        // Handle the keyword after the `try` block (before `catch` or `finally`)
        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));
        if (node.handler && node.finalizer) {
          // Handle the keyword after the `catch` block (before `finally`)
          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
        }
      }
    };
  }
};

/***/ }),
/* 214 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Enforce return after a callback.
 * @author Jamund Ferguson
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `return` statements after callbacks",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/callback-return"
    },
    schema: [{
      type: "array",
      items: {
        type: "string"
      }
    }],
    messages: {
      missingReturn: "Expected return with your callback function."
    }
  },
  create(context) {
    const callbacks = context.options[0] || ["callback", "cb", "next"],
      sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Find the closest parent matching a list of types.
     * @param {ASTNode} node The node whose parents we are searching
     * @param {Array} types The node types to match
     * @returns {ASTNode} The matched node or undefined.
     */
    function findClosestParentOfType(node, types) {
      if (!node.parent) {
        return null;
      }
      if (types.indexOf(node.parent.type) === -1) {
        return findClosestParentOfType(node.parent, types);
      }
      return node.parent;
    }

    /**
     * Check to see if a node contains only identifers
     * @param {ASTNode} node The node to check
     * @returns {boolean} Whether or not the node contains only identifers
     */
    function containsOnlyIdentifiers(node) {
      if (node.type === "Identifier") {
        return true;
      }
      if (node.type === "MemberExpression") {
        if (node.object.type === "Identifier") {
          return true;
        }
        if (node.object.type === "MemberExpression") {
          return containsOnlyIdentifiers(node.object);
        }
      }
      return false;
    }

    /**
     * Check to see if a CallExpression is in our callback list.
     * @param {ASTNode} node The node to check against our callback names list.
     * @returns {boolean} Whether or not this function matches our callback name.
     */
    function isCallback(node) {
      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
    }

    /**
     * Determines whether or not the callback is part of a callback expression.
     * @param {ASTNode} node The callback node
     * @param {ASTNode} parentNode The expression node
     * @returns {boolean} Whether or not this is part of a callback expression
     */
    function isCallbackExpression(node, parentNode) {
      // ensure the parent node exists and is an expression
      if (!parentNode || parentNode.type !== "ExpressionStatement") {
        return false;
      }

      // cb()
      if (parentNode.expression === node) {
        return true;
      }

      // special case for cb && cb() and similar
      if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
        if (parentNode.expression.right === node) {
          return true;
        }
      }
      return false;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      CallExpression(node) {
        // if we're not a callback we can return
        if (!isCallback(node)) {
          return;
        }

        // find the closest block, return or loop
        const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};

        // if our parent is a return we know we're ok
        if (closestBlock.type === "ReturnStatement") {
          return;
        }

        // arrow functions don't always have blocks and implicitly return
        if (closestBlock.type === "ArrowFunctionExpression") {
          return;
        }

        // block statements are part of functions and most if statements
        if (closestBlock.type === "BlockStatement") {
          // find the last item in the block
          const lastItem = closestBlock.body[closestBlock.body.length - 1];

          // if the callback is the last thing in a block that might be ok
          if (isCallbackExpression(node, lastItem)) {
            const parentType = closestBlock.parent.type;

            // but only if the block is part of a function
            if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
              return;
            }
          }

          // ending a block with a return is also ok
          if (lastItem.type === "ReturnStatement") {
            // but only if the callback is immediately before
            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
              return;
            }
          }
        }

        // as long as you're the child of a function at this point you should be asked to return
        if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
          context.report({
            node,
            messageId: "missingReturn"
          });
        }
      }
    };
  }
};

/***/ }),
/* 215 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag non-camelcased identifiers
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce camelcase naming convention",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/camelcase"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: false
        },
        properties: {
          enum: ["always", "never"]
        },
        allow: {
          type: "array",
          items: [{
            type: "string"
          }],
          minItems: 0,
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      notCamelCase: "Identifier '{{name}}' is not in camel case."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    let properties = options.properties || "";
    const ignoreDestructuring = options.ignoreDestructuring;
    const allow = options.allow || [];
    if (properties !== "always" && properties !== "never") {
      properties = "always";
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation
    const reported = [];
    const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);

    /**
     * Checks if a string contains an underscore and isn't all upper-case
     * @param {string} name The string to check.
     * @returns {boolean} if the string is underscored
     * @private
     */
    function isUnderscored(name) {
      // if there's an underscore, it might be A_CONSTANT, which is okay
      return name.indexOf("_") > -1 && name !== name.toUpperCase();
    }

    /**
     * Checks if a string match the ignore list
     * @param {string} name The string to check.
     * @returns {boolean} if the string is ignored
     * @private
     */
    function isAllowed(name) {
      return allow.findIndex(entry => name === entry || name.match(new RegExp(entry)) // eslint-disable-line require-unicode-regexp
      ) !== -1;
    }

    /**
     * Checks if a parent of a node is an ObjectPattern.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} if the node is inside an ObjectPattern
     * @private
     */
    function isInsideObjectPattern(node) {
      let current = node;
      while (current) {
        const parent = current.parent;
        if (parent && parent.type === "Property" && parent.computed && parent.key === current) {
          return false;
        }
        if (current.type === "ObjectPattern") {
          return true;
        }
        current = parent;
      }
      return false;
    }

    /**
     * Reports an AST node as a rule violation.
     * @param {ASTNode} node The node to report.
     * @returns {void}
     * @private
     */
    function report(node) {
      if (reported.indexOf(node) < 0) {
        reported.push(node);
        context.report({
          node,
          messageId: "notCamelCase",
          data: {
            name: node.name
          }
        });
      }
    }
    return {
      Identifier(node) {
        /*
         * Leading and trailing underscores are commonly used to flag
         * private/protected identifiers, strip them before checking if underscored
         */
        const name = node.name,
          nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, "")),
          effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;

        // First, we ignore the node if it match the ignore list
        if (isAllowed(name)) {
          return;
        }

        // MemberExpressions get special rules
        if (node.parent.type === "MemberExpression") {
          // "never" check properties
          if (properties === "never") {
            return;
          }

          // Always report underscored object names
          if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && nameIsUnderscored) {
            report(node);

            // Report AssignmentExpressions only if they are the left side of the assignment
          } else if (effectiveParent.type === "AssignmentExpression" && nameIsUnderscored && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
            report(node);
          }

          /*
           * Properties have their own rules, and
           * AssignmentPattern nodes can be treated like Properties:
           * e.g.: const { no_camelcased = false } = bar;
           */
        } else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") {
          if (node.parent.parent && node.parent.parent.type === "ObjectPattern") {
            if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {
              report(node);
            }
            const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;
            if (isUnderscored(name) && node.parent.computed) {
              report(node);
            }

            // prevent checking righthand side of destructured object
            if (node.parent.key === node && node.parent.value !== node) {
              return;
            }
            const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;

            // ignore destructuring if the option is set, unless a new identifier is created
            if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
              report(node);
            }
          }

          // "never" check properties or always ignore destructuring
          if (properties === "never" || ignoreDestructuring && isInsideObjectPattern(node)) {
            return;
          }

          // don't check right hand side of AssignmentExpression to prevent duplicate warnings
          if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {
            report(node);
          }

          // Check if it's an import specifier
        } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) {
          // Report only if the local imported identifier is underscored
          if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {
            report(node);
          }

          // Report anything that is underscored that isn't a CallExpression
        } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
          report(node);
        }
      }
    };
  }
};

/***/ }),
/* 216 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview enforce or disallow capitalization of the first letter of a comment
 * @author Kevin Partington
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const LETTER_PATTERN = __webpack_require__(217);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
  WHITESPACE = /\s/gu,
  MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u; // TODO: Combine w/ max-len pattern?

/*
 * Base schema body for defining the basic capitalization rule, ignorePattern,
 * and ignoreInlineComments values.
 * This can be used in a few different ways in the actual schema.
 */
const SCHEMA_BODY = {
  type: "object",
  properties: {
    ignorePattern: {
      type: "string"
    },
    ignoreInlineComments: {
      type: "boolean"
    },
    ignoreConsecutiveComments: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
const DEFAULTS = {
  ignorePattern: "",
  ignoreInlineComments: false,
  ignoreConsecutiveComments: false
};

/**
 * Get normalized options for either block or line comments from the given
 * user-provided options.
 * - If the user-provided options is just a string, returns a normalized
 *   set of options using default values for all other options.
 * - If the user-provided options is an object, then a normalized option
 *   set is returned. Options specified in overrides will take priority
 *   over options specified in the main options object, which will in
 *   turn take priority over the rule's defaults.
 *
 * @param {Object|string} rawOptions The user-provided options.
 * @param {string} which Either "line" or "block".
 * @returns {Object} The normalized options.
 */
function getNormalizedOptions() {
  let rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  let which = arguments.length > 1 ? arguments[1] : undefined;
  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
}

/**
 * Get normalized options for block and line comments.
 *
 * @param {Object|string} rawOptions The user-provided options.
 * @returns {Object} An object with "Line" and "Block" keys and corresponding
 * normalized options objects.
 */
function getAllNormalizedOptions(rawOptions) {
  return {
    Line: getNormalizedOptions(rawOptions, "line"),
    Block: getNormalizedOptions(rawOptions, "block")
  };
}

/**
 * Creates a regular expression for each ignorePattern defined in the rule
 * options.
 *
 * This is done in order to avoid invoking the RegExp constructor repeatedly.
 *
 * @param {Object} normalizedOptions The normalized rule options.
 * @returns {void}
 */
function createRegExpForIgnorePatterns(normalizedOptions) {
  Object.keys(normalizedOptions).forEach(key => {
    const ignorePatternStr = normalizedOptions[key].ignorePattern;
    if (ignorePatternStr) {
      const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`); // eslint-disable-line require-unicode-regexp

      normalizedOptions[key].ignorePatternRegExp = regExp;
    }
  });
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce or disallow capitalization of the first letter of a comment",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/capitalized-comments"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "never"]
    }, {
      oneOf: [SCHEMA_BODY, {
        type: "object",
        properties: {
          line: SCHEMA_BODY,
          block: SCHEMA_BODY
        },
        additionalProperties: false
      }]
    }],
    messages: {
      unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
      unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
    }
  },
  create(context) {
    const capitalize = context.options[0] || "always",
      normalizedOptions = getAllNormalizedOptions(context.options[1]),
      sourceCode = context.getSourceCode();
    createRegExpForIgnorePatterns(normalizedOptions);

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Checks whether a comment is an inline comment.
     *
     * For the purpose of this rule, a comment is inline if:
     * 1. The comment is preceded by a token on the same line; and
     * 2. The command is followed by a token on the same line.
     *
     * Note that the comment itself need not be single-line!
     *
     * Also, it follows from this definition that only block comments can
     * be considered as possibly inline. This is because line comments
     * would consume any following tokens on the same line as the comment.
     *
     * @param {ASTNode} comment The comment node to check.
     * @returns {boolean} True if the comment is an inline comment, false
     * otherwise.
     */
    function isInlineComment(comment) {
      const previousToken = sourceCode.getTokenBefore(comment, {
          includeComments: true
        }),
        nextToken = sourceCode.getTokenAfter(comment, {
          includeComments: true
        });
      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);
    }

    /**
     * Determine if a comment follows another comment.
     *
     * @param {ASTNode} comment The comment to check.
     * @returns {boolean} True if the comment follows a valid comment.
     */
    function isConsecutiveComment(comment) {
      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {
        includeComments: true
      });
      return Boolean(previousTokenOrComment && ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1);
    }

    /**
     * Check a comment to determine if it is valid for this rule.
     *
     * @param {ASTNode} comment The comment node to process.
     * @param {Object} options The options for checking this comment.
     * @returns {boolean} True if the comment is valid, false otherwise.
     */
    function isCommentValid(comment, options) {
      // 1. Check for default ignore pattern.
      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
        return true;
      }

      // 2. Check for custom ignore pattern.
      const commentWithoutAsterisks = comment.value.replace(/\*/gu, "");
      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
        return true;
      }

      // 3. Check for inline comments.
      if (options.ignoreInlineComments && isInlineComment(comment)) {
        return true;
      }

      // 4. Is this a consecutive comment (and are we tolerating those)?
      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
        return true;
      }

      // 5. Does the comment start with a possible URL?
      if (MAYBE_URL.test(commentWithoutAsterisks)) {
        return true;
      }

      // 6. Is the initial word character a letter?
      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");
      if (commentWordCharsOnly.length === 0) {
        return true;
      }
      const firstWordChar = commentWordCharsOnly[0];
      if (!LETTER_PATTERN.test(firstWordChar)) {
        return true;
      }

      // 7. Check the case of the initial word character.
      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
        isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();
      if (capitalize === "always" && isLowercase) {
        return false;
      }
      if (capitalize === "never" && isUppercase) {
        return false;
      }
      return true;
    }

    /**
     * Process a comment to determine if it needs to be reported.
     *
     * @param {ASTNode} comment The comment node to process.
     * @returns {void}
     */
    function processComment(comment) {
      const options = normalizedOptions[comment.type],
        commentValid = isCommentValid(comment, options);
      if (!commentValid) {
        const messageId = capitalize === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
        context.report({
          node: null,
          // Intentionally using loc instead
          loc: comment.loc,
          messageId,
          fix(fixer) {
            const match = comment.value.match(LETTER_PATTERN);
            return fixer.replaceTextRange(
            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)
            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());
          }
        });
      }
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(processComment);
      }
    };
  }
};

/***/ }),
/* 217 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
 * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
 * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
 * @author Kevin Partington
 * @license MIT License (from JSCS). See below.
 */

/*
 * The MIT License (MIT)
 *
 * Copyright 2013-2016 Dulin Marat and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;

/***/ }),
/* 218 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce that all class methods use 'this'.
 * @author Patrick Williams
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce that class methods utilize `this`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/class-methods-use-this"
    },
    schema: [{
      type: "object",
      properties: {
        exceptMethods: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingThis: "Expected 'this' to be used by class method '{{name}}'."
    }
  },
  create(context) {
    const config = Object.assign({}, context.options[0]);
    const exceptMethods = new Set(config.exceptMethods || []);
    const stack = [];

    /**
     * Initializes the current context to false and pushes it onto the stack.
     * These booleans represent whether 'this' has been used in the context.
     * @returns {void}
     * @private
     */
    function enterFunction() {
      stack.push(false);
    }

    /**
     * Check if the node is an instance method
     * @param {ASTNode} node - node to check
     * @returns {boolean} True if its an instance method
     * @private
     */
    function isInstanceMethod(node) {
      return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
    }

    /**
     * Check if the node is an instance method not excluded by config
     * @param {ASTNode} node - node to check
     * @returns {boolean} True if it is an instance method, and not excluded by config
     * @private
     */
    function isIncludedInstanceMethod(node) {
      return isInstanceMethod(node) && !exceptMethods.has(node.key.name);
    }

    /**
     * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
     * Static methods and the constructor are exempt.
     * Then pops the context off the stack.
     * @param {ASTNode} node - A function node that was entered.
     * @returns {void}
     * @private
     */
    function exitFunction(node) {
      const methodUsesThis = stack.pop();
      if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
        context.report({
          node,
          messageId: "missingThis",
          data: {
            name: node.parent.key.name
          }
        });
      }
    }

    /**
     * Mark the current context as having used 'this'.
     * @returns {void}
     * @private
     */
    function markThisUsed() {
      if (stack.length) {
        stack[stack.length - 1] = true;
      }
    }
    return {
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      ThisExpression: markThisUsed,
      Super: markThisUsed
    };
  }
};

/***/ }),
/* 219 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to forbid or enforce dangling commas.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_OPTIONS = Object.freeze({
  arrays: "never",
  objects: "never",
  imports: "never",
  exports: "never",
  functions: "ignore"
});

/**
 * Checks whether or not a trailing comma is allowed in a given node.
 * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.
 *
 * @param {ASTNode} lastItem - The node of the last element in the given node.
 * @returns {boolean} `true` if a trailing comma is allowed.
 */
function isTrailingCommaAllowed(lastItem) {
  return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
}

/**
 * Normalize option value.
 *
 * @param {string|Object|undefined} optionValue - The 1st option value to normalize.
 * @returns {Object} The normalized option value.
 */
function normalizeOptions(optionValue) {
  if (typeof optionValue === "string") {
    return {
      arrays: optionValue,
      objects: optionValue,
      imports: optionValue,
      exports: optionValue,
      // For backward compatibility, always ignore functions.
      functions: "ignore"
    };
  }
  if (typeof optionValue === "object" && optionValue !== null) {
    return {
      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
      objects: optionValue.objects || DEFAULT_OPTIONS.objects,
      imports: optionValue.imports || DEFAULT_OPTIONS.imports,
      exports: optionValue.exports || DEFAULT_OPTIONS.exports,
      functions: optionValue.functions || DEFAULT_OPTIONS.functions
    };
  }
  return DEFAULT_OPTIONS;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow trailing commas",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-dangle"
    },
    fixable: "code",
    schema: {
      definitions: {
        value: {
          enum: ["always-multiline", "always", "never", "only-multiline"]
        },
        valueWithIgnore: {
          enum: ["always-multiline", "always", "ignore", "never", "only-multiline"]
        }
      },
      type: "array",
      items: [{
        oneOf: [{
          $ref: "#/definitions/value"
        }, {
          type: "object",
          properties: {
            arrays: {
              $ref: "#/definitions/valueWithIgnore"
            },
            objects: {
              $ref: "#/definitions/valueWithIgnore"
            },
            imports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            exports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            functions: {
              $ref: "#/definitions/valueWithIgnore"
            }
          },
          additionalProperties: false
        }]
      }]
    },
    messages: {
      unexpected: "Unexpected trailing comma.",
      missing: "Missing trailing comma."
    }
  },
  create(context) {
    const options = normalizeOptions(context.options[0]);
    const sourceCode = context.getSourceCode();

    /**
     * Gets the last item of the given node.
     * @param {ASTNode} node - The node to get.
     * @returns {ASTNode|null} The last node or null.
     */
    function getLastItem(node) {
      switch (node.type) {
        case "ObjectExpression":
        case "ObjectPattern":
          return lodash.last(node.properties);
        case "ArrayExpression":
        case "ArrayPattern":
          return lodash.last(node.elements);
        case "ImportDeclaration":
        case "ExportNamedDeclaration":
          return lodash.last(node.specifiers);
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
          return lodash.last(node.params);
        case "CallExpression":
        case "NewExpression":
          return lodash.last(node.arguments);
        default:
          return null;
      }
    }

    /**
     * Gets the trailing comma token of the given node.
     * If the trailing comma does not exist, this returns the token which is
     * the insertion point of the trailing comma token.
     *
     * @param {ASTNode} node - The node to get.
     * @param {ASTNode} lastItem - The last item of the node.
     * @returns {Token} The trailing comma token or the insertion point.
     */
    function getTrailingToken(node, lastItem) {
      switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "CallExpression":
        case "NewExpression":
          return sourceCode.getLastToken(node, 1);
        default:
          {
            const nextToken = sourceCode.getTokenAfter(lastItem);
            if (astUtils.isCommaToken(nextToken)) {
              return nextToken;
            }
            return sourceCode.getLastToken(lastItem);
          }
      }
    }

    /**
     * Checks whether or not a given node is multiline.
     * This rule handles a given node as multiline when the closing parenthesis
     * and the last element are not on the same line.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} `true` if the node is multiline.
     */
    function isMultiline(node) {
      const lastItem = getLastItem(node);
      if (!lastItem) {
        return false;
      }
      const penultimateToken = getTrailingToken(node, lastItem);
      const lastToken = sourceCode.getTokenAfter(penultimateToken);
      return lastToken.loc.end.line !== penultimateToken.loc.end.line;
    }

    /**
     * Reports a trailing comma if it exists.
     *
     * @param {ASTNode} node - A node to check. Its type is one of
     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
     *   ImportDeclaration, and ExportNamedDeclaration.
     * @returns {void}
     */
    function forbidTrailingComma(node) {
      const lastItem = getLastItem(node);
      if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
        return;
      }
      const trailingToken = getTrailingToken(node, lastItem);
      if (astUtils.isCommaToken(trailingToken)) {
        context.report({
          node: lastItem,
          loc: trailingToken.loc.start,
          messageId: "unexpected",
          fix(fixer) {
            return fixer.remove(trailingToken);
          }
        });
      }
    }

    /**
     * Reports the last element of a given node if it does not have a trailing
     * comma.
     *
     * If a given node is `ArrayPattern` which has `RestElement`, the trailing
     * comma is disallowed, so report if it exists.
     *
     * @param {ASTNode} node - A node to check. Its type is one of
     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
     *   ImportDeclaration, and ExportNamedDeclaration.
     * @returns {void}
     */
    function forceTrailingComma(node) {
      const lastItem = getLastItem(node);
      if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
        return;
      }
      if (!isTrailingCommaAllowed(lastItem)) {
        forbidTrailingComma(node);
        return;
      }
      const trailingToken = getTrailingToken(node, lastItem);
      if (trailingToken.value !== ",") {
        context.report({
          node: lastItem,
          loc: trailingToken.loc.end,
          messageId: "missing",
          fix(fixer) {
            return fixer.insertTextAfter(trailingToken, ",");
          }
        });
      }
    }

    /**
     * If a given node is multiline, reports the last element of a given node
     * when it does not have a trailing comma.
     * Otherwise, reports a trailing comma if it exists.
     *
     * @param {ASTNode} node - A node to check. Its type is one of
     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
     *   ImportDeclaration, and ExportNamedDeclaration.
     * @returns {void}
     */
    function forceTrailingCommaIfMultiline(node) {
      if (isMultiline(node)) {
        forceTrailingComma(node);
      } else {
        forbidTrailingComma(node);
      }
    }

    /**
     * Only if a given node is not multiline, reports the last element of a given node
     * when it does not have a trailing comma.
     * Otherwise, reports a trailing comma if it exists.
     *
     * @param {ASTNode} node - A node to check. Its type is one of
     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
     *   ImportDeclaration, and ExportNamedDeclaration.
     * @returns {void}
     */
    function allowTrailingCommaIfMultiline(node) {
      if (!isMultiline(node)) {
        forbidTrailingComma(node);
      }
    }
    const predicate = {
      always: forceTrailingComma,
      "always-multiline": forceTrailingCommaIfMultiline,
      "only-multiline": allowTrailingCommaIfMultiline,
      never: forbidTrailingComma,
      ignore: lodash.noop
    };
    return {
      ObjectExpression: predicate[options.objects],
      ObjectPattern: predicate[options.objects],
      ArrayExpression: predicate[options.arrays],
      ArrayPattern: predicate[options.arrays],
      ImportDeclaration: predicate[options.imports],
      ExportNamedDeclaration: predicate[options.exports],
      FunctionDeclaration: predicate[options.functions],
      FunctionExpression: predicate[options.functions],
      ArrowFunctionExpression: predicate[options.functions],
      CallExpression: predicate[options.functions],
      NewExpression: predicate[options.functions]
    };
  }
};

/***/ }),
/* 220 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Comma spacing - validates spacing before and after comma
 * @author Vignesh Anand aka vegetableman.
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after commas",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      missing: "A space is required {{loc}} ','.",
      unexpected: "There should be no space {{loc}} ','."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const tokensAndComments = sourceCode.tokensAndComments;
    const options = {
      before: context.options[0] ? context.options[0].before : false,
      after: context.options[0] ? context.options[0].after : true
    };

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    // list of comma tokens to ignore for the check of leading whitespace
    const commaTokensToIgnore = [];

    /**
     * Reports a spacing error with an appropriate message.
     * @param {ASTNode} node The binary expression node to report.
     * @param {string} loc Is the error "before" or "after" the comma?
     * @param {ASTNode} otherNode The node at the left or right of `node`
     * @returns {void}
     * @private
     */
    function report(node, loc, otherNode) {
      context.report({
        node,
        fix(fixer) {
          if (options[loc]) {
            if (loc === "before") {
              return fixer.insertTextBefore(node, " ");
            }
            return fixer.insertTextAfter(node, " ");
          }
          let start, end;
          const newText = "";
          if (loc === "before") {
            start = otherNode.range[1];
            end = node.range[0];
          } else {
            start = node.range[1];
            end = otherNode.range[0];
          }
          return fixer.replaceTextRange([start, end], newText);
        },
        messageId: options[loc] ? "missing" : "unexpected",
        data: {
          loc
        }
      });
    }

    /**
     * Validates the spacing around a comma token.
     * @param {Object} tokens - The tokens to be validated.
     * @param {Token} tokens.comma The token representing the comma.
     * @param {Token} [tokens.left] The last token before the comma.
     * @param {Token} [tokens.right] The first token after the comma.
     * @param {Token|ASTNode} reportItem The item to use when reporting an error.
     * @returns {void}
     * @private
     */
    function validateCommaItemSpacing(tokens, reportItem) {
      if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {
        report(reportItem, "before", tokens.left);
      }
      if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {
        return;
      }
      if (tokens.right && !options.after && tokens.right.type === "Line") {
        return;
      }
      if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {
        report(reportItem, "after", tokens.right);
      }
    }

    /**
     * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.
     * @param {ASTNode} node An ArrayExpression or ArrayPattern node.
     * @returns {void}
     */
    function addNullElementsToIgnoreList(node) {
      let previousToken = sourceCode.getFirstToken(node);
      node.elements.forEach(element => {
        let token;
        if (element === null) {
          token = sourceCode.getTokenAfter(previousToken);
          if (astUtils.isCommaToken(token)) {
            commaTokensToIgnore.push(token);
          }
        } else {
          token = sourceCode.getTokenAfter(element);
        }
        previousToken = token;
      });
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      "Program:exit"() {
        tokensAndComments.forEach((token, i) => {
          if (!astUtils.isCommaToken(token)) {
            return;
          }
          if (token && token.type === "JSXText") {
            return;
          }
          const previousToken = tokensAndComments[i - 1];
          const nextToken = tokensAndComments[i + 1];
          validateCommaItemSpacing({
            comma: token,
            left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
            right: astUtils.isCommaToken(nextToken) ? null : nextToken
          }, token);
        });
      },
      ArrayExpression: addNullElementsToIgnoreList,
      ArrayPattern: addNullElementsToIgnoreList
    };
  }
};

/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Comma style - enforces comma styles of two types: last and first
 * @author Vignesh Anand aka vegetableman
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent comma style",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/comma-style"
    },
    fixable: "code",
    schema: [{
      enum: ["first", "last"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
      expectedCommaFirst: "',' should be placed first.",
      expectedCommaLast: "',' should be placed last."
    }
  },
  create(context) {
    const style = context.options[0] || "last",
      sourceCode = context.getSourceCode();
    const exceptions = {
      ArrayPattern: true,
      ArrowFunctionExpression: true,
      CallExpression: true,
      FunctionDeclaration: true,
      FunctionExpression: true,
      ImportDeclaration: true,
      ObjectPattern: true,
      NewExpression: true
    };
    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], "exceptions")) {
      const keys = Object.keys(context.options[1].exceptions);
      for (let i = 0; i < keys.length; i++) {
        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
      }
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Modified text based on the style
     * @param {string} styleType Style type
     * @param {string} text Source code text
     * @returns {string} modified text
     * @private
     */
    function getReplacedText(styleType, text) {
      switch (styleType) {
        case "between":
          return `,${text.replace(astUtils.LINEBREAK_MATCHER, "")}`;
        case "first":
          return `${text},`;
        case "last":
          return `,${text}`;
        default:
          return "";
      }
    }

    /**
     * Determines the fixer function for a given style.
     * @param {string} styleType comma style
     * @param {ASTNode} previousItemToken The token to check.
     * @param {ASTNode} commaToken The token to check.
     * @param {ASTNode} currentItemToken The token to check.
     * @returns {Function} Fixer function
     * @private
     */
    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
      const range = [previousItemToken.range[1], currentItemToken.range[0]];
      return function (fixer) {
        return fixer.replaceTextRange(range, getReplacedText(styleType, text));
      };
    }

    /**
     * Validates the spacing around single items in lists.
     * @param {Token} previousItemToken The last token from the previous item.
     * @param {Token} commaToken The token representing the comma.
     * @param {Token} currentItemToken The first token of the current item.
     * @param {Token} reportItem The item to use when reporting an error.
     * @returns {void}
     * @private
     */
    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
      // if single line
      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

        // do nothing.
      } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
        const comment = sourceCode.getCommentsAfter(commaToken)[0];
        const styleType = comment && comment.type === "Block" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : "between";

        // lone comma
        context.report({
          node: reportItem,
          loc: {
            line: commaToken.loc.end.line,
            column: commaToken.loc.start.column
          },
          messageId: "unexpectedLineBeforeAndAfterComma",
          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)
        });
      } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
        context.report({
          node: reportItem,
          messageId: "expectedCommaFirst",
          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
        });
      } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
        context.report({
          node: reportItem,
          loc: {
            line: commaToken.loc.end.line,
            column: commaToken.loc.end.column
          },
          messageId: "expectedCommaLast",
          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
        });
      }
    }

    /**
     * Checks the comma placement with regards to a declaration/property/element
     * @param {ASTNode} node The binary expression node to check
     * @param {string} property The property of the node containing child nodes.
     * @private
     * @returns {void}
     */
    function validateComma(node, property) {
      const items = node[property],
        arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";
      if (items.length > 1 || arrayLiteral) {
        // seed as opening [
        let previousItemToken = sourceCode.getFirstToken(node);
        items.forEach(item => {
          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
            currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),
            reportItem = item || currentItemToken;

          /*
           * This works by comparing three token locations:
           * - previousItemToken is the last token of the previous item
           * - commaToken is the location of the comma before the current item
           * - currentItemToken is the first token of the current item
           *
           * These values get switched around if item is undefined.
           * previousItemToken will refer to the last token not belonging
           * to the current item, which could be a comma or an opening
           * square bracket. currentItemToken could be a comma.
           *
           * All comparisons are done based on these tokens directly, so
           * they are always valid regardless of an undefined item.
           */
          if (astUtils.isCommaToken(commaToken)) {
            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);
          }
          if (item) {
            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);
            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
          }
        });

        /*
         * Special case for array literals that have empty last items, such
         * as [ 1, 2, ]. These arrays only have two items show up in the
         * AST, so we need to look at the token to verify that there's no
         * dangling comma.
         */
        if (arrayLiteral) {
          const lastToken = sourceCode.getLastToken(node),
            nextToLastToken = sourceCode.getTokenBefore(lastToken);
          if (astUtils.isCommaToken(nextToLastToken)) {
            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);
          }
        }
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    const nodes = {};
    if (!exceptions.VariableDeclaration) {
      nodes.VariableDeclaration = function (node) {
        validateComma(node, "declarations");
      };
    }
    if (!exceptions.ObjectExpression) {
      nodes.ObjectExpression = function (node) {
        validateComma(node, "properties");
      };
    }
    if (!exceptions.ObjectPattern) {
      nodes.ObjectPattern = function (node) {
        validateComma(node, "properties");
      };
    }
    if (!exceptions.ArrayExpression) {
      nodes.ArrayExpression = function (node) {
        validateComma(node, "elements");
      };
    }
    if (!exceptions.ArrayPattern) {
      nodes.ArrayPattern = function (node) {
        validateComma(node, "elements");
      };
    }
    if (!exceptions.FunctionDeclaration) {
      nodes.FunctionDeclaration = function (node) {
        validateComma(node, "params");
      };
    }
    if (!exceptions.FunctionExpression) {
      nodes.FunctionExpression = function (node) {
        validateComma(node, "params");
      };
    }
    if (!exceptions.ArrowFunctionExpression) {
      nodes.ArrowFunctionExpression = function (node) {
        validateComma(node, "params");
      };
    }
    if (!exceptions.CallExpression) {
      nodes.CallExpression = function (node) {
        validateComma(node, "arguments");
      };
    }
    if (!exceptions.ImportDeclaration) {
      nodes.ImportDeclaration = function (node) {
        validateComma(node, "specifiers");
      };
    }
    if (!exceptions.NewExpression) {
      nodes.NewExpression = function (node) {
        validateComma(node, "arguments");
      };
    }
    return nodes;
  }
};

/***/ }),
/* 222 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.
 * Counts the number of if, conditional, for, whilte, try, switch/case,
 * @author Patrick Brosset
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum cyclomatic complexity allowed in a program",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/complexity"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      complex: "{{name}} has a complexity of {{complexity}}."
    }
  },
  create(context) {
    const option = context.options[0];
    let THRESHOLD = 20;
    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      THRESHOLD = option.maximum || option.max;
    } else if (typeof option === "number") {
      THRESHOLD = option;
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    // Using a stack to store complexity (handling nested functions)
    const fns = [];

    /**
     * When parsing a new function, store it in our function stack
     * @returns {void}
     * @private
     */
    function startFunction() {
      fns.push(1);
    }

    /**
     * Evaluate the node at the end of function
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function endFunction(node) {
      const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
      const complexity = fns.pop();
      if (complexity > THRESHOLD) {
        context.report({
          node,
          messageId: "complex",
          data: {
            name,
            complexity
          }
        });
      }
    }

    /**
     * Increase the complexity of the function in context
     * @returns {void}
     * @private
     */
    function increaseComplexity() {
      if (fns.length) {
        fns[fns.length - 1]++;
      }
    }

    /**
     * Increase the switch complexity in context
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function increaseSwitchComplexity(node) {
      // Avoiding `default`
      if (node.test) {
        increaseComplexity();
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,
      CatchClause: increaseComplexity,
      ConditionalExpression: increaseComplexity,
      LogicalExpression: increaseComplexity,
      ForStatement: increaseComplexity,
      ForInStatement: increaseComplexity,
      ForOfStatement: increaseComplexity,
      IfStatement: increaseComplexity,
      SwitchCase: increaseSwitchComplexity,
      WhileStatement: increaseComplexity,
      DoWhileStatement: increaseComplexity
    };
  }
};

/***/ }),
/* 223 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside computed properties.
 * @author Jamund Ferguson
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside computed property brackets",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/computed-property-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports that there shouldn't be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @param {Token} tokenAfter - The token after `token`.
     * @returns {void}
     */
    function reportNoBeginningSpace(node, token, tokenAfter) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
        }
      });
    }

    /**
     * Reports that there shouldn't be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @param {Token} tokenBefore - The token before `token`.
     * @returns {void}
     */
    function reportNoEndingSpace(node, token, tokenBefore) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
        }
      });
    }

    /**
     * Reports that there should be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }

    /**
     * Reports that there should be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: token.value
        },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }

    /**
     * Returns a function that checks the spacing of a node on the property name
     * that was passed in.
     * @param {string} propertyName The property on the node to check for spacing
     * @returns {Function} A function that will check spacing on a node
     */
    function checkSpacing(propertyName) {
      return function (node) {
        if (!node.computed) {
          return;
        }
        const property = node[propertyName];
        const before = sourceCode.getTokenBefore(property),
          first = sourceCode.getFirstToken(property),
          last = sourceCode.getLastToken(property),
          after = sourceCode.getTokenAfter(property);
        if (astUtils.isTokenOnSameLine(before, first)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
              reportRequiredBeginningSpace(node, before);
            }
          } else {
            if (sourceCode.isSpaceBetweenTokens(before, first)) {
              reportNoBeginningSpace(node, before, first);
            }
          }
        }
        if (astUtils.isTokenOnSameLine(last, after)) {
          if (propertyNameMustBeSpaced) {
            if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
              reportRequiredEndingSpace(node, after);
            }
          } else {
            if (sourceCode.isSpaceBetweenTokens(last, after)) {
              reportNoEndingSpace(node, after, last);
            }
          }
        }
      };
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Property: checkSpacing("key"),
      MemberExpression: checkSpacing("property")
    };
  }
};

/***/ }),
/* 224 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag consistent return values
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is an `Identifier` node which was named a given name.
 * @param {ASTNode} node - A node to check.
 * @param {string} name - An expected name of the node.
 * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
 */
function isIdentifier(node, name) {
  return node.type === "Identifier" && node.name === name;
}

/**
 * Checks whether or not a given code path segment is unreachable.
 * @param {CodePathSegment} segment - A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is unreachable.
 */
function isUnreachable(segment) {
  return !segment.reachable;
}

/**
 * Checks whether a given node is a `constructor` method in an ES6 class
 * @param {ASTNode} node A node to check
 * @returns {boolean} `true` if the node is a `constructor` method
 */
function isClassConstructor(node) {
  return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `return` statements to either always or never specify values",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/consistent-return"
    },
    schema: [{
      type: "object",
      properties: {
        treatUndefinedAsUnspecified: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingReturn: "Expected to return a value at the end of {{name}}.",
      missingReturnValue: "{{name}} expected a return value.",
      unexpectedReturnValue: "{{name}} expected no return value."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
    let funcInfo = null;

    /**
     * Checks whether of not the implicit returning is consistent if the last
     * code path segment is reachable.
     *
     * @param {ASTNode} node - A program/function node to check.
     * @returns {void}
     */
    function checkLastSegment(node) {
      let loc, name;

      /*
       * Skip if it expected no return value or unreachable.
       * When unreachable, all paths are returned or thrown.
       */
      if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
        return;
      }

      // Adjust a location and a message.
      if (node.type === "Program") {
        // The head of program.
        loc = {
          line: 1,
          column: 0
        };
        name = "program";
      } else if (node.type === "ArrowFunctionExpression") {
        // `=>` token
        loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
      } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
        // Method name.
        loc = node.parent.key.loc.start;
      } else {
        // Function name or `function` keyword.
        loc = (node.id || node).loc.start;
      }
      if (!name) {
        name = astUtils.getFunctionNameWithKind(node);
      }

      // Reports.
      context.report({
        node,
        loc,
        messageId: "missingReturn",
        data: {
          name
        }
      });
    }
    return {
      // Initializes/Disposes state of each code path.
      onCodePathStart(codePath, node) {
        funcInfo = {
          upper: funcInfo,
          codePath,
          hasReturn: false,
          hasReturnValue: false,
          messageId: "",
          node
        };
      },
      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },
      // Reports a given return statement if it's inconsistent.
      ReturnStatement(node) {
        const argument = node.argument;
        let hasReturnValue = Boolean(argument);
        if (treatUndefinedAsUnspecified && hasReturnValue) {
          hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
        }
        if (!funcInfo.hasReturn) {
          funcInfo.hasReturn = true;
          funcInfo.hasReturnValue = hasReturnValue;
          funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
          funcInfo.data = {
            name: funcInfo.node.type === "Program" ? "Program" : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
          };
        } else if (funcInfo.hasReturnValue !== hasReturnValue) {
          context.report({
            node,
            messageId: funcInfo.messageId,
            data: funcInfo.data
          });
        }
      },
      // Reports a given program/function if the implicit returning is not consistent.
      "Program:exit": checkLastSegment,
      "FunctionDeclaration:exit": checkLastSegment,
      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }
};

/***/ }),
/* 225 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce consistent naming of "this" context variables
 * @author Raphael Pigulla
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent naming when capturing the current execution context",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/consistent-this"
    },
    schema: {
      type: "array",
      items: {
        type: "string",
        minLength: 1
      },
      uniqueItems: true
    },
    messages: {
      aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
      unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
    }
  },
  create(context) {
    let aliases = [];
    if (context.options.length === 0) {
      aliases.push("that");
    } else {
      aliases = context.options;
    }

    /**
     * Reports that a variable declarator or assignment expression is assigning
     * a non-'this' value to the specified alias.
     * @param {ASTNode} node - The assigning node.
     * @param {string}  name - the name of the alias that was incorrectly used.
     * @returns {void}
     */
    function reportBadAssignment(node, name) {
      context.report({
        node,
        messageId: "aliasNotAssignedToThis",
        data: {
          name
        }
      });
    }

    /**
     * Checks that an assignment to an identifier only assigns 'this' to the
     * appropriate alias, and the alias is only assigned to 'this'.
     * @param {ASTNode} node - The assigning node.
     * @param {Identifier} name - The name of the variable assigned to.
     * @param {Expression} value - The value of the assignment.
     * @returns {void}
     */
    function checkAssignment(node, name, value) {
      const isThis = value.type === "ThisExpression";
      if (aliases.indexOf(name) !== -1) {
        if (!isThis || node.operator && node.operator !== "=") {
          reportBadAssignment(node, name);
        }
      } else if (isThis) {
        context.report({
          node,
          messageId: "unexpectedAlias",
          data: {
            name
          }
        });
      }
    }

    /**
     * Ensures that a variable declaration of the alias in a program or function
     * is assigned to the correct value.
     * @param {string} alias alias the check the assignment of.
     * @param {Object} scope scope of the current code we are checking.
     * @private
     * @returns {void}
     */
    function checkWasAssigned(alias, scope) {
      const variable = scope.set.get(alias);
      if (!variable) {
        return;
      }
      if (variable.defs.some(def => def.node.type === "VariableDeclarator" && def.node.init !== null)) {
        return;
      }

      /*
       * The alias has been declared and not assigned: check it was
       * assigned later in the same scope.
       */
      if (!variable.references.some(reference => {
        const write = reference.writeExpr;
        return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
      })) {
        variable.defs.map(def => def.node).forEach(node => {
          reportBadAssignment(node, alias);
        });
      }
    }

    /**
     * Check each alias to ensure that is was assinged to the correct value.
     * @returns {void}
     */
    function ensureWasAssigned() {
      const scope = context.getScope();
      aliases.forEach(alias => {
        checkWasAssigned(alias, scope);
      });
    }
    return {
      "Program:exit": ensureWasAssigned,
      "FunctionExpression:exit": ensureWasAssigned,
      "FunctionDeclaration:exit": ensureWasAssigned,
      VariableDeclarator(node) {
        const id = node.id;
        const isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";
        if (node.init !== null && !isDestructuring) {
          checkAssignment(node, id.name, node.init);
        }
      },
      AssignmentExpression(node) {
        if (node.left.type === "Identifier") {
          checkAssignment(node, node.left.name, node.right);
        }
      }
    };
  }
};

/***/ }),
/* 226 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to verify `super()` callings in constructor.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a given code path segment is reachable or not.
 *
 * @param {CodePathSegment} segment - A code path segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

/**
 * Checks whether or not a given node is a constructor.
 * @param {ASTNode} node - A node to check. This node type is one of
 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
 *   `ArrowFunctionExpression`.
 * @returns {boolean} `true` if the node is a constructor.
 */
function isConstructorFunction(node) {
  return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

/**
 * Checks whether a given node can be a constructor or not.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node can be a constructor.
 */
function isPossibleConstructor(node) {
  if (!node) {
    return false;
  }
  switch (node.type) {
    case "ClassExpression":
    case "FunctionExpression":
    case "ThisExpression":
    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "YieldExpression":
    case "TaggedTemplateExpression":
    case "MetaProperty":
      return true;
    case "Identifier":
      return node.name !== "undefined";
    case "AssignmentExpression":
      return isPossibleConstructor(node.right);
    case "LogicalExpression":
      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
    case "ConditionalExpression":
      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);
    case "SequenceExpression":
      {
        const lastExpression = node.expressions[node.expressions.length - 1];
        return isPossibleConstructor(lastExpression);
      }
    default:
      return false;
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "require `super()` calls in constructors",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/constructor-super"
    },
    schema: [],
    messages: {
      missingSome: "Lacked a call of 'super()' in some code paths.",
      missingAll: "Expected to call 'super()'.",
      duplicate: "Unexpected duplicate 'super()'.",
      badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
      unexpected: "Unexpected 'super()'."
    }
  },
  create(context) {
    /*
     * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}
     * Information for each constructor.
     * - upper:      Information of the upper constructor.
     * - hasExtends: A flag which shows whether own class has a valid `extends`
     *               part.
     * - scope:      The scope of own class.
     * - codePath:   The code path object of the constructor.
     */
    let funcInfo = null;

    /*
     * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}
     * Information for each code path segment.
     * - calledInSomePaths:  A flag of be called `super()` in some code paths.
     * - calledInEveryPaths: A flag of be called `super()` in all code paths.
     * - validNodes:
     */
    let segInfoMap = Object.create(null);

    /**
     * Gets the flag which shows `super()` is called in some paths.
     * @param {CodePathSegment} segment - A code path segment to get.
     * @returns {boolean} The flag which shows `super()` is called in some paths
     */
    function isCalledInSomePath(segment) {
      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
    }

    /**
     * Gets the flag which shows `super()` is called in all paths.
     * @param {CodePathSegment} segment - A code path segment to get.
     * @returns {boolean} The flag which shows `super()` is called in all paths.
     */
    function isCalledInEveryPath(segment) {
      /*
       * If specific segment is the looped segment of the current segment,
       * skip the segment.
       * If not skipped, this never becomes true after a loop.
       */
      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
        return true;
      }
      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
    }
    return {
      /**
       * Stacks a constructor information.
       * @param {CodePath} codePath - A code path which was started.
       * @param {ASTNode} node - The current node.
       * @returns {void}
       */
      onCodePathStart(codePath, node) {
        if (isConstructorFunction(node)) {
          // Class > ClassBody > MethodDefinition > FunctionExpression
          const classNode = node.parent.parent.parent;
          const superClass = classNode.superClass;
          funcInfo = {
            upper: funcInfo,
            isConstructor: true,
            hasExtends: Boolean(superClass),
            superIsConstructor: isPossibleConstructor(superClass),
            codePath
          };
        } else {
          funcInfo = {
            upper: funcInfo,
            isConstructor: false,
            hasExtends: false,
            superIsConstructor: false,
            codePath
          };
        }
      },
      /**
       * Pops a constructor information.
       * And reports if `super()` lacked.
       * @param {CodePath} codePath - A code path which was ended.
       * @param {ASTNode} node - The current node.
       * @returns {void}
       */
      onCodePathEnd(codePath, node) {
        const hasExtends = funcInfo.hasExtends;

        // Pop.
        funcInfo = funcInfo.upper;
        if (!hasExtends) {
          return;
        }

        // Reports if `super()` lacked.
        const segments = codePath.returnedSegments;
        const calledInEveryPaths = segments.every(isCalledInEveryPath);
        const calledInSomePaths = segments.some(isCalledInSomePath);
        if (!calledInEveryPaths) {
          context.report({
            messageId: calledInSomePaths ? "missingSome" : "missingAll",
            node: node.parent
          });
        }
      },
      /**
       * Initialize information of a given code path segment.
       * @param {CodePathSegment} segment - A code path segment to initialize.
       * @returns {void}
       */
      onCodePathSegmentStart(segment) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        // Initialize info.
        const info = segInfoMap[segment.id] = {
          calledInSomePaths: false,
          calledInEveryPaths: false,
          validNodes: []
        };

        // When there are previous segments, aggregates these.
        const prevSegments = segment.prevSegments;
        if (prevSegments.length > 0) {
          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
        }
      },
      /**
       * Update information of the code path segment when a code path was
       * looped.
       * @param {CodePathSegment} fromSegment - The code path segment of the
       *      end of a loop.
       * @param {CodePathSegment} toSegment - A code path segment of the head
       *      of a loop.
       * @returns {void}
       */
      onCodePathSegmentLoop(fromSegment, toSegment) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        // Update information inside of the loop.
        const isRealLoop = toSegment.prevSegments.length >= 2;
        funcInfo.codePath.traverseSegments({
          first: toSegment,
          last: fromSegment
        }, segment => {
          const info = segInfoMap[segment.id];
          const prevSegments = segment.prevSegments;

          // Updates flags.
          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);

          // If flags become true anew, reports the valid nodes.
          if (info.calledInSomePaths || isRealLoop) {
            const nodes = info.validNodes;
            info.validNodes = [];
            for (let i = 0; i < nodes.length; ++i) {
              const node = nodes[i];
              context.report({
                messageId: "duplicate",
                node
              });
            }
          }
        });
      },
      /**
       * Checks for a call of `super()`.
       * @param {ASTNode} node - A CallExpression node to check.
       * @returns {void}
       */
      "CallExpression:exit"(node) {
        if (!(funcInfo && funcInfo.isConstructor)) {
          return;
        }

        // Skips except `super()`.
        if (node.callee.type !== "Super") {
          return;
        }

        // Reports if needed.
        if (funcInfo.hasExtends) {
          const segments = funcInfo.codePath.currentSegments;
          let duplicate = false;
          let info = null;
          for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];
            if (segment.reachable) {
              info = segInfoMap[segment.id];
              duplicate = duplicate || info.calledInSomePaths;
              info.calledInSomePaths = info.calledInEveryPaths = true;
            }
          }
          if (info) {
            if (duplicate) {
              context.report({
                messageId: "duplicate",
                node
              });
            } else if (!funcInfo.superIsConstructor) {
              context.report({
                messageId: "badSuper",
                node
              });
            } else {
              info.validNodes.push(node);
            }
          }
        } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
          context.report({
            messageId: "unexpected",
            node
          });
        }
      },
      /**
       * Set the mark to the returned path as `super()` was called.
       * @param {ASTNode} node - A ReturnStatement node to check.
       * @returns {void}
       */
      ReturnStatement(node) {
        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
          return;
        }

        // Skips if no argument.
        if (!node.argument) {
          return;
        }

        // Returning argument is a substitute of 'super()'.
        const segments = funcInfo.codePath.currentSegments;
        for (let i = 0; i < segments.length; ++i) {
          const segment = segments[i];
          if (segment.reachable) {
            const info = segInfoMap[segment.id];
            info.calledInSomePaths = info.calledInEveryPaths = true;
          }
        }
      },
      /**
       * Resets state.
       * @returns {void}
       */
      "Program:exit"() {
        segInfoMap = Object.create(null);
      }
    };
  }
};

/***/ }),
/* 227 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag statements without curly braces
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent brace style for all control statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/curly"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["all"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["multi", "multi-line", "multi-or-nest"]
        }, {
          enum: ["consistent"]
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      missingCurlyAfter: "Expected { after '{{name}}'.",
      missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
      unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
      unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
    }
  },
  create(context) {
    const multiOnly = context.options[0] === "multi";
    const multiLine = context.options[0] === "multi-line";
    const multiOrNest = context.options[0] === "multi-or-nest";
    const consistent = context.options[1] === "consistent";
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Determines if a given node is a one-liner that's on the same line as it's preceding code.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.
     * @private
     */
    function isCollapsedOneLiner(node) {
      const before = sourceCode.getTokenBefore(node);
      const last = sourceCode.getLastToken(node);
      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
    }

    /**
     * Determines if a given node is a one-liner.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} True if the node is a one-liner.
     * @private
     */
    function isOneLiner(node) {
      const first = sourceCode.getFirstToken(node),
        last = sourceCode.getLastToken(node);
      return first.loc.start.line === last.loc.end.line;
    }

    /**
     * Checks if the given token is an `else` token or not.
     *
     * @param {Token} token - The token to check.
     * @returns {boolean} `true` if the token is an `else` token.
     */
    function isElseKeywordToken(token) {
      return token.value === "else" && token.type === "Keyword";
    }

    /**
     * Gets the `else` keyword token of a given `IfStatement` node.
     * @param {ASTNode} node - A `IfStatement` node to get.
     * @returns {Token} The `else` keyword token.
     */
    function getElseKeyword(node) {
      return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
    }

    /**
     * Checks a given IfStatement node requires braces of the consequent chunk.
     * This returns `true` when below:
     *
     * 1. The given node has the `alternate` node.
     * 2. There is a `IfStatement` which doesn't have `alternate` node in the
     *    trailing statement chain of the `consequent` node.
     *
     * @param {ASTNode} node - A IfStatement node to check.
     * @returns {boolean} `true` if the node requires braces of the consequent chunk.
     */
    function requiresBraceOfConsequent(node) {
      if (node.alternate && node.consequent.type === "BlockStatement") {
        if (node.consequent.body.length >= 2) {
          return true;
        }
        for (let currentNode = node.consequent.body[0]; currentNode; currentNode = astUtils.getTrailingStatement(currentNode)) {
          if (currentNode.type === "IfStatement" && !currentNode.alternate) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.
     * @param {Token} closingBracket The } token
     * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.
     */
    function needsSemicolon(closingBracket) {
      const tokenBefore = sourceCode.getTokenBefore(closingBracket);
      const tokenAfter = sourceCode.getTokenAfter(closingBracket);
      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);
      if (astUtils.isSemicolonToken(tokenBefore)) {
        // If the last statement already has a semicolon, don't add another one.
        return false;
      }
      if (!tokenAfter) {
        // If there are no statements after this block, there is no need to add a semicolon.
        return false;
      }
      if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
        /*
         * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),
         * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause
         * a SyntaxError if it was followed by `else`.
         */
        return false;
      }
      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
        // If the next token is on the same line, insert a semicolon.
        return true;
      }
      if (/^[([/`+-]/u.test(tokenAfter.value)) {
        // If the next token starts with a character that would disrupt ASI, insert a semicolon.
        return true;
      }
      if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
        // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.
        return true;
      }

      // Otherwise, do not insert a semicolon.
      return false;
    }

    /**
     * Prepares to check the body of a node to see if it's a block statement.
     * @param {ASTNode} node The node to report if there's a problem.
     * @param {ASTNode} body The body node to check for blocks.
     * @param {string} name The name to report if there's a problem.
     * @param {{ condition: boolean }} opts Options to pass to the report functions
     * @returns {Object} a prepared check object, with "actual", "expected", "check" properties.
     *   "actual" will be `true` or `false` whether the body is already a block statement.
     *   "expected" will be `true` or `false` if the body should be a block statement or not, or
     *   `null` if it doesn't matter, depending on the rule options. It can be modified to change
     *   the final behavior of "check".
     *   "check" will be a function reporting appropriate problems depending on the other
     *   properties.
     */
    function prepareCheck(node, body, name, opts) {
      const hasBlock = body.type === "BlockStatement";
      let expected = null;
      if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
        expected = true;
      } else if (multiOnly) {
        if (hasBlock && body.body.length === 1) {
          expected = false;
        }
      } else if (multiLine) {
        if (!isCollapsedOneLiner(body)) {
          expected = true;
        }
      } else if (multiOrNest) {
        if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
          const leadingComments = sourceCode.getCommentsBefore(body.body[0]);
          expected = leadingComments.length > 0;
        } else if (!isOneLiner(body)) {
          expected = true;
        }
      } else {
        expected = true;
      }
      return {
        actual: hasBlock,
        expected,
        check() {
          if (this.expected !== null && this.expected !== this.actual) {
            if (this.expected) {
              context.report({
                node,
                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                data: {
                  name
                },
                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)
              });
            } else {
              context.report({
                node,
                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                data: {
                  name
                },
                fix(fixer) {
                  /*
                   * `do while` expressions sometimes need a space to be inserted after `do`.
                   * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`
                   */
                  const needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(body, {
                    skip: 1
                  }));
                  const openingBracket = sourceCode.getFirstToken(body);
                  const closingBracket = sourceCode.getLastToken(body);
                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);
                  if (needsSemicolon(closingBracket)) {
                    /*
                     * If removing braces would cause a SyntaxError due to multiple statements on the same line (or
                     * change the semantics of the code due to ASI), don't perform a fix.
                     */
                    return null;
                  }
                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
                  return fixer.replaceText(body, (needsPrecedingSpace ? " " : "") + resultingBodyText);
                }
              });
            }
          }
        }
      };
    }

    /**
     * Prepares to check the bodies of a "if", "else if" and "else" chain.
     * @param {ASTNode} node The first IfStatement node of the chain.
     * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more
     *   information.
     */
    function prepareIfChecks(node) {
      const preparedChecks = [];
      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {
        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, "if", {
          condition: true
        }));
        if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") {
          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, "else"));
          break;
        }
      }
      if (consistent) {
        /*
         * If any node should have or already have braces, make sure they
         * all have braces.
         * If all nodes shouldn't have braces, make sure they don't.
         */
        const expected = preparedChecks.some(preparedCheck => {
          if (preparedCheck.expected !== null) {
            return preparedCheck.expected;
          }
          return preparedCheck.actual;
        });
        preparedChecks.forEach(preparedCheck => {
          preparedCheck.expected = expected;
        });
      }
      return preparedChecks;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      IfStatement(node) {
        if (node.parent.type !== "IfStatement") {
          prepareIfChecks(node).forEach(preparedCheck => {
            preparedCheck.check();
          });
        }
      },
      WhileStatement(node) {
        prepareCheck(node, node.body, "while", {
          condition: true
        }).check();
      },
      DoWhileStatement(node) {
        prepareCheck(node, node.body, "do").check();
      },
      ForStatement(node) {
        prepareCheck(node, node.body, "for", {
          condition: true
        }).check();
      },
      ForInStatement(node) {
        prepareCheck(node, node.body, "for-in").check();
      },
      ForOfStatement(node) {
        prepareCheck(node, node.body, "for-of").check();
      }
    };
  }
};

/***/ }),
/* 228 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview require default case in switch statements
 * @author Aliaksei Shytkin
 */


const DEFAULT_COMMENT_PATTERN = /^no default$/iu;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `default` cases in `switch` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/default-case"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string"
        }
      },
      additionalProperties: false
    }],
    messages: {
      missingDefaultCase: "Expected a default case."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const commentPattern = options.commentPattern ? new RegExp(options.commentPattern) // eslint-disable-line require-unicode-regexp
    : DEFAULT_COMMENT_PATTERN;
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Shortcut to get last element of array
     * @param  {*[]} collection Array
     * @returns {*} Last element
     */
    function last(collection) {
      return collection[collection.length - 1];
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      SwitchStatement(node) {
        if (!node.cases.length) {
          /*
           * skip check of empty switch because there is no easy way
           * to extract comments inside it now
           */
          return;
        }
        const hasDefault = node.cases.some(v => v.test === null);
        if (!hasDefault) {
          let comment;
          const lastCase = last(node.cases);
          const comments = sourceCode.getCommentsAfter(lastCase);
          if (comments.length) {
            comment = last(comments);
          }
          if (!comment || !commentPattern.test(comment.value.trim())) {
            context.report({
              node,
              messageId: "missingDefaultCase"
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 229 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Validates newlines before and after dots
 * @author Greg Cochard
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent newlines before and after dots",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/dot-location"
    },
    schema: [{
      enum: ["object", "property"]
    }],
    fixable: "code",
    messages: {
      expectedDotAfterObject: "Expected dot to be on same line as object.",
      expectedDotBeforeProperty: "Expected dot to be on same line as property."
    }
  },
  create(context) {
    const config = context.options[0];

    // default to onObject if no preference is passed
    const onObject = config === "object" || !config;
    const sourceCode = context.getSourceCode();

    /**
     * Reports if the dot between object and property is on the correct loccation.
     * @param {ASTNode} obj The object owning the property.
     * @param {ASTNode} prop The property of the object.
     * @param {ASTNode} node The corresponding node of the token.
     * @returns {void}
     */
    function checkDotLocation(obj, prop, node) {
      const dot = sourceCode.getTokenBefore(prop);
      const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);
      const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);
      if (dot.type === "Punctuator" && dot.value === ".") {
        if (onObject) {
          if (!astUtils.isTokenOnSameLine(obj, dot)) {
            const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? " " : "";
            context.report({
              node,
              loc: dot.loc.start,
              messageId: "expectedDotAfterObject",
              fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)
            });
          }
        } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
          context.report({
            node,
            loc: dot.loc.start,
            messageId: "expectedDotBeforeProperty",
            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)
          });
        }
      }
    }

    /**
     * Checks the spacing of the dot within a member expression.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */
    function checkNode(node) {
      checkDotLocation(node.object, node.property, node);
    }
    return {
      MemberExpression: checkNode
    };
  }
};

/***/ }),
/* 230 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
 * @author Josh Perez
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;
const keywords = __webpack_require__(231);
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce dot notation whenever possible",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/dot-notation"
    },
    schema: [{
      type: "object",
      properties: {
        allowKeywords: {
          type: "boolean",
          default: true
        },
        allowPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      useDot: "[{{key}}] is better written in dot notation.",
      useBrackets: ".{{key}} is a syntax error."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
    const sourceCode = context.getSourceCode();
    let allowPattern;
    if (options.allowPattern) {
      allowPattern = new RegExp(options.allowPattern); // eslint-disable-line require-unicode-regexp
    }

    /**
     * Check if the property is valid dot notation
     * @param {ASTNode} node The dot notation node
     * @param {string} value Value which is to be checked
     * @returns {void}
     */
    function checkComputedProperty(node, value) {
      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
        const formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;
        context.report({
          node: node.property,
          messageId: "useDot",
          data: {
            key: formattedValue
          },
          fix(fixer) {
            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
            const rightBracket = sourceCode.getLastToken(node);
            if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, {
              includeComments: true,
              filter: astUtils.isCommentToken
            })) {
              // Don't perform any fixes if there are comments inside the brackets.
              return null;
            }
            const tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
            const needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);
            const textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
            const textAfterProperty = needsSpaceAfterProperty ? " " : "";
            return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], `${textBeforeDot}.${value}${textAfterProperty}`);
          }
        });
      }
    }
    return {
      MemberExpression(node) {
        if (node.computed && node.property.type === "Literal") {
          checkComputedProperty(node, node.property.value);
        }
        if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
          checkComputedProperty(node, node.property.quasis[0].value.cooked);
        }
        if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
          context.report({
            node: node.property,
            messageId: "useBrackets",
            data: {
              key: node.property.name
            },
            fix(fixer) {
              const dot = sourceCode.getTokenBefore(node.property);
              const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);
              if (textAfterDot.trim()) {
                // Don't perform any fixes if there are comments between the dot and the property name.
                return null;
              }
              if (node.object.type === "Identifier" && node.object.name === "let") {
                /*
                 * A statement that starts with `let[` is parsed as a destructuring variable declaration, not
                 * a MemberExpression.
                 */
                return null;
              }
              return fixer.replaceTextRange([dot.range[0], node.property.range[1]], `[${textAfterDot}"${node.property.name}"]`);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 231 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A shared list of ES3 keywords.
 * @author Josh Perez
 */


module.exports = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"];

/***/ }),
/* 232 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Require or disallow newline at the end of files
 * @author Nodeca Team <https://github.com/nodeca>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newline at the end of files",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/eol-last"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never", "unix", "windows"]
    }],
    messages: {
      missing: "Newline required at end of file but not found.",
      unexpected: "Newline not allowed at end of file."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: function checkBadEOF(node) {
        const sourceCode = context.getSourceCode(),
          src = sourceCode.getText(),
          location = {
            column: lodash.last(sourceCode.lines).length,
            line: sourceCode.lines.length
          },
          LF = "\n",
          CRLF = `\r${LF}`,
          endsWithNewline = lodash.endsWith(src, LF);

        /*
         * Empty source is always valid: No content in file so we don't
         * need to lint for a newline on the last line of content.
         */
        if (!src.length) {
          return;
        }
        let mode = context.options[0] || "always",
          appendCRLF = false;
        if (mode === "unix") {
          // `"unix"` should behave exactly as `"always"`
          mode = "always";
        }
        if (mode === "windows") {
          // `"windows"` should behave exactly as `"always"`, but append CRLF in the fixer for backwards compatibility
          mode = "always";
          appendCRLF = true;
        }
        if (mode === "always" && !endsWithNewline) {
          // File is not newline-terminated, but should be
          context.report({
            node,
            loc: location,
            messageId: "missing",
            fix(fixer) {
              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
            }
          });
        } else if (mode === "never" && endsWithNewline) {
          // File is newline-terminated, but shouldn't be
          context.report({
            node,
            loc: location,
            messageId: "unexpected",
            fix(fixer) {
              const finalEOLs = /(?:\r?\n)+$/u,
                match = finalEOLs.exec(sourceCode.text),
                start = match.index,
                end = sourceCode.text.length;
              return fixer.replaceTextRange([start, end], "");
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 233 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag statements that use != and == instead of !== and ===
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require the use of `===` and `!==`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/eqeqeq"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            null: {
              enum: ["always", "never", "ignore"]
            }
          },
          additionalProperties: false
        }],
        additionalItems: false
      }, {
        type: "array",
        items: [{
          enum: ["smart", "allow-null"]
        }],
        additionalItems: false
      }]
    },
    fixable: "code",
    messages: {
      unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
    }
  },
  create(context) {
    const config = context.options[0] || "always";
    const options = context.options[1] || {};
    const sourceCode = context.getSourceCode();
    const nullOption = config === "always" ? options.null || "always" : "ignore";
    const enforceRuleForNull = nullOption === "always";
    const enforceInverseRuleForNull = nullOption === "never";

    /**
     * Checks if an expression is a typeof expression
     * @param  {ASTNode} node The node to check
     * @returns {boolean} if the node is a typeof expression
     */
    function isTypeOf(node) {
      return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    /**
     * Checks if either operand of a binary expression is a typeof operation
     * @param {ASTNode} node The node to check
     * @returns {boolean} if one of the operands is typeof
     * @private
     */
    function isTypeOfBinary(node) {
      return isTypeOf(node.left) || isTypeOf(node.right);
    }

    /**
     * Checks if operands are literals of the same type (via typeof)
     * @param {ASTNode} node The node to check
     * @returns {boolean} if operands are of same type
     * @private
     */
    function areLiteralsAndSameType(node) {
      return node.left.type === "Literal" && node.right.type === "Literal" && typeof node.left.value === typeof node.right.value;
    }

    /**
     * Checks if one of the operands is a literal null
     * @param {ASTNode} node The node to check
     * @returns {boolean} if operands are null
     * @private
     */
    function isNullCheck(node) {
      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
    }

    /**
     * Gets the location (line and column) of the binary expression's operator
     * @param {ASTNode} node The binary expression node to check
     * @returns {Object} { line, column } location of operator
     * @private
     */
    function getOperatorLocation(node) {
      const opToken = sourceCode.getTokenAfter(node.left);
      return {
        line: opToken.loc.start.line,
        column: opToken.loc.start.column
      };
    }

    /**
     * Reports a message for this rule.
     * @param {ASTNode} node The binary expression node that was checked
     * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')
     * @returns {void}
     * @private
     */
    function report(node, expectedOperator) {
      context.report({
        node,
        loc: getOperatorLocation(node),
        messageId: "unexpected",
        data: {
          expectedOperator,
          actualOperator: node.operator
        },
        fix(fixer) {
          // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.
          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
            return fixer.replaceText(operatorToken, expectedOperator);
          }
          return null;
        }
      });
    }
    return {
      BinaryExpression(node) {
        const isNull = isNullCheck(node);
        if (node.operator !== "==" && node.operator !== "!=") {
          if (enforceInverseRuleForNull && isNull) {
            report(node, node.operator.slice(0, -1));
          }
          return;
        }
        if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
          return;
        }
        if (!enforceRuleForNull && isNull) {
          return;
        }
        report(node, `${node.operator}=`);
      }
    };
  }
};

/***/ }),
/* 234 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview enforce "for" loop update clause moving the counter in the right direction.(for-direction)
 * @author Aladdin-ADD<hh_2013@foxmail.com>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce \"for\" loop update clause moving the counter in the right direction.",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/for-direction"
    },
    fixable: null,
    schema: [],
    messages: {
      incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
    }
  },
  create(context) {
    /**
     * report an error.
     * @param {ASTNode} node the node to report.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node,
        messageId: "incorrectDirection"
      });
    }

    /**
     * check the right side of the assignment
     * @param {ASTNode} update UpdateExpression to check
     * @param {int} dir expected direction that could either be turned around or invalidated
     * @returns {int} return dir, the negated dir or zero if it's not clear for identifiers
     */
    function getRightDirection(update, dir) {
      if (update.right.type === "UnaryExpression") {
        if (update.right.operator === "-") {
          return -dir;
        }
      } else if (update.right.type === "Identifier") {
        return 0;
      }
      return dir;
    }

    /**
     * check UpdateExpression add/sub the counter
     * @param {ASTNode} update UpdateExpression to check
     * @param {string} counter variable name to check
     * @returns {int} if add return 1, if sub return -1, if nochange, return 0
     */
    function getUpdateDirection(update, counter) {
      if (update.argument.type === "Identifier" && update.argument.name === counter) {
        if (update.operator === "++") {
          return 1;
        }
        if (update.operator === "--") {
          return -1;
        }
      }
      return 0;
    }

    /**
     * check AssignmentExpression add/sub the counter
     * @param {ASTNode} update AssignmentExpression to check
     * @param {string} counter variable name to check
     * @returns {int} if add return 1, if sub return -1, if nochange, return 0
     */
    function getAssignmentDirection(update, counter) {
      if (update.left.name === counter) {
        if (update.operator === "+=") {
          return getRightDirection(update, 1);
        }
        if (update.operator === "-=") {
          return getRightDirection(update, -1);
        }
      }
      return 0;
    }
    return {
      ForStatement(node) {
        if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
          const counter = node.test.left.name;
          const operator = node.test.operator;
          const update = node.update;
          let wrongDirection;
          if (operator === "<" || operator === "<=") {
            wrongDirection = -1;
          } else if (operator === ">" || operator === ">=") {
            wrongDirection = 1;
          } else {
            return;
          }
          if (update.type === "UpdateExpression") {
            if (getUpdateDirection(update, counter) === wrongDirection) {
              report(node);
            }
          } else if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) === wrongDirection) {
            report(node);
          }
        }
      }
    };
  }
};

/***/ }),
/* 235 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to control spacing within function calls
 * @author Matt DuVall <http://www.mattduvall.com>
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between function identifiers and their invocations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-call-spacing"
    },
    fixable: "whitespace",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            allowNewlines: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpected: "Unexpected newline between function name and paren.",
      missing: "Missing space between function name and paren."
    }
  },
  create(context) {
    const never = context.options[0] !== "always";
    const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
    const sourceCode = context.getSourceCode();
    const text = sourceCode.getText();

    /**
     * Check if open space is present in a function name
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkSpacing(node) {
      const lastToken = sourceCode.getLastToken(node);
      const lastCalleeToken = sourceCode.getLastToken(node.callee);
      const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
      const prevToken = parenToken && sourceCode.getTokenBefore(parenToken);

      // Parens in NewExpression are optional
      if (!(parenToken && parenToken.range[1] < node.range[1])) {
        return;
      }
      const textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\/\*.*?\*\//gu, "");
      const hasWhitespace = /\s/u.test(textBetweenTokens);
      const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);

      /*
       * never allowNewlines hasWhitespace hasNewline message
       * F     F             F             F          Missing space between function name and paren.
       * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
       * F     F             T             T          Unexpected newline between function name and paren.
       * F     F             T             F          (OK)
       * F     T             T             F          (OK)
       * F     T             T             T          (OK)
       * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
       * F     T             F             F          Missing space between function name and paren.
       * T     T             F             F          (Invalid `never && allowNewlines`)
       * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
       * T     T             T             T          (Invalid `never && allowNewlines`)
       * T     T             T             F          (Invalid `never && allowNewlines`)
       * T     F             T             F          Unexpected space between function name and paren.
       * T     F             T             T          Unexpected space between function name and paren.
       * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
       * T     F             F             F          (OK)
       *
       * T                   T                        Unexpected space between function name and paren.
       * F                   F                        Missing space between function name and paren.
       * F     F                           T          Unexpected newline between function name and paren.
       */

      if (never && hasWhitespace) {
        context.report({
          node,
          loc: lastCalleeToken.loc.start,
          messageId: "unexpected",
          fix(fixer) {
            /*
             * Only autofix if there is no newline
             * https://github.com/eslint/eslint/issues/7787
             */
            if (!hasNewline) {
              return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
            }
            return null;
          }
        });
      } else if (!never && !hasWhitespace) {
        context.report({
          node,
          loc: lastCalleeToken.loc.start,
          messageId: "missing",
          fix(fixer) {
            return fixer.insertTextBefore(parenToken, " ");
          }
        });
      } else if (!never && !allowNewlines && hasNewline) {
        context.report({
          node,
          loc: lastCalleeToken.loc.start,
          messageId: "unexpected",
          fix(fixer) {
            return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], " ");
          }
        });
      }
    }
    return {
      CallExpression: checkSpacing,
      NewExpression: checkSpacing
    };
  }
};

/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.
 * @author Annie Zhang, Pavel Strashkin
 */



//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------
const astUtils = __webpack_require__(110);
const esutils = __webpack_require__(111);

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines if a pattern is `module.exports` or `module["exports"]`
 * @param {ASTNode} pattern The left side of the AssignmentExpression
 * @returns {boolean} True if the pattern is `module.exports` or `module["exports"]`
 */
function isModuleExports(pattern) {
  if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
    // module.exports
    if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
      return true;
    }

    // module["exports"]
    if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
      return true;
    }
  }
  return false;
}

/**
 * Determines if a string name is a valid identifier
 * @param {string} name The string to be checked
 * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config
 * @returns {boolean} True if the string is a valid identifier
 */
function isIdentifier(name, ecmaVersion) {
  if (ecmaVersion >= 6) {
    return esutils.keyword.isIdentifierES6(name);
  }
  return esutils.keyword.isIdentifierES5(name);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const alwaysOrNever = {
  enum: ["always", "never"]
};
const optionsObject = {
  type: "object",
  properties: {
    considerPropertyDescriptor: {
      type: "boolean"
    },
    includeCommonJSModuleExports: {
      type: "boolean"
    }
  },
  additionalProperties: false
};
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require function names to match the name of the variable or property to which they are assigned",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-name-matching"
    },
    schema: {
      anyOf: [{
        type: "array",
        additionalItems: false,
        items: [alwaysOrNever, optionsObject]
      }, {
        type: "array",
        additionalItems: false,
        items: [optionsObject]
      }]
    },
    messages: {
      matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
      matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
      notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
      notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
    }
  },
  create(context) {
    const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
    const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
    const considerPropertyDescriptor = options.considerPropertyDescriptor;
    const includeModuleExports = options.includeCommonJSModuleExports;
    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;

    /**
     * Check whether node is a certain CallExpression.
     * @param {string} objName object name
     * @param {string} funcName function name
     * @param {ASTNode} node The node to check
     * @returns {boolean} `true` if node matches CallExpression
     */
    function isPropertyCall(objName, funcName, node) {
      if (!node) {
        return false;
      }
      return node.type === "CallExpression" && node.callee.object.name === objName && node.callee.property.name === funcName;
    }

    /**
     * Compares identifiers based on the nameMatches option
     * @param {string} x the first identifier
     * @param {string} y the second identifier
     * @returns {boolean} whether the two identifiers should warn.
     */
    function shouldWarn(x, y) {
      return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
    }

    /**
     * Reports
     * @param {ASTNode} node The node to report
     * @param {string} name The variable or property name
     * @param {string} funcName The function name
     * @param {boolean} isProp True if the reported node is a property assignment
     * @returns {void}
     */
    function report(node, name, funcName, isProp) {
      let messageId;
      if (nameMatches === "always" && isProp) {
        messageId = "matchProperty";
      } else if (nameMatches === "always") {
        messageId = "matchVariable";
      } else if (isProp) {
        messageId = "notMatchProperty";
      } else {
        messageId = "notMatchVariable";
      }
      context.report({
        node,
        messageId,
        data: {
          name,
          funcName
        }
      });
    }

    /**
     * Determines whether a given node is a string literal
     * @param {ASTNode} node The node to check
     * @returns {boolean} `true` if the node is a string literal
     */
    function isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string";
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      VariableDeclarator(node) {
        if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
          return;
        }
        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
          report(node, node.id.name, node.init.id.name, false);
        }
      },
      AssignmentExpression(node) {
        if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
          return;
        }
        const isProp = node.left.type === "MemberExpression";
        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;
        if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
          report(node, name, node.right.id.name, isProp);
        }
      },
      Property(node) {
        if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
          return;
        }
        if (node.key.type === "Identifier") {
          const functionName = node.value.id.name;
          let propertyName = node.key.name;
          if (considerPropertyDescriptor && propertyName === "value") {
            if (isPropertyCall("Object", "defineProperty", node.parent.parent) || isPropertyCall("Reflect", "defineProperty", node.parent.parent)) {
              const property = node.parent.parent.arguments[1];
              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {
                report(node, property.value, functionName, true);
              }
            } else if (isPropertyCall("Object", "defineProperties", node.parent.parent.parent.parent)) {
              propertyName = node.parent.parent.key.name;
              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
            } else if (isPropertyCall("Object", "create", node.parent.parent.parent.parent)) {
              propertyName = node.parent.parent.key.name;
              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
            } else if (shouldWarn(propertyName, functionName)) {
              report(node, propertyName, functionName, true);
            }
          } else if (shouldWarn(propertyName, functionName)) {
            report(node, propertyName, functionName, true);
          }
          return;
        }
        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
          report(node, node.key.value, node.value.id.name, true);
        }
      }
    };
  }
};

/***/ }),
/* 237 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to warn when a function expression does not have a name.
 * @author Kyle T. Nunery
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

/**
 * Checks whether or not a given variable is a function name.
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is a function name.
 */
function isFunctionName(variable) {
  return variable && variable.defs[0].type === "FunctionName";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow named `function` expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-names"
    },
    schema: {
      definitions: {
        value: {
          enum: ["always", "as-needed", "never"]
        }
      },
      items: [{
        $ref: "#/definitions/value"
      }, {
        type: "object",
        properties: {
          generators: {
            $ref: "#/definitions/value"
          }
        },
        additionalProperties: false
      }]
    },
    messages: {
      unnamed: "Unexpected unnamed {{name}}.",
      named: "Unexpected named {{name}}."
    }
  },
  create(context) {
    /**
     * Returns the config option for the given node.
     * @param {ASTNode} node - A node to get the config for.
     * @returns {string} The config option.
     */
    function getConfigForNode(node) {
      if (node.generator && context.options.length > 1 && context.options[1].generators) {
        return context.options[1].generators;
      }
      return context.options[0] || "always";
    }

    /**
     * Determines whether the current FunctionExpression node is a get, set, or
     * shorthand method in an object literal or a class.
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} True if the node is a get, set, or shorthand method.
     */
    function isObjectOrClassMethod(node) {
      const parent = node.parent;
      return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
    }

    /**
     * Determines whether the current FunctionExpression node has a name that would be
     * inferred from context in a conforming ES6 environment.
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} True if the node would have a name assigned automatically.
     */
    function hasInferredName(node) {
      const parent = node.parent;
      return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "ExportDefaultDeclaration" && parent.declaration === node || parent.type === "AssignmentPattern" && parent.right === node;
    }

    /**
     * Reports that an unnamed function should be named
     * @param {ASTNode} node - The node to report in the event of an error.
     * @returns {void}
     */
    function reportUnexpectedUnnamedFunction(node) {
      context.report({
        node,
        messageId: "unnamed",
        data: {
          name: astUtils.getFunctionNameWithKind(node)
        }
      });
    }

    /**
     * Reports that a named function should be unnamed
     * @param {ASTNode} node - The node to report in the event of an error.
     * @returns {void}
     */
    function reportUnexpectedNamedFunction(node) {
      context.report({
        node,
        messageId: "named",
        data: {
          name: astUtils.getFunctionNameWithKind(node)
        }
      });
    }
    return {
      "FunctionExpression:exit"(node) {
        // Skip recursive functions.
        const nameVar = context.getDeclaredVariables(node)[0];
        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        }
        const hasName = Boolean(node.id && node.id.name);
        const config = getConfigForNode(node);
        if (config === "never") {
          if (hasName) {
            reportUnexpectedNamedFunction(node);
          }
        } else if (config === "as-needed") {
          if (!hasName && !hasInferredName(node)) {
            reportUnexpectedUnnamedFunction(node);
          }
        } else {
          if (!hasName && !isObjectOrClassMethod(node)) {
            reportUnexpectedUnnamedFunction(node);
          }
        }
      }
    };
  }
};

/***/ }),
/* 238 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce a particular function style
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of either `function` declarations or expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/func-style"
    },
    schema: [{
      enum: ["declaration", "expression"]
    }, {
      type: "object",
      properties: {
        allowArrowFunctions: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expression: "Expected a function expression.",
      declaration: "Expected a function declaration."
    }
  },
  create(context) {
    const style = context.options[0],
      allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions,
      enforceDeclarations = style === "declaration",
      stack = [];
    const nodesToCheck = {
      FunctionDeclaration(node) {
        stack.push(false);
        if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
          context.report({
            node,
            messageId: "expression"
          });
        }
      },
      "FunctionDeclaration:exit"() {
        stack.pop();
      },
      FunctionExpression(node) {
        stack.push(false);
        if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
          context.report({
            node: node.parent,
            messageId: "declaration"
          });
        }
      },
      "FunctionExpression:exit"() {
        stack.pop();
      },
      ThisExpression() {
        if (stack.length > 0) {
          stack[stack.length - 1] = true;
        }
      }
    };
    if (!allowArrowFunctions) {
      nodesToCheck.ArrowFunctionExpression = function () {
        stack.push(false);
      };
      nodesToCheck["ArrowFunctionExpression:exit"] = function (node) {
        const hasThisExpr = stack.pop();
        if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
          context.report({
            node: node.parent,
            messageId: "declaration"
          });
        }
      };
    }
    return nodesToCheck;
  }
};

/***/ }),
/* 239 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview enforce consistent line breaks inside function parentheses
 * @author Teddy Katz
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks inside function parentheses",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/function-paren-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent", "multiline"]
      }, {
        type: "object",
        properties: {
          minItems: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      expectedBefore: "Expected newline before ')'.",
      expectedAfter: "Expected newline after '('.",
      unexpectedBefore: "Unexpected newline before '('.",
      unexpectedAfter: "Unexpected newline after ')'."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const rawOption = context.options[0] || "multiline";
    const multilineOption = rawOption === "multiline";
    const consistentOption = rawOption === "consistent";
    let minItems;
    if (typeof rawOption === "object") {
      minItems = rawOption.minItems;
    } else if (rawOption === "always") {
      minItems = 0;
    } else if (rawOption === "never") {
      minItems = Infinity;
    } else {
      minItems = null;
    }

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Determines whether there should be newlines inside function parens
     * @param {ASTNode[]} elements The arguments or parameters in the list
     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.
     * @returns {boolean} `true` if there should be newlines inside the function parens
     */
    function shouldHaveNewlines(elements, hasLeftNewline) {
      if (multilineOption) {
        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
      }
      if (consistentOption) {
        return hasLeftNewline;
      }
      return elements.length >= minItems;
    }

    /**
     * Validates a list of arguments or parameters
     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
     * @param {ASTNode[]} elements The arguments or parameters in the list
     * @returns {void}
     */
    function validateParens(parens, elements) {
      const leftParen = parens.leftParen;
      const rightParen = parens.rightParen;
      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
      if (hasLeftNewline && !needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "unexpectedAfter",
          fix(fixer) {
            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()

            // If there is a comment between the ( and the first element, don't do a fix.
            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
          }
        });
      } else if (!hasLeftNewline && needsNewlines) {
        context.report({
          node: leftParen,
          messageId: "expectedAfter",
          fix: fixer => fixer.insertTextAfter(leftParen, "\n")
        });
      }
      if (hasRightNewline && !needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "unexpectedBefore",
          fix(fixer) {
            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()

            // If there is a comment between the last element and the ), don't do a fix.
            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
          }
        });
      } else if (!hasRightNewline && needsNewlines) {
        context.report({
          node: rightParen,
          messageId: "expectedBefore",
          fix: fixer => fixer.insertTextBefore(rightParen, "\n")
        });
      }
    }

    /**
     * Gets the left paren and right paren tokens of a node.
     * @param {ASTNode} node The node with parens
     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.
     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression
     * with a single parameter)
     */
    function getParenTokens(node) {
      switch (node.type) {
        case "NewExpression":
          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {
            skip: 1
          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
            // If the NewExpression does not have parens (e.g. `new Foo`), return null.
            return null;
          }

        // falls through

        case "CallExpression":
          return {
            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
            rightParen: sourceCode.getLastToken(node)
          };
        case "FunctionDeclaration":
        case "FunctionExpression":
          {
            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
            return {
              leftParen,
              rightParen
            };
          }
        case "ArrowFunctionExpression":
          {
            const firstToken = sourceCode.getFirstToken(node);
            if (!astUtils.isOpeningParenToken(firstToken)) {
              // If the ArrowFunctionExpression has a single param without parens, return null.
              return null;
            }
            return {
              leftParen: firstToken,
              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
            };
          }
        default:
          throw new TypeError(`unexpected node with type ${node.type}`);
      }
    }

    /**
     * Validates the parentheses for a node
     * @param {ASTNode} node The node with parens
     * @returns {void}
     */
    function validateNode(node) {
      const parens = getParenTokens(node);
      if (parens) {
        validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);
      }
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      ArrowFunctionExpression: validateNode,
      CallExpression: validateNode,
      FunctionDeclaration: validateNode,
      FunctionExpression: validateNode,
      NewExpression: validateNode
    };
  }
};

/***/ }),
/* 240 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check the spacing around the * in generator functions.
 * @author Jamund Ferguson
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const OVERRIDE_SCHEMA = {
  oneOf: [{
    enum: ["before", "after", "both", "neither"]
  }, {
    type: "object",
    properties: {
      before: {
        type: "boolean"
      },
      after: {
        type: "boolean"
      }
    },
    additionalProperties: false
  }]
};
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing around `*` operators in generator functions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/generator-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          },
          named: OVERRIDE_SCHEMA,
          anonymous: OVERRIDE_SCHEMA,
          method: OVERRIDE_SCHEMA
        },
        additionalProperties: false
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(context) {
    const optionDefinitions = {
      before: {
        before: true,
        after: false
      },
      after: {
        before: false,
        after: true
      },
      both: {
        before: true,
        after: true
      },
      neither: {
        before: false,
        after: false
      }
    };

    /**
     * Returns resolved option definitions based on an option and defaults
     *
     * @param {any} option - The option object or string value
     * @param {Object} defaults - The defaults to use if options are not present
     * @returns {Object} the resolved object definition
     */
    function optionToDefinition(option, defaults) {
      if (!option) {
        return defaults;
      }
      return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
    }
    const modes = function (option) {
      const defaults = optionToDefinition(option, optionDefinitions.before);
      return {
        named: optionToDefinition(option.named, defaults),
        anonymous: optionToDefinition(option.anonymous, defaults),
        method: optionToDefinition(option.method, defaults)
      };
    }(context.options[0] || {});
    const sourceCode = context.getSourceCode();

    /**
     * Checks if the given token is a star token or not.
     *
     * @param {Token} token - The token to check.
     * @returns {boolean} `true` if the token is a star token.
     */
    function isStarToken(token) {
      return token.value === "*" && token.type === "Punctuator";
    }

    /**
     * Gets the generator star token of the given function node.
     *
     * @param {ASTNode} node - The function node to get.
     * @returns {Token} Found star token.
     */
    function getStarToken(node) {
      return sourceCode.getFirstToken(node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
    }

    /**
     * capitalize a given string.
     * @param {string} str the given string.
     * @returns {string} the capitalized string.
     */
    function capitalize(str) {
      return str[0].toUpperCase() + str.slice(1);
    }

    /**
     * Checks the spacing between two tokens before or after the star token.
     *
     * @param {string} kind Either "named", "anonymous", or "method"
     * @param {string} side Either "before" or "after".
     * @param {Token} leftToken `function` keyword token if side is "before", or
     *     star token if side is "after".
     * @param {Token} rightToken Star token if side is "before", or identifier
     *     token if side is "after".
     * @returns {void}
     */
    function checkSpacing(kind, side, leftToken, rightToken) {
      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
        const after = leftToken.value === "*";
        const spaceRequired = modes[kind][side];
        const node = after ? leftToken : rightToken;
        const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
        context.report({
          node,
          messageId,
          fix(fixer) {
            if (spaceRequired) {
              if (after) {
                return fixer.insertTextAfter(node, " ");
              }
              return fixer.insertTextBefore(node, " ");
            }
            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }
        });
      }
    }

    /**
     * Enforces the spacing around the star if node is a generator function.
     *
     * @param {ASTNode} node A function expression or declaration node.
     * @returns {void}
     */
    function checkFunction(node) {
      if (!node.generator) {
        return;
      }
      const starToken = getStarToken(node);
      const prevToken = sourceCode.getTokenBefore(starToken);
      const nextToken = sourceCode.getTokenAfter(starToken);
      let kind = "named";
      if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
        kind = "method";
      } else if (!node.id) {
        kind = "anonymous";
      }

      // Only check before when preceded by `function`|`static` keyword
      if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
        checkSpacing(kind, "before", prevToken, starToken);
      }
      checkSpacing(kind, "after", starToken, nextToken);
    }
    return {
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction
    };
  }
};

/***/ }),
/* 241 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Enforces that a return statement is present in property getters.
 * @author Aladdin-ADD(hh_2013@foxmail.com)
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;

/**
 * Checks a given code path segment is reachable.
 *
 * @param {CodePathSegment} segment - A segment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

/**
 * Gets a readable location.
 *
 * - FunctionExpression -> the function name or `function` keyword.
 *
 * @param {ASTNode} node - A function node to get.
 * @returns {ASTNode|Token} The node or the token of a location.
 */
function getId(node) {
  return node.id || node;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in getters",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/getter-return"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected to return a value in {{name}}.",
      expectedAlways: "Expected {{name}} to always return a value."
    }
  },
  create(context) {
    const options = context.options[0] || {
      allowImplicit: false
    };
    let funcInfo = {
      upper: null,
      codePath: null,
      hasReturn: false,
      shouldCheck: false,
      node: null
    };

    /**
     * Checks whether or not the last code path segment is reachable.
     * Then reports this function if the segment is reachable.
     *
     * If the last code path segment is reachable, there are paths which are not
     * returned or thrown.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function checkLastSegment(node) {
      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
        context.report({
          node,
          loc: getId(node).loc.start,
          messageId: funcInfo.hasReturn ? "expectedAlways" : "expected",
          data: {
            name: astUtils.getFunctionNameWithKind(funcInfo.node)
          }
        });
      }
    }

    /**
     * Checks whether a node means a getter function.
     * @param {ASTNode} node - a node to check.
     * @returns {boolean} if node means a getter, return true; else return false.
     */
    function isGetter(node) {
      const parent = node.parent;
      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
        if (parent.kind === "get") {
          return true;
        }
        if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
          // Object.defineProperty()
          if (parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
            return true;
          }

          // Object.defineProperties()
          if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
            return true;
          }
        }
      }
      return false;
    }
    return {
      // Stacks this function's information.
      onCodePathStart(codePath, node) {
        funcInfo = {
          upper: funcInfo,
          codePath,
          hasReturn: false,
          shouldCheck: isGetter(node),
          node
        };
      },
      // Pops this function's information.
      onCodePathEnd() {
        funcInfo = funcInfo.upper;
      },
      // Checks the return statement is valid.
      ReturnStatement(node) {
        if (funcInfo.shouldCheck) {
          funcInfo.hasReturn = true;

          // if allowImplicit: false, should also check node.argument
          if (!options.allowImplicit && !node.argument) {
            context.report({
              node,
              messageId: "expected",
              data: {
                name: astUtils.getFunctionNameWithKind(funcInfo.node)
              }
            });
          }
        }
      },
      // Reports a given function if the last path is reachable.
      "FunctionExpression:exit": checkLastSegment,
      "ArrowFunctionExpression:exit": checkLastSegment
    };
  }
};

/***/ }),
/* 242 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule for disallowing require() outside of the top-level module context
 * @author Jamund Ferguson
 */



const ACCEPTABLE_PARENTS = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration"];

/**
 * Finds the eslint-scope reference in the given scope.
 * @param {Object} scope The scope to search.
 * @param {ASTNode} node The identifier node.
 * @returns {Reference|null} Returns the found reference or null if none were found.
 */
function findReference(scope, node) {
  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);

  /* istanbul ignore else: correctly returns null */
  if (references.length === 1) {
    return references[0];
  }
  return null;
}

/**
 * Checks if the given identifier node is shadowed in the given scope.
 * @param {Object} scope The current scope.
 * @param {ASTNode} node The identifier node to check.
 * @returns {boolean} Whether or not the name is shadowed.
 */
function isShadowed(scope, node) {
  const reference = findReference(scope, node);
  return reference && reference.resolved && reference.resolved.defs.length > 0;
}
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `require()` calls to be placed at top-level module scope",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/global-require"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected require()."
    }
  },
  create(context) {
    return {
      CallExpression(node) {
        const currentScope = context.getScope();
        if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
          const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);
          if (!isGoodRequire) {
            context.report({
              node,
              messageId: "unexpected"
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 243 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag for-in loops without if statements inside
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `for-in` loops to include an `if` statement",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/guard-for-in"
    },
    schema: [],
    messages: {
      wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
    }
  },
  create(context) {
    return {
      ForInStatement(node) {
        const body = node.body;

        // empty statement
        if (body.type === "EmptyStatement") {
          return;
        }

        // if statement
        if (body.type === "IfStatement") {
          return;
        }

        // empty block
        if (body.type === "BlockStatement" && body.body.length === 0) {
          return;
        }

        // block with just if statement
        if (body.type === "BlockStatement" && body.body.length === 1 && body.body[0].type === "IfStatement") {
          return;
        }

        // block that starts with if statement
        if (body.type === "BlockStatement" && body.body.length >= 1 && body.body[0].type === "IfStatement") {
          const i = body.body[0];

          // ... whose consequent is a continue
          if (i.consequent.type === "ContinueStatement") {
            return;
          }

          // ... whose consequent is a block that contains only a continue
          if (i.consequent.type === "BlockStatement" && i.consequent.body.length === 1 && i.consequent.body[0].type === "ContinueStatement") {
            return;
          }
        }
        context.report({
          node,
          messageId: "wrap"
        });
      }
    };
  }
};

/***/ }),
/* 244 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Ensure handling of errors when we know they exist.
 * @author Jamund Ferguson
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require error handling in callbacks",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/handle-callback-err"
    },
    schema: [{
      type: "string"
    }],
    messages: {
      expected: "Expected error to be handled."
    }
  },
  create(context) {
    const errorArgument = context.options[0] || "err";

    /**
     * Checks if the given argument should be interpreted as a regexp pattern.
     * @param {string} stringToCheck The string which should be checked.
     * @returns {boolean} Whether or not the string should be interpreted as a pattern.
     */
    function isPattern(stringToCheck) {
      const firstChar = stringToCheck[0];
      return firstChar === "^";
    }

    /**
     * Checks if the given name matches the configured error argument.
     * @param {string} name The name which should be compared.
     * @returns {boolean} Whether or not the given name matches the configured error variable name.
     */
    function matchesConfiguredErrorName(name) {
      if (isPattern(errorArgument)) {
        const regexp = new RegExp(errorArgument); // eslint-disable-line require-unicode-regexp

        return regexp.test(name);
      }
      return name === errorArgument;
    }

    /**
     * Get the parameters of a given function scope.
     * @param {Object} scope The function scope.
     * @returns {Array} All parameters of the given scope.
     */
    function getParameters(scope) {
      return scope.variables.filter(variable => variable.defs[0] && variable.defs[0].type === "Parameter");
    }

    /**
     * Check to see if we're handling the error object properly.
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     */
    function checkForError(node) {
      const scope = context.getScope(),
        parameters = getParameters(scope),
        firstParameter = parameters[0];
      if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
        if (firstParameter.references.length === 0) {
          context.report({
            node,
            messageId: "expected"
          });
        }
      }
    }
    return {
      FunctionDeclaration: checkForError,
      FunctionExpression: checkForError,
      ArrowFunctionExpression: checkForError
    };
  }
};

/***/ }),
/* 245 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule that warns when identifier names that are
 * blacklisted in the configuration are used.
 * @author Keith Cirkel (http://keithcirkel.co.uk)
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified identifiers",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-blacklist"
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true
    },
    messages: {
      blacklisted: "Identifier '{{name}}' is blacklisted."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const blacklist = context.options;

    /**
     * Checks if a string matches the provided pattern
     * @param {string} name The string to check.
     * @returns {boolean} if the string is a match
     * @private
     */
    function isInvalid(name) {
      return blacklist.indexOf(name) !== -1;
    }

    /**
     * Verifies if we should report an error or not based on the effective
     * parent node and the identifier name.
     * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
     * @param {string} name The identifier name of the identifier node
     * @returns {boolean} whether an error should be reported or not
     */
    function shouldReport(effectiveParent, name) {
      return effectiveParent.type !== "CallExpression" && effectiveParent.type !== "NewExpression" && isInvalid(name);
    }

    /**
     * Reports an AST node as a rule violation.
     * @param {ASTNode} node The node to report.
     * @returns {void}
     * @private
     */
    function report(node) {
      context.report({
        node,
        messageId: "blacklisted",
        data: {
          name: node.name
        }
      });
    }
    return {
      Identifier(node) {
        const name = node.name,
          effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;

        // MemberExpressions get special rules
        if (node.parent.type === "MemberExpression") {
          // Always check object names
          if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name) {
            if (isInvalid(name)) {
              report(node);
            }

            // Report AssignmentExpressions only if they are the left side of the assignment
          } else if (effectiveParent.type === "AssignmentExpression" && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
            if (isInvalid(name)) {
              report(node);
            }
          }

          // Properties have their own rules
        } else if (node.parent.type === "Property") {
          if (shouldReport(effectiveParent, name)) {
            report(node);
          }

          // Report anything that is a match and not a CallExpression
        } else if (shouldReport(effectiveParent, name)) {
          report(node);
        }
      }
    };
  }
};

/***/ }),
/* 246 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule that warns when identifier names are shorter or longer
 * than the values provided in configuration.
 * @author Burak Yigit Kaya aka BYK
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce minimum and maximum identifier lengths",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-length"
    },
    schema: [{
      type: "object",
      properties: {
        min: {
          type: "integer",
          default: 2
        },
        max: {
          type: "integer"
        },
        exceptions: {
          type: "array",
          uniqueItems: true,
          items: {
            type: "string"
          }
        },
        properties: {
          enum: ["always", "never"]
        }
      },
      additionalProperties: false
    }],
    messages: {
      tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
      tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const minLength = typeof options.min !== "undefined" ? options.min : 2;
    const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
    const properties = options.properties !== "never";
    const exceptions = (options.exceptions ? options.exceptions : []).reduce((obj, item) => {
      obj[item] = true;
      return obj;
    }, {});
    const SUPPORTED_EXPRESSIONS = {
      MemberExpression: properties && function (parent) {
        return !parent.computed && (
        // regular property assignment
        parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||
        // or the last identifier in an ObjectPattern destructuring
        parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
      },
      AssignmentPattern(parent, node) {
        return parent.left === node;
      },
      VariableDeclarator(parent, node) {
        return parent.id === node;
      },
      Property: properties && function (parent, node) {
        return parent.key === node;
      },
      ImportDefaultSpecifier: true,
      RestElement: true,
      FunctionExpression: true,
      ArrowFunctionExpression: true,
      ClassDeclaration: true,
      FunctionDeclaration: true,
      MethodDefinition: true,
      CatchClause: true
    };
    return {
      Identifier(node) {
        const name = node.name;
        const parent = node.parent;
        const isShort = name.length < minLength;
        const isLong = name.length > maxLength;
        if (!(isShort || isLong) || exceptions[name]) {
          return; // Nothing to report
        }
        const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
        if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
          context.report({
            node,
            messageId: isShort ? "tooShort" : "tooLong",
            data: {
              name,
              min: minLength,
              max: maxLength
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 247 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag non-matching identifiers
 * @author Matthieu Larcher
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require identifiers to match a specified regular expression",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/id-match"
    },
    schema: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        properties: {
          type: "boolean",
          default: false
        },
        onlyDeclarations: {
          type: "boolean",
          default: false
        },
        ignoreDestructuring: {
          type: "boolean",
          default: false
        }
      }
    }],
    messages: {
      notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Options
    //--------------------------------------------------------------------------
    const pattern = context.options[0] || "^.+$",
      regexp = new RegExp(pattern); // eslint-disable-line require-unicode-regexp

    const options = context.options[1] || {},
      properties = !!options.properties,
      onlyDeclarations = !!options.onlyDeclarations,
      ignoreDestructuring = !!options.ignoreDestructuring;

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation
    const reported = new Map();
    const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
    const DECLARATION_TYPES = new Set(["FunctionDeclaration", "VariableDeclarator"]);
    const IMPORT_TYPES = new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);

    /**
     * Checks if a string matches the provided pattern
     * @param {string} name The string to check.
     * @returns {boolean} if the string is a match
     * @private
     */
    function isInvalid(name) {
      return !regexp.test(name);
    }

    /**
     * Checks if a parent of a node is an ObjectPattern.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} if the node is inside an ObjectPattern
     * @private
     */
    function isInsideObjectPattern(node) {
      let {
        parent
      } = node;
      while (parent) {
        if (parent.type === "ObjectPattern") {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    }

    /**
     * Verifies if we should report an error or not based on the effective
     * parent node and the identifier name.
     * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
     * @param {string} name The identifier name of the identifier node
     * @returns {boolean} whether an error should be reported or not
     */
    function shouldReport(effectiveParent, name) {
      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);
    }

    /**
     * Reports an AST node as a rule violation.
     * @param {ASTNode} node The node to report.
     * @returns {void}
     * @private
     */
    function report(node) {
      if (!reported.has(node)) {
        context.report({
          node,
          messageId: "notMatch",
          data: {
            name: node.name,
            pattern
          }
        });
        reported.set(node, true);
      }
    }
    return {
      Identifier(node) {
        const name = node.name,
          parent = node.parent,
          effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;
        if (parent.type === "MemberExpression") {
          if (!properties) {
            return;
          }

          // Always check object names
          if (parent.object.type === "Identifier" && parent.object.name === name) {
            if (isInvalid(name)) {
              report(node);
            }

            // Report AssignmentExpressions left side's assigned variable id
          } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name) {
            if (isInvalid(name)) {
              report(node);
            }

            // Report AssignmentExpressions only if they are the left side of the assignment
          } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.right.type !== "MemberExpression") {
            if (isInvalid(name)) {
              report(node);
            }
          }

          /*
           * Properties have their own rules, and
           * AssignmentPattern nodes can be treated like Properties:
           * e.g.: const { no_camelcased = false } = bar;
           */
        } else if (parent.type === "Property" || parent.type === "AssignmentPattern") {
          if (parent.parent && parent.parent.type === "ObjectPattern") {
            if (parent.shorthand && parent.value.left && isInvalid(name)) {
              report(node);
            }
            const assignmentKeyEqualsValue = parent.key.name === parent.value.name;

            // prevent checking righthand side of destructured object
            if (!assignmentKeyEqualsValue && parent.key === node) {
              return;
            }
            const valueIsInvalid = parent.value.name && isInvalid(name);

            // ignore destructuring if the option is set, unless a new identifier is created
            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
              report(node);
            }
          }

          // never check properties or always ignore destructuring
          if (!properties || ignoreDestructuring && isInsideObjectPattern(node)) {
            return;
          }

          // don't check right hand side of AssignmentExpression to prevent duplicate warnings
          if (parent.right !== node && shouldReport(effectiveParent, name)) {
            report(node);
          }

          // Check if it's an import specifier
        } else if (IMPORT_TYPES.has(parent.type)) {
          // Report only if the local imported identifier is invalid
          if (parent.local && parent.local.name === node.name && isInvalid(name)) {
            report(node);
          }

          // Report anything that is invalid that isn't a CallExpression
        } else if (shouldReport(effectiveParent, name)) {
          report(node);
        }
      }
    };
  }
};

/***/ }),
/* 248 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview enforce the location of arrow function bodies
 * @author Sharmila Jesupaul
 */


const {
  isCommentToken,
  isNotOpeningParenToken
} = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of arrow function bodies",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/implicit-arrow-linebreak"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["beside", "below"]
    }],
    messages: {
      expected: "Expected a linebreak before this expression.",
      unexpected: "Expected no linebreak before this expression."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "beside";

    /**
     * Validates the location of an arrow function body
     * @param {ASTNode} node The arrow function body
     * @returns {void}
     */
    function validateExpression(node) {
      if (node.body.type === "BlockStatement") {
        return;
      }
      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);
      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);
      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === "below") {
        context.report({
          node: firstTokenOfBody,
          messageId: "expected",
          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, "\n")
        });
      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === "beside") {
        context.report({
          node: firstTokenOfBody,
          messageId: "unexpected",
          fix(fixer) {
            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {
              includeComments: true,
              filter: isCommentToken
            })) {
              return null;
            }
            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], " ");
          }
        });
      }
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------
    return {
      ArrowFunctionExpression: node => validateExpression(node)
    };
  }
};

/***/ }),
/* 249 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview This rule sets a specific indentation style and width for your code
 *
 * @author Teddy Katz
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);
const createTree = __webpack_require__(250);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const KNOWN_NODES = new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"]);

/*
 * General rule strategy:
 * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another
 *    specified token or to the first column.
 * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a
 *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly
 *    brace of the BlockStatement.
 * 3. After traversing the AST, calculate the expected indentation levels of every token according to the
 *    OffsetStorage container.
 * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,
 *    and report the token if the two values are not equal.
 */

/**
 * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.
 * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation
 * can easily be swapped out.
 */
class BinarySearchTree {
  /**
   * Creates an empty tree
   */
  constructor() {
    this._rbTree = createTree();
  }

  /**
   * Inserts an entry into the tree.
   * @param {number} key The entry's key
   * @param {*} value The entry's value
   * @returns {void}
   */
  insert(key, value) {
    const iterator = this._rbTree.find(key);
    if (iterator.valid) {
      this._rbTree = iterator.update(value);
    } else {
      this._rbTree = this._rbTree.insert(key, value);
    }
  }

  /**
   * Finds the entry with the largest key less than or equal to the provided key
   * @param {number} key The provided key
   * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.
   */
  findLe(key) {
    const iterator = this._rbTree.le(key);
    return iterator && {
      key: iterator.key,
      value: iterator.value
    };
  }

  /**
   * Deletes all of the keys in the interval [start, end)
   * @param {number} start The start of the range
   * @param {number} end The end of the range
   * @returns {void}
   */
  deleteRange(start, end) {
    // Exit without traversing the tree if the range has zero size.
    if (start === end) {
      return;
    }
    const iterator = this._rbTree.ge(start);
    while (iterator.valid && iterator.key < end) {
      this._rbTree = this._rbTree.remove(iterator.key);
      iterator.next();
    }
  }
}

/**
 * A helper class to get token-based info related to indentation
 */
class TokenInfo {
  /**
   * @param {SourceCode} sourceCode A SourceCode object
   */
  constructor(sourceCode) {
    this.sourceCode = sourceCode;
    this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {
      if (!map.has(token.loc.start.line)) {
        map.set(token.loc.start.line, token);
      }
      if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
        map.set(token.loc.end.line, token);
      }
      return map;
    }, new Map());
  }

  /**
   * Gets the first token on a given token's line
   * @param {Token|ASTNode} token a node or token
   * @returns {Token} The first token on the given line
   */
  getFirstTokenOfLine(token) {
    return this.firstTokensByLineNumber.get(token.loc.start.line);
  }

  /**
   * Determines whether a token is the first token in its line
   * @param {Token} token The token
   * @returns {boolean} `true` if the token is the first on its line
   */
  isFirstTokenOfLine(token) {
    return this.getFirstTokenOfLine(token) === token;
  }

  /**
   * Get the actual indent of a token
   * @param {Token} token Token to examine. This should be the first token on its line.
   * @returns {string} The indentation characters that precede the token
   */
  getTokenIndent(token) {
    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
  }
}

/**
 * A class to store information on desired offsets of tokens from each other
 */
class OffsetStorage {
  /**
   * @param {TokenInfo} tokenInfo a TokenInfo instance
   * @param {number} indentSize The desired size of each indentation level
   * @param {string} indentType The indentation character
   */
  constructor(tokenInfo, indentSize, indentType) {
    this._tokenInfo = tokenInfo;
    this._indentSize = indentSize;
    this._indentType = indentType;
    this._tree = new BinarySearchTree();
    this._tree.insert(0, {
      offset: 0,
      from: null,
      force: false
    });
    this._lockedFirstTokens = new WeakMap();
    this._desiredIndentCache = new WeakMap();
    this._ignoredTokens = new WeakSet();
  }
  _getOffsetDescriptor(token) {
    return this._tree.findLe(token.range[0]).value;
  }

  /**
   * Sets the offset column of token B to match the offset column of token A.
   * **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
   * most cases, `setDesiredOffset` should be used instead.
   * @param {Token} baseToken The first token
   * @param {Token} offsetToken The second token, whose offset should be matched to the first token
   * @returns {void}
   */
  matchOffsetOf(baseToken, offsetToken) {
    /*
     * lockedFirstTokens is a map from a token whose indentation is controlled by the "first" option to
     * the token that it depends on. For example, with the `ArrayExpression: first` option, the first
     * token of each element in the array after the first will be mapped to the first token of the first
     * element. The desired indentation of each of these tokens is computed based on the desired indentation
     * of the "first" element, rather than through the normal offset mechanism.
     */
    this._lockedFirstTokens.set(offsetToken, baseToken);
  }

  /**
   * Sets the desired offset of a token.
   *
   * This uses a line-based offset collapsing behavior to handle tokens on the same line.
   * For example, consider the following two cases:
   *
   * (
   *     [
   *         bar
   *     ]
   * )
   *
   * ([
   *     bar
   * ])
   *
   * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
   * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
   * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
   * from the start of its line.
   *
   * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
   * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
   * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
   * by 1 indent level from the start of the line.
   *
   * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
   * without needing to check which lines those tokens are on.
   *
   * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
   * behavior can occur. For example, consider the following cases:
   *
   * foo(
   * ).
   *     bar(
   *         baz
   *     )
   *
   * foo(
   * ).bar(
   *     baz
   * )
   *
   * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
   * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
   * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
   * collapsing would occur).
   *
   * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
   * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
   * in the second case.
   *
   * @param {Token} token The token
   * @param {Token} fromToken The token that `token` should be offset from
   * @param {number} offset The desired indent level
   * @returns {void}
   */
  setDesiredOffset(token, fromToken, offset) {
    return this.setDesiredOffsets(token.range, fromToken, offset);
  }

  /**
   * Sets the desired offset of all tokens in a range
   * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
   * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
   * it). This means that the offset of each token is updated O(AST depth) times.
   * It would not be performant to store and update the offsets for each token independently, because the rule would end
   * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
   *
   * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
   * list could represent the state of the offset tree at a given point:
   *
   * * Tokens starting in the interval [0, 15) are aligned with the beginning of the file
   * * Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
   * * Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
   * * Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
   * * Tokens starting in the interval [820, ) are offset by 1 indent level from the `baz` token
   *
   * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
   * `setDesiredOffsets([30, 43], fooToken, 1);`
   *
   * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
   * @param {Token} fromToken The token that this is offset from
   * @param {number} offset The desired indent level
   * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
   * @returns {void}
   */
  setDesiredOffsets(range, fromToken, offset, force) {
    /*
     * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset
     * descriptor. The tree for the example above would have the following nodes:
     *
     * * key: 0, value: { offset: 0, from: null }
     * * key: 15, value: { offset: 1, from: barToken }
     * * key: 30, value: { offset: 1, from: fooToken }
     * * key: 43, value: { offset: 2, from: barToken }
     * * key: 820, value: { offset: 1, from: bazToken }
     *
     * To find the offset descriptor for any given token, one needs to find the node with the largest key
     * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary
     * search tree indexed by key.
     */

    const descriptorToInsert = {
      offset,
      from: fromToken,
      force
    };
    const descriptorAfterRange = this._tree.findLe(range[1]).value;
    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);

    // First, remove any existing nodes in the range from the tree.
    this._tree.deleteRange(range[0] + 1, range[1]);

    // Insert a new node into the tree for this range
    this._tree.insert(range[0], descriptorToInsert);

    /*
     * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,
     * even if it's in the current range.
     */
    if (fromTokenIsInRange) {
      this._tree.insert(fromToken.range[0], fromTokenDescriptor);
      this._tree.insert(fromToken.range[1], descriptorToInsert);
    }

    /*
     * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following
     * tokens the same as it was before.
     */
    this._tree.insert(range[1], descriptorAfterRange);
  }

  /**
   * Gets the desired indent of a token
   * @param {Token} token The token
   * @returns {string} The desired indent of the token
   */
  getDesiredIndent(token) {
    if (!this._desiredIndentCache.has(token)) {
      if (this._ignoredTokens.has(token)) {
        /*
         * If the token is ignored, use the actual indent of the token as the desired indent.
         * This ensures that no errors are reported for this token.
         */
        this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
      } else if (this._lockedFirstTokens.has(token)) {
        const firstToken = this._lockedFirstTokens.get(token);
        this._desiredIndentCache.set(token,
        // (indentation for the first element's line)
        this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +
        // (space between the start of the first element's line and the first element)
        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));
      } else {
        const offsetInfo = this._getOffsetDescriptor(token);
        const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;
        this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset));
      }
    }
    return this._desiredIndentCache.get(token);
  }

  /**
   * Ignores a token, preventing it from being reported.
   * @param {Token} token The token
   * @returns {void}
   */
  ignoreToken(token) {
    if (this._tokenInfo.isFirstTokenOfLine(token)) {
      this._ignoredTokens.add(token);
    }
  }

  /**
   * Gets the first token that the given token's indentation is dependent on
   * @param {Token} token The token
   * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
   */
  getFirstDependency(token) {
    return this._getOffsetDescriptor(token).from;
  }
}
const ELEMENT_LIST_SCHEMA = {
  oneOf: [{
    type: "integer",
    minimum: 0
  }, {
    enum: ["first", "off"]
  }]
};
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/indent"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0,
          default: 0
        },
        VariableDeclarator: {
          oneOf: [ELEMENT_LIST_SCHEMA, {
            type: "object",
            properties: {
              var: ELEMENT_LIST_SCHEMA,
              let: ELEMENT_LIST_SCHEMA,
              const: ELEMENT_LIST_SCHEMA
            },
            additionalProperties: false
          }]
        },
        outerIIFEBody: {
          type: "integer",
          minimum: 0
        },
        MemberExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["off"]
          }]
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: ELEMENT_LIST_SCHEMA,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: false
        },
        CallExpression: {
          type: "object",
          properties: {
            arguments: ELEMENT_LIST_SCHEMA
          },
          additionalProperties: false
        },
        ArrayExpression: ELEMENT_LIST_SCHEMA,
        ObjectExpression: ELEMENT_LIST_SCHEMA,
        ImportDeclaration: ELEMENT_LIST_SCHEMA,
        flatTernaryExpressions: {
          type: "boolean",
          default: false
        },
        ignoredNodes: {
          type: "array",
          items: {
            type: "string",
            not: {
              pattern: ":exit$"
            }
          }
        },
        ignoreComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },
  create(context) {
    const DEFAULT_VARIABLE_INDENT = 1;
    const DEFAULT_PARAMETER_INDENT = 1;
    const DEFAULT_FUNCTION_BODY_INDENT = 1;
    let indentType = "space";
    let indentSize = 4;
    const options = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: DEFAULT_VARIABLE_INDENT,
        let: DEFAULT_VARIABLE_INDENT,
        const: DEFAULT_VARIABLE_INDENT
      },
      outerIIFEBody: 1,
      FunctionDeclaration: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT
      },
      FunctionExpression: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT
      },
      CallExpression: {
        arguments: DEFAULT_PARAMETER_INDENT
      },
      MemberExpression: 1,
      ArrayExpression: 1,
      ObjectExpression: 1,
      ImportDeclaration: 1,
      flatTernaryExpressions: false,
      ignoredNodes: [],
      ignoreComments: false
    };
    if (context.options.length) {
      if (context.options[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else {
        indentSize = context.options[0];
        indentType = "space";
      }
      if (context.options[1]) {
        Object.assign(options, context.options[1]);
        if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
          options.VariableDeclarator = {
            var: options.VariableDeclarator,
            let: options.VariableDeclarator,
            const: options.VariableDeclarator
          };
        }
      }
    }
    const sourceCode = context.getSourceCode();
    const tokenInfo = new TokenInfo(sourceCode);
    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "\t");
    const parameterParens = new WeakSet();

    /**
     * Creates an error message for a line, given the expected/actual indentation.
     * @param {int} expectedAmount The expected amount of indentation characters for this line
     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
     * @param {int} actualTabs The actual number of indentation tabs that were found on this line
     * @returns {string} An error message for this line
     */
    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
      const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
      const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
      let foundStatement;
      if (actualSpaces > 0) {
        /*
         * Abbreviate the message if the expected indentation is also spaces.
         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
         */
        foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
      } else if (actualTabs > 0) {
        foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
      } else {
        foundStatement = "0";
      }
      return {
        expected: expectedStatement,
        actual: foundStatement
      };
    }

    /**
     * Reports a given indent violation
     * @param {Token} token Token violating the indent rule
     * @param {string} neededIndent Expected indentation string
     * @returns {void}
     */
    function report(token, neededIndent) {
      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
      const numSpaces = actualIndent.filter(char => char === " ").length;
      const numTabs = actualIndent.filter(char => char === "\t").length;
      context.report({
        node: token,
        messageId: "wrongIndentation",
        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
        loc: {
          start: {
            line: token.loc.start.line,
            column: 0
          },
          end: {
            line: token.loc.start.line,
            column: token.loc.start.column
          }
        },
        fix(fixer) {
          const range = [token.range[0] - token.loc.start.column, token.range[0]];
          const newText = neededIndent;
          return fixer.replaceTextRange(range, newText);
        }
      });
    }

    /**
     * Checks if a token's indentation is correct
     * @param {Token} token Token to examine
     * @param {string} desiredIndent Desired indentation of the string
     * @returns {boolean} `true` if the token's indentation is correct
     */
    function validateTokenIndent(token, desiredIndent) {
      const indentation = tokenInfo.getTokenIndent(token);
      return indentation === desiredIndent ||
      // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
      indentation.includes(" ") && indentation.includes("\t");
    }

    /**
     * Check to see if the node is a file level IIFE
     * @param {ASTNode} node The function node to check.
     * @returns {boolean} True if the node is the outer IIFE
     */
    function isOuterIIFE(node) {
      /*
       * Verify that the node is an IIFE
       */
      if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
        return false;
      }

      /*
       * Navigate legal ancestors to determine whether this IIFE is outer.
       * A "legal ancestor" is an expression or statement that causes the function to get executed immediately.
       * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.
       */
      let statement = node.parent && node.parent.parent;
      while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
        statement = statement.parent;
      }
      return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
    }

    /**
     * Counts the number of linebreaks that follow the last non-whitespace character in a string
     * @param {string} string The string to check
     * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,
     * or the total number of linebreaks if the string is all whitespace.
     */
    function countTrailingLinebreaks(string) {
      const trailingWhitespace = string.match(/\s*$/u)[0];
      const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());
      return linebreakMatches === null ? 0 : linebreakMatches.length;
    }

    /**
     * Check indentation for lists of elements (arrays, objects, function params)
     * @param {ASTNode[]} elements List of elements that should be offset
     * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['
     * @param {Token} endToken The end token of the list, e.g. ']'
     * @param {number|string} offset The amount that the elements should be offset
     * @returns {void}
     */
    function addElementListIndent(elements, startToken, endToken, offset) {
      /**
       * Gets the first token of a given element, including surrounding parentheses.
       * @param {ASTNode} element A node in the `elements` list
       * @returns {Token} The first token of this element
       */
      function getFirstToken(element) {
        let token = sourceCode.getTokenBefore(element);
        while (astUtils.isOpeningParenToken(token) && token !== startToken) {
          token = sourceCode.getTokenBefore(token);
        }
        return sourceCode.getTokenAfter(token);
      }

      // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)
      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === "number" ? offset : 1);
      offsets.setDesiredOffset(endToken, startToken, 0);

      // If the preference is "first" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.
      if (offset === "first" && elements.length && !elements[0]) {
        return;
      }
      elements.forEach((element, index) => {
        if (!element) {
          // Skip holes in arrays
          return;
        }
        if (offset === "off") {
          // Ignore the first token of every element if the "off" option is used
          offsets.ignoreToken(getFirstToken(element));
        }

        // Offset the following elements correctly relative to the first element
        if (index === 0) {
          return;
        }
        if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
          offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
        } else {
          const previousElement = elements[index - 1];
          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);
          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {
            offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);
          }
        }
      });
    }

    /**
     * Check and decide whether to check for indentation for blockless nodes
     * Scenarios are for or while statements without braces around them
     * @param {ASTNode} node node to examine
     * @returns {void}
     */
    function addBlocklessNodeIndent(node) {
      if (node.type !== "BlockStatement") {
        const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);
        let firstBodyToken = sourceCode.getFirstToken(node);
        let lastBodyToken = sourceCode.getLastToken(node);
        while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
        }
        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);

        /*
         * For blockless nodes with semicolon-first style, don't indent the semicolon.
         * e.g.
         * if (foo) bar()
         * ; [1, 2, 3].map(foo)
         */
        const lastToken = sourceCode.getLastToken(node);
        if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
          offsets.setDesiredOffset(lastToken, lastParentToken, 0);
        }
      }
    }

    /**
     * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)
     * @param {ASTNode} node A CallExpression or NewExpression node
     * @returns {void}
     */
    function addFunctionCallIndent(node) {
      let openingParen;
      if (node.arguments.length) {
        openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
      } else {
        openingParen = sourceCode.getLastToken(node, 1);
      }
      const closingParen = sourceCode.getLastToken(node);
      parameterParens.add(openingParen);
      parameterParens.add(closingParen);
      offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
    }

    /**
     * Checks the indentation of parenthesized values, given a list of tokens in a program
     * @param {Token[]} tokens A list of tokens
     * @returns {void}
     */
    function addParensIndent(tokens) {
      const parenStack = [];
      const parenPairs = [];
      tokens.forEach(nextToken => {
        // Accumulate a list of parenthesis pairs
        if (astUtils.isOpeningParenToken(nextToken)) {
          parenStack.push(nextToken);
        } else if (astUtils.isClosingParenToken(nextToken)) {
          parenPairs.unshift({
            left: parenStack.pop(),
            right: nextToken
          });
        }
      });
      parenPairs.forEach(pair => {
        const leftParen = pair.left;
        const rightParen = pair.right;

        // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.
        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
          parenthesizedTokens.forEach(token => {
            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
              offsets.setDesiredOffset(token, leftParen, 1);
            }
          });
        }
        offsets.setDesiredOffset(rightParen, leftParen, 0);
      });
    }

    /**
     * Ignore all tokens within an unknown node whose offset do not depend
     * on another token's offset within the unknown node
     * @param {ASTNode} node Unknown Node
     * @returns {void}
     */
    function ignoreNode(node) {
      const unknownNodeTokens = new Set(sourceCode.getTokens(node, {
        includeComments: true
      }));
      unknownNodeTokens.forEach(token => {
        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
          if (token === firstTokenOfLine) {
            offsets.ignoreToken(token);
          } else {
            offsets.setDesiredOffset(token, firstTokenOfLine, 0);
          }
        }
      });
    }

    /**
     * Check whether the given token is on the first line of a statement.
     * @param {Token} token The token to check.
     * @param {ASTNode} leafNode The expression node that the token belongs directly.
     * @returns {boolean} `true` if the token is on the first line of a statement.
     */
    function isOnFirstLineOfStatement(token, leafNode) {
      let node = leafNode;
      while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
        node = node.parent;
      }
      node = node.parent;
      return !node || node.loc.start.line === token.loc.start.line;
    }

    /**
     * Check whether there are any blank (whitespace-only) lines between
     * two tokens on separate lines.
     * @param {Token} firstToken The first token.
     * @param {Token} secondToken The second token.
     * @returns {boolean} `true` if the tokens are on separate lines and
     *   there exists a blank line between them, `false` otherwise.
     */
    function hasBlankLinesBetween(firstToken, secondToken) {
      const firstTokenLine = firstToken.loc.end.line;
      const secondTokenLine = secondToken.loc.start.line;
      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
        return false;
      }
      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
        if (!tokenInfo.firstTokensByLineNumber.has(line)) {
          return true;
        }
      }
      return false;
    }
    const ignoredNodeFirstTokens = new Set();
    const baseOffsetListeners = {
      "ArrayExpression, ArrayPattern"(node) {
        const openingBracket = sourceCode.getFirstToken(node);
        const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);
        addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
      },
      "ObjectExpression, ObjectPattern"(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);
        addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
      },
      ArrowFunctionExpression(node) {
        const firstToken = sourceCode.getFirstToken(node);
        if (astUtils.isOpeningParenToken(firstToken)) {
          const openingParen = firstToken;
          const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
        }
        addBlocklessNodeIndent(node.body);
      },
      AssignmentExpression(node) {
        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
        offsets.ignoreToken(operator);
        offsets.ignoreToken(sourceCode.getTokenAfter(operator));
      },
      "BinaryExpression, LogicalExpression"(node) {
        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);

        /*
         * For backwards compatibility, don't check BinaryExpression indents, e.g.
         * var foo = bar &&
         *                   baz;
         */

        const tokenAfterOperator = sourceCode.getTokenAfter(operator);
        offsets.ignoreToken(operator);
        offsets.ignoreToken(tokenAfterOperator);
        offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
      },
      "BlockStatement, ClassBody"(node) {
        let blockIndentLevel;
        if (node.parent && isOuterIIFE(node.parent)) {
          blockIndentLevel = options.outerIIFEBody;
        } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
          blockIndentLevel = options.FunctionExpression.body;
        } else if (node.parent && node.parent.type === "FunctionDeclaration") {
          blockIndentLevel = options.FunctionDeclaration.body;
        } else {
          blockIndentLevel = 1;
        }

        /*
         * For blocks that aren't lone statements, ensure that the opening curly brace
         * is aligned with the parent.
         */
        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
          offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
        }
        addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
      },
      CallExpression: addFunctionCallIndent,
      "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
        const classToken = sourceCode.getFirstToken(node);
        const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);
        offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
      },
      ConditionalExpression(node) {
        const firstToken = sourceCode.getFirstToken(node);

        // `flatTernaryExpressions` option is for the following style:
        // var a =
        //     foo > 0 ? bar :
        //     foo < 0 ? baz :
        //     /*else*/ qiz ;
        if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
          const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === "Punctuator" && token.value === "?");
          const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === "Punctuator" && token.value === ":");
          const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
          const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
          const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
          offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
          offsets.setDesiredOffset(colonToken, firstToken, 1);
          offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);

          /*
           * The alternate and the consequent should usually have the same indentation.
           * If they share part of a line, align the alternate against the first token of the consequent.
           * This allows the alternate to be indented correctly in cases like this:
           * foo ? (
           *   bar
           * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`
           *   baz // as a result, `baz` is offset by 1 rather than 2
           * )
           */
          if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
            offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
          } else {
            /**
             * If the alternate and consequent do not share part of a line, offset the alternate from the first
             * token of the conditional expression. For example:
             * foo ? bar
             *   : baz
             *
             * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up
             * having no expected indentation.
             */
            offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);
          }
        }
      },
      "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": node => addBlocklessNodeIndent(node.body),
      ExportNamedDeclaration(node) {
        if (node.declaration === null) {
          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);

          // Indent the specifiers in `export {foo, bar, baz}`
          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {
            skip: 1
          }), closingCurly, 1);
          if (node.source) {
            // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`
            offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
          }
        }
      },
      ForStatement(node) {
        const forOpeningParen = sourceCode.getFirstToken(node, 1);
        if (node.init) {
          offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
        }
        if (node.test) {
          offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
        }
        if (node.update) {
          offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
        }
        addBlocklessNodeIndent(node.body);
      },
      "FunctionDeclaration, FunctionExpression"(node) {
        const closingParen = sourceCode.getTokenBefore(node.body);
        const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
      },
      IfStatement(node) {
        addBlocklessNodeIndent(node.consequent);
        if (node.alternate && node.alternate.type !== "IfStatement") {
          addBlocklessNodeIndent(node.alternate);
        }
      },
      ImportDeclaration(node) {
        if (node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) {
          const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
          addElementListIndent(node.specifiers.filter(specifier => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
        }
        const fromToken = sourceCode.getLastToken(node, token => token.type === "Identifier" && token.value === "from");
        const sourceToken = sourceCode.getLastToken(node, token => token.type === "String");
        const semiToken = sourceCode.getLastToken(node, token => token.type === "Punctuator" && token.value === ";");
        if (fromToken) {
          const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];
          offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);
        }
      },
      "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
        const object = node.type === "MetaProperty" ? node.meta : node.object;
        const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
        const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
        const objectParenCount = sourceCode.getTokensBetween(object, node.property, {
          filter: astUtils.isClosingParenToken
        }).length;
        const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {
          skip: objectParenCount - 1
        }) : sourceCode.getFirstToken(object);
        const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
        const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;
        if (node.computed) {
          // For computed MemberExpressions, match the closing bracket with the opening bracket.
          offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
          offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
        }

        /*
         * If the object ends on the same line that the property starts, match against the last token
         * of the object, to ensure that the MemberExpression is not indented.
         *
         * Otherwise, match against the first token of the object, e.g.
         * foo
         *   .bar
         *   .baz // <-- offset by 1 from `foo`
         */
        const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;
        if (typeof options.MemberExpression === "number") {
          // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.
          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);

          /*
           * For computed MemberExpressions, match the first token of the property against the opening bracket.
           * Otherwise, match the first token of the property against the object.
           */
          offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
        } else {
          // If the MemberExpression option is off, ignore the dot and the first token of the property.
          offsets.ignoreToken(firstNonObjectToken);
          offsets.ignoreToken(secondNonObjectToken);

          // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.
          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
          offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
        }
      },
      NewExpression(node) {
        // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`
        if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
          addFunctionCallIndent(node);
        }
      },
      Property(node) {
        if (!node.shorthand && !node.method && node.kind === "init") {
          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);
          offsets.ignoreToken(sourceCode.getTokenAfter(colon));
        }
      },
      SwitchStatement(node) {
        const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);
        if (node.cases.length) {
          sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {
            includeComments: true,
            filter: astUtils.isCommentToken
          }).forEach(token => offsets.ignoreToken(token));
        }
      },
      SwitchCase(node) {
        if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
          const caseKeyword = sourceCode.getFirstToken(node);
          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);
          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
        }
      },
      TemplateLiteral(node) {
        node.expressions.forEach((expression, index) => {
          const previousQuasi = node.quasis[index];
          const nextQuasi = node.quasis[index + 1];
          const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;
          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
        });
      },
      VariableDeclaration(node) {
        let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;
        const firstToken = sourceCode.getFirstToken(node),
          lastToken = sourceCode.getLastToken(node);
        if (options.VariableDeclarator[node.kind] === "first") {
          if (node.declarations.length > 1) {
            addElementListIndent(node.declarations, firstToken, lastToken, "first");
            return;
          }
          variableIndent = DEFAULT_VARIABLE_INDENT;
        }
        if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
          /*
           * VariableDeclarator indentation is a bit different from other forms of indentation, in that the
           * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,
           * the following indentations are correct:
           *
           * var foo = {
           *   ok: true
           * };
           *
           * var foo = {
           *     ok: true,
           *   },
           *   bar = 1;
           *
           * Account for when exiting the AST (after indentations have already been set for the nodes in
           * the declaration) by manually increasing the indentation level of the tokens in this declarator
           * on the same line as the start of the declaration, provided that there are declarators that
           * follow this one.
           */
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
        } else {
          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
        }
        if (astUtils.isSemicolonToken(lastToken)) {
          offsets.ignoreToken(lastToken);
        }
      },
      VariableDeclarator(node) {
        if (node.init) {
          const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
          const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);
          offsets.ignoreToken(equalOperator);
          offsets.ignoreToken(tokenAfterOperator);
          offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
          offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
        }
      },
      "JSXAttribute[value]"(node) {
        const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === "Punctuator" && token.value === "=");
        offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
      },
      JSXElement(node) {
        if (node.closingElement) {
          addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
        }
      },
      JSXOpeningElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        let closingToken;
        if (node.selfClosing) {
          closingToken = sourceCode.getLastToken(node, {
            skip: 1
          });
          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
        } else {
          closingToken = sourceCode.getLastToken(node);
        }
        offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
        addElementListIndent(node.attributes, firstToken, closingToken, 1);
      },
      JSXClosingElement(node) {
        const firstToken = sourceCode.getFirstToken(node);
        offsets.setDesiredOffsets(node.name.range, firstToken, 1);
      },
      JSXExpressionContainer(node) {
        const openingCurly = sourceCode.getFirstToken(node);
        const closingCurly = sourceCode.getLastToken(node);
        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
      },
      "*"(node) {
        const firstToken = sourceCode.getFirstToken(node);

        // Ensure that the children of every node are indented at least as much as the first token.
        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
          offsets.setDesiredOffsets(node.range, firstToken, 0);
        }
      }
    };
    const listenerCallQueue = [];

    /*
     * To ignore the indentation of a node:
     * 1. Don't call the node's listener when entering it (if it has a listener)
     * 2. Don't set any offsets against the first token of the node.
     * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.
     */
    const offsetListeners = lodash.mapValues(baseOffsetListeners,
    /*
     * Offset listener calls are deferred until traversal is finished, and are called as
     * part of the final `Program:exit` listener. This is necessary because a node might
     * be matched by multiple selectors.
     *
     * Example: Suppose there is an offset listener for `Identifier`, and the user has
     * specified in configuration that `MemberExpression > Identifier` should be ignored.
     * Due to selector specificity rules, the `Identifier` listener will get called first. However,
     * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener
     * should not have been called at all. Without doing extra selector matching, we don't know
     * whether the Identifier matches the `MemberExpression > Identifier` selector until the
     * `MemberExpression > Identifier` listener is called.
     *
     * To avoid this, the `Identifier` listener isn't called until traversal finishes and all
     * ignored nodes are known.
     */
    listener => node => listenerCallQueue.push({
      listener,
      node
    }));

    // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.
    const ignoredNodes = new Set();

    /**
     * Ignores a node
     * @param {ASTNode} node The node to ignore
     * @returns {void}
     */
    function addToIgnoredNodes(node) {
      ignoredNodes.add(node);
      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
    }
    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {
      [ignoredSelector]: addToIgnoredNodes
    }), {});

    /*
     * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation
     * at the end.
     *
     * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears
     * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,
     * so those listeners wouldn't be called anyway.
     */
    return Object.assign(offsetListeners, ignoredNodeListeners, {
      "*:exit"(node) {
        // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.
        if (!KNOWN_NODES.has(node.type)) {
          addToIgnoredNodes(node);
        }
      },
      "Program:exit"() {
        // If ignoreComments option is enabled, ignore all comment tokens.
        if (options.ignoreComments) {
          sourceCode.getAllComments().forEach(comment => offsets.ignoreToken(comment));
        }

        // Invoke the queued offset listeners for the nodes that aren't ignored.
        listenerCallQueue.filter(nodeInfo => !ignoredNodes.has(nodeInfo.node)).forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));

        // Update the offsets for ignored nodes to prevent their child tokens from being reported.
        ignoredNodes.forEach(ignoreNode);
        addParensIndent(sourceCode.ast.tokens);

        /*
         * Create a Map from (tokenOrComment) => (precedingToken).
         * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.
         */
        const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {
          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
        }, new WeakMap());
        sourceCode.lines.forEach((line, lineIndex) => {
          const lineNumber = lineIndex + 1;
          if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
            // Don't check indentation on blank lines
            return;
          }
          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);
          if (firstTokenOfLine.loc.start.line !== lineNumber) {
            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.
            return;
          }

          // If the token matches the expected expected indentation, don't report it.
          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
            return;
          }
          if (astUtils.isCommentToken(firstTokenOfLine)) {
            const tokenBefore = precedingTokens.get(firstTokenOfLine);
            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);

            // If a comment matches the expected indentation of the token immediately before or after, don't report it.
            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
              return;
            }
          }

          // Otherwise, report the token/comment.
          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
        });
      }
    });
  }
};

/***/ }),
/* 250 */
/***/ ((module) => {

"use strict";


module.exports = createRBTree;
var RED = 0;
var BLACK = 1;
function RBNode(color, key, value, left, right, count) {
  this._color = color;
  this.key = key;
  this.value = value;
  this.left = left;
  this.right = right;
  this._count = count;
}
function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
}
function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
}
function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
}
function RedBlackTree(compare, root) {
  this._compare = compare;
  this.root = root;
}
var proto = RedBlackTree.prototype;
Object.defineProperty(proto, "keys", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(k);
    });
    return result;
  }
});
Object.defineProperty(proto, "values", {
  get: function () {
    var result = [];
    this.forEach(function (k, v) {
      result.push(v);
    });
    return result;
  }
});

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function () {
    if (this.root) {
      return this.root._count;
    }
    return 0;
  }
});

//Insert a new item into the tree
proto.insert = function (key, value) {
  var cmp = this._compare;
  //Find point to insert new node at
  var n = this.root;
  var n_stack = [];
  var d_stack = [];
  while (n) {
    var d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1));
  for (var s = n_stack.length - 2; s >= 0; --s) {
    var n = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for (var s = n_stack.length - 1; s > 1; --s) {
    var p = n_stack[s - 1];
    var n = n_stack[s];
    if (p._color === BLACK || n._color === BLACK) {
      break;
    }
    var pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n) {
        var y = pp.right;
        if (y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LLb")
          pp._color = RED;
          pp.left = p.right;
          p._color = BLACK;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        var y = pp.right;
        if (y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK;
          pp.right = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("LRb")
          p.right = n.left;
          pp._color = RED;
          pp.left = n.right;
          n._color = BLACK;
          n.left = p;
          n.right = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n;
            } else {
              ppp.right = n;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n) {
        var y = pp.left;
        if (y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RRb")
          pp._color = RED;
          pp.right = p.left;
          p._color = BLACK;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n;
          recount(pp);
          recount(p);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        var y = pp.left;
        if (y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK;
          pp.left = repaint(BLACK, y);
          pp._color = RED;
          s -= 1;
        } else {
          //console.log("RLb")
          p.left = n.right;
          pp._color = RED;
          pp.right = n.left;
          n._color = BLACK;
          n.right = p;
          n.left = pp;
          n_stack[s - 2] = n;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n);
          if (s >= 3) {
            var ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n;
            } else {
              ppp.left = n;
            }
          }
          break;
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK;
  return new RedBlackTree(cmp, n_stack[0]);
};

//Visit all nodes inorder
function doVisitFull(visit, node) {
  if (node.left) {
    var v = doVisitFull(visit, node.left);
    if (v) {
      return v;
    }
  }
  var v = visit(node.key, node.value);
  if (v) {
    return v;
  }
  if (node.right) {
    return doVisitFull(visit, node.right);
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key);
  if (l <= 0) {
    if (node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left);
      if (v) {
        return v;
      }
    }
    var v = visit(node.key, node.value);
    if (v) {
      return v;
    }
  }
  if (node.right) {
    return doVisitHalf(lo, compare, visit, node.right);
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key);
  var h = compare(hi, node.key);
  var v;
  if (l <= 0) {
    if (node.left) {
      v = doVisit(lo, hi, compare, visit, node.left);
      if (v) {
        return v;
      }
    }
    if (h > 0) {
      v = visit(node.key, node.value);
      if (v) {
        return v;
      }
    }
  }
  if (h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right);
  }
}
proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if (!this.root) {
    return;
  }
  switch (arguments.length) {
    case 1:
      return doVisitFull(visit, this.root);
      break;
    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root);
      break;
    case 3:
      if (this._compare(lo, hi) >= 0) {
        return;
      }
      return doVisit(lo, hi, this._compare, visit, this.root);
      break;
  }
};

//First item in list
Object.defineProperty(proto, "begin", {
  get: function () {
    var stack = [];
    var n = this.root;
    while (n) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack);
  }
});

//Last item in list
Object.defineProperty(proto, "end", {
  get: function () {
    var stack = [];
    var n = this.root;
    while (n) {
      stack.push(n);
      n = n.right;
    }
    return new RedBlackTreeIterator(this, stack);
  }
});

//Find the ith item in the tree
proto.at = function (idx) {
  if (idx < 0) {
    return new RedBlackTreeIterator(this, []);
  }
  var n = this.root;
  var stack = [];
  while (true) {
    stack.push(n);
    if (n.left) {
      if (idx < n.left._count) {
        n = n.left;
        continue;
      }
      idx -= n.left._count;
    }
    if (!idx) {
      return new RedBlackTreeIterator(this, stack);
    }
    idx -= 1;
    if (n.right) {
      if (idx >= n.right._count) {
        break;
      }
      n = n.right;
    } else {
      break;
    }
  }
  return new RedBlackTreeIterator(this, []);
};
proto.ge = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d <= 0) {
      last_ptr = stack.length;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};
proto.gt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d < 0) {
      last_ptr = stack.length;
    }
    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};
proto.lt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d > 0) {
      last_ptr = stack.length;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};
proto.le = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d >= 0) {
      last_ptr = stack.length;
    }
    if (d < 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

//Finds the item with key if it exists
proto.find = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  while (n) {
    var d = cmp(key, n.key);
    stack.push(n);
    if (d === 0) {
      return new RedBlackTreeIterator(this, stack);
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  return new RedBlackTreeIterator(this, []);
};

//Removes item with key from tree
proto.remove = function (key) {
  var iter = this.find(key);
  if (iter) {
    return iter.remove();
  }
  return this;
};

//Returns the item at `key`
proto.get = function (key) {
  var cmp = this._compare;
  var n = this.root;
  while (n) {
    var d = cmp(key, n.key);
    if (d === 0) {
      return n.value;
    }
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  return;
};

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree;
  this._stack = stack;
}
var iproto = RedBlackTreeIterator.prototype;

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function () {
    return this._stack.length > 0;
  }
});

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1];
    }
    return null;
  },
  enumerable: true
});

//Makes a copy of an iterator
iproto.clone = function () {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
};

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n._color = v._color;
  n._count = v._count;
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z;
  for (var i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n._color = BLACK;
      return;
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i - 1];
    if (p.left === n) {
      //console.log("left child")
      s = p.right;
      if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK;
          p.right = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.right = s.left;
        s.left = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      //console.log("right child")
      s = p.left;
      if (s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s);
        z = s.left = cloneNode(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s._color = p._color;
        n._color = BLACK;
        p._color = BLACK;
        z._color = BLACK;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s);
        z = s.right = cloneNode(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z._color = p._color;
        p._color = BLACK;
        s._color = BLACK;
        n._color = BLACK;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s._color === BLACK) {
        if (p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK;
          p.left = repaint(RED, s);
          return;
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s);
          continue;
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s);
        p.left = s.right;
        s.right = p;
        s._color = p._color;
        p._color = RED;
        recount(p);
        recount(s);
        if (i > 1) {
          var pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return this.tree;
  }
  //First copy path to node
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
    var n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  }

  //Get node
  n = cstack[cstack.length - 1];
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if (n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length;
    n = n.left;
    while (n.right) {
      cstack.push(n);
      n = n.right;
    }
    //Copy path to leaf
    var v = cstack[split - 1];
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value;

    //Fix up stack
    for (var i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
    cstack[split - 1].left = cstack[split];
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length - 1];
  if (n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = null;
    } else if (p.right === n) {
      p.right = null;
    }
    cstack.pop();
    for (var i = 0; i < cstack.length; ++i) {
      cstack[i]._count--;
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  } else {
    if (n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if (n.left) {
        swapNode(n, n.left);
      } else if (n.right) {
        swapNode(n, n.right);
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK;
      for (var i = 0; i < cstack.length - 1; ++i) {
        cstack[i]._count--;
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    } else if (cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null);
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for (var i = 0; i < cstack.length; ++i) {
        cstack[i]._count--;
      }
      var parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      //Fix up links
      if (parent.left === n) {
        parent.left = null;
      } else {
        parent.right = null;
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};

//Returns key
Object.defineProperty(iproto, "key", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].key;
    }
    return;
  },
  enumerable: true
});

//Returns value
Object.defineProperty(iproto, "value", {
  get: function () {
    if (this._stack.length > 0) {
      return this._stack[this._stack.length - 1].value;
    }
    return;
  },
  enumerable: true
});

//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function () {
    var idx = 0;
    var stack = this._stack;
    if (stack.length === 0) {
      var r = this.tree.root;
      if (r) {
        return r._count;
      }
      return 0;
    } else if (stack[stack.length - 1].left) {
      idx = stack[stack.length - 1].left._count;
    }
    for (var s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left) {
          idx += stack[s].left._count;
        }
      }
    }
    return idx;
  },
  enumerable: true
});

//Advances iterator to next element in list
iproto.next = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return;
  }
  var n = stack[stack.length - 1];
  if (n.right) {
    n = n.right;
    while (n) {
      stack.push(n);
      n = n.left;
    }
  } else {
    stack.pop();
    while (stack.length > 0 && stack[stack.length - 1].right === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
};

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function () {
    var stack = this._stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right) {
      return true;
    }
    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
});

//Update value
iproto.update = function (value) {
  var stack = this._stack;
  if (stack.length === 0) {
    throw new Error("Can't update empty node!");
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};

//Moves iterator backward one element
iproto.prev = function () {
  var stack = this._stack;
  if (stack.length === 0) {
    return;
  }
  var n = stack[stack.length - 1];
  if (n.left) {
    n = n.left;
    while (n) {
      stack.push(n);
      n = n.right;
    }
  } else {
    stack.pop();
    while (stack.length > 0 && stack[stack.length - 1].left === n) {
      n = stack[stack.length - 1];
      stack.pop();
    }
  }
};

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function () {
    var stack = this._stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left) {
      return true;
    }
    for (var s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
});

//Default comparison function
function defaultCompare(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null);
}

/***/ }),
/* 251 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview This option sets a specific tab width for your code
 *
 * This rule has been ported and modified from nodeca.
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/indent-legacy"
    },
    deprecated: true,
    replacedBy: ["indent"],
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0
        },
        VariableDeclarator: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            type: "object",
            properties: {
              var: {
                type: "integer",
                minimum: 0
              },
              let: {
                type: "integer",
                minimum: 0
              },
              const: {
                type: "integer",
                minimum: 0
              }
            }
          }]
        },
        outerIIFEBody: {
          type: "integer",
          minimum: 0
        },
        MemberExpression: {
          type: "integer",
          minimum: 0
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        CallExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            }
          }
        },
        ArrayExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        },
        ObjectExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },
  create(context) {
    const DEFAULT_VARIABLE_INDENT = 1;
    const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
    const DEFAULT_FUNCTION_BODY_INDENT = 1;
    let indentType = "space";
    let indentSize = 4;
    const options = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: DEFAULT_VARIABLE_INDENT,
        let: DEFAULT_VARIABLE_INDENT,
        const: DEFAULT_VARIABLE_INDENT
      },
      outerIIFEBody: null,
      FunctionDeclaration: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT
      },
      FunctionExpression: {
        parameters: DEFAULT_PARAMETER_INDENT,
        body: DEFAULT_FUNCTION_BODY_INDENT
      },
      CallExpression: {
        arguments: DEFAULT_PARAMETER_INDENT
      },
      ArrayExpression: 1,
      ObjectExpression: 1
    };
    const sourceCode = context.getSourceCode();
    if (context.options.length) {
      if (context.options[0] === "tab") {
        indentSize = 1;
        indentType = "tab";
      } else /* istanbul ignore else : this will be caught by options validation */if (typeof context.options[0] === "number") {
          indentSize = context.options[0];
          indentType = "space";
        }
      if (context.options[1]) {
        const opts = context.options[1];
        options.SwitchCase = opts.SwitchCase || 0;
        const variableDeclaratorRules = opts.VariableDeclarator;
        if (typeof variableDeclaratorRules === "number") {
          options.VariableDeclarator = {
            var: variableDeclaratorRules,
            let: variableDeclaratorRules,
            const: variableDeclaratorRules
          };
        } else if (typeof variableDeclaratorRules === "object") {
          Object.assign(options.VariableDeclarator, variableDeclaratorRules);
        }
        if (typeof opts.outerIIFEBody === "number") {
          options.outerIIFEBody = opts.outerIIFEBody;
        }
        if (typeof opts.MemberExpression === "number") {
          options.MemberExpression = opts.MemberExpression;
        }
        if (typeof opts.FunctionDeclaration === "object") {
          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
        }
        if (typeof opts.FunctionExpression === "object") {
          Object.assign(options.FunctionExpression, opts.FunctionExpression);
        }
        if (typeof opts.CallExpression === "object") {
          Object.assign(options.CallExpression, opts.CallExpression);
        }
        if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
          options.ArrayExpression = opts.ArrayExpression;
        }
        if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
          options.ObjectExpression = opts.ObjectExpression;
        }
      }
    }
    const caseIndentStore = {};

    /**
     * Creates an error message for a line, given the expected/actual indentation.
     * @param {int} expectedAmount The expected amount of indentation characters for this line
     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
     * @param {int} actualTabs The actual number of indentation tabs that were found on this line
     * @returns {string} An error message for this line
     */
    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
      const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
      const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
      let foundStatement;
      if (actualSpaces > 0 && actualTabs > 0) {
        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. "1 space and 2 tabs"
      } else if (actualSpaces > 0) {
        /*
         * Abbreviate the message if the expected indentation is also spaces.
         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
         */
        foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
      } else if (actualTabs > 0) {
        foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
      } else {
        foundStatement = "0";
      }
      return {
        expected: expectedStatement,
        actual: foundStatement
      };
    }

    /**
     * Reports a given indent violation
     * @param {ASTNode} node Node violating the indent rule
     * @param {int} needed Expected indentation character count
     * @param {int} gottenSpaces Indentation space count in the actual node/code
     * @param {int} gottenTabs Indentation tab count in the actual node/code
     * @param {Object=} loc Error line and column location
     * @param {boolean} isLastNodeCheck Is the error for last node check
     * @returns {void}
     */
    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
      if (gottenSpaces && gottenTabs) {
        // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.
        return;
      }
      const desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);
      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];
      context.report({
        node,
        loc,
        messageId: "expected",
        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)
      });
    }

    /**
     * Get the actual indent of node
     * @param {ASTNode|Token} node Node to examine
     * @param {boolean} [byLastLine=false] get indent of node's last line
     * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also
     * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and
     * `badChar` is the amount of the other indentation character.
     */
    function getNodeIndent(node, byLastLine) {
      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t"));
      const spaces = indentChars.filter(char => char === " ").length;
      const tabs = indentChars.filter(char => char === "\t").length;
      return {
        space: spaces,
        tab: tabs,
        goodChar: indentType === "space" ? spaces : tabs,
        badChar: indentType === "space" ? tabs : spaces
      };
    }

    /**
     * Checks node is the first in its own start line. By default it looks by start line.
     * @param {ASTNode} node The node to check
     * @param {boolean} [byEndLocation=false] Lookup based on start position or end
     * @returns {boolean} true if its the first in the its start line
     */
    function isNodeFirstInLine(node, byEndLocation) {
      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
        startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
        endLine = firstToken ? firstToken.loc.end.line : -1;
      return startLine !== endLine;
    }

    /**
     * Check indent for node
     * @param {ASTNode} node Node to check
     * @param {int} neededIndent needed indent
     * @returns {void}
     */
    function checkNodeIndent(node, neededIndent) {
      const actualIndent = getNodeIndent(node, false);
      if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
        report(node, neededIndent, actualIndent.space, actualIndent.tab);
      }
      if (node.type === "IfStatement" && node.alternate) {
        const elseToken = sourceCode.getTokenBefore(node.alternate);
        checkNodeIndent(elseToken, neededIndent);
        if (!isNodeFirstInLine(node.alternate)) {
          checkNodeIndent(node.alternate, neededIndent);
        }
      }
      if (node.type === "TryStatement" && node.handler) {
        const catchToken = sourceCode.getFirstToken(node.handler);
        checkNodeIndent(catchToken, neededIndent);
      }
      if (node.type === "TryStatement" && node.finalizer) {
        const finallyToken = sourceCode.getTokenBefore(node.finalizer);
        checkNodeIndent(finallyToken, neededIndent);
      }
      if (node.type === "DoWhileStatement") {
        const whileToken = sourceCode.getTokenAfter(node.body);
        checkNodeIndent(whileToken, neededIndent);
      }
    }

    /**
     * Check indent for nodes list
     * @param {ASTNode[]} nodes list of node objects
     * @param {int} indent needed indent
     * @returns {void}
     */
    function checkNodesIndent(nodes, indent) {
      nodes.forEach(node => checkNodeIndent(node, indent));
    }

    /**
     * Check last node line indent this detects, that block closed correctly
     * @param {ASTNode} node Node to examine
     * @param {int} lastLineIndent needed indent
     * @returns {void}
     */
    function checkLastNodeLineIndent(node, lastLineIndent) {
      const lastToken = sourceCode.getLastToken(node);
      const endIndent = getNodeIndent(lastToken, true);
      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
        report(node, lastLineIndent, endIndent.space, endIndent.tab, {
          line: lastToken.loc.start.line,
          column: lastToken.loc.start.column
        }, true);
      }
    }

    /**
     * Check last node line indent this detects, that block closed correctly
     * This function for more complicated return statement case, where closing parenthesis may be followed by ';'
     * @param {ASTNode} node Node to examine
     * @param {int} firstLineIndent first line needed indent
     * @returns {void}
     */
    function checkLastReturnStatementLineIndent(node, firstLineIndent) {
      /*
       * in case if return statement ends with ');' we have traverse back to ')'
       * otherwise we'll measure indent for ';' and replace ')'
       */
      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
      if (textBeforeClosingParenthesis.trim()) {
        // There are tokens before the closing paren, don't report this case
        return;
      }
      const endIndent = getNodeIndent(lastToken, true);
      if (endIndent.goodChar !== firstLineIndent) {
        report(node, firstLineIndent, endIndent.space, endIndent.tab, {
          line: lastToken.loc.start.line,
          column: lastToken.loc.start.column
        }, true);
      }
    }

    /**
     * Check first node line indent is correct
     * @param {ASTNode} node Node to examine
     * @param {int} firstLineIndent needed indent
     * @returns {void}
     */
    function checkFirstNodeLineIndent(node, firstLineIndent) {
      const startIndent = getNodeIndent(node, false);
      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
        report(node, firstLineIndent, startIndent.space, startIndent.tab, {
          line: node.loc.start.line,
          column: node.loc.start.column
        });
      }
    }

    /**
     * Returns a parent node of given node based on a specified type
     * if not present then return null
     * @param {ASTNode} node node to examine
     * @param {string} type type that is being looked for
     * @param {string} stopAtList end points for the evaluating code
     * @returns {ASTNode|void} if found then node otherwise null
     */
    function getParentNodeByType(node, type, stopAtList) {
      let parent = node.parent;
      const stopAtSet = new Set(stopAtList || ["Program"]);
      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== "Program") {
        parent = parent.parent;
      }
      return parent.type === type ? parent : null;
    }

    /**
     * Returns the VariableDeclarator based on the current node
     * if not present then return null
     * @param {ASTNode} node node to examine
     * @returns {ASTNode|void} if found then node otherwise null
     */
    function getVariableDeclaratorNode(node) {
      return getParentNodeByType(node, "VariableDeclarator");
    }

    /**
     * Check to see if the node is part of the multi-line variable declaration.
     * Also if its on the same line as the varNode
     * @param {ASTNode} node node to check
     * @param {ASTNode} varNode variable declaration node to check against
     * @returns {boolean} True if all the above condition satisfy
     */
    function isNodeInVarOnTop(node, varNode) {
      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
    }

    /**
     * Check to see if the argument before the callee node is multi-line and
     * there should only be 1 argument before the callee node
     * @param {ASTNode} node node to check
     * @returns {boolean} True if arguments are multi-line
     */
    function isArgBeforeCalleeNodeMultiline(node) {
      const parent = node.parent;
      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
      }
      return false;
    }

    /**
     * Check to see if the node is a file level IIFE
     * @param {ASTNode} node The function node to check.
     * @returns {boolean} True if the node is the outer IIFE
     */
    function isOuterIIFE(node) {
      const parent = node.parent;
      let stmt = parent.parent;

      /*
       * Verify that the node is an IIEF
       */
      if (parent.type !== "CallExpression" || parent.callee !== node) {
        return false;
      }

      /*
       * Navigate legal ancestors to determine whether this IIEF is outer
       */
      while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {
        stmt = stmt.parent;
      }
      return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
    }

    /**
     * Check indent for function block content
     * @param {ASTNode} node A BlockStatement node that is inside of a function.
     * @returns {void}
     */
    function checkIndentInFunctionBlock(node) {
      /*
       * Search first caller in chain.
       * Ex.:
       *
       * Models <- Identifier
       *   .User
       *   .find()
       *   .exec(function() {
       *   // function body
       * });
       *
       * Looks for 'Models'
       */
      const calleeNode = node.parent; // FunctionExpression
      let indent;
      if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
        // If function is part of array or object, comma can be put at left
        indent = getNodeIndent(calleeNode, false).goodChar;
      } else {
        // If function is standalone, simple calculate indent
        indent = getNodeIndent(calleeNode).goodChar;
      }
      if (calleeNode.parent.type === "CallExpression") {
        const calleeParent = calleeNode.parent;
        if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
            indent = getNodeIndent(calleeParent).goodChar;
          }
        } else {
          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
            indent = getNodeIndent(calleeParent).goodChar;
          }
        }
      }

      /*
       * function body indent should be indent + indent size, unless this
       * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.
       */
      let functionOffset = indentSize;
      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
        functionOffset = options.outerIIFEBody * indentSize;
      } else if (calleeNode.type === "FunctionExpression") {
        functionOffset = options.FunctionExpression.body * indentSize;
      } else if (calleeNode.type === "FunctionDeclaration") {
        functionOffset = options.FunctionDeclaration.body * indentSize;
      }
      indent += functionOffset;

      // check if the node is inside a variable
      const parentVarNode = getVariableDeclaratorNode(node);
      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
      }
      if (node.body.length > 0) {
        checkNodesIndent(node.body, indent);
      }
      checkLastNodeLineIndent(node, indent - functionOffset);
    }

    /**
     * Checks if the given node starts and ends on the same line
     * @param {ASTNode} node The node to check
     * @returns {boolean} Whether or not the block starts and ends on the same line.
     */
    function isSingleLineNode(node) {
      const lastToken = sourceCode.getLastToken(node),
        startLine = node.loc.start.line,
        endLine = lastToken.loc.end.line;
      return startLine === endLine;
    }

    /**
     * Check to see if the first element inside an array is an object and on the same line as the node
     * If the node is not an array then it will return false.
     * @param {ASTNode} node node to check
     * @returns {boolean} success/failure
     */
    function isFirstArrayElementOnSameLine(node) {
      if (node.type === "ArrayExpression" && node.elements[0]) {
        return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
      }
      return false;
    }

    /**
     * Check indent for array block content or object block content
     * @param {ASTNode} node node to examine
     * @returns {void}
     */
    function checkIndentInArrayOrObjectBlock(node) {
      // Skip inline
      if (isSingleLineNode(node)) {
        return;
      }
      let elements = node.type === "ArrayExpression" ? node.elements : node.properties;

      // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
      elements = elements.filter(elem => elem !== null);
      let nodeIndent;
      let elementsIndent;
      const parentVarNode = getVariableDeclaratorNode(node);

      // TODO - come up with a better strategy in future
      if (isNodeFirstInLine(node)) {
        const parent = node.parent;
        nodeIndent = getNodeIndent(parent).goodChar;
        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
          if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
            if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
            } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
              const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;
              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {

                /*
                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.
                 * e.g. [{
                 *        foo: 1
                 *      },
                 *      {
                 *        bar: 1
                 *      }]
                 * the second object is not indented.
                 */
              } else if (typeof options[parent.type] === "number") {
                nodeIndent += options[parent.type] * indentSize;
              } else {
                nodeIndent = parentElements[0].loc.start.column;
              }
            } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
              if (typeof options.CallExpression.arguments === "number") {
                nodeIndent += options.CallExpression.arguments * indentSize;
              } else if (options.CallExpression.arguments === "first") {
                if (parent.arguments.indexOf(node) !== -1) {
                  nodeIndent = parent.arguments[0].loc.start.column;
                }
              } else {
                nodeIndent += indentSize;
              }
            } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
              nodeIndent += indentSize;
            }
          }
        } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== "MemberExpression" && parent.type !== "ExpressionStatement" && parent.type !== "AssignmentExpression" && parent.type !== "Property") {
          nodeIndent += indentSize;
        }
        checkFirstNodeLineIndent(node, nodeIndent);
      } else {
        nodeIndent = getNodeIndent(node).goodChar;
      }
      if (options[node.type] === "first") {
        elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.
      } else {
        elementsIndent = nodeIndent + indentSize * options[node.type];
      }

      /*
       * Check if the node is a multiple variable declaration; if so, then
       * make sure indentation takes that into account.
       */
      if (isNodeInVarOnTop(node, parentVarNode)) {
        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
      }
      checkNodesIndent(elements, elementsIndent);
      if (elements.length > 0) {
        // Skip last block line check if last item in same line
        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
          return;
        }
      }
      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
    }

    /**
     * Check if the node or node body is a BlockStatement or not
     * @param {ASTNode} node node to test
     * @returns {boolean} True if it or its body is a block statement
     */
    function isNodeBodyBlock(node) {
      return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
    }

    /**
     * Check indentation for blocks
     * @param {ASTNode} node node to check
     * @returns {void}
     */
    function blockIndentationCheck(node) {
      // Skip inline blocks
      if (isSingleLineNode(node)) {
        return;
      }
      if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
        checkIndentInFunctionBlock(node);
        return;
      }
      let indent;
      let nodesToCheck = [];

      /*
       * For this statements we should check indent from statement beginning,
       * not from the beginning of the block.
       */
      const statementsWithProperties = ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"];
      if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
        indent = getNodeIndent(node.parent).goodChar;
      } else if (node.parent && node.parent.type === "CatchClause") {
        indent = getNodeIndent(node.parent.parent).goodChar;
      } else {
        indent = getNodeIndent(node).goodChar;
      }
      if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
        nodesToCheck = [node.consequent];
      } else if (Array.isArray(node.body)) {
        nodesToCheck = node.body;
      } else {
        nodesToCheck = [node.body];
      }
      if (nodesToCheck.length > 0) {
        checkNodesIndent(nodesToCheck, indent + indentSize);
      }
      if (node.type === "BlockStatement") {
        checkLastNodeLineIndent(node, indent);
      }
    }

    /**
     * Filter out the elements which are on the same line of each other or the node.
     * basically have only 1 elements from each line except the variable declaration line.
     * @param {ASTNode} node Variable declaration node
     * @returns {ASTNode[]} Filtered elements
     */
    function filterOutSameLineVars(node) {
      return node.declarations.reduce((finalCollection, elem) => {
        const lastElem = finalCollection[finalCollection.length - 1];
        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
          finalCollection.push(elem);
        }
        return finalCollection;
      }, []);
    }

    /**
     * Check indentation for variable declarations
     * @param {ASTNode} node node to examine
     * @returns {void}
     */
    function checkIndentInVariableDeclarations(node) {
      const elements = filterOutSameLineVars(node);
      const nodeIndent = getNodeIndent(node).goodChar;
      const lastElement = elements[elements.length - 1];
      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
      checkNodesIndent(elements, elementsIndent);

      // Only check the last line if there is any token after the last item
      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
        return;
      }
      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);
      if (tokenBeforeLastElement.value === ",") {
        // Special case for comma-first syntax where the semicolon is indented
        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
      } else {
        checkLastNodeLineIndent(node, elementsIndent - indentSize);
      }
    }

    /**
     * Check and decide whether to check for indentation for blockless nodes
     * Scenarios are for or while statements without braces around them
     * @param {ASTNode} node node to examine
     * @returns {void}
     */
    function blockLessNodes(node) {
      if (node.body.type !== "BlockStatement") {
        blockIndentationCheck(node);
      }
    }

    /**
     * Returns the expected indentation for the case statement
     * @param {ASTNode} node node to examine
     * @param {int} [providedSwitchIndent] indent for switch statement
     * @returns {int} indent size
     */
    function expectedCaseIndent(node, providedSwitchIndent) {
      const switchNode = node.type === "SwitchStatement" ? node : node.parent;
      const switchIndent = typeof providedSwitchIndent === "undefined" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;
      let caseIndent;
      if (caseIndentStore[switchNode.loc.start.line]) {
        return caseIndentStore[switchNode.loc.start.line];
      }
      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
        caseIndent = switchIndent;
      } else {
        caseIndent = switchIndent + indentSize * options.SwitchCase;
      }
      caseIndentStore[switchNode.loc.start.line] = caseIndent;
      return caseIndent;
    }

    /**
     * Checks wether a return statement is wrapped in ()
     * @param {ASTNode} node node to examine
     * @returns {boolean} the result
     */
    function isWrappedInParenthesis(node) {
      const regex = /^return\s*?\(\s*?\);*?/u;
      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), "");
      return regex.test(statementWithoutArgument);
    }
    return {
      Program(node) {
        if (node.body.length > 0) {
          // Root nodes should have no indent
          checkNodesIndent(node.body, getNodeIndent(node).goodChar);
        }
      },
      ClassBody: blockIndentationCheck,
      BlockStatement: blockIndentationCheck,
      WhileStatement: blockLessNodes,
      ForStatement: blockLessNodes,
      ForInStatement: blockLessNodes,
      ForOfStatement: blockLessNodes,
      DoWhileStatement: blockLessNodes,
      IfStatement(node) {
        if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
          blockIndentationCheck(node);
        }
      },
      VariableDeclaration(node) {
        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
          checkIndentInVariableDeclarations(node);
        }
      },
      ObjectExpression(node) {
        checkIndentInArrayOrObjectBlock(node);
      },
      ArrayExpression(node) {
        checkIndentInArrayOrObjectBlock(node);
      },
      MemberExpression(node) {
        if (typeof options.MemberExpression === "undefined") {
          return;
        }
        if (isSingleLineNode(node)) {
          return;
        }

        /*
         * The typical layout of variable declarations and assignments
         * alter the expectation of correct indentation. Skip them.
         * TODO: Add appropriate configuration options for variable
         * declarations and assignments.
         */
        if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
          return;
        }
        if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
          return;
        }
        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
        const checkNodes = [node.property];
        const dot = sourceCode.getTokenBefore(node.property);
        if (dot.type === "Punctuator" && dot.value === ".") {
          checkNodes.push(dot);
        }
        checkNodesIndent(checkNodes, propertyIndent);
      },
      SwitchStatement(node) {
        // Switch is not a 'BlockStatement'
        const switchIndent = getNodeIndent(node).goodChar;
        const caseIndent = expectedCaseIndent(node, switchIndent);
        checkNodesIndent(node.cases, caseIndent);
        checkLastNodeLineIndent(node, switchIndent);
      },
      SwitchCase(node) {
        // Skip inline cases
        if (isSingleLineNode(node)) {
          return;
        }
        const caseIndent = expectedCaseIndent(node);
        checkNodesIndent(node.consequent, caseIndent + indentSize);
      },
      FunctionDeclaration(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
        } else if (options.FunctionDeclaration.parameters !== null) {
          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
        }
      },
      FunctionExpression(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        if (options.FunctionExpression.parameters === "first" && node.params.length) {
          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
        } else if (options.FunctionExpression.parameters !== null) {
          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
        }
      },
      ReturnStatement(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        const firstLineIndent = getNodeIndent(node).goodChar;

        // in case if return statement is wrapped in parenthesis
        if (isWrappedInParenthesis(node)) {
          checkLastReturnStatementLineIndent(node, firstLineIndent);
        } else {
          checkNodeIndent(node, firstLineIndent);
        }
      },
      CallExpression(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        if (options.CallExpression.arguments === "first" && node.arguments.length) {
          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
        } else if (options.CallExpression.arguments !== null) {
          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
        }
      }
    };
  }
};

/***/ }),
/* 252 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to control the style of variable initializations.
 * @author Colin Ihrig
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a for loop.
 * @param {ASTNode} block - A node to check.
 * @returns {boolean} `true` when the node is a for loop.
 */
function isForLoop(block) {
  return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
}

/**
 * Checks whether or not a given declarator node has its initializer.
 * @param {ASTNode} node - A declarator node to check.
 * @returns {boolean} `true` when the node has its initializer.
 */
function isInitialized(node) {
  const declaration = node.parent;
  const block = declaration.parent;
  if (isForLoop(block)) {
    if (block.type === "ForStatement") {
      return block.init === declaration;
    }
    return block.left === declaration;
  }
  return Boolean(node.init);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow initialization in variable declarations",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/init-declarations"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            ignoreForLoopInit: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      initialized: "Variable '{{idName}}' should be initialized on declaration.",
      notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
    }
  },
  create(context) {
    const MODE_ALWAYS = "always",
      MODE_NEVER = "never";
    const mode = context.options[0] || MODE_ALWAYS;
    const params = context.options[1] || {};

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      "VariableDeclaration:exit"(node) {
        const kind = node.kind,
          declarations = node.declarations;
        for (let i = 0; i < declarations.length; ++i) {
          const declaration = declarations[i],
            id = declaration.id,
            initialized = isInitialized(declaration),
            isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
          let messageId = "";
          if (mode === MODE_ALWAYS && !initialized) {
            messageId = "initialized";
          } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
            messageId = "notInitialized";
          }
          if (id.type === "Identifier" && messageId) {
            context.report({
              node: declaration,
              messageId,
              data: {
                idName: id.name
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 253 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to ensure consistent quotes used in jsx syntax.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const QUOTE_SETTINGS = {
  "prefer-double": {
    quote: "\"",
    description: "singlequote",
    convert(str) {
      return str.replace(/'/gu, "\"");
    }
  },
  "prefer-single": {
    quote: "'",
    description: "doublequote",
    convert(str) {
      return str.replace(/"/gu, "'");
    }
  }
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either double or single quotes in JSX attributes",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/jsx-quotes"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["prefer-single", "prefer-double"]
    }],
    messages: {
      unexpected: "Unexpected usage of {{description}}."
    }
  },
  create(context) {
    const quoteOption = context.options[0] || "prefer-double",
      setting = QUOTE_SETTINGS[quoteOption];

    /**
     * Checks if the given string literal node uses the expected quotes
     * @param {ASTNode} node - A string literal node.
     * @returns {boolean} Whether or not the string literal used the expected quotes.
     * @public
     */
    function usesExpectedQuotes(node) {
      return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
    }
    return {
      JSXAttribute(node) {
        const attributeValue = node.value;
        if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
          context.report({
            node: attributeValue,
            messageId: "unexpected",
            data: {
              description: setting.description
            },
            fix(fixer) {
              return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 254 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to specify spacing of object literal keys and values
 * @author Brandon Mills
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param {string} str String to test.
 * @returns {boolean} True if str contains a line terminator.
 */
function containsLineTerminator(str) {
  return astUtils.LINEBREAK_MATCHER.test(str);
}

/**
 * Gets the last element of an array.
 * @param {Array} arr An array.
 * @returns {any} Last element of arr.
 */
function last(arr) {
  return arr[arr.length - 1];
}

/**
 * Checks whether a node is contained on a single line.
 * @param {ASTNode} node AST Node being evaluated.
 * @returns {boolean} True if the node is a single line.
 */
function isSingleLine(node) {
  return node.loc.end.line === node.loc.start.line;
}

/**
 * Initializes a single option property from the configuration with defaults for undefined values
 * @param {Object} toOptions Object to be initialized
 * @param {Object} fromOptions Object to be initialized from
 * @returns {Object} The object with correctly initialized options and values
 */
function initOptionProperty(toOptions, fromOptions) {
  toOptions.mode = fromOptions.mode || "strict";

  // Set value of beforeColon
  if (typeof fromOptions.beforeColon !== "undefined") {
    toOptions.beforeColon = +fromOptions.beforeColon;
  } else {
    toOptions.beforeColon = 0;
  }

  // Set value of afterColon
  if (typeof fromOptions.afterColon !== "undefined") {
    toOptions.afterColon = +fromOptions.afterColon;
  } else {
    toOptions.afterColon = 1;
  }

  // Set align if exists
  if (typeof fromOptions.align !== "undefined") {
    if (typeof fromOptions.align === "object") {
      toOptions.align = fromOptions.align;
    } else {
      // "string"
      toOptions.align = {
        on: fromOptions.align,
        mode: toOptions.mode,
        beforeColon: toOptions.beforeColon,
        afterColon: toOptions.afterColon
      };
    }
  }
  return toOptions;
}

/**
 * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
 * @param {Object} toOptions Object to be initialized
 * @param {Object} fromOptions Object to be initialized from
 * @returns {Object} The object with correctly initialized options and values
 */
function initOptions(toOptions, fromOptions) {
  if (typeof fromOptions.align === "object") {
    // Initialize the alignment configuration
    toOptions.align = initOptionProperty({}, fromOptions.align);
    toOptions.align.on = fromOptions.align.on || "colon";
    toOptions.align.mode = fromOptions.align.mode || "strict";
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
  } else {
    // string or undefined
    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);

    // If alignment options are defined in multiLine, pull them out into the general align configuration
    if (toOptions.multiLine.align) {
      toOptions.align = {
        on: toOptions.multiLine.align.on,
        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
        beforeColon: toOptions.multiLine.align.beforeColon,
        afterColon: toOptions.multiLine.align.afterColon
      };
    }
  }
  return toOptions;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing between keys and values in object literal properties",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/key-spacing"
    },
    fixable: "whitespace",
    schema: [{
      anyOf: [{
        type: "object",
        properties: {
          align: {
            anyOf: [{
              enum: ["colon", "value"]
            }, {
              type: "object",
              properties: {
                mode: {
                  enum: ["strict", "minimum"]
                },
                on: {
                  enum: ["colon", "value"]
                },
                beforeColon: {
                  type: "boolean"
                },
                afterColon: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }]
          },
          mode: {
            enum: ["strict", "minimum"]
          },
          beforeColon: {
            type: "boolean"
          },
          afterColon: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              align: {
                anyOf: [{
                  enum: ["colon", "value"]
                }, {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    on: {
                      enum: ["colon", "value"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }]
              },
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          multiLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          align: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              on: {
                enum: ["colon", "value"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      extraKey: "Extra space after {{computed}}key '{{key}}'.",
      extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
      missingKey: "Missing space after {{computed}}key '{{key}}'.",
      missingValue: "Missing space before value for {{computed}}key '{{key}}'."
    }
  },
  create(context) {
    /**
     * OPTIONS
     * "key-spacing": [2, {
     *     beforeColon: false,
     *     afterColon: true,
     *     align: "colon" // Optional, or "value"
     * }
     */
    const options = context.options[0] || {},
      ruleOptions = initOptions({}, options),
      multiLineOptions = ruleOptions.multiLine,
      singleLineOptions = ruleOptions.singleLine,
      alignmentOptions = ruleOptions.align || null;
    const sourceCode = context.getSourceCode();

    /**
     * Checks whether a property is a member of the property group it follows.
     * @param {ASTNode} lastMember The last Property known to be in the group.
     * @param {ASTNode} candidate The next Property that might be in the group.
     * @returns {boolean} True if the candidate property is part of the group.
     */
    function continuesPropertyGroup(lastMember, candidate) {
      const groupEndLine = lastMember.loc.start.line,
        candidateStartLine = candidate.loc.start.line;
      if (candidateStartLine - groupEndLine <= 1) {
        return true;
      }

      /*
       * Check that the first comment is adjacent to the end of the group, the
       * last comment is adjacent to the candidate property, and that successive
       * comments are adjacent to each other.
       */
      const leadingComments = sourceCode.getCommentsBefore(candidate);
      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {
        for (let i = 1; i < leadingComments.length; i++) {
          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
            return false;
          }
        }
        return true;
      }
      return false;
    }

    /**
     * Determines if the given property is key-value property.
     * @param {ASTNode} property Property node to check.
     * @returns {boolean} Whether the property is a key-value property.
     */
    function isKeyValueProperty(property) {
      return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property" // Could be "ExperimentalSpreadProperty" or "SpreadElement"
      );
    }

    /**
     * Starting from the given a node (a property.key node here) looks forward
     * until it finds the last token before a colon punctuator and returns it.
     * @param {ASTNode} node The node to start looking from.
     * @returns {ASTNode} The last token before a colon punctuator.
     */
    function getLastTokenBeforeColon(node) {
      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);
      return sourceCode.getTokenBefore(colonToken);
    }

    /**
     * Starting from the given a node (a property.key node here) looks forward
     * until it finds the colon punctuator and returns it.
     * @param {ASTNode} node The node to start looking from.
     * @returns {ASTNode} The colon punctuator.
     */
    function getNextColon(node) {
      return sourceCode.getTokenAfter(node, astUtils.isColonToken);
    }

    /**
     * Gets an object literal property's key as the identifier name or string value.
     * @param {ASTNode} property Property node whose key to retrieve.
     * @returns {string} The property's key.
     */
    function getKey(property) {
      const key = property.key;
      if (property.computed) {
        return sourceCode.getText().slice(key.range[0], key.range[1]);
      }
      return property.key.name || property.key.value;
    }

    /**
     * Reports an appropriately-formatted error if spacing is incorrect on one
     * side of the colon.
     * @param {ASTNode} property Key-value pair in an object literal.
     * @param {string} side Side being verified - either "key" or "value".
     * @param {string} whitespace Actual whitespace string.
     * @param {int} expected Expected whitespace length.
     * @param {string} mode Value of the mode as "strict" or "minimum"
     * @returns {void}
     */
    function report(property, side, whitespace, expected, mode) {
      const diff = whitespace.length - expected,
        nextColon = getNextColon(property.key),
        tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {
          includeComments: true
        }),
        tokenAfterColon = sourceCode.getTokenAfter(nextColon, {
          includeComments: true
        }),
        isKeySide = side === "key",
        locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
        isExtra = diff > 0,
        diffAbs = Math.abs(diff),
        spaces = Array(diffAbs + 1).join(" ");
      if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
        let fix;
        if (isExtra) {
          let range;

          // Remove whitespace
          if (isKeySide) {
            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
          } else {
            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
          }
          fix = function (fixer) {
            return fixer.removeRange(range);
          };
        } else {
          // Add whitespace
          if (isKeySide) {
            fix = function (fixer) {
              return fixer.insertTextAfter(tokenBeforeColon, spaces);
            };
          } else {
            fix = function (fixer) {
              return fixer.insertTextBefore(tokenAfterColon, spaces);
            };
          }
        }
        let messageId = "";
        if (isExtra) {
          messageId = side === "key" ? "extraKey" : "extraValue";
        } else {
          messageId = side === "key" ? "missingKey" : "missingValue";
        }
        context.report({
          node: property[side],
          loc: locStart,
          messageId,
          data: {
            computed: property.computed ? "computed " : "",
            key: getKey(property)
          },
          fix
        });
      }
    }

    /**
     * Gets the number of characters in a key, including quotes around string
     * keys and braces around computed property keys.
     * @param {ASTNode} property Property of on object literal.
     * @returns {int} Width of the key.
     */
    function getKeyWidth(property) {
      const startToken = sourceCode.getFirstToken(property);
      const endToken = getLastTokenBeforeColon(property.key);
      return endToken.range[1] - startToken.range[0];
    }

    /**
     * Gets the whitespace around the colon in an object literal property.
     * @param {ASTNode} property Property node from an object literal.
     * @returns {Object} Whitespace before and after the property's colon.
     */
    function getPropertyWhitespace(property) {
      const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));
      if (whitespace) {
        return {
          beforeColon: whitespace[1],
          afterColon: whitespace[2]
        };
      }
      return null;
    }

    /**
     * Creates groups of properties.
     * @param  {ASTNode} node ObjectExpression node being evaluated.
     * @returns {Array.<ASTNode[]>} Groups of property AST node lists.
     */
    function createGroups(node) {
      if (node.properties.length === 1) {
        return [node.properties];
      }
      return node.properties.reduce((groups, property) => {
        const currentGroup = last(groups),
          prev = last(currentGroup);
        if (!prev || continuesPropertyGroup(prev, property)) {
          currentGroup.push(property);
        } else {
          groups.push([property]);
        }
        return groups;
      }, [[]]);
    }

    /**
     * Verifies correct vertical alignment of a group of properties.
     * @param {ASTNode[]} properties List of Property AST nodes.
     * @returns {void}
     */
    function verifyGroupAlignment(properties) {
      const length = properties.length,
        widths = properties.map(getKeyWidth),
        // Width of keys, including quotes
        align = alignmentOptions.on; // "value" or "colon"
      let targetWidth = Math.max(...widths),
        beforeColon,
        afterColon,
        mode;
      if (alignmentOptions && length > 1) {
        // When aligning values within a group, use the alignment configuration.
        beforeColon = alignmentOptions.beforeColon;
        afterColon = alignmentOptions.afterColon;
        mode = alignmentOptions.mode;
      } else {
        beforeColon = multiLineOptions.beforeColon;
        afterColon = multiLineOptions.afterColon;
        mode = alignmentOptions.mode;
      }

      // Conditionally include one space before or after colon
      targetWidth += align === "colon" ? beforeColon : afterColon;
      for (let i = 0; i < length; i++) {
        const property = properties[i];
        const whitespace = getPropertyWhitespace(property);
        if (whitespace) {
          // Object literal getters/setters lack a colon
          const width = widths[i];
          if (align === "value") {
            report(property, "key", whitespace.beforeColon, beforeColon, mode);
            report(property, "value", whitespace.afterColon, targetWidth - width, mode);
          } else {
            // align = "colon"
            report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
            report(property, "value", whitespace.afterColon, afterColon, mode);
          }
        }
      }
    }

    /**
     * Verifies vertical alignment, taking into account groups of properties.
     * @param  {ASTNode} node ObjectExpression node being evaluated.
     * @returns {void}
     */
    function verifyAlignment(node) {
      createGroups(node).forEach(group => {
        verifyGroupAlignment(group.filter(isKeyValueProperty));
      });
    }

    /**
     * Verifies spacing of property conforms to specified options.
     * @param  {ASTNode} node Property node being evaluated.
     * @param {Object} lineOptions Configured singleLine or multiLine options
     * @returns {void}
     */
    function verifySpacing(node, lineOptions) {
      const actual = getPropertyWhitespace(node);
      if (actual) {
        // Object literal getters/setters lack colons
        report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
        report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
      }
    }

    /**
     * Verifies spacing of each property in a list.
     * @param  {ASTNode[]} properties List of Property AST nodes.
     * @returns {void}
     */
    function verifyListSpacing(properties) {
      const length = properties.length;
      for (let i = 0; i < length; i++) {
        verifySpacing(properties[i], singleLineOptions);
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    if (alignmentOptions) {
      // Verify vertical alignment

      return {
        ObjectExpression(node) {
          if (isSingleLine(node)) {
            verifyListSpacing(node.properties.filter(isKeyValueProperty));
          } else {
            verifyAlignment(node);
          }
        }
      };
    }

    // Obey beforeColon and afterColon in each property as configured
    return {
      Property(node) {
        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
      }
    };
  }
};

/***/ }),
/* 255 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce spacing before and after keywords.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110),
  keywords = __webpack_require__(231);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const PREV_TOKEN = /^[)\]}>]$/u;
const NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
const PREV_TOKEN_M = /^[)\]}>*]$/u;
const NEXT_TOKEN_M = /^[{*]$/u;
const TEMPLATE_OPEN_PAREN = /\$\{$/u;
const TEMPLATE_CLOSE_PAREN = /^\}/u;
const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;
const KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);

// check duplications.
(function () {
  KEYS.sort();
  for (let i = 1; i < KEYS.length; ++i) {
    if (KEYS[i] === KEYS[i - 1]) {
      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
    }
  }
})();

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given token is a "Template" token ends with "${".
 *
 * @param {Token} token - A token to check.
 * @returns {boolean} `true` if the token is a "Template" token ends with "${".
 */
function isOpenParenOfTemplate(token) {
  return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}

/**
 * Checks whether or not a given token is a "Template" token starts with "}".
 *
 * @param {Token} token - A token to check.
 * @returns {boolean} `true` if the token is a "Template" token starts with "}".
 */
function isCloseParenOfTemplate(token) {
  return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after keywords",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/keyword-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: true
        },
        after: {
          type: "boolean",
          default: true
        },
        overrides: {
          type: "object",
          properties: KEYS.reduce((retv, key) => {
            retv[key] = {
              type: "object",
              properties: {
                before: {
                  type: "boolean",
                  default: true
                },
                after: {
                  type: "boolean",
                  default: true
                }
              },
              additionalProperties: false
            };
            return retv;
          }, {}),
          additionalProperties: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      expectedBefore: "Expected space(s) before \"{{value}}\".",
      expectedAfter: "Expected space(s) after \"{{value}}\".",
      unexpectedBefore: "Unexpected space(s) before \"{{value}}\".",
      unexpectedAfter: "Unexpected space(s) after \"{{value}}\"."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Reports a given token if there are not space(s) before the token.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp} pattern - A pattern of the previous token to check.
     * @returns {void}
     */
    function expectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
        context.report({
          loc: token.loc.start,
          messageId: "expectedBefore",
          data: token,
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
    }

    /**
     * Reports a given token if there are space(s) before the token.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp} pattern - A pattern of the previous token to check.
     * @returns {void}
     */
    function unexpectSpaceBefore(token, pattern) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
        context.report({
          loc: token.loc.start,
          messageId: "unexpectedBefore",
          data: token,
          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], token.range[0]]);
          }
        });
      }
    }

    /**
     * Reports a given token if there are not space(s) after the token.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp} pattern - A pattern of the next token to check.
     * @returns {void}
     */
    function expectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
        context.report({
          loc: token.loc.start,
          messageId: "expectedAfter",
          data: token,
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
    }

    /**
     * Reports a given token if there are space(s) after the token.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp} pattern - A pattern of the next token to check.
     * @returns {void}
     */
    function unexpectSpaceAfter(token, pattern) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
        context.report({
          loc: token.loc.start,
          messageId: "unexpectedAfter",
          data: token,
          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
    }

    /**
     * Parses the option object and determines check methods for each keyword.
     *
     * @param {Object|undefined} options - The option object to parse.
     * @returns {Object} - Normalized option object.
     *      Keys are keywords (there are for every keyword).
     *      Values are instances of `{"before": function, "after": function}`.
     */
    function parseOptions() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const before = options.before !== false;
      const after = options.after !== false;
      const defaultValue = {
        before: before ? expectSpaceBefore : unexpectSpaceBefore,
        after: after ? expectSpaceAfter : unexpectSpaceAfter
      };
      const overrides = options && options.overrides || {};
      const retv = Object.create(null);
      for (let i = 0; i < KEYS.length; ++i) {
        const key = KEYS[i];
        const override = overrides[key];
        if (override) {
          const thisBefore = "before" in override ? override.before : before;
          const thisAfter = "after" in override ? override.after : after;
          retv[key] = {
            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
          };
        } else {
          retv[key] = defaultValue;
        }
      }
      return retv;
    }
    const checkMethodMap = parseOptions(context.options[0]);

    /**
     * Reports a given token if usage of spacing followed by the token is
     * invalid.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
     *      token to check.
     * @returns {void}
     */
    function checkSpacingBefore(token, pattern) {
      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
    }

    /**
     * Reports a given token if usage of spacing preceded by the token is
     * invalid.
     *
     * @param {Token} token - A token to report.
     * @param {RegExp|undefined} pattern - Optional. A pattern of the next
     *      token to check.
     * @returns {void}
     */
    function checkSpacingAfter(token, pattern) {
      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
    }

    /**
     * Reports a given token if usage of spacing around the token is invalid.
     *
     * @param {Token} token - A token to report.
     * @returns {void}
     */
    function checkSpacingAround(token) {
      checkSpacingBefore(token);
      checkSpacingAfter(token);
    }

    /**
     * Reports the first token of a given node if the first token is a keyword
     * and usage of spacing around the token is invalid.
     *
     * @param {ASTNode|null} node - A node to report.
     * @returns {void}
     */
    function checkSpacingAroundFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (firstToken && firstToken.type === "Keyword") {
        checkSpacingAround(firstToken);
      }
    }

    /**
     * Reports the first token of a given node if the first token is a keyword
     * and usage of spacing followed by the token is invalid.
     *
     * This is used for unary operators (e.g. `typeof`), `function`, and `super`.
     * Other rules are handling usage of spacing preceded by those keywords.
     *
     * @param {ASTNode|null} node - A node to report.
     * @returns {void}
     */
    function checkSpacingBeforeFirstToken(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (firstToken && firstToken.type === "Keyword") {
        checkSpacingBefore(firstToken);
      }
    }

    /**
     * Reports the previous token of a given node if the token is a keyword and
     * usage of spacing around the token is invalid.
     *
     * @param {ASTNode|null} node - A node to report.
     * @returns {void}
     */
    function checkSpacingAroundTokenBefore(node) {
      if (node) {
        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
        checkSpacingAround(token);
      }
    }

    /**
     * Reports `async` or `function` keywords of a given node if usage of
     * spacing around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForFunction(node) {
      const firstToken = node && sourceCode.getFirstToken(node);
      if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
        checkSpacingBefore(firstToken);
      }
    }

    /**
     * Reports `class` and `extends` keywords of a given node if usage of
     * spacing around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForClass(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.superClass);
    }

    /**
     * Reports `if` and `else` keywords of a given node if usage of spacing
     * around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForIfStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.alternate);
    }

    /**
     * Reports `try`, `catch`, and `finally` keywords of a given node if usage
     * of spacing around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForTryStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundFirstToken(node.handler);
      checkSpacingAroundTokenBefore(node.finalizer);
    }

    /**
     * Reports `do` and `while` keywords of a given node if usage of spacing
     * around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForDoWhileStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.test);
    }

    /**
     * Reports `for` and `in` keywords of a given node if usage of spacing
     * around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForForInStatement(node) {
      checkSpacingAroundFirstToken(node);
      checkSpacingAroundTokenBefore(node.right);
    }

    /**
     * Reports `for` and `of` keywords of a given node if usage of spacing
     * around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForForOfStatement(node) {
      if (node.await) {
        checkSpacingBefore(sourceCode.getFirstToken(node, 0));
        checkSpacingAfter(sourceCode.getFirstToken(node, 1));
      } else {
        checkSpacingAroundFirstToken(node);
      }
      checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
    }

    /**
     * Reports `import`, `export`, `as`, and `from` keywords of a given node if
     * usage of spacing around those keywords is invalid.
     *
     * This rule handles the `*` token in module declarations.
     *
     *     import*as A from "./a"; /*error Expected space(s) after "import".
     *                               error Expected space(s) before "as".
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForModuleDeclaration(node) {
      const firstToken = sourceCode.getFirstToken(node);
      checkSpacingBefore(firstToken, PREV_TOKEN_M);
      checkSpacingAfter(firstToken, NEXT_TOKEN_M);
      if (node.type === "ExportDefaultDeclaration") {
        checkSpacingAround(sourceCode.getTokenAfter(firstToken));
      }
      if (node.source) {
        const fromToken = sourceCode.getTokenBefore(node.source);
        checkSpacingBefore(fromToken, PREV_TOKEN_M);
        checkSpacingAfter(fromToken, NEXT_TOKEN_M);
      }
    }

    /**
     * Reports `as` keyword of a given node if usage of spacing around this
     * keyword is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForImportNamespaceSpecifier(node) {
      const asToken = sourceCode.getFirstToken(node, 1);
      checkSpacingBefore(asToken, PREV_TOKEN_M);
    }

    /**
     * Reports `static`, `get`, and `set` keywords of a given node if usage of
     * spacing around those keywords is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForProperty(node) {
      if (node.static) {
        checkSpacingAroundFirstToken(node);
      }
      if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
        const token = sourceCode.getTokenBefore(node.key, tok => {
          switch (tok.value) {
            case "get":
            case "set":
            case "async":
              return true;
            default:
              return false;
          }
        });
        if (!token) {
          throw new Error("Failed to find token get, set, or async beside method name");
        }
        checkSpacingAround(token);
      }
    }

    /**
     * Reports `await` keyword of a given node if usage of spacing before
     * this keyword is invalid.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function checkSpacingForAwaitExpression(node) {
      checkSpacingBefore(sourceCode.getFirstToken(node));
    }
    return {
      // Statements
      DebuggerStatement: checkSpacingAroundFirstToken,
      WithStatement: checkSpacingAroundFirstToken,
      // Statements - Control flow
      BreakStatement: checkSpacingAroundFirstToken,
      ContinueStatement: checkSpacingAroundFirstToken,
      ReturnStatement: checkSpacingAroundFirstToken,
      ThrowStatement: checkSpacingAroundFirstToken,
      TryStatement: checkSpacingForTryStatement,
      // Statements - Choice
      IfStatement: checkSpacingForIfStatement,
      SwitchStatement: checkSpacingAroundFirstToken,
      SwitchCase: checkSpacingAroundFirstToken,
      // Statements - Loops
      DoWhileStatement: checkSpacingForDoWhileStatement,
      ForInStatement: checkSpacingForForInStatement,
      ForOfStatement: checkSpacingForForOfStatement,
      ForStatement: checkSpacingAroundFirstToken,
      WhileStatement: checkSpacingAroundFirstToken,
      // Statements - Declarations
      ClassDeclaration: checkSpacingForClass,
      ExportNamedDeclaration: checkSpacingForModuleDeclaration,
      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
      ExportAllDeclaration: checkSpacingForModuleDeclaration,
      FunctionDeclaration: checkSpacingForFunction,
      ImportDeclaration: checkSpacingForModuleDeclaration,
      VariableDeclaration: checkSpacingAroundFirstToken,
      // Expressions
      ArrowFunctionExpression: checkSpacingForFunction,
      AwaitExpression: checkSpacingForAwaitExpression,
      ClassExpression: checkSpacingForClass,
      FunctionExpression: checkSpacingForFunction,
      NewExpression: checkSpacingBeforeFirstToken,
      Super: checkSpacingBeforeFirstToken,
      ThisExpression: checkSpacingBeforeFirstToken,
      UnaryExpression: checkSpacingBeforeFirstToken,
      YieldExpression: checkSpacingBeforeFirstToken,
      // Others
      ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
      MethodDefinition: checkSpacingForProperty,
      Property: checkSpacingForProperty
    };
  }
};

/***/ }),
/* 256 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce the position of line comments
 * @author Alberto Rodrguez
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce position of line comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/line-comment-position"
    },
    schema: [{
      oneOf: [{
        enum: ["above", "beside"]
      }, {
        type: "object",
        properties: {
          position: {
            enum: ["above", "beside"],
            default: "above"
          },
          ignorePattern: {
            type: "string"
          },
          applyDefaultPatterns: {
            type: "boolean"
          },
          applyDefaultIgnorePatterns: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      above: "Expected comment to be above code.",
      beside: "Expected comment to be beside code."
    }
  },
  create(context) {
    const options = context.options[0];
    let above,
      ignorePattern,
      applyDefaultIgnorePatterns = true;
    if (!options || typeof options === "string") {
      above = !options || options === "above";
    } else {
      above = !options.position || options.position === "above";
      ignorePattern = options.ignorePattern;
      if (Object.prototype.hasOwnProperty.call(options, "applyDefaultIgnorePatterns")) {
        applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;
      } else {
        applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
      }
    }
    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
    const fallThroughRegExp = /^\s*falls?\s?through/u;
    const customIgnoreRegExp = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type === "Line").forEach(node => {
          if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
            return;
          }
          if (ignorePattern && customIgnoreRegExp.test(node.value)) {
            return;
          }
          const previous = sourceCode.getTokenBefore(node, {
            includeComments: true
          });
          const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;
          if (above) {
            if (isOnSameLine) {
              context.report({
                node,
                messageId: "above"
              });
            }
          } else {
            if (!isOnSameLine) {
              context.report({
                node,
                messageId: "beside"
              });
            }
          }
        });
      }
    };
  }
};

/***/ }),
/* 257 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce a single linebreak style.
 * @author Erik Mueller
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/linebreak-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["unix", "windows"]
    }],
    messages: {
      expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
      expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Builds a fix function that replaces text at the specified range in the source text.
     * @param {int[]} range The range to replace
     * @param {string} text The text to insert.
     * @returns {Function} Fixer function
     * @private
     */
    function createFix(range, text) {
      return function (fixer) {
        return fixer.replaceTextRange(range, text);
      };
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: function checkForlinebreakStyle(node) {
        const linebreakStyle = context.options[0] || "unix",
          expectedLF = linebreakStyle === "unix",
          expectedLFChars = expectedLF ? "\n" : "\r\n",
          source = sourceCode.getText(),
          pattern = astUtils.createGlobalLinebreakMatcher();
        let match;
        let i = 0;
        while ((match = pattern.exec(source)) !== null) {
          i++;
          if (match[0] === expectedLFChars) {
            continue;
          }
          const index = match.index;
          const range = [index, index + match[0].length];
          context.report({
            node,
            loc: {
              line: i,
              column: sourceCode.lines[i - 1].length
            },
            messageId: expectedLF ? "expectedLF" : "expectedCRLF",
            fix: createFix(range, expectedLFChars)
          });
        }
      }
    };
  }
};

/***/ }),
/* 258 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Enforces empty lines around comments.
 * @author Jamund Ferguson
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99),
  astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Return an array with with any line numbers that are empty.
 * @param {Array} lines An array of each line of the file.
 * @returns {Array} An array of line numbers.
 */
function getEmptyLineNums(lines) {
  const emptyLines = lines.map((line, i) => ({
    code: line.trim(),
    num: i + 1
  })).filter(line => !line.code).map(line => line.num);
  return emptyLines;
}

/**
 * Return an array with with any line numbers that contain comments.
 * @param {Array} comments An array of comment tokens.
 * @returns {Array} An array of line numbers.
 */
function getCommentLineNums(comments) {
  const lines = [];
  comments.forEach(token => {
    const start = token.loc.start.line;
    const end = token.loc.end.line;
    lines.push(start, end);
  });
  return lines;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require empty lines around comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-around-comment"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        beforeBlockComment: {
          type: "boolean",
          default: true
        },
        afterBlockComment: {
          type: "boolean",
          default: false
        },
        beforeLineComment: {
          type: "boolean",
          default: false
        },
        afterLineComment: {
          type: "boolean",
          default: false
        },
        allowBlockStart: {
          type: "boolean",
          default: false
        },
        allowBlockEnd: {
          type: "boolean",
          default: false
        },
        allowClassStart: {
          type: "boolean"
        },
        allowClassEnd: {
          type: "boolean"
        },
        allowObjectStart: {
          type: "boolean"
        },
        allowObjectEnd: {
          type: "boolean"
        },
        allowArrayStart: {
          type: "boolean"
        },
        allowArrayEnd: {
          type: "boolean"
        },
        ignorePattern: {
          type: "string"
        },
        applyDefaultIgnorePatterns: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      after: "Expected line after comment.",
      before: "Expected line before comment."
    }
  },
  create(context) {
    const options = Object.assign({}, context.options[0]);
    const ignorePattern = options.ignorePattern;
    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
    const customIgnoreRegExp = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp
    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
    options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
    const sourceCode = context.getSourceCode();
    const lines = sourceCode.lines,
      numLines = lines.length + 1,
      comments = sourceCode.getAllComments(),
      commentLines = getCommentLineNums(comments),
      emptyLines = getEmptyLineNums(lines),
      commentAndEmptyLines = commentLines.concat(emptyLines);

    /**
     * Returns whether or not comments are on lines starting with or ending with code
     * @param {token} token The comment token to check.
     * @returns {boolean} True if the comment is not alone.
     */
    function codeAroundComment(token) {
      let currentToken = token;
      do {
        currentToken = sourceCode.getTokenBefore(currentToken, {
          includeComments: true
        });
      } while (currentToken && astUtils.isCommentToken(currentToken));
      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
        return true;
      }
      currentToken = token;
      do {
        currentToken = sourceCode.getTokenAfter(currentToken, {
          includeComments: true
        });
      } while (currentToken && astUtils.isCommentToken(currentToken));
      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
        return true;
      }
      return false;
    }

    /**
     * Returns whether or not comments are inside a node type or not.
     * @param {ASTNode} parent The Comment parent node.
     * @param {string} nodeType The parent type to check against.
     * @returns {boolean} True if the comment is inside nodeType.
     */
    function isParentNodeType(parent, nodeType) {
      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
    }

    /**
     * Returns the parent node that contains the given token.
     * @param {token} token The token to check.
     * @returns {ASTNode} The parent node that contains the given token.
     */
    function getParentNodeOfToken(token) {
      return sourceCode.getNodeByRangeIndex(token.range[0]);
    }

    /**
     * Returns whether or not comments are at the parent start or not.
     * @param {token} token The Comment token.
     * @param {string} nodeType The parent type to check against.
     * @returns {boolean} True if the comment is at parent start.
     */
    function isCommentAtParentStart(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;
    }

    /**
     * Returns whether or not comments are at the parent end or not.
     * @param {token} token The Comment token.
     * @param {string} nodeType The parent type to check against.
     * @returns {boolean} True if the comment is at parent end.
     */
    function isCommentAtParentEnd(token, nodeType) {
      const parent = getParentNodeOfToken(token);
      return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
    }

    /**
     * Returns whether or not comments are at the block start or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at block start.
     */
    function isCommentAtBlockStart(token) {
      return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
    }

    /**
     * Returns whether or not comments are at the block end or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at block end.
     */
    function isCommentAtBlockEnd(token) {
      return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
    }

    /**
     * Returns whether or not comments are at the class start or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at class start.
     */
    function isCommentAtClassStart(token) {
      return isCommentAtParentStart(token, "ClassBody");
    }

    /**
     * Returns whether or not comments are at the class end or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at class end.
     */
    function isCommentAtClassEnd(token) {
      return isCommentAtParentEnd(token, "ClassBody");
    }

    /**
     * Returns whether or not comments are at the object start or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at object start.
     */
    function isCommentAtObjectStart(token) {
      return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
    }

    /**
     * Returns whether or not comments are at the object end or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at object end.
     */
    function isCommentAtObjectEnd(token) {
      return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
    }

    /**
     * Returns whether or not comments are at the array start or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at array start.
     */
    function isCommentAtArrayStart(token) {
      return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
    }

    /**
     * Returns whether or not comments are at the array end or not.
     * @param {token} token The Comment token.
     * @returns {boolean} True if the comment is at array end.
     */
    function isCommentAtArrayEnd(token) {
      return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
    }

    /**
     * Checks if a comment token has lines around it (ignores inline comments)
     * @param {token} token The Comment token.
     * @param {Object} opts Options to determine the newline.
     * @param {boolean} opts.after Should have a newline after this line.
     * @param {boolean} opts.before Should have a newline before this line.
     * @returns {void}
     */
    function checkForEmptyLine(token, opts) {
      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
        return;
      }
      if (ignorePattern && customIgnoreRegExp.test(token.value)) {
        return;
      }
      let after = opts.after,
        before = opts.before;
      const prevLineNum = token.loc.start.line - 1,
        nextLineNum = token.loc.end.line + 1,
        commentIsNotAlone = codeAroundComment(token);
      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),
        blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),
        classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),
        classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),
        objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),
        objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),
        arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),
        arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;

      // ignore top of the file and bottom of the file
      if (prevLineNum < 1) {
        before = false;
      }
      if (nextLineNum >= numLines) {
        after = false;
      }

      // we ignore all inline comments
      if (commentIsNotAlone) {
        return;
      }
      const previousTokenOrComment = sourceCode.getTokenBefore(token, {
        includeComments: true
      });
      const nextTokenOrComment = sourceCode.getTokenAfter(token, {
        includeComments: true
      });

      // check for newline before
      if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
        const lineStart = token.range[0] - token.loc.start.column;
        const range = [lineStart, lineStart];
        context.report({
          node: token,
          messageId: "before",
          fix(fixer) {
            return fixer.insertTextBeforeRange(range, "\n");
          }
        });
      }

      // check for newline after
      if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
        context.report({
          node: token,
          messageId: "after",
          fix(fixer) {
            return fixer.insertTextAfter(token, "\n");
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program() {
        comments.forEach(token => {
          if (token.type === "Line") {
            if (options.beforeLineComment || options.afterLineComment) {
              checkForEmptyLine(token, {
                after: options.afterLineComment,
                before: options.beforeLineComment
              });
            }
          } else if (token.type === "Block") {
            if (options.beforeBlockComment || options.afterBlockComment) {
              checkForEmptyLine(token, {
                after: options.afterBlockComment,
                before: options.beforeBlockComment
              });
            }
          }
        });
      }
    };
  }
};

/***/ }),
/* 259 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Require or disallow newlines around directives.
 * @author Kai Cataldo
 * @deprecated
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newlines around directives",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-around-directive"
    },
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          before: {
            enum: ["always", "never"]
          },
          after: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: false,
        minProperties: 2
      }]
    }],
    fixable: "whitespace",
    messages: {
      expected: "Expected newline {{location}} \"{{value}}\" directive.",
      unexpected: "Unexpected newline {{location}} \"{{value}}\" directive."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const config = context.options[0] || "always";
    const expectLineBefore = typeof config === "string" ? config : config.before;
    const expectLineAfter = typeof config === "string" ? config : config.after;

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Check if node is preceded by a blank newline.
     * @param {ASTNode} node Node to check.
     * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.
     */
    function hasNewlineBefore(node) {
      const tokenBefore = sourceCode.getTokenBefore(node, {
        includeComments: true
      });
      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
      return node.loc.start.line - tokenLineBefore >= 2;
    }

    /**
     * Gets the last token of a node that is on the same line as the rest of the node.
     * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing
     * semicolon on a different line.
     * @param {ASTNode} node A directive node
     * @returns {Token} The last token of the node on the line
     */
    function getLastTokenOnLine(node) {
      const lastToken = sourceCode.getLastToken(node);
      const secondToLastToken = sourceCode.getTokenBefore(lastToken);
      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
    }

    /**
     * Check if node is followed by a blank newline.
     * @param {ASTNode} node Node to check.
     * @returns {boolean} Whether or not the passed in node is followed by a blank newline.
     */
    function hasNewlineAfter(node) {
      const lastToken = getLastTokenOnLine(node);
      const tokenAfter = sourceCode.getTokenAfter(lastToken, {
        includeComments: true
      });
      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
    }

    /**
     * Report errors for newlines around directives.
     * @param {ASTNode} node Node to check.
     * @param {string} location Whether the error was found before or after the directive.
     * @param {boolean} expected Whether or not a newline was expected or unexpected.
     * @returns {void}
     */
    function reportError(node, location, expected) {
      context.report({
        node,
        messageId: expected ? "expected" : "unexpected",
        data: {
          value: node.expression.value,
          location
        },
        fix(fixer) {
          const lastToken = getLastTokenOnLine(node);
          if (expected) {
            return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
          }
          return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
        }
      });
    }

    /**
     * Check lines around directives in node
     * @param {ASTNode} node - node to check
     * @returns {void}
     */
    function checkDirectives(node) {
      const directives = astUtils.getDirectivePrologue(node);
      if (!directives.length) {
        return;
      }
      const firstDirective = directives[0];
      const leadingComments = sourceCode.getCommentsBefore(firstDirective);

      /*
       * Only check before the first directive if it is preceded by a comment or if it is at the top of
       * the file and expectLineBefore is set to "never". This is to not force a newline at the top of
       * the file if there are no comments as well as for compatibility with padded-blocks.
       */
      if (leadingComments.length) {
        if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", true);
        }
        if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", false);
        }
      } else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
        reportError(firstDirective, "before", false);
      }
      const lastDirective = directives[directives.length - 1];
      const statements = node.type === "Program" ? node.body : node.body.body;

      /*
       * Do not check after the last directive if the body only
       * contains a directive prologue and isn't followed by a comment to ensure
       * this rule behaves well with padded-blocks.
       */
      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
        return;
      }
      if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
        reportError(lastDirective, "after", true);
      }
      if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
        reportError(lastDirective, "after", false);
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: checkDirectives,
      FunctionDeclaration: checkDirectives,
      FunctionExpression: checkDirectives,
      ArrowFunctionExpression: checkDirectives
    };
  }
};

/***/ }),
/* 260 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to check empty newline between class members
 * @author <hh_2013@foxmail.com>
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line between class members",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/lines-between-class-members"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptAfterSingleLine: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      never: "Unexpected blank line between class members.",
      always: "Expected blank line between class members."
    }
  },
  create(context) {
    const options = [];
    options[0] = context.options[0] || "always";
    options[1] = context.options[1] || {
      exceptAfterSingleLine: false
    };
    const sourceCode = context.getSourceCode();

    /**
     * Checks if there is padding between two tokens
     * @param {Token} first The first token
     * @param {Token} second The second token
     * @returns {boolean} True if there is at least a line between the tokens
     */
    function isPaddingBetweenTokens(first, second) {
      const comments = sourceCode.getCommentsBefore(second);
      const len = comments.length;

      // If there is no comments
      if (len === 0) {
        const linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;
        return linesBetweenFstAndSnd >= 1;
      }

      // If there are comments
      let sumOfCommentLines = 0; // the numbers of lines of comments
      let prevCommentLineNum = -1; // line number of the end of the previous comment

      for (let i = 0; i < len; i++) {
        const commentLinesOfThisComment = comments[i].loc.end.line - comments[i].loc.start.line + 1;
        sumOfCommentLines += commentLinesOfThisComment;

        /*
         * If this comment and the previous comment are in the same line,
         * the count of comment lines is duplicated. So decrement sumOfCommentLines.
         */
        if (prevCommentLineNum === comments[i].loc.start.line) {
          sumOfCommentLines -= 1;
        }
        prevCommentLineNum = comments[i].loc.end.line;
      }

      /*
       * If the first block and the first comment are in the same line,
       * the count of comment lines is duplicated. So decrement sumOfCommentLines.
       */
      if (first.loc.end.line === comments[0].loc.start.line) {
        sumOfCommentLines -= 1;
      }

      /*
       * If the last comment and the second block are in the same line,
       * the count of comment lines is duplicated. So decrement sumOfCommentLines.
       */
      if (comments[len - 1].loc.end.line === second.loc.start.line) {
        sumOfCommentLines -= 1;
      }
      const linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;
      return linesBetweenFstAndSnd - sumOfCommentLines >= 1;
    }
    return {
      ClassBody(node) {
        const body = node.body;
        for (let i = 0; i < body.length - 1; i++) {
          const curFirst = sourceCode.getFirstToken(body[i]);
          const curLast = sourceCode.getLastToken(body[i]);
          const nextFirst = sourceCode.getFirstToken(body[i + 1]);
          const isPadded = isPaddingBetweenTokens(curLast, nextFirst);
          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
          const skip = !isMulti && options[1].exceptAfterSingleLine;
          if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
            context.report({
              node: body[i + 1],
              messageId: isPadded ? "never" : "always",
              fix(fixer) {
                return isPadded ? fixer.replaceTextRange([curLast.range[1], nextFirst.range[0]], "\n") : fixer.insertTextAfter(curLast, "\n");
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 261 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Enforce a maximum number of classes per file
 * @author James Garbutt <https://github.com/43081j>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of classes per file",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-classes-per-file"
    },
    schema: [{
      type: "integer",
      minimum: 1
    }],
    messages: {
      maximumExceeded: "Number of classes per file must not exceed {{ max }}."
    }
  },
  create(context) {
    const maxClasses = context.options[0] || 1;
    let classCount = 0;
    return {
      Program() {
        classCount = 0;
      },
      "Program:exit"(node) {
        if (classCount > maxClasses) {
          context.report({
            node,
            messageId: "maximumExceeded",
            data: {
              max: maxClasses
            }
          });
        }
      },
      "ClassDeclaration, ClassExpression"() {
        classCount++;
      }
    };
  }
};

/***/ }),
/* 262 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to set the maximum depth block can be nested in a function.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that blocks can be nested",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-depth"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      tooDeeply: "Blocks are nested too deeply ({{depth}})."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const functionStack = [],
      option = context.options[0];
    let maxDepth = 4;
    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      maxDepth = option.maximum || option.max;
    }
    if (typeof option === "number") {
      maxDepth = option;
    }

    /**
     * When parsing a new function, store it in our function stack
     * @returns {void}
     * @private
     */
    function startFunction() {
      functionStack.push(0);
    }

    /**
     * When parsing is done then pop out the reference
     * @returns {void}
     * @private
     */
    function endFunction() {
      functionStack.pop();
    }

    /**
     * Save the block and Evaluate the node
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function pushBlock(node) {
      const len = ++functionStack[functionStack.length - 1];
      if (len > maxDepth) {
        context.report({
          node,
          messageId: "tooDeeply",
          data: {
            depth: len
          }
        });
      }
    }

    /**
     * Pop the saved block
     * @returns {void}
     * @private
     */
    function popBlock() {
      functionStack[functionStack.length - 1]--;
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      Program: startFunction,
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      IfStatement(node) {
        if (node.parent.type !== "IfStatement") {
          pushBlock(node);
        }
      },
      SwitchStatement: pushBlock,
      TryStatement: pushBlock,
      DoWhileStatement: pushBlock,
      WhileStatement: pushBlock,
      WithStatement: pushBlock,
      ForStatement: pushBlock,
      ForInStatement: pushBlock,
      ForOfStatement: pushBlock,
      "IfStatement:exit": popBlock,
      "SwitchStatement:exit": popBlock,
      "TryStatement:exit": popBlock,
      "DoWhileStatement:exit": popBlock,
      "WhileStatement:exit": popBlock,
      "WithStatement:exit": popBlock,
      "ForStatement:exit": popBlock,
      "ForInStatement:exit": popBlock,
      "ForOfStatement:exit": popBlock,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,
      "Program:exit": endFunction
    };
  }
};

/***/ }),
/* 263 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for max length on a line.
 * @author Matt DuVall <http://www.mattduvall.com>
 */



//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
const OPTIONS_SCHEMA = {
  type: "object",
  properties: {
    code: {
      type: "integer",
      minimum: 0,
      default: 80
    },
    comments: {
      type: "integer",
      minimum: 0
    },
    tabWidth: {
      type: "integer",
      minimum: 0,
      default: 4
    },
    ignorePattern: {
      type: "string"
    },
    ignoreComments: {
      type: "boolean",
      default: false
    },
    ignoreStrings: {
      type: "boolean",
      default: false
    },
    ignoreUrls: {
      type: "boolean",
      default: false
    },
    ignoreTemplateLiterals: {
      type: "boolean",
      default: false
    },
    ignoreRegExpLiterals: {
      type: "boolean",
      default: false
    },
    ignoreTrailingComments: {
      type: "boolean",
      default: false
    }
  },
  additionalProperties: false
};
const OPTIONS_OR_INTEGER_SCHEMA = {
  anyOf: [OPTIONS_SCHEMA, {
    type: "integer",
    minimum: 0
  }]
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum line length",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-len"
    },
    schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA],
    messages: {
      max: "Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.",
      maxComment: "Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}."
    }
  },
  create(context) {
    /*
     * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:
     * - They're matching an entire string that we know is a URI
     * - We're matching part of a string where we think there *might* be a URL
     * - We're only concerned about URLs, as picking out any URI would cause
     *   too many false positives
     * - We don't care about matching the entire URL, any small segment is fine
     */
    const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
    const sourceCode = context.getSourceCode();

    /**
     * Computes the length of a line that may contain tabs. The width of each
     * tab will be the number of spaces to the next tab stop.
     * @param {string} line The line.
     * @param {int} tabWidth The width of each tab stop in spaces.
     * @returns {int} The computed line length.
     * @private
     */
    function computeLineLength(line, tabWidth) {
      let extraCharacterCount = 0;
      line.replace(/\t/gu, (match, offset) => {
        const totalOffset = offset + extraCharacterCount,
          previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
          spaceCount = tabWidth - previousTabStopOffset;
        extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
      });
      return Array.from(line).length + extraCharacterCount;
    }

    // The options object must be the last option specified
    const options = Object.assign({}, context.options[context.options.length - 1]);

    // but max code length
    if (typeof context.options[0] === "number") {
      options.code = context.options[0];
    }

    // and tabWidth can be optionally specified directly as integers.
    if (typeof context.options[1] === "number") {
      options.tabWidth = context.options[1];
    }
    const maxLength = options.code || 80,
      tabWidth = options.tabWidth || 4,
      ignoreComments = options.ignoreComments || false,
      ignoreStrings = options.ignoreStrings || false,
      ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,
      ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,
      ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
      ignoreUrls = options.ignoreUrls || false,
      maxCommentLength = options.comments;
    let ignorePattern = options.ignorePattern || null;
    if (ignorePattern) {
      ignorePattern = new RegExp(ignorePattern); // eslint-disable-line require-unicode-regexp
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Tells if a given comment is trailing: it starts on the current line and
     * extends to or past the end of the current line.
     * @param {string} line The source line we want to check for a trailing comment on
     * @param {number} lineNumber The one-indexed line number for line
     * @param {ASTNode} comment The comment to inspect
     * @returns {boolean} If the comment is trailing on the given line
     */
    function isTrailingComment(line, lineNumber, comment) {
      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
    }

    /**
     * Tells if a comment encompasses the entire line.
     * @param {string} line The source line with a trailing comment
     * @param {number} lineNumber The one-indexed line number this is on
     * @param {ASTNode} comment The comment to remove
     * @returns {boolean} If the comment covers the entire line
     */
    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start,
        end = comment.loc.end,
        isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
    }

    /**
     * Gets the line after the comment and any remaining trailing whitespace is
     * stripped.
     * @param {string} line The source line with a trailing comment
     * @param {ASTNode} comment The comment to remove
     * @returns {string} Line without comment and trailing whitepace
     */
    function stripTrailingComment(line, comment) {
      // loc.column is zero-indexed
      return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
    }

    /**
     * Ensure that an array exists at [key] on `object`, and add `value` to it.
     *
     * @param {Object} object the object to mutate
     * @param {string} key the object's key
     * @param {*} value the value to add
     * @returns {void}
     * @private
     */
    function ensureArrayAndPush(object, key, value) {
      if (!Array.isArray(object[key])) {
        object[key] = [];
      }
      object[key].push(value);
    }

    /**
     * Retrieves an array containing all strings (" or ') in the source code.
     *
     * @returns {ASTNode[]} An array of string nodes.
     */
    function getAllStrings() {
      return sourceCode.ast.tokens.filter(token => token.type === "String" || token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute");
    }

    /**
     * Retrieves an array containing all template literals in the source code.
     *
     * @returns {ASTNode[]} An array of template literal nodes.
     */
    function getAllTemplateLiterals() {
      return sourceCode.ast.tokens.filter(token => token.type === "Template");
    }

    /**
     * Retrieves an array containing all RegExp literals in the source code.
     *
     * @returns {ASTNode[]} An array of RegExp literal nodes.
     */
    function getAllRegExpLiterals() {
      return sourceCode.ast.tokens.filter(token => token.type === "RegularExpression");
    }

    /**
     * A reducer to group an AST node by line number, both start and end.
     *
     * @param {Object} acc the accumulator
     * @param {ASTNode} node the AST node in question
     * @returns {Object} the modified accumulator
     * @private
     */
    function groupByLineNumber(acc, node) {
      for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {
        ensureArrayAndPush(acc, i, node);
      }
      return acc;
    }

    /**
     * Check the program for max length
     * @param {ASTNode} node Node to examine
     * @returns {void}
     * @private
     */
    function checkProgramForMaxLength(node) {
      // split (honors line-ending)
      const lines = sourceCode.lines,
        // list of comments to ignore
        comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];

      // we iterate over comments in parallel with the lines
      let commentsIndex = 0;
      const strings = getAllStrings();
      const stringsByLine = strings.reduce(groupByLineNumber, {});
      const templateLiterals = getAllTemplateLiterals();
      const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});
      const regExpLiterals = getAllRegExpLiterals();
      const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});
      lines.forEach((line, i) => {
        // i is zero-indexed, line numbers are one-indexed
        const lineNumber = i + 1;

        /*
         * if we're checking comment length; we need to know whether this
         * line is a comment
         */
        let lineIsComment = false;
        let textToMeasure;

        /*
         * We can short-circuit the comment checks if we're already out of
         * comments to check.
         */
        if (commentsIndex < comments.length) {
          let comment = null;

          // iterate over comments until we find one past the current line
          do {
            comment = comments[++commentsIndex];
          } while (comment && comment.loc.start.line <= lineNumber);

          // and step back by one
          comment = comments[--commentsIndex];
          if (isFullLineComment(line, lineNumber, comment)) {
            lineIsComment = true;
            textToMeasure = line;
          } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
            textToMeasure = stripTrailingComment(line, comment);
          } else {
            textToMeasure = line;
          }
        } else {
          textToMeasure = line;
        }
        if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
          // ignore this line
          return;
        }
        const lineLength = computeLineLength(textToMeasure, tabWidth);
        const commentLengthApplies = lineIsComment && maxCommentLength;
        if (lineIsComment && ignoreComments) {
          return;
        }
        if (commentLengthApplies) {
          if (lineLength > maxCommentLength) {
            context.report({
              node,
              loc: {
                line: lineNumber,
                column: 0
              },
              messageId: "maxComment",
              data: {
                lineNumber: i + 1,
                maxCommentLength
              }
            });
          }
        } else if (lineLength > maxLength) {
          context.report({
            node,
            loc: {
              line: lineNumber,
              column: 0
            },
            messageId: "max",
            data: {
              lineNumber: i + 1,
              maxLength
            }
          });
        }
      });
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      Program: checkProgramForMaxLength
    };
  }
};

/***/ }),
/* 264 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview enforce a maximum file length
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of lines per file",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-lines"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          max: {
            type: "integer",
            minimum: 0
          },
          skipComments: {
            type: "boolean"
          },
          skipBlankLines: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "File must be at most {{max}} lines long. It's {{actual}} lines long."
    }
  },
  create(context) {
    const option = context.options[0];
    let max = 300;
    if (typeof option === "object" && Object.prototype.hasOwnProperty.call(option, "max")) {
      max = option.max;
    } else if (typeof option === "number") {
      max = option;
    }
    const skipComments = option && option.skipComments;
    const skipBlankLines = option && option.skipBlankLines;
    const sourceCode = context.getSourceCode();

    /**
     * Returns whether or not a token is a comment node type
     * @param {Token} token The token to check
     * @returns {boolean} True if the token is a comment node
     */
    function isCommentNodeType(token) {
      return token && (token.type === "Block" || token.type === "Line");
    }

    /**
     * Returns the line numbers of a comment that don't have any code on the same line
     * @param {Node} comment The comment node to check
     * @returns {number[]} The line numbers
     */
    function getLinesWithoutCode(comment) {
      let start = comment.loc.start.line;
      let end = comment.loc.end.line;
      let token;
      token = comment;
      do {
        token = sourceCode.getTokenBefore(token, {
          includeComments: true
        });
      } while (isCommentNodeType(token));
      if (token && astUtils.isTokenOnSameLine(token, comment)) {
        start += 1;
      }
      token = comment;
      do {
        token = sourceCode.getTokenAfter(token, {
          includeComments: true
        });
      } while (isCommentNodeType(token));
      if (token && astUtils.isTokenOnSameLine(comment, token)) {
        end -= 1;
      }
      if (start <= end) {
        return lodash.range(start, end + 1);
      }
      return [];
    }
    return {
      "Program:exit"() {
        let lines = sourceCode.lines.map((text, i) => ({
          lineNumber: i + 1,
          text
        }));
        if (skipBlankLines) {
          lines = lines.filter(l => l.text.trim() !== "");
        }
        if (skipComments) {
          const comments = sourceCode.getAllComments();
          const commentLines = lodash.flatten(comments.map(comment => getLinesWithoutCode(comment)));
          lines = lines.filter(l => !lodash.includes(commentLines, l.lineNumber));
        }
        if (lines.length > max) {
          context.report({
            loc: {
              line: 1,
              column: 0
            },
            messageId: "exceed",
            data: {
              max,
              actual: lines.length
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 265 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to set the maximum number of line of code in a function.
 * @author Pete Ward <peteward44@gmail.com>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const OPTIONS_SCHEMA = {
  type: "object",
  properties: {
    max: {
      type: "integer",
      minimum: 0,
      default: 50
    },
    skipComments: {
      type: "boolean",
      default: false
    },
    skipBlankLines: {
      type: "boolean",
      default: false
    },
    IIFEs: {
      type: "boolean",
      default: false
    }
  },
  additionalProperties: false
};
const OPTIONS_OR_INTEGER_SCHEMA = {
  oneOf: [OPTIONS_SCHEMA, {
    type: "integer",
    minimum: 1
  }]
};

/**
 * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.
 * @param {Array} comments An array of comment nodes.
 * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.
 */
function getCommentLineNumbers(comments) {
  const map = new Map();
  if (!comments) {
    return map;
  }
  comments.forEach(comment => {
    for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
      map.set(i, comment);
    }
  });
  return map;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of line of code in a function",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-lines-per-function"
    },
    schema: [OPTIONS_OR_INTEGER_SCHEMA],
    messages: {
      exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const lines = sourceCode.lines;
    const option = context.options[0];
    let maxLines = 50;
    let skipComments = false;
    let skipBlankLines = false;
    let IIFEs = false;
    if (typeof option === "object") {
      maxLines = option.max;
      skipComments = option.skipComments;
      skipBlankLines = option.skipBlankLines;
      IIFEs = option.IIFEs;
    } else if (typeof option === "number") {
      maxLines = option;
    }
    const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Tells if a comment encompasses the entire line.
     * @param {string} line The source line with a trailing comment
     * @param {number} lineNumber The one-indexed line number this is on
     * @param {ASTNode} comment The comment to remove
     * @returns {boolean} If the comment covers the entire line
     */
    function isFullLineComment(line, lineNumber, comment) {
      const start = comment.loc.start,
        end = comment.loc.end,
        isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),
        isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
    }

    /**
     * Identifies is a node is a FunctionExpression which is part of an IIFE
     * @param {ASTNode} node Node to test
     * @returns {boolean} True if it's an IIFE
     */
    function isIIFE(node) {
      return node.type === "FunctionExpression" && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
    }

    /**
     * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property
     * @param {ASTNode} node Node to test
     * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property
     */
    function isEmbedded(node) {
      if (!node.parent) {
        return false;
      }
      if (node !== node.parent.value) {
        return false;
      }
      if (node.parent.type === "MethodDefinition") {
        return true;
      }
      if (node.parent.type === "Property") {
        return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
      }
      return false;
    }

    /**
     * Count the lines in the function
     * @param {ASTNode} funcNode Function AST node
     * @returns {void}
     * @private
     */
    function processFunction(funcNode) {
      const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;
      if (!IIFEs && isIIFE(node)) {
        return;
      }
      let lineCount = 0;
      for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {
        const line = lines[i];
        if (skipComments) {
          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
            continue;
          }
        }
        if (skipBlankLines) {
          if (line.match(/^\s*$/u)) {
            continue;
          }
        }
        lineCount++;
      }
      if (lineCount > maxLines) {
        const name = astUtils.getFunctionNameWithKind(funcNode);
        context.report({
          node,
          messageId: "exceed",
          data: {
            name,
            lineCount,
            maxLines
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      FunctionDeclaration: processFunction,
      FunctionExpression: processFunction,
      ArrowFunctionExpression: processFunction
    };
  }
};

/***/ }),
/* 266 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce a maximum number of nested callbacks.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that callbacks can be nested",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-nested-callbacks"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Constants
    //--------------------------------------------------------------------------
    const option = context.options[0];
    let THRESHOLD = 10;
    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      THRESHOLD = option.maximum || option.max;
    } else if (typeof option === "number") {
      THRESHOLD = option;
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const callbackStack = [];

    /**
     * Checks a given function node for too many callbacks.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */
    function checkFunction(node) {
      const parent = node.parent;
      if (parent.type === "CallExpression") {
        callbackStack.push(node);
      }
      if (callbackStack.length > THRESHOLD) {
        const opts = {
          num: callbackStack.length,
          max: THRESHOLD
        };
        context.report({
          node,
          messageId: "exceed",
          data: opts
        });
      }
    }

    /**
     * Pops the call stack.
     * @returns {void}
     * @private
     */
    function popStack() {
      callbackStack.pop();
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      ArrowFunctionExpression: checkFunction,
      "ArrowFunctionExpression:exit": popStack,
      FunctionExpression: checkFunction,
      "FunctionExpression:exit": popStack
    };
  }
};

/***/ }),
/* 267 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when a function has too many parameters
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of parameters in function definitions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-params"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0];
    let numParams = 3;
    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      numParams = option.maximum || option.max;
    }
    if (typeof option === "number") {
      numParams = option;
    }

    /**
     * Checks a function to see if it has too many parameters.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */
    function checkFunction(node) {
      if (node.params.length > numParams) {
        context.report({
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          node,
          messageId: "exceed",
          data: {
            name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),
            count: node.params.length,
            max: numParams
          }
        });
      }
    }
    return {
      FunctionDeclaration: checkFunction,
      ArrowFunctionExpression: checkFunction,
      FunctionExpression: checkFunction
    };
  }
};

/***/ }),
/* 268 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to set the maximum number of statements in a function.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of statements allowed in function blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-statements"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: false
      }]
    }, {
      type: "object",
      properties: {
        ignoreTopLevelFunctions: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }],
    messages: {
      exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const functionStack = [],
      option = context.options[0],
      ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
      topLevelFunctions = [];
    let maxStatements = 10;
    if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
      maxStatements = option.maximum || option.max;
    } else if (typeof option === "number") {
      maxStatements = option;
    }

    /**
     * Reports a node if it has too many statements
     * @param {ASTNode} node node to evaluate
     * @param {int} count Number of statements in node
     * @param {int} max Maximum number of statements allowed
     * @returns {void}
     * @private
     */
    function reportIfTooManyStatements(node, count, max) {
      if (count > max) {
        const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
        context.report({
          node,
          messageId: "exceed",
          data: {
            name,
            count,
            max
          }
        });
      }
    }

    /**
     * When parsing a new function, store it in our function stack
     * @returns {void}
     * @private
     */
    function startFunction() {
      functionStack.push(0);
    }

    /**
     * Evaluate the node at the end of function
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function endFunction(node) {
      const count = functionStack.pop();
      if (ignoreTopLevelFunctions && functionStack.length === 0) {
        topLevelFunctions.push({
          node,
          count
        });
      } else {
        reportIfTooManyStatements(node, count, maxStatements);
      }
    }

    /**
     * Increment the count of the functions
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function countStatements(node) {
      functionStack[functionStack.length - 1] += node.body.length;
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      BlockStatement: countStatements,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction,
      "Program:exit"() {
        if (topLevelFunctions.length === 1) {
          return;
        }
        topLevelFunctions.forEach(element => {
          const count = element.count;
          const node = element.node;
          reportIfTooManyStatements(node, count, maxStatements);
        });
      }
    };
  }
};

/***/ }),
/* 269 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Specify the maximum number of statements allowed per line.
 * @author Kenneth Williams
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum number of statements allowed per line",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/max-statements-per-line"
    },
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 1,
          default: 1
        }
      },
      additionalProperties: false
    }],
    messages: {
      exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode(),
      options = context.options[0] || {},
      maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1;
    let lastStatementLine = 0,
      numberOfStatementsOnThisLine = 0,
      firstExtraStatement;

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;

    /**
     * Reports with the first extra statement, and clears it.
     *
     * @returns {void}
     */
    function reportFirstExtraStatementAndClear() {
      if (firstExtraStatement) {
        context.report({
          node: firstExtraStatement,
          messageId: "exceed",
          data: {
            numberOfStatementsOnThisLine,
            maxStatementsPerLine,
            statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
          }
        });
      }
      firstExtraStatement = null;
    }

    /**
     * Gets the actual last token of a given node.
     *
     * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.
     * @returns {Token} The actual last token.
     */
    function getActualLastToken(node) {
      return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
    }

    /**
     * Addresses a given node.
     * It updates the state of this rule, then reports the node if the node violated this rule.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function enterStatement(node) {
      const line = node.loc.start.line;

      /*
       * Skip to allow non-block statements if this is direct child of control statements.
       * `if (a) foo();` is counted as 1.
       * But `if (a) foo(); else foo();` should be counted as 2.
       */
      if (SINGLE_CHILD_ALLOWED.test(node.parent.type) && node.parent.alternate !== node) {
        return;
      }

      // Update state.
      if (line === lastStatementLine) {
        numberOfStatementsOnThisLine += 1;
      } else {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }

      // Reports if the node violated this rule.
      if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
        firstExtraStatement = firstExtraStatement || node;
      }
    }

    /**
     * Updates the state of this rule with the end line of leaving node to check with the next statement.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function leaveStatement(node) {
      const line = getActualLastToken(node).loc.end.line;

      // Update state.
      if (line !== lastStatementLine) {
        reportFirstExtraStatementAndClear();
        numberOfStatementsOnThisLine = 1;
        lastStatementLine = line;
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      BreakStatement: enterStatement,
      ClassDeclaration: enterStatement,
      ContinueStatement: enterStatement,
      DebuggerStatement: enterStatement,
      DoWhileStatement: enterStatement,
      ExpressionStatement: enterStatement,
      ForInStatement: enterStatement,
      ForOfStatement: enterStatement,
      ForStatement: enterStatement,
      FunctionDeclaration: enterStatement,
      IfStatement: enterStatement,
      ImportDeclaration: enterStatement,
      LabeledStatement: enterStatement,
      ReturnStatement: enterStatement,
      SwitchStatement: enterStatement,
      ThrowStatement: enterStatement,
      TryStatement: enterStatement,
      VariableDeclaration: enterStatement,
      WhileStatement: enterStatement,
      WithStatement: enterStatement,
      ExportNamedDeclaration: enterStatement,
      ExportDefaultDeclaration: enterStatement,
      ExportAllDeclaration: enterStatement,
      "BreakStatement:exit": leaveStatement,
      "ClassDeclaration:exit": leaveStatement,
      "ContinueStatement:exit": leaveStatement,
      "DebuggerStatement:exit": leaveStatement,
      "DoWhileStatement:exit": leaveStatement,
      "ExpressionStatement:exit": leaveStatement,
      "ForInStatement:exit": leaveStatement,
      "ForOfStatement:exit": leaveStatement,
      "ForStatement:exit": leaveStatement,
      "FunctionDeclaration:exit": leaveStatement,
      "IfStatement:exit": leaveStatement,
      "ImportDeclaration:exit": leaveStatement,
      "LabeledStatement:exit": leaveStatement,
      "ReturnStatement:exit": leaveStatement,
      "SwitchStatement:exit": leaveStatement,
      "ThrowStatement:exit": leaveStatement,
      "TryStatement:exit": leaveStatement,
      "VariableDeclaration:exit": leaveStatement,
      "WhileStatement:exit": leaveStatement,
      "WithStatement:exit": leaveStatement,
      "ExportNamedDeclaration:exit": leaveStatement,
      "ExportDefaultDeclaration:exit": leaveStatement,
      "ExportAllDeclaration:exit": leaveStatement,
      "Program:exit": reportFirstExtraStatementAndClear
    };
  }
};

/***/ }),
/* 270 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview enforce a particular style for multiline comments
 * @author Teddy Katz
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a particular style for multiline comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/multiline-comment-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["starred-block", "separate-lines", "bare-block"]
    }],
    messages: {
      expectedBlock: "Expected a block comment instead of consecutive line comments.",
      startNewline: "Expected a linebreak after '/*'.",
      endNewline: "Expected a linebreak before '*/'.",
      missingStar: "Expected a '*' at the start of this line.",
      alignment: "Expected this line to be aligned with the start of the comment.",
      expectedLines: "Expected multiple line comments instead of a block comment."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "starred-block";

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Gets a list of comment lines in a group
     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment
     * @returns {string[]} A list of comment lines
     */
    function getCommentLines(commentGroup) {
      if (commentGroup[0].type === "Line") {
        return commentGroup.map(comment => comment.value);
      }
      return commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER).map(line => line.replace(/^\s*\*?/u, ""));
    }

    /**
     * Converts a comment into starred-block form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in starred-block form, excluding start and end markers
     */
    function convertToStarredBlock(firstComment, commentLinesList) {
      const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
      const starredLines = commentLinesList.map(line => `${initialOffset} *${line}`);
      return `\n${starredLines.join("\n")}\n${initialOffset} `;
    }

    /**
     * Converts a comment into separate-line form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in separate-line form
     */
    function convertToSeparateLines(firstComment, commentLinesList) {
      const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
      const separateLines = commentLinesList.map(line => `// ${line.trim()}`);
      return separateLines.join(`\n${initialOffset}`);
    }

    /**
     * Converts a comment into bare-block form
     * @param {Token} firstComment The first comment of the group being converted
     * @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
     * @returns {string} A representation of the comment value in bare-block form
     */
    function convertToBlock(firstComment, commentLinesList) {
      const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
      const blockLines = commentLinesList.map(line => line.trim());
      return `/* ${blockLines.join(`\n${initialOffset}   `)} */`;
    }

    /**
     * Check a comment is JSDoc form
     * @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment
     * @returns {boolean} if commentGroup is JSDoc form, return true
     */
    function isJSDoc(commentGroup) {
      const lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);
      return commentGroup[0].type === "Block" && /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every(line => /^\s* /u.test(line)) && /^\s*$/u.test(lines[lines.length - 1]);
    }

    /**
     * Each method checks a group of comments to see if it's valid according to the given option.
     * @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single
     * block comment or multiple line comments.
     * @returns {void}
     */
    const commentGroupCheckers = {
      "starred-block"(commentGroup) {
        const commentLines = getCommentLines(commentGroup);
        if (commentLines.some(value => value.includes("*/"))) {
          return;
        }
        if (commentGroup.length > 1) {
          context.report({
            loc: {
              start: commentGroup[0].loc.start,
              end: commentGroup[commentGroup.length - 1].loc.end
            },
            messageId: "expectedBlock",
            fix(fixer) {
              const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
              const starredBlock = `/*${convertToStarredBlock(commentGroup[0], commentLines)}*/`;
              return commentLines.some(value => value.startsWith("/")) ? null : fixer.replaceTextRange(range, starredBlock);
            }
          });
        } else {
          const block = commentGroup[0];
          const lines = block.value.split(astUtils.LINEBREAK_MATCHER);
          const expectedLinePrefix = `${sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0])} *`;
          if (!/^\*?\s*$/u.test(lines[0])) {
            const start = block.value.startsWith("*") ? block.range[0] + 1 : block.range[0];
            context.report({
              loc: {
                start: block.loc.start,
                end: {
                  line: block.loc.start.line,
                  column: block.loc.start.column + 2
                }
              },
              messageId: "startNewline",
              fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\n${expectedLinePrefix}`)
            });
          }
          if (!/^\s*$/u.test(lines[lines.length - 1])) {
            context.report({
              loc: {
                start: {
                  line: block.loc.end.line,
                  column: block.loc.end.column - 2
                },
                end: block.loc.end
              },
              messageId: "endNewline",
              fix: fixer => fixer.replaceTextRange([block.range[1] - 2, block.range[1]], `\n${expectedLinePrefix}/`)
            });
          }
          for (let lineNumber = block.loc.start.line + 1; lineNumber <= block.loc.end.line; lineNumber++) {
            const lineText = sourceCode.lines[lineNumber - 1];
            if (!lineText.startsWith(expectedLinePrefix)) {
              context.report({
                loc: {
                  start: {
                    line: lineNumber,
                    column: 0
                  },
                  end: {
                    line: lineNumber,
                    column: sourceCode.lines[lineNumber - 1].length
                  }
                },
                messageId: /^\s*\*/u.test(lineText) ? "alignment" : "missingStar",
                fix(fixer) {
                  const lineStartIndex = sourceCode.getIndexFromLoc({
                    line: lineNumber,
                    column: 0
                  });
                  const linePrefixLength = lineText.match(/^\s*\*? ?/u)[0].length;
                  const commentStartIndex = lineStartIndex + linePrefixLength;
                  const replacementText = lineNumber === block.loc.end.line || lineText.length === linePrefixLength ? expectedLinePrefix : `${expectedLinePrefix} `;
                  return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
                }
              });
            }
          }
        }
      },
      "separate-lines"(commentGroup) {
        if (!isJSDoc(commentGroup) && commentGroup[0].type === "Block") {
          const commentLines = getCommentLines(commentGroup);
          const block = commentGroup[0];
          const tokenAfter = sourceCode.getTokenAfter(block, {
            includeComments: true
          });
          if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) {
            return;
          }
          context.report({
            loc: {
              start: block.loc.start,
              end: {
                line: block.loc.start.line,
                column: block.loc.start.column + 2
              }
            },
            messageId: "expectedLines",
            fix(fixer) {
              return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(line => line)));
            }
          });
        }
      },
      "bare-block"(commentGroup) {
        if (!isJSDoc(commentGroup)) {
          const commentLines = getCommentLines(commentGroup);

          // disallows consecutive line comments in favor of using a block comment.
          if (commentGroup[0].type === "Line" && commentLines.length > 1 && !commentLines.some(value => value.includes("*/"))) {
            context.report({
              loc: {
                start: commentGroup[0].loc.start,
                end: commentGroup[commentGroup.length - 1].loc.end
              },
              messageId: "expectedBlock",
              fix(fixer) {
                const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                const block = convertToBlock(commentGroup[0], commentLines.filter(line => line));
                return fixer.replaceTextRange(range, block);
              }
            });
          }

          // prohibits block comments from having a * at the beginning of each line.
          if (commentGroup[0].type === "Block") {
            const block = commentGroup[0];
            const lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(line => line.trim());
            if (lines.length > 0 && lines.every(line => /^\s*\*/u.test(line))) {
              context.report({
                loc: {
                  start: block.loc.start,
                  end: {
                    line: block.loc.start.line,
                    column: block.loc.start.column + 2
                  }
                },
                messageId: "expectedBlock",
                fix(fixer) {
                  return fixer.replaceText(block, convertToBlock(block, commentLines.filter(line => line)));
                }
              });
            }
          }
        }
      }
    };

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      Program() {
        return sourceCode.getAllComments().filter(comment => comment.type !== "Shebang").filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter(comment => {
          const tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
        }).reduce((commentGroups, comment, index, commentList) => {
          const tokenBefore = sourceCode.getTokenBefore(comment, {
            includeComments: true
          });
          if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
            commentGroups[commentGroups.length - 1].push(comment);
          } else {
            commentGroups.push([comment]);
          }
          return commentGroups;
        }, []).filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);
      }
    };
  }
};

/***/ }),
/* 271 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Enforce newlines between operands of ternary expressions
 * @author Kai Cataldo
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce newlines between operands of ternary expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/multiline-ternary"
    },
    schema: [{
      enum: ["always", "always-multiline", "never"]
    }],
    messages: {
      expectedTestCons: "Expected newline between test and consequent of ternary expression.",
      expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
      unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
      unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
    }
  },
  create(context) {
    const option = context.options[0];
    const multiline = option !== "never";
    const allowSingleLine = option === "always-multiline";

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Tests whether node is preceded by supplied tokens
     * @param {ASTNode} node - node to check
     * @param {ASTNode} parentNode - parent of node to report
     * @param {boolean} expected - whether newline was expected or not
     * @returns {void}
     * @private
     */
    function reportError(node, parentNode, expected) {
      context.report({
        node,
        messageId: `${expected ? "expected" : "unexpected"}${node === parentNode.test ? "TestCons" : "ConsAlt"}`
      });
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ConditionalExpression(node) {
        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);
        if (!multiline) {
          if (!areTestAndConsequentOnSameLine) {
            reportError(node.test, node, false);
          }
          if (!areConsequentAndAlternateOnSameLine) {
            reportError(node.consequent, node, false);
          }
        } else {
          if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
            return;
          }
          if (areTestAndConsequentOnSameLine) {
            reportError(node.test, node, true);
          }
          if (areConsequentAndAlternateOnSameLine) {
            reportError(node.consequent, node, true);
          }
        }
      }
    };
  }
};

/***/ }),
/* 272 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of constructors without capital letters
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const CAPS_ALLOWED = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol"];

/**
 * Ensure that if the key is provided, it must be an array.
 * @param {Object} obj Object to check with `key`.
 * @param {string} key Object key to check on `obj`.
 * @param {*} fallback If obj[key] is not present, this will be returned.
 * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`
 */
function checkArray(obj, key, fallback) {
  /* istanbul ignore if */
  if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
    throw new TypeError(`${key}, if provided, must be an Array`);
  }
  return obj[key] || fallback;
}

/**
 * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
 * @param {Object} map Accumulator object for the reduce.
 * @param {string} key Object key to set to `true`.
 * @returns {Object} Returns the updated Object for further reduction.
 */
function invert(map, key) {
  map[key] = true;
  return map;
}

/**
 * Creates an object with the cap is new exceptions as its keys and true as their values.
 * @param {Object} config Rule configuration
 * @returns {Object} Object with cap is new exceptions.
 */
function calculateCapIsNewExceptions(config) {
  let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);
  if (capIsNewExceptions !== CAPS_ALLOWED) {
    capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
  }
  return capIsNewExceptions.reduce(invert, {});
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require constructor names to begin with a capital letter",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/new-cap"
    },
    schema: [{
      type: "object",
      properties: {
        newIsCap: {
          type: "boolean",
          default: true
        },
        capIsNew: {
          type: "boolean",
          default: true
        },
        newIsCapExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        newIsCapExceptionPattern: {
          type: "string"
        },
        capIsNewExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        capIsNewExceptionPattern: {
          type: "string"
        },
        properties: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
      lower: "A constructor name should not start with a lowercase letter."
    }
  },
  create(context) {
    const config = Object.assign({}, context.options[0]);
    config.newIsCap = config.newIsCap !== false;
    config.capIsNew = config.capIsNew !== false;
    const skipProperties = config.properties === false;
    const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
    const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null; // eslint-disable-line require-unicode-regexp

    const capIsNewExceptions = calculateCapIsNewExceptions(config);
    const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null; // eslint-disable-line require-unicode-regexp

    const listeners = {};
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Get exact callee name from expression
     * @param {ASTNode} node CallExpression or NewExpression node
     * @returns {string} name
     */
    function extractNameFromExpression(node) {
      let name = "";
      if (node.callee.type === "MemberExpression") {
        const property = node.callee.property;
        if (property.type === "Literal" && typeof property.value === "string") {
          name = property.value;
        } else if (property.type === "Identifier" && !node.callee.computed) {
          name = property.name;
        }
      } else {
        name = node.callee.name;
      }
      return name;
    }

    /**
     * Returns the capitalization state of the string -
     * Whether the first character is uppercase, lowercase, or non-alphabetic
     * @param {string} str String
     * @returns {string} capitalization state: "non-alpha", "lower", or "upper"
     */
    function getCap(str) {
      const firstChar = str.charAt(0);
      const firstCharLower = firstChar.toLowerCase();
      const firstCharUpper = firstChar.toUpperCase();
      if (firstCharLower === firstCharUpper) {
        // char has no uppercase variant, so it's non-alphabetic
        return "non-alpha";
      }
      if (firstChar === firstCharLower) {
        return "lower";
      }
      return "upper";
    }

    /**
     * Check if capitalization is allowed for a CallExpression
     * @param {Object} allowedMap Object mapping calleeName to a Boolean
     * @param {ASTNode} node CallExpression node
     * @param {string} calleeName Capitalized callee name from a CallExpression
     * @param {Object} pattern RegExp object from options pattern
     * @returns {boolean} Returns true if the callee may be capitalized
     */
    function isCapAllowed(allowedMap, node, calleeName, pattern) {
      const sourceText = sourceCode.getText(node.callee);
      if (allowedMap[calleeName] || allowedMap[sourceText]) {
        return true;
      }
      if (pattern && pattern.test(sourceText)) {
        return true;
      }
      if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
        // allow if callee is Date.UTC
        return node.callee.object.type === "Identifier" && node.callee.object.name === "Date";
      }
      return skipProperties && node.callee.type === "MemberExpression";
    }

    /**
     * Reports the given messageId for the given node. The location will be the start of the property or the callee.
     * @param {ASTNode} node CallExpression or NewExpression node.
     * @param {string} messageId The messageId to report.
     * @returns {void}
     */
    function report(node, messageId) {
      let callee = node.callee;
      if (callee.type === "MemberExpression") {
        callee = callee.property;
      }
      context.report({
        node,
        loc: callee.loc.start,
        messageId
      });
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    if (config.newIsCap) {
      listeners.NewExpression = function (node) {
        const constructorName = extractNameFromExpression(node);
        if (constructorName) {
          const capitalization = getCap(constructorName);
          const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);
          if (!isAllowed) {
            report(node, "lower");
          }
        }
      };
    }
    if (config.capIsNew) {
      listeners.CallExpression = function (node) {
        const calleeName = extractNameFromExpression(node);
        if (calleeName) {
          const capitalization = getCap(calleeName);
          const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);
          if (!isAllowed) {
            report(node, "upper");
          }
        }
      };
    }
    return listeners;
  }
};

/***/ }),
/* 273 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when using constructor without parentheses
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses when invoking a constructor with no arguments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/new-parens"
    },
    fixable: "code",
    schema: [],
    messages: {
      missing: "Missing '()' invoking a constructor."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      NewExpression(node) {
        if (node.arguments.length !== 0) {
          return; // shortcut: if there are arguments, there have to be parens
        }
        const lastToken = sourceCode.getLastToken(node);
        const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
        const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));
        if (!hasParens) {
          context.report({
            node,
            messageId: "missing",
            fix: fixer => fixer.insertTextAfter(node, "()")
          });
        }
      }
    };
  }
};

/***/ }),
/* 274 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to check empty newline after "var" statement
 * @author Gopal Venkatesan
 * @deprecated
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line after variable declarations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-after-var"
    },
    schema: [{
      enum: ["never", "always"]
    }],
    fixable: "whitespace",
    messages: {
      expected: "Expected blank line after variable declarations.",
      unexpected: "Unexpected blank line after variable declarations."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    // Default `mode` to "always".
    const mode = context.options[0] === "never" ? "never" : "always";

    // Cache starting and ending line numbers of comments for faster lookup
    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {
      result[token.loc.start.line] = token.loc.end.line;
      return result;
    }, {});

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Gets a token from the given node to compare line to the next statement.
     *
     * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.
     *
     * - The last token is semicolon.
     * - The semicolon is on a different line from the previous token of the semicolon.
     *
     * This behavior would address semicolon-less style code. e.g.:
     *
     *     var foo = 1
     *
     *     ;(a || b).doSomething()
     *
     * @param {ASTNode} node - The node to get.
     * @returns {Token} The token to compare line to the next statement.
     */
    function getLastToken(node) {
      const lastToken = sourceCode.getLastToken(node);
      if (lastToken.type === "Punctuator" && lastToken.value === ";") {
        const prevToken = sourceCode.getTokenBefore(lastToken);
        if (prevToken.loc.end.line !== lastToken.loc.start.line) {
          return prevToken;
        }
      }
      return lastToken;
    }

    /**
     * Determine if provided keyword is a variable declaration
     * @private
     * @param {string} keyword - keyword to test
     * @returns {boolean} True if `keyword` is a type of var
     */
    function isVar(keyword) {
      return keyword === "var" || keyword === "let" || keyword === "const";
    }

    /**
     * Determine if provided keyword is a variant of for specifiers
     * @private
     * @param {string} keyword - keyword to test
     * @returns {boolean} True if `keyword` is a variant of for specifier
     */
    function isForTypeSpecifier(keyword) {
      return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    /**
     * Determine if provided keyword is an export specifiers
     * @private
     * @param {string} nodeType - nodeType to test
     * @returns {boolean} True if `nodeType` is an export specifier
     */
    function isExportSpecifier(nodeType) {
      return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
    }

    /**
     * Determine if provided node is the last of their parent block.
     * @private
     * @param {ASTNode} node - node to test
     * @returns {boolean} True if `node` is last of their parent block.
     */
    function isLastNode(node) {
      const token = sourceCode.getTokenAfter(node);
      return !token || token.type === "Punctuator" && token.value === "}";
    }

    /**
     * Gets the last line of a group of consecutive comments
     * @param {number} commentStartLine The starting line of the group
     * @returns {number} The number of the last comment line of the group
     */
    function getLastCommentLineOfBlock(commentStartLine) {
      const currentCommentEnd = commentEndLine[commentStartLine];
      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
    }

    /**
     * Determine if a token starts more than one line after a comment ends
     * @param  {token}   token            The token being checked
     * @param {integer}  commentStartLine The line number on which the comment starts
     * @returns {boolean}                 True if `token` does not start immediately after a comment
     */
    function hasBlankLineAfterComment(token, commentStartLine) {
      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
    }

    /**
     * Checks that a blank line exists after a variable declaration when mode is
     * set to "always", or checks that there is no blank line when mode is set
     * to "never"
     * @private
     * @param {ASTNode} node - `VariableDeclaration` node to test
     * @returns {void}
     */
    function checkForBlankLine(node) {
      /*
       * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will
       * sometimes be second-last if there is a semicolon on a different line.
       */
      const lastToken = getLastToken(node),
        /*
         * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken
         * is the last token of the node.
         */
        nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
        nextLineNum = lastToken.loc.end.line + 1;

      // Ignore if there is no following statement
      if (!nextToken) {
        return;
      }

      // Ignore if parent of node is a for variant
      if (isForTypeSpecifier(node.parent.type)) {
        return;
      }

      // Ignore if parent of node is an export specifier
      if (isExportSpecifier(node.parent.type)) {
        return;
      }

      /*
       * Some coding styles use multiple `var` statements, so do nothing if
       * the next token is a `var` statement.
       */
      if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
        return;
      }

      // Ignore if it is last statement in a block
      if (isLastNode(node)) {
        return;
      }

      // Next statement is not a `var`...
      const noNextLineToken = nextToken.loc.start.line > nextLineNum;
      const hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";
      if (mode === "never" && noNextLineToken && !hasNextLineComment) {
        context.report({
          node,
          messageId: "unexpected",
          data: {
            identifier: node.name
          },
          fix(fixer) {
            const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);
            return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}\n${linesBetween[linesBetween.length - 1]}`);
          }
        });
      }

      // Token on the next line, or comment without blank line
      if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
        context.report({
          node,
          messageId: "expected",
          data: {
            identifier: node.name
          },
          fix(fixer) {
            if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
              return fixer.insertTextBefore(nextToken, "\n\n");
            }
            return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      VariableDeclaration: checkForBlankLine
    };
  }
};

/***/ }),
/* 275 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to require newlines before `return` statement
 * @author Kai Cataldo
 * @deprecated
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require an empty line before `return` statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-before-return"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      expected: "Expected newline before return statement."
    },
    deprecated: true,
    replacedBy: ["padding-line-between-statements"]
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Tests whether node is preceded by supplied tokens
     * @param {ASTNode} node - node to check
     * @param {Array} testTokens - array of tokens to test against
     * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens
     * @private
     */
    function isPrecededByTokens(node, testTokens) {
      const tokenBefore = sourceCode.getTokenBefore(node);
      return testTokens.some(token => tokenBefore.value === token);
    }

    /**
     * Checks whether node is the first node after statement or in block
     * @param {ASTNode} node - node to check
     * @returns {boolean} Whether or not the node is the first node after statement or in block
     * @private
     */
    function isFirstNode(node) {
      const parentType = node.parent.type;
      if (node.parent.body) {
        return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
      }
      if (parentType === "IfStatement") {
        return isPrecededByTokens(node, ["else", ")"]);
      }
      if (parentType === "DoWhileStatement") {
        return isPrecededByTokens(node, ["do"]);
      }
      if (parentType === "SwitchCase") {
        return isPrecededByTokens(node, [":"]);
      }
      return isPrecededByTokens(node, [")"]);
    }

    /**
     * Returns the number of lines of comments that precede the node
     * @param {ASTNode} node - node to check for overlapping comments
     * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments
     * @returns {number} Number of lines of comments that precede the node
     * @private
     */
    function calcCommentLines(node, lineNumTokenBefore) {
      const comments = sourceCode.getCommentsBefore(node);
      let numLinesComments = 0;
      if (!comments.length) {
        return numLinesComments;
      }
      comments.forEach(comment => {
        numLinesComments++;
        if (comment.type === "Block") {
          numLinesComments += comment.loc.end.line - comment.loc.start.line;
        }

        // avoid counting lines with inline comments twice
        if (comment.loc.start.line === lineNumTokenBefore) {
          numLinesComments--;
        }
        if (comment.loc.end.line === node.loc.start.line) {
          numLinesComments--;
        }
      });
      return numLinesComments;
    }

    /**
     * Returns the line number of the token before the node that is passed in as an argument
     * @param {ASTNode} node - The node to use as the start of the calculation
     * @returns {number} Line number of the token before `node`
     * @private
     */
    function getLineNumberOfTokenBefore(node) {
      const tokenBefore = sourceCode.getTokenBefore(node);
      let lineNumTokenBefore;

      /**
       * Global return (at the beginning of a script) is a special case.
       * If there is no token before `return`, then we expect no line
       * break before the return. Comments are allowed to occupy lines
       * before the global return, just no blank lines.
       * Setting lineNumTokenBefore to zero in that case results in the
       * desired behavior.
       */
      if (tokenBefore) {
        lineNumTokenBefore = tokenBefore.loc.end.line;
      } else {
        lineNumTokenBefore = 0; // global return at beginning of script
      }
      return lineNumTokenBefore;
    }

    /**
     * Checks whether node is preceded by a newline
     * @param {ASTNode} node - node to check
     * @returns {boolean} Whether or not the node is preceded by a newline
     * @private
     */
    function hasNewlineBefore(node) {
      const lineNumNode = node.loc.start.line;
      const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
      const commentLines = calcCommentLines(node, lineNumTokenBefore);
      return lineNumNode - lineNumTokenBefore - commentLines > 1;
    }

    /**
     * Checks whether it is safe to apply a fix to a given return statement.
     *
     * The fix is not considered safe if the given return statement has leading comments,
     * as we cannot safely determine if the newline should be added before or after the comments.
     * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211
     *
     * @param {ASTNode} node - The return statement node to check.
     * @returns {boolean} `true` if it can fix the node.
     * @private
     */
    function canFix(node) {
      const leadingComments = sourceCode.getCommentsBefore(node);
      const lastLeadingComment = leadingComments[leadingComments.length - 1];
      const tokenBefore = sourceCode.getTokenBefore(node);
      if (leadingComments.length === 0) {
        return true;
      }

      /*
       * if the last leading comment ends in the same line as the previous token and
       * does not share a line with the `return` node, we can consider it safe to fix.
       * Example:
       * function a() {
       *     var b; //comment
       *     return;
       * }
       */
      if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
        return true;
      }
      return false;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ReturnStatement(node) {
        if (!isFirstNode(node) && !hasNewlineBefore(node)) {
          context.report({
            node,
            messageId: "expected",
            fix(fixer) {
              if (canFix(node)) {
                const tokenBefore = sourceCode.getTokenBefore(node);
                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
                return fixer.insertTextBefore(node, newlines);
              }
              return null;
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 276 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to ensure newline per method call when chaining calls
 * @author Rajendra Patil
 * @author Burak Yigit Kaya
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require a newline after each call in a method chain",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/newline-per-chained-call"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        ignoreChainWithDepth: {
          type: "integer",
          minimum: 1,
          maximum: 10,
          default: 2
        }
      },
      additionalProperties: false
    }],
    messages: {
      expected: "Expected line break before `{{callee}}`."
    }
  },
  create(context) {
    const options = context.options[0] || {},
      ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
    const sourceCode = context.getSourceCode();

    /**
     * Get the prefix of a given MemberExpression node.
     * If the MemberExpression node is a computed value it returns a
     * left bracket. If not it returns a period.
     *
     * @param  {ASTNode} node - A MemberExpression node to get
     * @returns {string} The prefix of the node.
     */
    function getPrefix(node) {
      return node.computed ? "[" : ".";
    }

    /**
     * Gets the property text of a given MemberExpression node.
     * If the text is multiline, this returns only the first line.
     *
     * @param {ASTNode} node - A MemberExpression node to get.
     * @returns {string} The property text of the node.
     */
    function getPropertyText(node) {
      const prefix = getPrefix(node);
      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
      const suffix = node.computed && lines.length === 1 ? "]" : "";
      return prefix + lines[0] + suffix;
    }
    return {
      "CallExpression:exit"(node) {
        if (!node.callee || node.callee.type !== "MemberExpression") {
          return;
        }
        const callee = node.callee;
        let parent = callee.object;
        let depth = 1;
        while (parent && parent.callee) {
          depth += 1;
          parent = parent.callee.object;
        }
        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
          context.report({
            node: callee.property,
            loc: callee.property.loc.start,
            messageId: "expected",
            data: {
              callee: getPropertyText(callee)
            },
            fix(fixer) {
              const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);
              return fixer.insertTextBefore(firstTokenAfterObject, "\n");
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 277 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of alert, confirm, prompt
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const getPropertyName = (__webpack_require__(110).getStaticPropertyName);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks if the given name is a prohibited identifier.
 * @param {string} name The name to check
 * @returns {boolean} Whether or not the name is prohibited.
 */
function isProhibitedIdentifier(name) {
  return /^(alert|confirm|prompt)$/u.test(name);
}

/**
 * Finds the eslint-scope reference in the given scope.
 * @param {Object} scope The scope to search.
 * @param {ASTNode} node The identifier node.
 * @returns {Reference|null} Returns the found reference or null if none were found.
 */
function findReference(scope, node) {
  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);
  if (references.length === 1) {
    return references[0];
  }
  return null;
}

/**
 * Checks if the given identifier node is shadowed in the given scope.
 * @param {Object} scope The current scope.
 * @param {string} node The identifier node to check
 * @returns {boolean} Whether or not the name is shadowed.
 */
function isShadowed(scope, node) {
  const reference = findReference(scope, node);
  return reference && reference.resolved && reference.resolved.defs.length > 0;
}

/**
 * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.
 * @param {Object} scope The current scope.
 * @param {string} node The identifier node to check
 * @returns {boolean} Whether or not the node is a reference to the global object.
 */
function isGlobalThisReferenceOrGlobalWindow(scope, node) {
  if (scope.type === "global" && node.type === "ThisExpression") {
    return true;
  }
  if (node.name === "window") {
    return !isShadowed(scope, node);
  }
  return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `alert`, `confirm`, and `prompt`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-alert"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected {{name}}."
    }
  },
  create(context) {
    return {
      CallExpression(node) {
        const callee = node.callee,
          currentScope = context.getScope();

        // without window.
        if (callee.type === "Identifier") {
          const name = callee.name;
          if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                name
              }
            });
          }
        } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
          const name = getPropertyName(callee);
          if (isProhibitedIdentifier(name)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                name
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 278 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow construction of dense arrays using the Array constructor
 * @author Matt DuVall <http://www.mattduvall.com/>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Array` constructors",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-array-constructor"
    },
    schema: [],
    messages: {
      preferLiteral: "The array literal notation [] is preferable."
    }
  },
  create(context) {
    /**
     * Disallow construction of dense arrays using the Array constructor
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function check(node) {
      if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
        context.report({
          node,
          messageId: "preferLiteral"
        });
      }
    }
    return {
      CallExpression: check,
      NewExpression: check
    };
  }
};

/***/ }),
/* 279 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview disallow using an async function as a Promise executor
 * @author Teddy Katz
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow using an async function as a Promise executor",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-async-promise-executor"
    },
    fixable: null,
    schema: [],
    messages: {
      async: "Promise executor functions should not be async."
    }
  },
  create(context) {
    return {
      "NewExpression[callee.name='Promise'][arguments.0.async=true]"(node) {
        context.report({
          node: context.getSourceCode().getFirstToken(node.arguments[0], token => token.value === "async"),
          messageId: "async"
        });
      }
    };
  }
};

/***/ }),
/* 280 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow uses of await inside of loops.
 * @author Nat Mote (nmote)
 */


/**
 * Check whether it should stop traversing ancestors at the given node.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if it should stop traversing.
 */
function isBoundary(node) {
  const t = node.type;
  return t === "FunctionDeclaration" || t === "FunctionExpression" || t === "ArrowFunctionExpression" || (
  /*
   * Don't report the await expressions on for-await-of loop since it's
   * asynchronous iteration intentionally.
   */
  t === "ForOfStatement" && node.await === true);
}

/**
 * Check whether the given node is in loop.
 * @param {ASTNode} node A node to check.
 * @param {ASTNode} parent A parent node to check.
 * @returns {boolean} `true` if the node is in loop.
 */
function isLooped(node, parent) {
  switch (parent.type) {
    case "ForStatement":
      return node === parent.test || node === parent.update || node === parent.body;
    case "ForOfStatement":
    case "ForInStatement":
      return node === parent.body;
    case "WhileStatement":
    case "DoWhileStatement":
      return node === parent.test || node === parent.body;
    default:
      return false;
  }
}
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `await` inside of loops",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-await-in-loop"
    },
    schema: [],
    messages: {
      unexpectedAwait: "Unexpected `await` inside a loop."
    }
  },
  create(context) {
    /**
     * Validate an await expression.
     * @param {ASTNode} awaitNode An AwaitExpression or ForOfStatement node to validate.
     * @returns {void}
     */
    function validate(awaitNode) {
      if (awaitNode.type === "ForOfStatement" && !awaitNode.await) {
        return;
      }
      let node = awaitNode;
      let parent = node.parent;
      while (parent && !isBoundary(parent)) {
        if (isLooped(node, parent)) {
          context.report({
            node: awaitNode,
            messageId: "unexpectedAwait"
          });
          return;
        }
        node = parent;
        parent = parent.parent;
      }
    }
    return {
      AwaitExpression: validate,
      ForOfStatement: validate
    };
  }
};

/***/ }),
/* 281 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag bitwise identifiers
 * @author Nicholas C. Zakas
 */



/*
 *
 * Set of bitwise operators.
 *
 */
const BITWISE_OPERATORS = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"];

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow bitwise operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-bitwise"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: BITWISE_OPERATORS
          },
          uniqueItems: true
        },
        int32Hint: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected use of '{{operator}}'."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];
    const int32Hint = options.int32Hint === true;

    /**
     * Reports an unexpected use of a bitwise operator.
     * @param   {ASTNode} node Node which contains the bitwise operator.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node,
        messageId: "unexpected",
        data: {
          operator: node.operator
        }
      });
    }

    /**
     * Checks if the given node has a bitwise operator.
     * @param   {ASTNode} node The node to check.
     * @returns {boolean} Whether or not the node has a bitwise operator.
     */
    function hasBitwiseOperator(node) {
      return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
    }

    /**
     * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.
     * @param   {ASTNode} node The node to check.
     * @returns {boolean} Whether or not the node has a bitwise operator.
     */
    function allowedOperator(node) {
      return allowed.indexOf(node.operator) !== -1;
    }

    /**
     * Checks if the given bitwise operator is used for integer typecasting, i.e. "|0"
     * @param   {ASTNode} node The node to check.
     * @returns {boolean} whether the node is used in integer typecasting.
     */
    function isInt32Hint(node) {
      return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
    }

    /**
     * Report if the given node contains a bitwise operator.
     * @param   {ASTNode} node The node to check.
     * @returns {void}
     */
    function checkNodeForBitwiseOperator(node) {
      if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
        report(node);
      }
    }
    return {
      AssignmentExpression: checkNodeForBitwiseOperator,
      BinaryExpression: checkNodeForBitwiseOperator,
      UnaryExpression: checkNodeForBitwiseOperator
    };
  }
};

/***/ }),
/* 282 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview disallow use of the Buffer() constructor
 * @author Teddy Katz
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow use of the `Buffer()` constructor",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-buffer-constructor"
    },
    schema: [],
    messages: {
      deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
    }
  },
  create(context) {
    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node) {
        context.report({
          node,
          messageId: "deprecated",
          data: {
            expr: node.type === "CallExpression" ? "Buffer()" : "new Buffer()"
          }
        });
      }
    };
  }
};

/***/ }),
/* 283 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of arguments.callee and arguments.caller.
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `arguments.caller` or `arguments.callee`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-caller"
    },
    schema: [],
    messages: {
      unexpected: "Avoid arguments.{{prop}}."
    }
  },
  create(context) {
    return {
      MemberExpression(node) {
        const objectName = node.object.name,
          propertyName = node.property.name;
        if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              prop: propertyName
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 284 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of an lexical declarations inside a case clause
 * @author Erik Arvidsson
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow lexical declarations in case clauses",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-case-declarations"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected lexical declaration in case block."
    }
  },
  create(context) {
    /**
     * Checks whether or not a node is a lexical declaration.
     * @param {ASTNode} node A direct child statement of a switch case.
     * @returns {boolean} Whether or not the node is a lexical declaration.
     */
    function isLexicalDeclaration(node) {
      switch (node.type) {
        case "FunctionDeclaration":
        case "ClassDeclaration":
          return true;
        case "VariableDeclaration":
          return node.kind !== "var";
        default:
          return false;
      }
    }
    return {
      SwitchCase(node) {
        for (let i = 0; i < node.consequent.length; i++) {
          const statement = node.consequent[i];
          if (isLexicalDeclaration(statement)) {
            context.report({
              node: statement,
              messageId: "unexpected"
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 285 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier
 * @author Ian Christian Myers
 * @deprecated in ESLint v5.1.0
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-catch-shadow"
    },
    replacedBy: ["no-shadow"],
    deprecated: true,
    schema: [],
    messages: {
      mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Check if the parameters are been shadowed
     * @param {Object} scope current scope
     * @param {string} name parameter name
     * @returns {boolean} True is its been shadowed
     */
    function paramIsShadowing(scope, name) {
      return astUtils.getVariableByName(scope, name) !== null;
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      "CatchClause[param!=null]"(node) {
        let scope = context.getScope();

        /*
         * When ecmaVersion >= 6, CatchClause creates its own scope
         * so start from one upper scope to exclude the current node
         */
        if (scope.block === node) {
          scope = scope.upper;
        }
        if (paramIsShadowing(scope, node.param.name)) {
          context.report({
            node,
            messageId: "mutable",
            data: {
              name: node.param.name
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 286 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow modifying variables of class declarations
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning class members",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-class-assign"
    },
    schema: [],
    messages: {
      class: "'{{name}}' is a class."
    }
  },
  create(context) {
    /**
     * Finds and reports references that are non initializer and writable.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "class",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }

    /**
     * Finds and reports references that are non initializer and writable.
     * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.
     * @returns {void}
     */
    function checkForClass(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }
    return {
      ClassDeclaration: checkForClass,
      ClassExpression: checkForClass
    };
  }
};

/***/ }),
/* 287 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview The rule should warn against code that tries to compare against -0.
 * @author Aladdin-ADD <hh_2013@foxmail.com>
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparing against -0",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-compare-neg-zero"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Do not use the '{{operator}}' operator to compare against -0."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Checks a given node is -0
     *
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} `true` if the node is -0.
     */
    function isNegZero(node) {
      return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
    }
    const OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
    return {
      BinaryExpression(node) {
        if (OPERATORS_TO_CHECK.has(node.operator)) {
          if (isNegZero(node.left) || isNegZero(node.right)) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                operator: node.operator
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 288 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag assignment in a conditional statement's test expression
 * @author Stephen Murray <spmurrayzzz>
 */


const astUtils = __webpack_require__(110);
const NODE_DESCRIPTIONS = {
  DoWhileStatement: "a 'do...while' statement",
  ForStatement: "a 'for' statement",
  IfStatement: "an 'if' statement",
  WhileStatement: "a 'while' statement"
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignment operators in conditional expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-cond-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }],
    messages: {
      unexpected: "Unexpected assignment within {{type}}.",
      // must match JSHint's error message
      missing: "Expected a conditional expression and instead saw an assignment."
    }
  },
  create(context) {
    const prohibitAssign = context.options[0] || "except-parens";
    const sourceCode = context.getSourceCode();

    /**
     * Check whether an AST node is the test expression for a conditional statement.
     * @param {!Object} node The node to test.
     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.
     */
    function isConditionalTestExpression(node) {
      return node.parent && node.parent.test && node === node.parent.test;
    }

    /**
     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.
     * @param {!Object} node The node to use at the start of the search.
     * @returns {?Object} The closest ancestor node that represents a conditional statement.
     */
    function findConditionalAncestor(node) {
      let currentAncestor = node;
      do {
        if (isConditionalTestExpression(currentAncestor)) {
          return currentAncestor.parent;
        }
      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));
      return null;
    }

    /**
     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.
     * @param {!Object} node The node to test.
     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.
     */
    function isParenthesisedTwice(node) {
      const previousToken = sourceCode.getTokenBefore(node, 1),
        nextToken = sourceCode.getTokenAfter(node, 1);
      return astUtils.isParenthesised(sourceCode, node) && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
    }

    /**
     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.
     * @param {!Object} node The node for the conditional statement.
     * @returns {void}
     */
    function testForAssign(node) {
      if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
        context.report({
          node,
          loc: node.test.loc.start,
          messageId: "missing"
        });
      }
    }

    /**
     * Check whether an assignment expression is descended from a conditional statement's test expression.
     * @param {!Object} node The node for the assignment expression.
     * @returns {void}
     */
    function testForConditionalAncestor(node) {
      const ancestor = findConditionalAncestor(node);
      if (ancestor) {
        context.report({
          node: ancestor,
          messageId: "unexpected",
          data: {
            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
          }
        });
      }
    }
    if (prohibitAssign === "always") {
      return {
        AssignmentExpression: testForConditionalAncestor
      };
    }
    return {
      DoWhileStatement: testForAssign,
      ForStatement: testForAssign,
      IfStatement: testForAssign,
      WhileStatement: testForAssign,
      ConditionalExpression: testForAssign
    };
  }
};

/***/ }),
/* 289 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to warn against using arrow functions when they could be
 * confused with comparisions
 * @author Jxck <https://github.com/Jxck>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a node is a conditional expression.
 * @param {ASTNode} node - node to test
 * @returns {boolean} `true` if the node is a conditional expression.
 */
function isConditional(node) {
  return node && node.type === "ConditionalExpression";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow arrow functions where they could be confused with comparisons",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-confusing-arrow"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        allowParens: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      confusing: "Arrow function used ambiguously with a conditional expression."
    }
  },
  create(context) {
    const config = context.options[0] || {};
    const sourceCode = context.getSourceCode();

    /**
     * Reports if an arrow function contains an ambiguous conditional.
     * @param {ASTNode} node - A node to check and report.
     * @returns {void}
     */
    function checkArrowFunc(node) {
      const body = node.body;
      if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {
        context.report({
          node,
          messageId: "confusing",
          fix(fixer) {
            // if `allowParens` is not set to true dont bother wrapping in parens
            return config.allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);
          }
        });
      }
    }
    return {
      ArrowFunctionExpression: checkArrowFunc
    };
  }
};

/***/ }),
/* 290 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of console object
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `console`",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-console"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          },
          minItems: 1,
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected console statement."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];

    /**
     * Checks whether the given reference is 'console' or not.
     *
     * @param {eslint-scope.Reference} reference - The reference to check.
     * @returns {boolean} `true` if the reference is 'console'.
     */
    function isConsole(reference) {
      const id = reference.identifier;
      return id && id.name === "console";
    }

    /**
     * Checks whether the property name of the given MemberExpression node
     * is allowed by options or not.
     *
     * @param {ASTNode} node - The MemberExpression node to check.
     * @returns {boolean} `true` if the property name of the node is allowed.
     */
    function isAllowed(node) {
      const propertyName = astUtils.getStaticPropertyName(node);
      return propertyName && allowed.indexOf(propertyName) !== -1;
    }

    /**
     * Checks whether the given reference is a member access which is not
     * allowed by options or not.
     *
     * @param {eslint-scope.Reference} reference - The reference to check.
     * @returns {boolean} `true` if the reference is a member access which
     *      is not allowed by options.
     */
    function isMemberAccessExceptAllowed(reference) {
      const node = reference.identifier;
      const parent = node.parent;
      return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
    }

    /**
     * Reports the given reference as a violation.
     *
     * @param {eslint-scope.Reference} reference - The reference to report.
     * @returns {void}
     */
    function report(reference) {
      const node = reference.identifier.parent;
      context.report({
        node,
        loc: node.loc,
        messageId: "unexpected"
      });
    }
    return {
      "Program:exit"() {
        const scope = context.getScope();
        const consoleVar = astUtils.getVariableByName(scope, "console");
        const shadowed = consoleVar && consoleVar.defs.length > 0;

        /*
         * 'scope.through' includes all references to undefined
         * variables. If the variable 'console' is not defined, it uses
         * 'scope.through'.
         */
        const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);
        if (!shadowed) {
          references.filter(isMemberAccessExceptAllowed).forEach(report);
        }
      }
    };
  }
};

/***/ }),
/* 291 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow modifying variables that are declared using `const`
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `const` variables",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-const-assign"
    },
    schema: [],
    messages: {
      const: "'{{name}}' is constant."
    }
  },
  create(context) {
    /**
     * Finds and reports references that are non initializer and writable.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "const",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }
    return {
      VariableDeclaration(node) {
        if (node.kind === "const") {
          context.getDeclaredVariables(node).forEach(checkVariable);
        }
      }
    };
  }
};

/***/ }),
/* 292 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use constant conditions
 * @author Christian Schulz <http://rndm.de>
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const EQUALITY_OPERATORS = ["===", "!==", "==", "!="];
const RELATIONAL_OPERATORS = [">", "<", ">=", "<=", "in", "instanceof"];

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow constant expressions in conditions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-constant-condition"
    },
    schema: [{
      type: "object",
      properties: {
        checkLoops: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected constant condition."
    }
  },
  create(context) {
    const options = context.options[0] || {},
      checkLoops = options.checkLoops !== false,
      loopSetStack = [];
    let loopsInCurrentScope = new Set();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Checks if a branch node of LogicalExpression short circuits the whole condition
     * @param {ASTNode} node The branch of main condition which needs to be checked
     * @param {string} operator The operator of the main LogicalExpression.
     * @returns {boolean} true when condition short circuits whole condition
     */
    function isLogicalIdentity(node, operator) {
      switch (node.type) {
        case "Literal":
          return operator === "||" && node.value === true || operator === "&&" && node.value === false;
        case "UnaryExpression":
          return operator === "&&" && node.operator === "void";
        case "LogicalExpression":
          return isLogicalIdentity(node.left, node.operator) || isLogicalIdentity(node.right, node.operator);

        // no default
      }
      return false;
    }

    /**
     * Checks if a node has a constant truthiness value.
     * @param {ASTNode} node The AST node to check.
     * @param {boolean} inBooleanPosition `false` if checking branch of a condition.
     *  `true` in all other cases
     * @returns {Bool} true when node's truthiness is constant
     * @private
     */
    function isConstant(node, inBooleanPosition) {
      switch (node.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ObjectExpression":
        case "ArrayExpression":
          return true;
        case "UnaryExpression":
          if (node.operator === "void") {
            return true;
          }
          return node.operator === "typeof" && inBooleanPosition || isConstant(node.argument, true);
        case "BinaryExpression":
          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== "in";
        case "LogicalExpression":
          {
            const isLeftConstant = isConstant(node.left, inBooleanPosition);
            const isRightConstant = isConstant(node.right, inBooleanPosition);
            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
            const isRightShortCircuit = isRightConstant && isLogicalIdentity(node.right, node.operator);
            return isLeftConstant && isRightConstant ||
            // in the case of an "OR", we need to know if the right constant value is truthy
            node.operator === "||" && isRightConstant && node.right.value && (!node.parent || node.parent.type !== "BinaryExpression" || !(EQUALITY_OPERATORS.includes(node.parent.operator) || RELATIONAL_OPERATORS.includes(node.parent.operator))) || isLeftShortCircuit || isRightShortCircuit;
          }
        case "AssignmentExpression":
          return node.operator === "=" && isConstant(node.right, inBooleanPosition);
        case "SequenceExpression":
          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);

        // no default
      }
      return false;
    }

    /**
     * Tracks when the given node contains a constant condition.
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     * @private
     */
    function trackConstantConditionLoop(node) {
      if (node.test && isConstant(node.test, true)) {
        loopsInCurrentScope.add(node);
      }
    }

    /**
     * Reports when the set contains the given constant condition node
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     * @private
     */
    function checkConstantConditionLoopInSet(node) {
      if (loopsInCurrentScope.has(node)) {
        loopsInCurrentScope.delete(node);
        context.report({
          node: node.test,
          messageId: "unexpected"
        });
      }
    }

    /**
     * Reports when the given node contains a constant condition.
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     * @private
     */
    function reportIfConstant(node) {
      if (node.test && isConstant(node.test, true)) {
        context.report({
          node: node.test,
          messageId: "unexpected"
        });
      }
    }

    /**
     * Stores current set of constant loops in loopSetStack temporarily
     * and uses a new set to track constant loops
     * @returns {void}
     * @private
     */
    function enterFunction() {
      loopSetStack.push(loopsInCurrentScope);
      loopsInCurrentScope = new Set();
    }

    /**
     * Reports when the set still contains stored constant conditions
     * @returns {void}
     * @private
     */
    function exitFunction() {
      loopsInCurrentScope = loopSetStack.pop();
    }

    /**
     * Checks node when checkLoops option is enabled
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     * @private
     */
    function checkLoop(node) {
      if (checkLoops) {
        trackConstantConditionLoop(node);
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ConditionalExpression: reportIfConstant,
      IfStatement: reportIfConstant,
      WhileStatement: checkLoop,
      "WhileStatement:exit": checkConstantConditionLoopInSet,
      DoWhileStatement: checkLoop,
      "DoWhileStatement:exit": checkConstantConditionLoopInSet,
      ForStatement: checkLoop,
      "ForStatement > .test": node => checkLoop(node.parent),
      "ForStatement:exit": checkConstantConditionLoopInSet,
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      YieldExpression: () => loopsInCurrentScope.clear()
    };
  }
};

/***/ }),
/* 293 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of continue statement
 * @author Borislav Zhivkov
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `continue` statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-continue"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected use of continue statement."
    }
  },
  create(context) {
    return {
      ContinueStatement(node) {
        context.report({
          node,
          messageId: "unexpected"
        });
      }
    };
  }
};

/***/ }),
/* 294 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to forbid control charactes from regular expressions.
 * @author Nicholas C. Zakas
 */



const RegExpValidator = (__webpack_require__(295).RegExpValidator);
const collector = new class {
  constructor() {
    this.ecmaVersion = 2018;
    this._source = "";
    this._controlChars = [];
    this._validator = new RegExpValidator(this);
  }
  onPatternEnter() {
    this._controlChars = [];
  }
  onCharacter(start, end, cp) {
    if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
      this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);
    }
  }
  collectControlChars(regexpStr) {
    try {
      this._source = regexpStr;
      this._validator.validatePattern(regexpStr); // Call onCharacter hook
    } catch (err) {

      // Ignore syntax errors in RegExp.
    }
    return this._controlChars;
  }
}();

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control characters in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-control-regex"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
    }
  },
  create(context) {
    /**
     * Get the regex expression
     * @param {ASTNode} node node to evaluate
     * @returns {RegExp|null} Regex if found else null
     * @private
     */
    function getRegExpPattern(node) {
      if (node.regex) {
        return node.regex.pattern;
      }
      if (typeof node.value === "string" && (node.parent.type === "NewExpression" || node.parent.type === "CallExpression") && node.parent.callee.type === "Identifier" && node.parent.callee.name === "RegExp" && node.parent.arguments[0] === node) {
        return node.value;
      }
      return null;
    }
    return {
      Literal(node) {
        const pattern = getRegExpPattern(node);
        if (pattern) {
          const controlCharacters = collector.collectControlChars(pattern);
          if (controlCharacters.length > 0) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                controlChars: controlCharacters.join(", ")
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 295 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*! @author Toru Nagashima <https://github.com/mysticatea> */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var ast = /*#__PURE__*/Object.freeze({});
function isIdStart(cp) {
  if (cp < 0x41) return false;
  if (cp < 0x5b) return true;
  if (cp < 0x61) return false;
  if (cp < 0x7b) return true;
  return isLargeIdStart(cp);
}
function isIdContinue(cp) {
  if (cp < 0x30) return false;
  if (cp < 0x3a) return true;
  if (cp < 0x41) return false;
  if (cp < 0x5b) return true;
  if (cp === 0x5f) return true;
  if (cp < 0x61) return false;
  if (cp < 0x7b) return true;
  return isLargeIdStart(cp) || isLargeIdContinue(cp);
}
function isLargeIdStart(cp) {
  if (cp < 0x30a1) {
    if (cp < 0xec0) {
      if (cp < 0xa35) {
        if (cp < 0x6e5) {
          if (cp < 0x37a) {
            if (cp < 0x294) {
              if (cp < 0xf8) {
                if (cp === 0xaa) return true;
                if (cp === 0xb5) return true;
                if (cp === 0xba) return true;
                if (cp < 0xc0) return false;
                if (cp < 0xd7) return true;
                if (cp < 0xd8) return false;
                if (cp < 0xf7) return true;
                return false;
              }
              if (cp < 0x1bb) return true;
              if (cp === 0x1bb) return true;
              if (cp < 0x1bc) return false;
              if (cp < 0x1c0) return true;
              if (cp < 0x1c0) return false;
              if (cp < 0x1c4) return true;
              if (cp < 0x1c4) return false;
              if (cp < 0x294) return true;
              return false;
            }
            if (cp < 0x2ec) {
              if (cp === 0x294) return true;
              if (cp < 0x295) return false;
              if (cp < 0x2b0) return true;
              if (cp < 0x2b0) return false;
              if (cp < 0x2c2) return true;
              if (cp < 0x2c6) return false;
              if (cp < 0x2d2) return true;
              if (cp < 0x2e0) return false;
              if (cp < 0x2e5) return true;
              return false;
            }
            if (cp === 0x2ec) return true;
            if (cp === 0x2ee) return true;
            if (cp < 0x370) return false;
            if (cp < 0x374) return true;
            if (cp === 0x374) return true;
            if (cp < 0x376) return false;
            if (cp < 0x378) return true;
            return false;
          }
          if (cp < 0x531) {
            if (cp < 0x38c) {
              if (cp === 0x37a) return true;
              if (cp < 0x37b) return false;
              if (cp < 0x37e) return true;
              if (cp === 0x37f) return true;
              if (cp === 0x386) return true;
              if (cp < 0x388) return false;
              if (cp < 0x38b) return true;
              return false;
            }
            if (cp === 0x38c) return true;
            if (cp < 0x38e) return false;
            if (cp < 0x3a2) return true;
            if (cp < 0x3a3) return false;
            if (cp < 0x3f6) return true;
            if (cp < 0x3f7) return false;
            if (cp < 0x482) return true;
            if (cp < 0x48a) return false;
            if (cp < 0x530) return true;
            return false;
          }
          if (cp < 0x620) {
            if (cp < 0x531) return false;
            if (cp < 0x557) return true;
            if (cp === 0x559) return true;
            if (cp < 0x560) return false;
            if (cp < 0x589) return true;
            if (cp < 0x5d0) return false;
            if (cp < 0x5eb) return true;
            if (cp < 0x5ef) return false;
            if (cp < 0x5f3) return true;
            return false;
          }
          if (cp < 0x640) return true;
          if (cp === 0x640) return true;
          if (cp < 0x641) return false;
          if (cp < 0x64b) return true;
          if (cp < 0x66e) return false;
          if (cp < 0x670) return true;
          if (cp < 0x671) return false;
          if (cp < 0x6d4) return true;
          if (cp === 0x6d5) return true;
          return false;
        }
        if (cp < 0x950) {
          if (cp < 0x7fa) {
            if (cp < 0x712) {
              if (cp < 0x6e5) return false;
              if (cp < 0x6e7) return true;
              if (cp < 0x6ee) return false;
              if (cp < 0x6f0) return true;
              if (cp < 0x6fa) return false;
              if (cp < 0x6fd) return true;
              if (cp === 0x6ff) return true;
              if (cp === 0x710) return true;
              return false;
            }
            if (cp < 0x730) return true;
            if (cp < 0x74d) return false;
            if (cp < 0x7a6) return true;
            if (cp === 0x7b1) return true;
            if (cp < 0x7ca) return false;
            if (cp < 0x7eb) return true;
            if (cp < 0x7f4) return false;
            if (cp < 0x7f6) return true;
            return false;
          }
          if (cp < 0x840) {
            if (cp === 0x7fa) return true;
            if (cp < 0x800) return false;
            if (cp < 0x816) return true;
            if (cp === 0x81a) return true;
            if (cp === 0x824) return true;
            if (cp === 0x828) return true;
            return false;
          }
          if (cp < 0x859) return true;
          if (cp < 0x860) return false;
          if (cp < 0x86b) return true;
          if (cp < 0x8a0) return false;
          if (cp < 0x8b5) return true;
          if (cp < 0x8b6) return false;
          if (cp < 0x8be) return true;
          if (cp < 0x904) return false;
          if (cp < 0x93a) return true;
          if (cp === 0x93d) return true;
          return false;
        }
        if (cp < 0x9bd) {
          if (cp < 0x98f) {
            if (cp === 0x950) return true;
            if (cp < 0x958) return false;
            if (cp < 0x962) return true;
            if (cp === 0x971) return true;
            if (cp < 0x972) return false;
            if (cp < 0x981) return true;
            if (cp < 0x985) return false;
            if (cp < 0x98d) return true;
            return false;
          }
          if (cp < 0x991) return true;
          if (cp < 0x993) return false;
          if (cp < 0x9a9) return true;
          if (cp < 0x9aa) return false;
          if (cp < 0x9b1) return true;
          if (cp === 0x9b2) return true;
          if (cp < 0x9b6) return false;
          if (cp < 0x9ba) return true;
          return false;
        }
        if (cp < 0x9fc) {
          if (cp === 0x9bd) return true;
          if (cp === 0x9ce) return true;
          if (cp < 0x9dc) return false;
          if (cp < 0x9de) return true;
          if (cp < 0x9df) return false;
          if (cp < 0x9e2) return true;
          if (cp < 0x9f0) return false;
          if (cp < 0x9f2) return true;
          return false;
        }
        if (cp === 0x9fc) return true;
        if (cp < 0xa05) return false;
        if (cp < 0xa0b) return true;
        if (cp < 0xa0f) return false;
        if (cp < 0xa11) return true;
        if (cp < 0xa13) return false;
        if (cp < 0xa29) return true;
        if (cp < 0xa2a) return false;
        if (cp < 0xa31) return true;
        if (cp < 0xa32) return false;
        if (cp < 0xa34) return true;
        return false;
      }
      if (cp < 0xc60) {
        if (cp < 0xb3d) {
          if (cp < 0xab5) {
            if (cp < 0xa85) {
              if (cp < 0xa35) return false;
              if (cp < 0xa37) return true;
              if (cp < 0xa38) return false;
              if (cp < 0xa3a) return true;
              if (cp < 0xa59) return false;
              if (cp < 0xa5d) return true;
              if (cp === 0xa5e) return true;
              if (cp < 0xa72) return false;
              if (cp < 0xa75) return true;
              return false;
            }
            if (cp < 0xa8e) return true;
            if (cp < 0xa8f) return false;
            if (cp < 0xa92) return true;
            if (cp < 0xa93) return false;
            if (cp < 0xaa9) return true;
            if (cp < 0xaaa) return false;
            if (cp < 0xab1) return true;
            if (cp < 0xab2) return false;
            if (cp < 0xab4) return true;
            return false;
          }
          if (cp < 0xb05) {
            if (cp < 0xab5) return false;
            if (cp < 0xaba) return true;
            if (cp === 0xabd) return true;
            if (cp === 0xad0) return true;
            if (cp < 0xae0) return false;
            if (cp < 0xae2) return true;
            if (cp === 0xaf9) return true;
            return false;
          }
          if (cp < 0xb0d) return true;
          if (cp < 0xb0f) return false;
          if (cp < 0xb11) return true;
          if (cp < 0xb13) return false;
          if (cp < 0xb29) return true;
          if (cp < 0xb2a) return false;
          if (cp < 0xb31) return true;
          if (cp < 0xb32) return false;
          if (cp < 0xb34) return true;
          if (cp < 0xb35) return false;
          if (cp < 0xb3a) return true;
          return false;
        }
        if (cp < 0xb9e) {
          if (cp < 0xb85) {
            if (cp === 0xb3d) return true;
            if (cp < 0xb5c) return false;
            if (cp < 0xb5e) return true;
            if (cp < 0xb5f) return false;
            if (cp < 0xb62) return true;
            if (cp === 0xb71) return true;
            if (cp === 0xb83) return true;
            return false;
          }
          if (cp < 0xb8b) return true;
          if (cp < 0xb8e) return false;
          if (cp < 0xb91) return true;
          if (cp < 0xb92) return false;
          if (cp < 0xb96) return true;
          if (cp < 0xb99) return false;
          if (cp < 0xb9b) return true;
          if (cp === 0xb9c) return true;
          return false;
        }
        if (cp < 0xc05) {
          if (cp < 0xb9e) return false;
          if (cp < 0xba0) return true;
          if (cp < 0xba3) return false;
          if (cp < 0xba5) return true;
          if (cp < 0xba8) return false;
          if (cp < 0xbab) return true;
          if (cp < 0xbae) return false;
          if (cp < 0xbba) return true;
          if (cp === 0xbd0) return true;
          return false;
        }
        if (cp < 0xc0d) return true;
        if (cp < 0xc0e) return false;
        if (cp < 0xc11) return true;
        if (cp < 0xc12) return false;
        if (cp < 0xc29) return true;
        if (cp < 0xc2a) return false;
        if (cp < 0xc3a) return true;
        if (cp === 0xc3d) return true;
        if (cp < 0xc58) return false;
        if (cp < 0xc5b) return true;
        return false;
      }
      if (cp < 0xdb3) {
        if (cp < 0xcf1) {
          if (cp < 0xcaa) {
            if (cp < 0xc60) return false;
            if (cp < 0xc62) return true;
            if (cp === 0xc80) return true;
            if (cp < 0xc85) return false;
            if (cp < 0xc8d) return true;
            if (cp < 0xc8e) return false;
            if (cp < 0xc91) return true;
            if (cp < 0xc92) return false;
            if (cp < 0xca9) return true;
            return false;
          }
          if (cp < 0xcb4) return true;
          if (cp < 0xcb5) return false;
          if (cp < 0xcba) return true;
          if (cp === 0xcbd) return true;
          if (cp === 0xcde) return true;
          if (cp < 0xce0) return false;
          if (cp < 0xce2) return true;
          return false;
        }
        if (cp < 0xd4e) {
          if (cp < 0xcf1) return false;
          if (cp < 0xcf3) return true;
          if (cp < 0xd05) return false;
          if (cp < 0xd0d) return true;
          if (cp < 0xd0e) return false;
          if (cp < 0xd11) return true;
          if (cp < 0xd12) return false;
          if (cp < 0xd3b) return true;
          if (cp === 0xd3d) return true;
          return false;
        }
        if (cp === 0xd4e) return true;
        if (cp < 0xd54) return false;
        if (cp < 0xd57) return true;
        if (cp < 0xd5f) return false;
        if (cp < 0xd62) return true;
        if (cp < 0xd7a) return false;
        if (cp < 0xd80) return true;
        if (cp < 0xd85) return false;
        if (cp < 0xd97) return true;
        if (cp < 0xd9a) return false;
        if (cp < 0xdb2) return true;
        return false;
      }
      if (cp < 0xe8a) {
        if (cp < 0xe40) {
          if (cp < 0xdb3) return false;
          if (cp < 0xdbc) return true;
          if (cp === 0xdbd) return true;
          if (cp < 0xdc0) return false;
          if (cp < 0xdc7) return true;
          if (cp < 0xe01) return false;
          if (cp < 0xe31) return true;
          if (cp < 0xe32) return false;
          if (cp < 0xe34) return true;
          return false;
        }
        if (cp < 0xe46) return true;
        if (cp === 0xe46) return true;
        if (cp < 0xe81) return false;
        if (cp < 0xe83) return true;
        if (cp === 0xe84) return true;
        if (cp < 0xe87) return false;
        if (cp < 0xe89) return true;
        return false;
      }
      if (cp < 0xea5) {
        if (cp === 0xe8a) return true;
        if (cp === 0xe8d) return true;
        if (cp < 0xe94) return false;
        if (cp < 0xe98) return true;
        if (cp < 0xe99) return false;
        if (cp < 0xea0) return true;
        if (cp < 0xea1) return false;
        if (cp < 0xea4) return true;
        return false;
      }
      if (cp === 0xea5) return true;
      if (cp === 0xea7) return true;
      if (cp < 0xeaa) return false;
      if (cp < 0xeac) return true;
      if (cp < 0xead) return false;
      if (cp < 0xeb1) return true;
      if (cp < 0xeb2) return false;
      if (cp < 0xeb4) return true;
      if (cp === 0xebd) return true;
      return false;
    }
    if (cp < 0x1ce9) {
      if (cp < 0x166f) {
        if (cp < 0x10fd) {
          if (cp < 0x105a) {
            if (cp < 0xf49) {
              if (cp < 0xec0) return false;
              if (cp < 0xec5) return true;
              if (cp === 0xec6) return true;
              if (cp < 0xedc) return false;
              if (cp < 0xee0) return true;
              if (cp === 0xf00) return true;
              if (cp < 0xf40) return false;
              if (cp < 0xf48) return true;
              return false;
            }
            if (cp < 0xf6d) return true;
            if (cp < 0xf88) return false;
            if (cp < 0xf8d) return true;
            if (cp < 0x1000) return false;
            if (cp < 0x102b) return true;
            if (cp === 0x103f) return true;
            if (cp < 0x1050) return false;
            if (cp < 0x1056) return true;
            return false;
          }
          if (cp < 0x108e) {
            if (cp < 0x105a) return false;
            if (cp < 0x105e) return true;
            if (cp === 0x1061) return true;
            if (cp < 0x1065) return false;
            if (cp < 0x1067) return true;
            if (cp < 0x106e) return false;
            if (cp < 0x1071) return true;
            if (cp < 0x1075) return false;
            if (cp < 0x1082) return true;
            return false;
          }
          if (cp === 0x108e) return true;
          if (cp < 0x10a0) return false;
          if (cp < 0x10c6) return true;
          if (cp === 0x10c7) return true;
          if (cp === 0x10cd) return true;
          if (cp < 0x10d0) return false;
          if (cp < 0x10fb) return true;
          if (cp === 0x10fc) return true;
          return false;
        }
        if (cp < 0x12b8) {
          if (cp < 0x125a) {
            if (cp < 0x10fd) return false;
            if (cp < 0x1100) return true;
            if (cp < 0x1100) return false;
            if (cp < 0x1249) return true;
            if (cp < 0x124a) return false;
            if (cp < 0x124e) return true;
            if (cp < 0x1250) return false;
            if (cp < 0x1257) return true;
            if (cp === 0x1258) return true;
            return false;
          }
          if (cp < 0x125e) return true;
          if (cp < 0x1260) return false;
          if (cp < 0x1289) return true;
          if (cp < 0x128a) return false;
          if (cp < 0x128e) return true;
          if (cp < 0x1290) return false;
          if (cp < 0x12b1) return true;
          if (cp < 0x12b2) return false;
          if (cp < 0x12b6) return true;
          return false;
        }
        if (cp < 0x1312) {
          if (cp < 0x12b8) return false;
          if (cp < 0x12bf) return true;
          if (cp === 0x12c0) return true;
          if (cp < 0x12c2) return false;
          if (cp < 0x12c6) return true;
          if (cp < 0x12c8) return false;
          if (cp < 0x12d7) return true;
          if (cp < 0x12d8) return false;
          if (cp < 0x1311) return true;
          return false;
        }
        if (cp < 0x1316) return true;
        if (cp < 0x1318) return false;
        if (cp < 0x135b) return true;
        if (cp < 0x1380) return false;
        if (cp < 0x1390) return true;
        if (cp < 0x13a0) return false;
        if (cp < 0x13f6) return true;
        if (cp < 0x13f8) return false;
        if (cp < 0x13fe) return true;
        if (cp < 0x1401) return false;
        if (cp < 0x166d) return true;
        return false;
      }
      if (cp < 0x18b0) {
        if (cp < 0x176e) {
          if (cp < 0x1700) {
            if (cp < 0x166f) return false;
            if (cp < 0x1680) return true;
            if (cp < 0x1681) return false;
            if (cp < 0x169b) return true;
            if (cp < 0x16a0) return false;
            if (cp < 0x16eb) return true;
            if (cp < 0x16ee) return false;
            if (cp < 0x16f1) return true;
            if (cp < 0x16f1) return false;
            if (cp < 0x16f9) return true;
            return false;
          }
          if (cp < 0x170d) return true;
          if (cp < 0x170e) return false;
          if (cp < 0x1712) return true;
          if (cp < 0x1720) return false;
          if (cp < 0x1732) return true;
          if (cp < 0x1740) return false;
          if (cp < 0x1752) return true;
          if (cp < 0x1760) return false;
          if (cp < 0x176d) return true;
          return false;
        }
        if (cp < 0x1843) {
          if (cp < 0x176e) return false;
          if (cp < 0x1771) return true;
          if (cp < 0x1780) return false;
          if (cp < 0x17b4) return true;
          if (cp === 0x17d7) return true;
          if (cp === 0x17dc) return true;
          if (cp < 0x1820) return false;
          if (cp < 0x1843) return true;
          return false;
        }
        if (cp === 0x1843) return true;
        if (cp < 0x1844) return false;
        if (cp < 0x1879) return true;
        if (cp < 0x1880) return false;
        if (cp < 0x1885) return true;
        if (cp < 0x1885) return false;
        if (cp < 0x1887) return true;
        if (cp < 0x1887) return false;
        if (cp < 0x18a9) return true;
        if (cp === 0x18aa) return true;
        return false;
      }
      if (cp < 0x1b45) {
        if (cp < 0x19b0) {
          if (cp < 0x18b0) return false;
          if (cp < 0x18f6) return true;
          if (cp < 0x1900) return false;
          if (cp < 0x191f) return true;
          if (cp < 0x1950) return false;
          if (cp < 0x196e) return true;
          if (cp < 0x1970) return false;
          if (cp < 0x1975) return true;
          if (cp < 0x1980) return false;
          if (cp < 0x19ac) return true;
          return false;
        }
        if (cp < 0x19ca) return true;
        if (cp < 0x1a00) return false;
        if (cp < 0x1a17) return true;
        if (cp < 0x1a20) return false;
        if (cp < 0x1a55) return true;
        if (cp === 0x1aa7) return true;
        if (cp < 0x1b05) return false;
        if (cp < 0x1b34) return true;
        return false;
      }
      if (cp < 0x1c4d) {
        if (cp < 0x1b45) return false;
        if (cp < 0x1b4c) return true;
        if (cp < 0x1b83) return false;
        if (cp < 0x1ba1) return true;
        if (cp < 0x1bae) return false;
        if (cp < 0x1bb0) return true;
        if (cp < 0x1bba) return false;
        if (cp < 0x1be6) return true;
        if (cp < 0x1c00) return false;
        if (cp < 0x1c24) return true;
        return false;
      }
      if (cp < 0x1c50) return true;
      if (cp < 0x1c5a) return false;
      if (cp < 0x1c78) return true;
      if (cp < 0x1c78) return false;
      if (cp < 0x1c7e) return true;
      if (cp < 0x1c80) return false;
      if (cp < 0x1c89) return true;
      if (cp < 0x1c90) return false;
      if (cp < 0x1cbb) return true;
      if (cp < 0x1cbd) return false;
      if (cp < 0x1cc0) return true;
      return false;
    }
    if (cp < 0x212f) {
      if (cp < 0x1fc2) {
        if (cp < 0x1f18) {
          if (cp < 0x1d6b) {
            if (cp < 0x1ce9) return false;
            if (cp < 0x1ced) return true;
            if (cp < 0x1cee) return false;
            if (cp < 0x1cf2) return true;
            if (cp < 0x1cf5) return false;
            if (cp < 0x1cf7) return true;
            if (cp < 0x1d00) return false;
            if (cp < 0x1d2c) return true;
            if (cp < 0x1d2c) return false;
            if (cp < 0x1d6b) return true;
            return false;
          }
          if (cp < 0x1d78) return true;
          if (cp === 0x1d78) return true;
          if (cp < 0x1d79) return false;
          if (cp < 0x1d9b) return true;
          if (cp < 0x1d9b) return false;
          if (cp < 0x1dc0) return true;
          if (cp < 0x1e00) return false;
          if (cp < 0x1f16) return true;
          return false;
        }
        if (cp < 0x1f5b) {
          if (cp < 0x1f18) return false;
          if (cp < 0x1f1e) return true;
          if (cp < 0x1f20) return false;
          if (cp < 0x1f46) return true;
          if (cp < 0x1f48) return false;
          if (cp < 0x1f4e) return true;
          if (cp < 0x1f50) return false;
          if (cp < 0x1f58) return true;
          if (cp === 0x1f59) return true;
          return false;
        }
        if (cp === 0x1f5b) return true;
        if (cp === 0x1f5d) return true;
        if (cp < 0x1f5f) return false;
        if (cp < 0x1f7e) return true;
        if (cp < 0x1f80) return false;
        if (cp < 0x1fb5) return true;
        if (cp < 0x1fb6) return false;
        if (cp < 0x1fbd) return true;
        if (cp === 0x1fbe) return true;
        return false;
      }
      if (cp < 0x2102) {
        if (cp < 0x1ff2) {
          if (cp < 0x1fc2) return false;
          if (cp < 0x1fc5) return true;
          if (cp < 0x1fc6) return false;
          if (cp < 0x1fcd) return true;
          if (cp < 0x1fd0) return false;
          if (cp < 0x1fd4) return true;
          if (cp < 0x1fd6) return false;
          if (cp < 0x1fdc) return true;
          if (cp < 0x1fe0) return false;
          if (cp < 0x1fed) return true;
          return false;
        }
        if (cp < 0x1ff5) return true;
        if (cp < 0x1ff6) return false;
        if (cp < 0x1ffd) return true;
        if (cp === 0x2071) return true;
        if (cp === 0x207f) return true;
        if (cp < 0x2090) return false;
        if (cp < 0x209d) return true;
        return false;
      }
      if (cp < 0x2119) {
        if (cp === 0x2102) return true;
        if (cp === 0x2107) return true;
        if (cp < 0x210a) return false;
        if (cp < 0x2114) return true;
        if (cp === 0x2115) return true;
        if (cp === 0x2118) return true;
        return false;
      }
      if (cp < 0x211e) return true;
      if (cp === 0x2124) return true;
      if (cp === 0x2126) return true;
      if (cp === 0x2128) return true;
      if (cp < 0x212a) return false;
      if (cp < 0x212e) return true;
      if (cp === 0x212e) return true;
      return false;
    }
    if (cp < 0x2d80) {
      if (cp < 0x2c30) {
        if (cp < 0x214e) {
          if (cp < 0x212f) return false;
          if (cp < 0x2135) return true;
          if (cp < 0x2135) return false;
          if (cp < 0x2139) return true;
          if (cp === 0x2139) return true;
          if (cp < 0x213c) return false;
          if (cp < 0x2140) return true;
          if (cp < 0x2145) return false;
          if (cp < 0x214a) return true;
          return false;
        }
        if (cp === 0x214e) return true;
        if (cp < 0x2160) return false;
        if (cp < 0x2183) return true;
        if (cp < 0x2183) return false;
        if (cp < 0x2185) return true;
        if (cp < 0x2185) return false;
        if (cp < 0x2189) return true;
        if (cp < 0x2c00) return false;
        if (cp < 0x2c2f) return true;
        return false;
      }
      if (cp < 0x2cf2) {
        if (cp < 0x2c30) return false;
        if (cp < 0x2c5f) return true;
        if (cp < 0x2c60) return false;
        if (cp < 0x2c7c) return true;
        if (cp < 0x2c7c) return false;
        if (cp < 0x2c7e) return true;
        if (cp < 0x2c7e) return false;
        if (cp < 0x2ce5) return true;
        if (cp < 0x2ceb) return false;
        if (cp < 0x2cef) return true;
        return false;
      }
      if (cp < 0x2cf4) return true;
      if (cp < 0x2d00) return false;
      if (cp < 0x2d26) return true;
      if (cp === 0x2d27) return true;
      if (cp === 0x2d2d) return true;
      if (cp < 0x2d30) return false;
      if (cp < 0x2d68) return true;
      if (cp === 0x2d6f) return true;
      return false;
    }
    if (cp < 0x3006) {
      if (cp < 0x2dc0) {
        if (cp < 0x2d80) return false;
        if (cp < 0x2d97) return true;
        if (cp < 0x2da0) return false;
        if (cp < 0x2da7) return true;
        if (cp < 0x2da8) return false;
        if (cp < 0x2daf) return true;
        if (cp < 0x2db0) return false;
        if (cp < 0x2db7) return true;
        if (cp < 0x2db8) return false;
        if (cp < 0x2dbf) return true;
        return false;
      }
      if (cp < 0x2dc7) return true;
      if (cp < 0x2dc8) return false;
      if (cp < 0x2dcf) return true;
      if (cp < 0x2dd0) return false;
      if (cp < 0x2dd7) return true;
      if (cp < 0x2dd8) return false;
      if (cp < 0x2ddf) return true;
      if (cp === 0x3005) return true;
      return false;
    }
    if (cp < 0x303b) {
      if (cp === 0x3006) return true;
      if (cp === 0x3007) return true;
      if (cp < 0x3021) return false;
      if (cp < 0x302a) return true;
      if (cp < 0x3031) return false;
      if (cp < 0x3036) return true;
      if (cp < 0x3038) return false;
      if (cp < 0x303b) return true;
      return false;
    }
    if (cp === 0x303b) return true;
    if (cp === 0x303c) return true;
    if (cp < 0x3041) return false;
    if (cp < 0x3097) return true;
    if (cp < 0x309b) return false;
    if (cp < 0x309d) return true;
    if (cp < 0x309d) return false;
    if (cp < 0x309f) return true;
    if (cp === 0x309f) return true;
    return false;
  }
  if (cp < 0x10b60) {
    if (cp < 0xd7b0) {
      if (cp < 0xa882) {
        if (cp < 0xa67f) {
          if (cp < 0xa015) {
            if (cp < 0x31a0) {
              if (cp < 0x30a1) return false;
              if (cp < 0x30fb) return true;
              if (cp < 0x30fc) return false;
              if (cp < 0x30ff) return true;
              if (cp === 0x30ff) return true;
              if (cp < 0x3105) return false;
              if (cp < 0x3130) return true;
              if (cp < 0x3131) return false;
              if (cp < 0x318f) return true;
              return false;
            }
            if (cp < 0x31bb) return true;
            if (cp < 0x31f0) return false;
            if (cp < 0x3200) return true;
            if (cp < 0x3400) return false;
            if (cp < 0x4db6) return true;
            if (cp < 0x4e00) return false;
            if (cp < 0x9ff0) return true;
            if (cp < 0xa000) return false;
            if (cp < 0xa015) return true;
            return false;
          }
          if (cp < 0xa60c) {
            if (cp === 0xa015) return true;
            if (cp < 0xa016) return false;
            if (cp < 0xa48d) return true;
            if (cp < 0xa4d0) return false;
            if (cp < 0xa4f8) return true;
            if (cp < 0xa4f8) return false;
            if (cp < 0xa4fe) return true;
            if (cp < 0xa500) return false;
            if (cp < 0xa60c) return true;
            return false;
          }
          if (cp === 0xa60c) return true;
          if (cp < 0xa610) return false;
          if (cp < 0xa620) return true;
          if (cp < 0xa62a) return false;
          if (cp < 0xa62c) return true;
          if (cp < 0xa640) return false;
          if (cp < 0xa66e) return true;
          if (cp === 0xa66e) return true;
          return false;
        }
        if (cp < 0xa78b) {
          if (cp < 0xa717) {
            if (cp === 0xa67f) return true;
            if (cp < 0xa680) return false;
            if (cp < 0xa69c) return true;
            if (cp < 0xa69c) return false;
            if (cp < 0xa69e) return true;
            if (cp < 0xa6a0) return false;
            if (cp < 0xa6e6) return true;
            if (cp < 0xa6e6) return false;
            if (cp < 0xa6f0) return true;
            return false;
          }
          if (cp < 0xa720) return true;
          if (cp < 0xa722) return false;
          if (cp < 0xa770) return true;
          if (cp === 0xa770) return true;
          if (cp < 0xa771) return false;
          if (cp < 0xa788) return true;
          if (cp === 0xa788) return true;
          return false;
        }
        if (cp < 0xa7fa) {
          if (cp < 0xa78b) return false;
          if (cp < 0xa78f) return true;
          if (cp === 0xa78f) return true;
          if (cp < 0xa790) return false;
          if (cp < 0xa7ba) return true;
          if (cp === 0xa7f7) return true;
          if (cp < 0xa7f8) return false;
          if (cp < 0xa7fa) return true;
          return false;
        }
        if (cp === 0xa7fa) return true;
        if (cp < 0xa7fb) return false;
        if (cp < 0xa802) return true;
        if (cp < 0xa803) return false;
        if (cp < 0xa806) return true;
        if (cp < 0xa807) return false;
        if (cp < 0xa80b) return true;
        if (cp < 0xa80c) return false;
        if (cp < 0xa823) return true;
        if (cp < 0xa840) return false;
        if (cp < 0xa874) return true;
        return false;
      }
      if (cp < 0xaab1) {
        if (cp < 0xa9e6) {
          if (cp < 0xa930) {
            if (cp < 0xa882) return false;
            if (cp < 0xa8b4) return true;
            if (cp < 0xa8f2) return false;
            if (cp < 0xa8f8) return true;
            if (cp === 0xa8fb) return true;
            if (cp < 0xa8fd) return false;
            if (cp < 0xa8ff) return true;
            if (cp < 0xa90a) return false;
            if (cp < 0xa926) return true;
            return false;
          }
          if (cp < 0xa947) return true;
          if (cp < 0xa960) return false;
          if (cp < 0xa97d) return true;
          if (cp < 0xa984) return false;
          if (cp < 0xa9b3) return true;
          if (cp === 0xa9cf) return true;
          if (cp < 0xa9e0) return false;
          if (cp < 0xa9e5) return true;
          return false;
        }
        if (cp < 0xaa44) {
          if (cp === 0xa9e6) return true;
          if (cp < 0xa9e7) return false;
          if (cp < 0xa9f0) return true;
          if (cp < 0xa9fa) return false;
          if (cp < 0xa9ff) return true;
          if (cp < 0xaa00) return false;
          if (cp < 0xaa29) return true;
          if (cp < 0xaa40) return false;
          if (cp < 0xaa43) return true;
          return false;
        }
        if (cp < 0xaa4c) return true;
        if (cp < 0xaa60) return false;
        if (cp < 0xaa70) return true;
        if (cp === 0xaa70) return true;
        if (cp < 0xaa71) return false;
        if (cp < 0xaa77) return true;
        if (cp === 0xaa7a) return true;
        if (cp < 0xaa7e) return false;
        if (cp < 0xaab0) return true;
        return false;
      }
      if (cp < 0xab01) {
        if (cp < 0xaadb) {
          if (cp === 0xaab1) return true;
          if (cp < 0xaab5) return false;
          if (cp < 0xaab7) return true;
          if (cp < 0xaab9) return false;
          if (cp < 0xaabe) return true;
          if (cp === 0xaac0) return true;
          if (cp === 0xaac2) return true;
          return false;
        }
        if (cp < 0xaadd) return true;
        if (cp === 0xaadd) return true;
        if (cp < 0xaae0) return false;
        if (cp < 0xaaeb) return true;
        if (cp === 0xaaf2) return true;
        if (cp < 0xaaf3) return false;
        if (cp < 0xaaf5) return true;
        return false;
      }
      if (cp < 0xab30) {
        if (cp < 0xab01) return false;
        if (cp < 0xab07) return true;
        if (cp < 0xab09) return false;
        if (cp < 0xab0f) return true;
        if (cp < 0xab11) return false;
        if (cp < 0xab17) return true;
        if (cp < 0xab20) return false;
        if (cp < 0xab27) return true;
        if (cp < 0xab28) return false;
        if (cp < 0xab2f) return true;
        return false;
      }
      if (cp < 0xab5b) return true;
      if (cp < 0xab5c) return false;
      if (cp < 0xab60) return true;
      if (cp < 0xab60) return false;
      if (cp < 0xab66) return true;
      if (cp < 0xab70) return false;
      if (cp < 0xabc0) return true;
      if (cp < 0xabc0) return false;
      if (cp < 0xabe3) return true;
      if (cp < 0xac00) return false;
      if (cp < 0xd7a4) return true;
      return false;
    }
    if (cp < 0x1032d) {
      if (cp < 0xff41) {
        if (cp < 0xfb3e) {
          if (cp < 0xfb13) {
            if (cp < 0xd7b0) return false;
            if (cp < 0xd7c7) return true;
            if (cp < 0xd7cb) return false;
            if (cp < 0xd7fc) return true;
            if (cp < 0xf900) return false;
            if (cp < 0xfa6e) return true;
            if (cp < 0xfa70) return false;
            if (cp < 0xfada) return true;
            if (cp < 0xfb00) return false;
            if (cp < 0xfb07) return true;
            return false;
          }
          if (cp < 0xfb18) return true;
          if (cp === 0xfb1d) return true;
          if (cp < 0xfb1f) return false;
          if (cp < 0xfb29) return true;
          if (cp < 0xfb2a) return false;
          if (cp < 0xfb37) return true;
          if (cp < 0xfb38) return false;
          if (cp < 0xfb3d) return true;
          return false;
        }
        if (cp < 0xfd50) {
          if (cp === 0xfb3e) return true;
          if (cp < 0xfb40) return false;
          if (cp < 0xfb42) return true;
          if (cp < 0xfb43) return false;
          if (cp < 0xfb45) return true;
          if (cp < 0xfb46) return false;
          if (cp < 0xfbb2) return true;
          if (cp < 0xfbd3) return false;
          if (cp < 0xfd3e) return true;
          return false;
        }
        if (cp < 0xfd90) return true;
        if (cp < 0xfd92) return false;
        if (cp < 0xfdc8) return true;
        if (cp < 0xfdf0) return false;
        if (cp < 0xfdfc) return true;
        if (cp < 0xfe70) return false;
        if (cp < 0xfe75) return true;
        if (cp < 0xfe76) return false;
        if (cp < 0xfefd) return true;
        if (cp < 0xff21) return false;
        if (cp < 0xff3b) return true;
        return false;
      }
      if (cp < 0x10000) {
        if (cp < 0xffa0) {
          if (cp < 0xff41) return false;
          if (cp < 0xff5b) return true;
          if (cp < 0xff66) return false;
          if (cp < 0xff70) return true;
          if (cp === 0xff70) return true;
          if (cp < 0xff71) return false;
          if (cp < 0xff9e) return true;
          if (cp < 0xff9e) return false;
          if (cp < 0xffa0) return true;
          return false;
        }
        if (cp < 0xffbf) return true;
        if (cp < 0xffc2) return false;
        if (cp < 0xffc8) return true;
        if (cp < 0xffca) return false;
        if (cp < 0xffd0) return true;
        if (cp < 0xffd2) return false;
        if (cp < 0xffd8) return true;
        if (cp < 0xffda) return false;
        if (cp < 0xffdd) return true;
        return false;
      }
      if (cp < 0x10050) {
        if (cp < 0x10000) return false;
        if (cp < 0x1000c) return true;
        if (cp < 0x1000d) return false;
        if (cp < 0x10027) return true;
        if (cp < 0x10028) return false;
        if (cp < 0x1003b) return true;
        if (cp < 0x1003c) return false;
        if (cp < 0x1003e) return true;
        if (cp < 0x1003f) return false;
        if (cp < 0x1004e) return true;
        return false;
      }
      if (cp < 0x1005e) return true;
      if (cp < 0x10080) return false;
      if (cp < 0x100fb) return true;
      if (cp < 0x10140) return false;
      if (cp < 0x10175) return true;
      if (cp < 0x10280) return false;
      if (cp < 0x1029d) return true;
      if (cp < 0x102a0) return false;
      if (cp < 0x102d1) return true;
      if (cp < 0x10300) return false;
      if (cp < 0x10320) return true;
      return false;
    }
    if (cp < 0x10837) {
      if (cp < 0x10450) {
        if (cp < 0x10380) {
          if (cp < 0x1032d) return false;
          if (cp < 0x10341) return true;
          if (cp === 0x10341) return true;
          if (cp < 0x10342) return false;
          if (cp < 0x1034a) return true;
          if (cp === 0x1034a) return true;
          if (cp < 0x10350) return false;
          if (cp < 0x10376) return true;
          return false;
        }
        if (cp < 0x1039e) return true;
        if (cp < 0x103a0) return false;
        if (cp < 0x103c4) return true;
        if (cp < 0x103c8) return false;
        if (cp < 0x103d0) return true;
        if (cp < 0x103d1) return false;
        if (cp < 0x103d6) return true;
        if (cp < 0x10400) return false;
        if (cp < 0x10450) return true;
        return false;
      }
      if (cp < 0x10600) {
        if (cp < 0x10450) return false;
        if (cp < 0x1049e) return true;
        if (cp < 0x104b0) return false;
        if (cp < 0x104d4) return true;
        if (cp < 0x104d8) return false;
        if (cp < 0x104fc) return true;
        if (cp < 0x10500) return false;
        if (cp < 0x10528) return true;
        if (cp < 0x10530) return false;
        if (cp < 0x10564) return true;
        return false;
      }
      if (cp < 0x10737) return true;
      if (cp < 0x10740) return false;
      if (cp < 0x10756) return true;
      if (cp < 0x10760) return false;
      if (cp < 0x10768) return true;
      if (cp < 0x10800) return false;
      if (cp < 0x10806) return true;
      if (cp === 0x10808) return true;
      if (cp < 0x1080a) return false;
      if (cp < 0x10836) return true;
      return false;
    }
    if (cp < 0x109be) {
      if (cp < 0x108e0) {
        if (cp < 0x10837) return false;
        if (cp < 0x10839) return true;
        if (cp === 0x1083c) return true;
        if (cp < 0x1083f) return false;
        if (cp < 0x10856) return true;
        if (cp < 0x10860) return false;
        if (cp < 0x10877) return true;
        if (cp < 0x10880) return false;
        if (cp < 0x1089f) return true;
        return false;
      }
      if (cp < 0x108f3) return true;
      if (cp < 0x108f4) return false;
      if (cp < 0x108f6) return true;
      if (cp < 0x10900) return false;
      if (cp < 0x10916) return true;
      if (cp < 0x10920) return false;
      if (cp < 0x1093a) return true;
      if (cp < 0x10980) return false;
      if (cp < 0x109b8) return true;
      return false;
    }
    if (cp < 0x10a60) {
      if (cp < 0x109be) return false;
      if (cp < 0x109c0) return true;
      if (cp === 0x10a00) return true;
      if (cp < 0x10a10) return false;
      if (cp < 0x10a14) return true;
      if (cp < 0x10a15) return false;
      if (cp < 0x10a18) return true;
      if (cp < 0x10a19) return false;
      if (cp < 0x10a36) return true;
      return false;
    }
    if (cp < 0x10a7d) return true;
    if (cp < 0x10a80) return false;
    if (cp < 0x10a9d) return true;
    if (cp < 0x10ac0) return false;
    if (cp < 0x10ac8) return true;
    if (cp < 0x10ac9) return false;
    if (cp < 0x10ae5) return true;
    if (cp < 0x10b00) return false;
    if (cp < 0x10b36) return true;
    if (cp < 0x10b40) return false;
    if (cp < 0x10b56) return true;
    return false;
  }
  if (cp < 0x16e40) {
    if (cp < 0x11580) {
      if (cp < 0x11213) {
        if (cp < 0x11083) {
          if (cp < 0x10d00) {
            if (cp < 0x10b60) return false;
            if (cp < 0x10b73) return true;
            if (cp < 0x10b80) return false;
            if (cp < 0x10b92) return true;
            if (cp < 0x10c00) return false;
            if (cp < 0x10c49) return true;
            if (cp < 0x10c80) return false;
            if (cp < 0x10cb3) return true;
            if (cp < 0x10cc0) return false;
            if (cp < 0x10cf3) return true;
            return false;
          }
          if (cp < 0x10d24) return true;
          if (cp < 0x10f00) return false;
          if (cp < 0x10f1d) return true;
          if (cp === 0x10f27) return true;
          if (cp < 0x10f30) return false;
          if (cp < 0x10f46) return true;
          if (cp < 0x11003) return false;
          if (cp < 0x11038) return true;
          return false;
        }
        if (cp < 0x11176) {
          if (cp < 0x11083) return false;
          if (cp < 0x110b0) return true;
          if (cp < 0x110d0) return false;
          if (cp < 0x110e9) return true;
          if (cp < 0x11103) return false;
          if (cp < 0x11127) return true;
          if (cp === 0x11144) return true;
          if (cp < 0x11150) return false;
          if (cp < 0x11173) return true;
          return false;
        }
        if (cp === 0x11176) return true;
        if (cp < 0x11183) return false;
        if (cp < 0x111b3) return true;
        if (cp < 0x111c1) return false;
        if (cp < 0x111c5) return true;
        if (cp === 0x111da) return true;
        if (cp === 0x111dc) return true;
        if (cp < 0x11200) return false;
        if (cp < 0x11212) return true;
        return false;
      }
      if (cp < 0x1132a) {
        if (cp < 0x1129f) {
          if (cp < 0x11213) return false;
          if (cp < 0x1122c) return true;
          if (cp < 0x11280) return false;
          if (cp < 0x11287) return true;
          if (cp === 0x11288) return true;
          if (cp < 0x1128a) return false;
          if (cp < 0x1128e) return true;
          if (cp < 0x1128f) return false;
          if (cp < 0x1129e) return true;
          return false;
        }
        if (cp < 0x112a9) return true;
        if (cp < 0x112b0) return false;
        if (cp < 0x112df) return true;
        if (cp < 0x11305) return false;
        if (cp < 0x1130d) return true;
        if (cp < 0x1130f) return false;
        if (cp < 0x11311) return true;
        if (cp < 0x11313) return false;
        if (cp < 0x11329) return true;
        return false;
      }
      if (cp < 0x1135d) {
        if (cp < 0x1132a) return false;
        if (cp < 0x11331) return true;
        if (cp < 0x11332) return false;
        if (cp < 0x11334) return true;
        if (cp < 0x11335) return false;
        if (cp < 0x1133a) return true;
        if (cp === 0x1133d) return true;
        if (cp === 0x11350) return true;
        return false;
      }
      if (cp < 0x11362) return true;
      if (cp < 0x11400) return false;
      if (cp < 0x11435) return true;
      if (cp < 0x11447) return false;
      if (cp < 0x1144b) return true;
      if (cp < 0x11480) return false;
      if (cp < 0x114b0) return true;
      if (cp < 0x114c4) return false;
      if (cp < 0x114c6) return true;
      if (cp === 0x114c7) return true;
      return false;
    }
    if (cp < 0x11d00) {
      if (cp < 0x11a0b) {
        if (cp < 0x11700) {
          if (cp < 0x11580) return false;
          if (cp < 0x115af) return true;
          if (cp < 0x115d8) return false;
          if (cp < 0x115dc) return true;
          if (cp < 0x11600) return false;
          if (cp < 0x11630) return true;
          if (cp === 0x11644) return true;
          if (cp < 0x11680) return false;
          if (cp < 0x116ab) return true;
          return false;
        }
        if (cp < 0x1171b) return true;
        if (cp < 0x11800) return false;
        if (cp < 0x1182c) return true;
        if (cp < 0x118a0) return false;
        if (cp < 0x118e0) return true;
        if (cp === 0x118ff) return true;
        if (cp === 0x11a00) return true;
        return false;
      }
      if (cp < 0x11a9d) {
        if (cp < 0x11a0b) return false;
        if (cp < 0x11a33) return true;
        if (cp === 0x11a3a) return true;
        if (cp === 0x11a50) return true;
        if (cp < 0x11a5c) return false;
        if (cp < 0x11a84) return true;
        if (cp < 0x11a86) return false;
        if (cp < 0x11a8a) return true;
        return false;
      }
      if (cp === 0x11a9d) return true;
      if (cp < 0x11ac0) return false;
      if (cp < 0x11af9) return true;
      if (cp < 0x11c00) return false;
      if (cp < 0x11c09) return true;
      if (cp < 0x11c0a) return false;
      if (cp < 0x11c2f) return true;
      if (cp === 0x11c40) return true;
      if (cp < 0x11c72) return false;
      if (cp < 0x11c90) return true;
      return false;
    }
    if (cp < 0x12400) {
      if (cp < 0x11d67) {
        if (cp < 0x11d00) return false;
        if (cp < 0x11d07) return true;
        if (cp < 0x11d08) return false;
        if (cp < 0x11d0a) return true;
        if (cp < 0x11d0b) return false;
        if (cp < 0x11d31) return true;
        if (cp === 0x11d46) return true;
        if (cp < 0x11d60) return false;
        if (cp < 0x11d66) return true;
        return false;
      }
      if (cp < 0x11d69) return true;
      if (cp < 0x11d6a) return false;
      if (cp < 0x11d8a) return true;
      if (cp === 0x11d98) return true;
      if (cp < 0x11ee0) return false;
      if (cp < 0x11ef3) return true;
      if (cp < 0x12000) return false;
      if (cp < 0x1239a) return true;
      return false;
    }
    if (cp < 0x16a40) {
      if (cp < 0x12400) return false;
      if (cp < 0x1246f) return true;
      if (cp < 0x12480) return false;
      if (cp < 0x12544) return true;
      if (cp < 0x13000) return false;
      if (cp < 0x1342f) return true;
      if (cp < 0x14400) return false;
      if (cp < 0x14647) return true;
      if (cp < 0x16800) return false;
      if (cp < 0x16a39) return true;
      return false;
    }
    if (cp < 0x16a5f) return true;
    if (cp < 0x16ad0) return false;
    if (cp < 0x16aee) return true;
    if (cp < 0x16b00) return false;
    if (cp < 0x16b30) return true;
    if (cp < 0x16b40) return false;
    if (cp < 0x16b44) return true;
    if (cp < 0x16b63) return false;
    if (cp < 0x16b78) return true;
    if (cp < 0x16b7d) return false;
    if (cp < 0x16b90) return true;
    return false;
  }
  if (cp < 0x1d7c4) {
    if (cp < 0x1d4bd) {
      if (cp < 0x1bc70) {
        if (cp < 0x17000) {
          if (cp < 0x16e40) return false;
          if (cp < 0x16e80) return true;
          if (cp < 0x16f00) return false;
          if (cp < 0x16f45) return true;
          if (cp === 0x16f50) return true;
          if (cp < 0x16f93) return false;
          if (cp < 0x16fa0) return true;
          if (cp < 0x16fe0) return false;
          if (cp < 0x16fe2) return true;
          return false;
        }
        if (cp < 0x187f2) return true;
        if (cp < 0x18800) return false;
        if (cp < 0x18af3) return true;
        if (cp < 0x1b000) return false;
        if (cp < 0x1b11f) return true;
        if (cp < 0x1b170) return false;
        if (cp < 0x1b2fc) return true;
        if (cp < 0x1bc00) return false;
        if (cp < 0x1bc6b) return true;
        return false;
      }
      if (cp < 0x1d49e) {
        if (cp < 0x1bc70) return false;
        if (cp < 0x1bc7d) return true;
        if (cp < 0x1bc80) return false;
        if (cp < 0x1bc89) return true;
        if (cp < 0x1bc90) return false;
        if (cp < 0x1bc9a) return true;
        if (cp < 0x1d400) return false;
        if (cp < 0x1d455) return true;
        if (cp < 0x1d456) return false;
        if (cp < 0x1d49d) return true;
        return false;
      }
      if (cp < 0x1d4a0) return true;
      if (cp === 0x1d4a2) return true;
      if (cp < 0x1d4a5) return false;
      if (cp < 0x1d4a7) return true;
      if (cp < 0x1d4a9) return false;
      if (cp < 0x1d4ad) return true;
      if (cp < 0x1d4ae) return false;
      if (cp < 0x1d4ba) return true;
      if (cp === 0x1d4bb) return true;
      return false;
    }
    if (cp < 0x1d552) {
      if (cp < 0x1d51e) {
        if (cp < 0x1d4bd) return false;
        if (cp < 0x1d4c4) return true;
        if (cp < 0x1d4c5) return false;
        if (cp < 0x1d506) return true;
        if (cp < 0x1d507) return false;
        if (cp < 0x1d50b) return true;
        if (cp < 0x1d50d) return false;
        if (cp < 0x1d515) return true;
        if (cp < 0x1d516) return false;
        if (cp < 0x1d51d) return true;
        return false;
      }
      if (cp < 0x1d53a) return true;
      if (cp < 0x1d53b) return false;
      if (cp < 0x1d53f) return true;
      if (cp < 0x1d540) return false;
      if (cp < 0x1d545) return true;
      if (cp === 0x1d546) return true;
      if (cp < 0x1d54a) return false;
      if (cp < 0x1d551) return true;
      return false;
    }
    if (cp < 0x1d716) {
      if (cp < 0x1d552) return false;
      if (cp < 0x1d6a6) return true;
      if (cp < 0x1d6a8) return false;
      if (cp < 0x1d6c1) return true;
      if (cp < 0x1d6c2) return false;
      if (cp < 0x1d6db) return true;
      if (cp < 0x1d6dc) return false;
      if (cp < 0x1d6fb) return true;
      if (cp < 0x1d6fc) return false;
      if (cp < 0x1d715) return true;
      return false;
    }
    if (cp < 0x1d735) return true;
    if (cp < 0x1d736) return false;
    if (cp < 0x1d74f) return true;
    if (cp < 0x1d750) return false;
    if (cp < 0x1d76f) return true;
    if (cp < 0x1d770) return false;
    if (cp < 0x1d789) return true;
    if (cp < 0x1d78a) return false;
    if (cp < 0x1d7a9) return true;
    if (cp < 0x1d7aa) return false;
    if (cp < 0x1d7c3) return true;
    return false;
  }
  if (cp < 0x1ee5b) {
    if (cp < 0x1ee39) {
      if (cp < 0x1ee21) {
        if (cp < 0x1d7c4) return false;
        if (cp < 0x1d7cc) return true;
        if (cp < 0x1e800) return false;
        if (cp < 0x1e8c5) return true;
        if (cp < 0x1e900) return false;
        if (cp < 0x1e944) return true;
        if (cp < 0x1ee00) return false;
        if (cp < 0x1ee04) return true;
        if (cp < 0x1ee05) return false;
        if (cp < 0x1ee20) return true;
        return false;
      }
      if (cp < 0x1ee23) return true;
      if (cp === 0x1ee24) return true;
      if (cp === 0x1ee27) return true;
      if (cp < 0x1ee29) return false;
      if (cp < 0x1ee33) return true;
      if (cp < 0x1ee34) return false;
      if (cp < 0x1ee38) return true;
      return false;
    }
    if (cp < 0x1ee4b) {
      if (cp === 0x1ee39) return true;
      if (cp === 0x1ee3b) return true;
      if (cp === 0x1ee42) return true;
      if (cp === 0x1ee47) return true;
      if (cp === 0x1ee49) return true;
      return false;
    }
    if (cp === 0x1ee4b) return true;
    if (cp < 0x1ee4d) return false;
    if (cp < 0x1ee50) return true;
    if (cp < 0x1ee51) return false;
    if (cp < 0x1ee53) return true;
    if (cp === 0x1ee54) return true;
    if (cp === 0x1ee57) return true;
    if (cp === 0x1ee59) return true;
    return false;
  }
  if (cp < 0x1ee80) {
    if (cp < 0x1ee67) {
      if (cp === 0x1ee5b) return true;
      if (cp === 0x1ee5d) return true;
      if (cp === 0x1ee5f) return true;
      if (cp < 0x1ee61) return false;
      if (cp < 0x1ee63) return true;
      if (cp === 0x1ee64) return true;
      return false;
    }
    if (cp < 0x1ee6b) return true;
    if (cp < 0x1ee6c) return false;
    if (cp < 0x1ee73) return true;
    if (cp < 0x1ee74) return false;
    if (cp < 0x1ee78) return true;
    if (cp < 0x1ee79) return false;
    if (cp < 0x1ee7d) return true;
    if (cp === 0x1ee7e) return true;
    return false;
  }
  if (cp < 0x20000) {
    if (cp < 0x1ee80) return false;
    if (cp < 0x1ee8a) return true;
    if (cp < 0x1ee8b) return false;
    if (cp < 0x1ee9c) return true;
    if (cp < 0x1eea1) return false;
    if (cp < 0x1eea4) return true;
    if (cp < 0x1eea5) return false;
    if (cp < 0x1eeaa) return true;
    if (cp < 0x1eeab) return false;
    if (cp < 0x1eebc) return true;
    return false;
  }
  if (cp < 0x2a6d7) return true;
  if (cp < 0x2a700) return false;
  if (cp < 0x2b735) return true;
  if (cp < 0x2b740) return false;
  if (cp < 0x2b81e) return true;
  if (cp < 0x2b820) return false;
  if (cp < 0x2cea2) return true;
  if (cp < 0x2ceb0) return false;
  if (cp < 0x2ebe1) return true;
  if (cp < 0x2f800) return false;
  if (cp < 0x2fa1e) return true;
  return false;
}
function isLargeIdContinue(cp) {
  if (cp < 0x1cd0) {
    if (cp < 0xd82) {
      if (cp < 0xa83) {
        if (cp < 0x93b) {
          if (cp < 0x6ea) {
            if (cp < 0x5c7) {
              if (cp === 0xb7) return true;
              if (cp < 0x300) return false;
              if (cp < 0x370) return true;
              if (cp === 0x387) return true;
              if (cp < 0x483) return false;
              if (cp < 0x488) return true;
              if (cp < 0x591) return false;
              if (cp < 0x5be) return true;
              if (cp === 0x5bf) return true;
              if (cp < 0x5c1) return false;
              if (cp < 0x5c3) return true;
              if (cp < 0x5c4) return false;
              if (cp < 0x5c6) return true;
              return false;
            }
            if (cp === 0x5c7) return true;
            if (cp < 0x610) return false;
            if (cp < 0x61b) return true;
            if (cp < 0x64b) return false;
            if (cp < 0x660) return true;
            if (cp < 0x660) return false;
            if (cp < 0x66a) return true;
            if (cp === 0x670) return true;
            if (cp < 0x6d6) return false;
            if (cp < 0x6dd) return true;
            if (cp < 0x6df) return false;
            if (cp < 0x6e5) return true;
            if (cp < 0x6e7) return false;
            if (cp < 0x6e9) return true;
            return false;
          }
          if (cp < 0x816) {
            if (cp < 0x6ea) return false;
            if (cp < 0x6ee) return true;
            if (cp < 0x6f0) return false;
            if (cp < 0x6fa) return true;
            if (cp === 0x711) return true;
            if (cp < 0x730) return false;
            if (cp < 0x74b) return true;
            if (cp < 0x7a6) return false;
            if (cp < 0x7b1) return true;
            if (cp < 0x7c0) return false;
            if (cp < 0x7ca) return true;
            if (cp < 0x7eb) return false;
            if (cp < 0x7f4) return true;
            if (cp === 0x7fd) return true;
            return false;
          }
          if (cp < 0x81a) return true;
          if (cp < 0x81b) return false;
          if (cp < 0x824) return true;
          if (cp < 0x825) return false;
          if (cp < 0x828) return true;
          if (cp < 0x829) return false;
          if (cp < 0x82e) return true;
          if (cp < 0x859) return false;
          if (cp < 0x85c) return true;
          if (cp < 0x8d3) return false;
          if (cp < 0x8e2) return true;
          if (cp < 0x8e3) return false;
          if (cp < 0x903) return true;
          if (cp === 0x903) return true;
          if (cp === 0x93a) return true;
          return false;
        }
        if (cp < 0x9cd) {
          if (cp < 0x962) {
            if (cp === 0x93b) return true;
            if (cp === 0x93c) return true;
            if (cp < 0x93e) return false;
            if (cp < 0x941) return true;
            if (cp < 0x941) return false;
            if (cp < 0x949) return true;
            if (cp < 0x949) return false;
            if (cp < 0x94d) return true;
            if (cp === 0x94d) return true;
            if (cp < 0x94e) return false;
            if (cp < 0x950) return true;
            if (cp < 0x951) return false;
            if (cp < 0x958) return true;
            return false;
          }
          if (cp < 0x964) return true;
          if (cp < 0x966) return false;
          if (cp < 0x970) return true;
          if (cp === 0x981) return true;
          if (cp < 0x982) return false;
          if (cp < 0x984) return true;
          if (cp === 0x9bc) return true;
          if (cp < 0x9be) return false;
          if (cp < 0x9c1) return true;
          if (cp < 0x9c1) return false;
          if (cp < 0x9c5) return true;
          if (cp < 0x9c7) return false;
          if (cp < 0x9c9) return true;
          if (cp < 0x9cb) return false;
          if (cp < 0x9cd) return true;
          return false;
        }
        if (cp < 0xa3e) {
          if (cp === 0x9cd) return true;
          if (cp === 0x9d7) return true;
          if (cp < 0x9e2) return false;
          if (cp < 0x9e4) return true;
          if (cp < 0x9e6) return false;
          if (cp < 0x9f0) return true;
          if (cp === 0x9fe) return true;
          if (cp < 0xa01) return false;
          if (cp < 0xa03) return true;
          if (cp === 0xa03) return true;
          if (cp === 0xa3c) return true;
          return false;
        }
        if (cp < 0xa41) return true;
        if (cp < 0xa41) return false;
        if (cp < 0xa43) return true;
        if (cp < 0xa47) return false;
        if (cp < 0xa49) return true;
        if (cp < 0xa4b) return false;
        if (cp < 0xa4e) return true;
        if (cp === 0xa51) return true;
        if (cp < 0xa66) return false;
        if (cp < 0xa70) return true;
        if (cp < 0xa70) return false;
        if (cp < 0xa72) return true;
        if (cp === 0xa75) return true;
        if (cp < 0xa81) return false;
        if (cp < 0xa83) return true;
        return false;
      }
      if (cp < 0xc00) {
        if (cp < 0xb41) {
          if (cp < 0xae2) {
            if (cp === 0xa83) return true;
            if (cp === 0xabc) return true;
            if (cp < 0xabe) return false;
            if (cp < 0xac1) return true;
            if (cp < 0xac1) return false;
            if (cp < 0xac6) return true;
            if (cp < 0xac7) return false;
            if (cp < 0xac9) return true;
            if (cp === 0xac9) return true;
            if (cp < 0xacb) return false;
            if (cp < 0xacd) return true;
            if (cp === 0xacd) return true;
            return false;
          }
          if (cp < 0xae4) return true;
          if (cp < 0xae6) return false;
          if (cp < 0xaf0) return true;
          if (cp < 0xafa) return false;
          if (cp < 0xb00) return true;
          if (cp === 0xb01) return true;
          if (cp < 0xb02) return false;
          if (cp < 0xb04) return true;
          if (cp === 0xb3c) return true;
          if (cp === 0xb3e) return true;
          if (cp === 0xb3f) return true;
          if (cp === 0xb40) return true;
          return false;
        }
        if (cp < 0xb82) {
          if (cp < 0xb41) return false;
          if (cp < 0xb45) return true;
          if (cp < 0xb47) return false;
          if (cp < 0xb49) return true;
          if (cp < 0xb4b) return false;
          if (cp < 0xb4d) return true;
          if (cp === 0xb4d) return true;
          if (cp === 0xb56) return true;
          if (cp === 0xb57) return true;
          if (cp < 0xb62) return false;
          if (cp < 0xb64) return true;
          if (cp < 0xb66) return false;
          if (cp < 0xb70) return true;
          return false;
        }
        if (cp === 0xb82) return true;
        if (cp < 0xbbe) return false;
        if (cp < 0xbc0) return true;
        if (cp === 0xbc0) return true;
        if (cp < 0xbc1) return false;
        if (cp < 0xbc3) return true;
        if (cp < 0xbc6) return false;
        if (cp < 0xbc9) return true;
        if (cp < 0xbca) return false;
        if (cp < 0xbcd) return true;
        if (cp === 0xbcd) return true;
        if (cp === 0xbd7) return true;
        if (cp < 0xbe6) return false;
        if (cp < 0xbf0) return true;
        return false;
      }
      if (cp < 0xcc7) {
        if (cp < 0xc62) {
          if (cp === 0xc00) return true;
          if (cp < 0xc01) return false;
          if (cp < 0xc04) return true;
          if (cp === 0xc04) return true;
          if (cp < 0xc3e) return false;
          if (cp < 0xc41) return true;
          if (cp < 0xc41) return false;
          if (cp < 0xc45) return true;
          if (cp < 0xc46) return false;
          if (cp < 0xc49) return true;
          if (cp < 0xc4a) return false;
          if (cp < 0xc4e) return true;
          if (cp < 0xc55) return false;
          if (cp < 0xc57) return true;
          return false;
        }
        if (cp < 0xc64) return true;
        if (cp < 0xc66) return false;
        if (cp < 0xc70) return true;
        if (cp === 0xc81) return true;
        if (cp < 0xc82) return false;
        if (cp < 0xc84) return true;
        if (cp === 0xcbc) return true;
        if (cp === 0xcbe) return true;
        if (cp === 0xcbf) return true;
        if (cp < 0xcc0) return false;
        if (cp < 0xcc5) return true;
        if (cp === 0xcc6) return true;
        return false;
      }
      if (cp < 0xd3b) {
        if (cp < 0xcc7) return false;
        if (cp < 0xcc9) return true;
        if (cp < 0xcca) return false;
        if (cp < 0xccc) return true;
        if (cp < 0xccc) return false;
        if (cp < 0xcce) return true;
        if (cp < 0xcd5) return false;
        if (cp < 0xcd7) return true;
        if (cp < 0xce2) return false;
        if (cp < 0xce4) return true;
        if (cp < 0xce6) return false;
        if (cp < 0xcf0) return true;
        if (cp < 0xd00) return false;
        if (cp < 0xd02) return true;
        if (cp < 0xd02) return false;
        if (cp < 0xd04) return true;
        return false;
      }
      if (cp < 0xd3d) return true;
      if (cp < 0xd3e) return false;
      if (cp < 0xd41) return true;
      if (cp < 0xd41) return false;
      if (cp < 0xd45) return true;
      if (cp < 0xd46) return false;
      if (cp < 0xd49) return true;
      if (cp < 0xd4a) return false;
      if (cp < 0xd4d) return true;
      if (cp === 0xd4d) return true;
      if (cp === 0xd57) return true;
      if (cp < 0xd62) return false;
      if (cp < 0xd64) return true;
      if (cp < 0xd66) return false;
      if (cp < 0xd70) return true;
      return false;
    }
    if (cp < 0x17e0) {
      if (cp < 0x1038) {
        if (cp < 0xf18) {
          if (cp < 0xe31) {
            if (cp < 0xd82) return false;
            if (cp < 0xd84) return true;
            if (cp === 0xdca) return true;
            if (cp < 0xdcf) return false;
            if (cp < 0xdd2) return true;
            if (cp < 0xdd2) return false;
            if (cp < 0xdd5) return true;
            if (cp === 0xdd6) return true;
            if (cp < 0xdd8) return false;
            if (cp < 0xde0) return true;
            if (cp < 0xde6) return false;
            if (cp < 0xdf0) return true;
            if (cp < 0xdf2) return false;
            if (cp < 0xdf4) return true;
            return false;
          }
          if (cp === 0xe31) return true;
          if (cp < 0xe34) return false;
          if (cp < 0xe3b) return true;
          if (cp < 0xe47) return false;
          if (cp < 0xe4f) return true;
          if (cp < 0xe50) return false;
          if (cp < 0xe5a) return true;
          if (cp === 0xeb1) return true;
          if (cp < 0xeb4) return false;
          if (cp < 0xeba) return true;
          if (cp < 0xebb) return false;
          if (cp < 0xebd) return true;
          if (cp < 0xec8) return false;
          if (cp < 0xece) return true;
          if (cp < 0xed0) return false;
          if (cp < 0xeda) return true;
          return false;
        }
        if (cp < 0xf80) {
          if (cp < 0xf18) return false;
          if (cp < 0xf1a) return true;
          if (cp < 0xf20) return false;
          if (cp < 0xf2a) return true;
          if (cp === 0xf35) return true;
          if (cp === 0xf37) return true;
          if (cp === 0xf39) return true;
          if (cp < 0xf3e) return false;
          if (cp < 0xf40) return true;
          if (cp < 0xf71) return false;
          if (cp < 0xf7f) return true;
          if (cp === 0xf7f) return true;
          return false;
        }
        if (cp < 0xf85) return true;
        if (cp < 0xf86) return false;
        if (cp < 0xf88) return true;
        if (cp < 0xf8d) return false;
        if (cp < 0xf98) return true;
        if (cp < 0xf99) return false;
        if (cp < 0xfbd) return true;
        if (cp === 0xfc6) return true;
        if (cp < 0x102b) return false;
        if (cp < 0x102d) return true;
        if (cp < 0x102d) return false;
        if (cp < 0x1031) return true;
        if (cp === 0x1031) return true;
        if (cp < 0x1032) return false;
        if (cp < 0x1038) return true;
        return false;
      }
      if (cp < 0x1090) {
        if (cp < 0x1062) {
          if (cp === 0x1038) return true;
          if (cp < 0x1039) return false;
          if (cp < 0x103b) return true;
          if (cp < 0x103b) return false;
          if (cp < 0x103d) return true;
          if (cp < 0x103d) return false;
          if (cp < 0x103f) return true;
          if (cp < 0x1040) return false;
          if (cp < 0x104a) return true;
          if (cp < 0x1056) return false;
          if (cp < 0x1058) return true;
          if (cp < 0x1058) return false;
          if (cp < 0x105a) return true;
          if (cp < 0x105e) return false;
          if (cp < 0x1061) return true;
          return false;
        }
        if (cp < 0x1065) return true;
        if (cp < 0x1067) return false;
        if (cp < 0x106e) return true;
        if (cp < 0x1071) return false;
        if (cp < 0x1075) return true;
        if (cp === 0x1082) return true;
        if (cp < 0x1083) return false;
        if (cp < 0x1085) return true;
        if (cp < 0x1085) return false;
        if (cp < 0x1087) return true;
        if (cp < 0x1087) return false;
        if (cp < 0x108d) return true;
        if (cp === 0x108d) return true;
        if (cp === 0x108f) return true;
        return false;
      }
      if (cp < 0x1772) {
        if (cp < 0x1090) return false;
        if (cp < 0x109a) return true;
        if (cp < 0x109a) return false;
        if (cp < 0x109d) return true;
        if (cp === 0x109d) return true;
        if (cp < 0x135d) return false;
        if (cp < 0x1360) return true;
        if (cp < 0x1369) return false;
        if (cp < 0x1372) return true;
        if (cp < 0x1712) return false;
        if (cp < 0x1715) return true;
        if (cp < 0x1732) return false;
        if (cp < 0x1735) return true;
        if (cp < 0x1752) return false;
        if (cp < 0x1754) return true;
        return false;
      }
      if (cp < 0x1774) return true;
      if (cp < 0x17b4) return false;
      if (cp < 0x17b6) return true;
      if (cp === 0x17b6) return true;
      if (cp < 0x17b7) return false;
      if (cp < 0x17be) return true;
      if (cp < 0x17be) return false;
      if (cp < 0x17c6) return true;
      if (cp === 0x17c6) return true;
      if (cp < 0x17c7) return false;
      if (cp < 0x17c9) return true;
      if (cp < 0x17c9) return false;
      if (cp < 0x17d4) return true;
      if (cp === 0x17dd) return true;
      return false;
    }
    if (cp < 0x1b04) {
      if (cp < 0x1a1b) {
        if (cp < 0x1930) {
          if (cp < 0x17e0) return false;
          if (cp < 0x17ea) return true;
          if (cp < 0x180b) return false;
          if (cp < 0x180e) return true;
          if (cp < 0x1810) return false;
          if (cp < 0x181a) return true;
          if (cp === 0x18a9) return true;
          if (cp < 0x1920) return false;
          if (cp < 0x1923) return true;
          if (cp < 0x1923) return false;
          if (cp < 0x1927) return true;
          if (cp < 0x1927) return false;
          if (cp < 0x1929) return true;
          if (cp < 0x1929) return false;
          if (cp < 0x192c) return true;
          return false;
        }
        if (cp < 0x1932) return true;
        if (cp === 0x1932) return true;
        if (cp < 0x1933) return false;
        if (cp < 0x1939) return true;
        if (cp < 0x1939) return false;
        if (cp < 0x193c) return true;
        if (cp < 0x1946) return false;
        if (cp < 0x1950) return true;
        if (cp < 0x19d0) return false;
        if (cp < 0x19da) return true;
        if (cp === 0x19da) return true;
        if (cp < 0x1a17) return false;
        if (cp < 0x1a19) return true;
        if (cp < 0x1a19) return false;
        if (cp < 0x1a1b) return true;
        return false;
      }
      if (cp < 0x1a63) {
        if (cp === 0x1a1b) return true;
        if (cp === 0x1a55) return true;
        if (cp === 0x1a56) return true;
        if (cp === 0x1a57) return true;
        if (cp < 0x1a58) return false;
        if (cp < 0x1a5f) return true;
        if (cp === 0x1a60) return true;
        if (cp === 0x1a61) return true;
        if (cp === 0x1a62) return true;
        return false;
      }
      if (cp < 0x1a65) return true;
      if (cp < 0x1a65) return false;
      if (cp < 0x1a6d) return true;
      if (cp < 0x1a6d) return false;
      if (cp < 0x1a73) return true;
      if (cp < 0x1a73) return false;
      if (cp < 0x1a7d) return true;
      if (cp === 0x1a7f) return true;
      if (cp < 0x1a80) return false;
      if (cp < 0x1a8a) return true;
      if (cp < 0x1a90) return false;
      if (cp < 0x1a9a) return true;
      if (cp < 0x1ab0) return false;
      if (cp < 0x1abe) return true;
      if (cp < 0x1b00) return false;
      if (cp < 0x1b04) return true;
      return false;
    }
    if (cp < 0x1baa) {
      if (cp < 0x1b43) {
        if (cp === 0x1b04) return true;
        if (cp === 0x1b34) return true;
        if (cp === 0x1b35) return true;
        if (cp < 0x1b36) return false;
        if (cp < 0x1b3b) return true;
        if (cp === 0x1b3b) return true;
        if (cp === 0x1b3c) return true;
        if (cp < 0x1b3d) return false;
        if (cp < 0x1b42) return true;
        if (cp === 0x1b42) return true;
        return false;
      }
      if (cp < 0x1b45) return true;
      if (cp < 0x1b50) return false;
      if (cp < 0x1b5a) return true;
      if (cp < 0x1b6b) return false;
      if (cp < 0x1b74) return true;
      if (cp < 0x1b80) return false;
      if (cp < 0x1b82) return true;
      if (cp === 0x1b82) return true;
      if (cp === 0x1ba1) return true;
      if (cp < 0x1ba2) return false;
      if (cp < 0x1ba6) return true;
      if (cp < 0x1ba6) return false;
      if (cp < 0x1ba8) return true;
      if (cp < 0x1ba8) return false;
      if (cp < 0x1baa) return true;
      return false;
    }
    if (cp < 0x1bee) {
      if (cp === 0x1baa) return true;
      if (cp < 0x1bab) return false;
      if (cp < 0x1bae) return true;
      if (cp < 0x1bb0) return false;
      if (cp < 0x1bba) return true;
      if (cp === 0x1be6) return true;
      if (cp === 0x1be7) return true;
      if (cp < 0x1be8) return false;
      if (cp < 0x1bea) return true;
      if (cp < 0x1bea) return false;
      if (cp < 0x1bed) return true;
      if (cp === 0x1bed) return true;
      return false;
    }
    if (cp === 0x1bee) return true;
    if (cp < 0x1bef) return false;
    if (cp < 0x1bf2) return true;
    if (cp < 0x1bf2) return false;
    if (cp < 0x1bf4) return true;
    if (cp < 0x1c24) return false;
    if (cp < 0x1c2c) return true;
    if (cp < 0x1c2c) return false;
    if (cp < 0x1c34) return true;
    if (cp < 0x1c34) return false;
    if (cp < 0x1c36) return true;
    if (cp < 0x1c36) return false;
    if (cp < 0x1c38) return true;
    if (cp < 0x1c40) return false;
    if (cp < 0x1c4a) return true;
    if (cp < 0x1c50) return false;
    if (cp < 0x1c5a) return true;
    return false;
  }
  if (cp < 0x1123e) {
    if (cp < 0xaab7) {
      if (cp < 0xa8b4) {
        if (cp < 0x2d7f) {
          if (cp < 0x1cf8) {
            if (cp < 0x1cd0) return false;
            if (cp < 0x1cd3) return true;
            if (cp < 0x1cd4) return false;
            if (cp < 0x1ce1) return true;
            if (cp === 0x1ce1) return true;
            if (cp < 0x1ce2) return false;
            if (cp < 0x1ce9) return true;
            if (cp === 0x1ced) return true;
            if (cp < 0x1cf2) return false;
            if (cp < 0x1cf4) return true;
            if (cp === 0x1cf4) return true;
            if (cp === 0x1cf7) return true;
            return false;
          }
          if (cp < 0x1cfa) return true;
          if (cp < 0x1dc0) return false;
          if (cp < 0x1dfa) return true;
          if (cp < 0x1dfb) return false;
          if (cp < 0x1e00) return true;
          if (cp < 0x203f) return false;
          if (cp < 0x2041) return true;
          if (cp === 0x2054) return true;
          if (cp < 0x20d0) return false;
          if (cp < 0x20dd) return true;
          if (cp === 0x20e1) return true;
          if (cp < 0x20e5) return false;
          if (cp < 0x20f1) return true;
          if (cp < 0x2cef) return false;
          if (cp < 0x2cf2) return true;
          return false;
        }
        if (cp < 0xa69e) {
          if (cp === 0x2d7f) return true;
          if (cp < 0x2de0) return false;
          if (cp < 0x2e00) return true;
          if (cp < 0x302a) return false;
          if (cp < 0x302e) return true;
          if (cp < 0x302e) return false;
          if (cp < 0x3030) return true;
          if (cp < 0x3099) return false;
          if (cp < 0x309b) return true;
          if (cp < 0xa620) return false;
          if (cp < 0xa62a) return true;
          if (cp === 0xa66f) return true;
          if (cp < 0xa674) return false;
          if (cp < 0xa67e) return true;
          return false;
        }
        if (cp < 0xa6a0) return true;
        if (cp < 0xa6f0) return false;
        if (cp < 0xa6f2) return true;
        if (cp === 0xa802) return true;
        if (cp === 0xa806) return true;
        if (cp === 0xa80b) return true;
        if (cp < 0xa823) return false;
        if (cp < 0xa825) return true;
        if (cp < 0xa825) return false;
        if (cp < 0xa827) return true;
        if (cp === 0xa827) return true;
        if (cp < 0xa880) return false;
        if (cp < 0xa882) return true;
        return false;
      }
      if (cp < 0xa9d0) {
        if (cp < 0xa952) {
          if (cp < 0xa8b4) return false;
          if (cp < 0xa8c4) return true;
          if (cp < 0xa8c4) return false;
          if (cp < 0xa8c6) return true;
          if (cp < 0xa8d0) return false;
          if (cp < 0xa8da) return true;
          if (cp < 0xa8e0) return false;
          if (cp < 0xa8f2) return true;
          if (cp === 0xa8ff) return true;
          if (cp < 0xa900) return false;
          if (cp < 0xa90a) return true;
          if (cp < 0xa926) return false;
          if (cp < 0xa92e) return true;
          if (cp < 0xa947) return false;
          if (cp < 0xa952) return true;
          return false;
        }
        if (cp < 0xa954) return true;
        if (cp < 0xa980) return false;
        if (cp < 0xa983) return true;
        if (cp === 0xa983) return true;
        if (cp === 0xa9b3) return true;
        if (cp < 0xa9b4) return false;
        if (cp < 0xa9b6) return true;
        if (cp < 0xa9b6) return false;
        if (cp < 0xa9ba) return true;
        if (cp < 0xa9ba) return false;
        if (cp < 0xa9bc) return true;
        if (cp === 0xa9bc) return true;
        if (cp < 0xa9bd) return false;
        if (cp < 0xa9c1) return true;
        return false;
      }
      if (cp < 0xaa43) {
        if (cp < 0xa9d0) return false;
        if (cp < 0xa9da) return true;
        if (cp === 0xa9e5) return true;
        if (cp < 0xa9f0) return false;
        if (cp < 0xa9fa) return true;
        if (cp < 0xaa29) return false;
        if (cp < 0xaa2f) return true;
        if (cp < 0xaa2f) return false;
        if (cp < 0xaa31) return true;
        if (cp < 0xaa31) return false;
        if (cp < 0xaa33) return true;
        if (cp < 0xaa33) return false;
        if (cp < 0xaa35) return true;
        if (cp < 0xaa35) return false;
        if (cp < 0xaa37) return true;
        return false;
      }
      if (cp === 0xaa43) return true;
      if (cp === 0xaa4c) return true;
      if (cp === 0xaa4d) return true;
      if (cp < 0xaa50) return false;
      if (cp < 0xaa5a) return true;
      if (cp === 0xaa7b) return true;
      if (cp === 0xaa7c) return true;
      if (cp === 0xaa7d) return true;
      if (cp === 0xaab0) return true;
      if (cp < 0xaab2) return false;
      if (cp < 0xaab5) return true;
      return false;
    }
    if (cp < 0x10d30) {
      if (cp < 0xfe00) {
        if (cp < 0xabe3) {
          if (cp < 0xaab7) return false;
          if (cp < 0xaab9) return true;
          if (cp < 0xaabe) return false;
          if (cp < 0xaac0) return true;
          if (cp === 0xaac1) return true;
          if (cp === 0xaaeb) return true;
          if (cp < 0xaaec) return false;
          if (cp < 0xaaee) return true;
          if (cp < 0xaaee) return false;
          if (cp < 0xaaf0) return true;
          if (cp === 0xaaf5) return true;
          if (cp === 0xaaf6) return true;
          return false;
        }
        if (cp < 0xabe5) return true;
        if (cp === 0xabe5) return true;
        if (cp < 0xabe6) return false;
        if (cp < 0xabe8) return true;
        if (cp === 0xabe8) return true;
        if (cp < 0xabe9) return false;
        if (cp < 0xabeb) return true;
        if (cp === 0xabec) return true;
        if (cp === 0xabed) return true;
        if (cp < 0xabf0) return false;
        if (cp < 0xabfa) return true;
        if (cp === 0xfb1e) return true;
        return false;
      }
      if (cp < 0x10376) {
        if (cp < 0xfe00) return false;
        if (cp < 0xfe10) return true;
        if (cp < 0xfe20) return false;
        if (cp < 0xfe30) return true;
        if (cp < 0xfe33) return false;
        if (cp < 0xfe35) return true;
        if (cp < 0xfe4d) return false;
        if (cp < 0xfe50) return true;
        if (cp < 0xff10) return false;
        if (cp < 0xff1a) return true;
        if (cp === 0xff3f) return true;
        if (cp === 0x101fd) return true;
        if (cp === 0x102e0) return true;
        return false;
      }
      if (cp < 0x1037b) return true;
      if (cp < 0x104a0) return false;
      if (cp < 0x104aa) return true;
      if (cp < 0x10a01) return false;
      if (cp < 0x10a04) return true;
      if (cp < 0x10a05) return false;
      if (cp < 0x10a07) return true;
      if (cp < 0x10a0c) return false;
      if (cp < 0x10a10) return true;
      if (cp < 0x10a38) return false;
      if (cp < 0x10a3b) return true;
      if (cp === 0x10a3f) return true;
      if (cp < 0x10ae5) return false;
      if (cp < 0x10ae7) return true;
      if (cp < 0x10d24) return false;
      if (cp < 0x10d28) return true;
      return false;
    }
    if (cp < 0x1112d) {
      if (cp < 0x11082) {
        if (cp < 0x10d30) return false;
        if (cp < 0x10d3a) return true;
        if (cp < 0x10f46) return false;
        if (cp < 0x10f51) return true;
        if (cp === 0x11000) return true;
        if (cp === 0x11001) return true;
        if (cp === 0x11002) return true;
        if (cp < 0x11038) return false;
        if (cp < 0x11047) return true;
        if (cp < 0x11066) return false;
        if (cp < 0x11070) return true;
        if (cp < 0x1107f) return false;
        if (cp < 0x11082) return true;
        return false;
      }
      if (cp === 0x11082) return true;
      if (cp < 0x110b0) return false;
      if (cp < 0x110b3) return true;
      if (cp < 0x110b3) return false;
      if (cp < 0x110b7) return true;
      if (cp < 0x110b7) return false;
      if (cp < 0x110b9) return true;
      if (cp < 0x110b9) return false;
      if (cp < 0x110bb) return true;
      if (cp < 0x110f0) return false;
      if (cp < 0x110fa) return true;
      if (cp < 0x11100) return false;
      if (cp < 0x11103) return true;
      if (cp < 0x11127) return false;
      if (cp < 0x1112c) return true;
      if (cp === 0x1112c) return true;
      return false;
    }
    if (cp < 0x111bf) {
      if (cp < 0x1112d) return false;
      if (cp < 0x11135) return true;
      if (cp < 0x11136) return false;
      if (cp < 0x11140) return true;
      if (cp < 0x11145) return false;
      if (cp < 0x11147) return true;
      if (cp === 0x11173) return true;
      if (cp < 0x11180) return false;
      if (cp < 0x11182) return true;
      if (cp === 0x11182) return true;
      if (cp < 0x111b3) return false;
      if (cp < 0x111b6) return true;
      if (cp < 0x111b6) return false;
      if (cp < 0x111bf) return true;
      return false;
    }
    if (cp < 0x111c1) return true;
    if (cp < 0x111c9) return false;
    if (cp < 0x111cd) return true;
    if (cp < 0x111d0) return false;
    if (cp < 0x111da) return true;
    if (cp < 0x1122c) return false;
    if (cp < 0x1122f) return true;
    if (cp < 0x1122f) return false;
    if (cp < 0x11232) return true;
    if (cp < 0x11232) return false;
    if (cp < 0x11234) return true;
    if (cp === 0x11234) return true;
    if (cp === 0x11235) return true;
    if (cp < 0x11236) return false;
    if (cp < 0x11238) return true;
    return false;
  }
  if (cp < 0x11a33) {
    if (cp < 0x115af) {
      if (cp < 0x11435) {
        if (cp < 0x1133e) {
          if (cp === 0x1123e) return true;
          if (cp === 0x112df) return true;
          if (cp < 0x112e0) return false;
          if (cp < 0x112e3) return true;
          if (cp < 0x112e3) return false;
          if (cp < 0x112eb) return true;
          if (cp < 0x112f0) return false;
          if (cp < 0x112fa) return true;
          if (cp < 0x11300) return false;
          if (cp < 0x11302) return true;
          if (cp < 0x11302) return false;
          if (cp < 0x11304) return true;
          if (cp < 0x1133b) return false;
          if (cp < 0x1133d) return true;
          return false;
        }
        if (cp < 0x11340) return true;
        if (cp === 0x11340) return true;
        if (cp < 0x11341) return false;
        if (cp < 0x11345) return true;
        if (cp < 0x11347) return false;
        if (cp < 0x11349) return true;
        if (cp < 0x1134b) return false;
        if (cp < 0x1134e) return true;
        if (cp === 0x11357) return true;
        if (cp < 0x11362) return false;
        if (cp < 0x11364) return true;
        if (cp < 0x11366) return false;
        if (cp < 0x1136d) return true;
        if (cp < 0x11370) return false;
        if (cp < 0x11375) return true;
        return false;
      }
      if (cp < 0x114b0) {
        if (cp < 0x11435) return false;
        if (cp < 0x11438) return true;
        if (cp < 0x11438) return false;
        if (cp < 0x11440) return true;
        if (cp < 0x11440) return false;
        if (cp < 0x11442) return true;
        if (cp < 0x11442) return false;
        if (cp < 0x11445) return true;
        if (cp === 0x11445) return true;
        if (cp === 0x11446) return true;
        if (cp < 0x11450) return false;
        if (cp < 0x1145a) return true;
        if (cp === 0x1145e) return true;
        return false;
      }
      if (cp < 0x114b3) return true;
      if (cp < 0x114b3) return false;
      if (cp < 0x114b9) return true;
      if (cp === 0x114b9) return true;
      if (cp === 0x114ba) return true;
      if (cp < 0x114bb) return false;
      if (cp < 0x114bf) return true;
      if (cp < 0x114bf) return false;
      if (cp < 0x114c1) return true;
      if (cp === 0x114c1) return true;
      if (cp < 0x114c2) return false;
      if (cp < 0x114c4) return true;
      if (cp < 0x114d0) return false;
      if (cp < 0x114da) return true;
      return false;
    }
    if (cp < 0x116ae) {
      if (cp < 0x11633) {
        if (cp < 0x115af) return false;
        if (cp < 0x115b2) return true;
        if (cp < 0x115b2) return false;
        if (cp < 0x115b6) return true;
        if (cp < 0x115b8) return false;
        if (cp < 0x115bc) return true;
        if (cp < 0x115bc) return false;
        if (cp < 0x115be) return true;
        if (cp === 0x115be) return true;
        if (cp < 0x115bf) return false;
        if (cp < 0x115c1) return true;
        if (cp < 0x115dc) return false;
        if (cp < 0x115de) return true;
        if (cp < 0x11630) return false;
        if (cp < 0x11633) return true;
        return false;
      }
      if (cp < 0x1163b) return true;
      if (cp < 0x1163b) return false;
      if (cp < 0x1163d) return true;
      if (cp === 0x1163d) return true;
      if (cp === 0x1163e) return true;
      if (cp < 0x1163f) return false;
      if (cp < 0x11641) return true;
      if (cp < 0x11650) return false;
      if (cp < 0x1165a) return true;
      if (cp === 0x116ab) return true;
      if (cp === 0x116ac) return true;
      if (cp === 0x116ad) return true;
      return false;
    }
    if (cp < 0x11726) {
      if (cp < 0x116ae) return false;
      if (cp < 0x116b0) return true;
      if (cp < 0x116b0) return false;
      if (cp < 0x116b6) return true;
      if (cp === 0x116b6) return true;
      if (cp === 0x116b7) return true;
      if (cp < 0x116c0) return false;
      if (cp < 0x116ca) return true;
      if (cp < 0x1171d) return false;
      if (cp < 0x11720) return true;
      if (cp < 0x11720) return false;
      if (cp < 0x11722) return true;
      if (cp < 0x11722) return false;
      if (cp < 0x11726) return true;
      return false;
    }
    if (cp === 0x11726) return true;
    if (cp < 0x11727) return false;
    if (cp < 0x1172c) return true;
    if (cp < 0x11730) return false;
    if (cp < 0x1173a) return true;
    if (cp < 0x1182c) return false;
    if (cp < 0x1182f) return true;
    if (cp < 0x1182f) return false;
    if (cp < 0x11838) return true;
    if (cp === 0x11838) return true;
    if (cp < 0x11839) return false;
    if (cp < 0x1183b) return true;
    if (cp < 0x118e0) return false;
    if (cp < 0x118ea) return true;
    if (cp < 0x11a01) return false;
    if (cp < 0x11a0b) return true;
    return false;
  }
  if (cp < 0x11d97) {
    if (cp < 0x11ca9) {
      if (cp < 0x11a97) {
        if (cp < 0x11a33) return false;
        if (cp < 0x11a39) return true;
        if (cp === 0x11a39) return true;
        if (cp < 0x11a3b) return false;
        if (cp < 0x11a3f) return true;
        if (cp === 0x11a47) return true;
        if (cp < 0x11a51) return false;
        if (cp < 0x11a57) return true;
        if (cp < 0x11a57) return false;
        if (cp < 0x11a59) return true;
        if (cp < 0x11a59) return false;
        if (cp < 0x11a5c) return true;
        if (cp < 0x11a8a) return false;
        if (cp < 0x11a97) return true;
        return false;
      }
      if (cp === 0x11a97) return true;
      if (cp < 0x11a98) return false;
      if (cp < 0x11a9a) return true;
      if (cp === 0x11c2f) return true;
      if (cp < 0x11c30) return false;
      if (cp < 0x11c37) return true;
      if (cp < 0x11c38) return false;
      if (cp < 0x11c3e) return true;
      if (cp === 0x11c3e) return true;
      if (cp === 0x11c3f) return true;
      if (cp < 0x11c50) return false;
      if (cp < 0x11c5a) return true;
      if (cp < 0x11c92) return false;
      if (cp < 0x11ca8) return true;
      return false;
    }
    if (cp < 0x11d3c) {
      if (cp === 0x11ca9) return true;
      if (cp < 0x11caa) return false;
      if (cp < 0x11cb1) return true;
      if (cp === 0x11cb1) return true;
      if (cp < 0x11cb2) return false;
      if (cp < 0x11cb4) return true;
      if (cp === 0x11cb4) return true;
      if (cp < 0x11cb5) return false;
      if (cp < 0x11cb7) return true;
      if (cp < 0x11d31) return false;
      if (cp < 0x11d37) return true;
      if (cp === 0x11d3a) return true;
      return false;
    }
    if (cp < 0x11d3e) return true;
    if (cp < 0x11d3f) return false;
    if (cp < 0x11d46) return true;
    if (cp === 0x11d47) return true;
    if (cp < 0x11d50) return false;
    if (cp < 0x11d5a) return true;
    if (cp < 0x11d8a) return false;
    if (cp < 0x11d8f) return true;
    if (cp < 0x11d90) return false;
    if (cp < 0x11d92) return true;
    if (cp < 0x11d93) return false;
    if (cp < 0x11d95) return true;
    if (cp === 0x11d95) return true;
    if (cp === 0x11d96) return true;
    return false;
  }
  if (cp < 0x1d242) {
    if (cp < 0x16f51) {
      if (cp === 0x11d97) return true;
      if (cp < 0x11da0) return false;
      if (cp < 0x11daa) return true;
      if (cp < 0x11ef3) return false;
      if (cp < 0x11ef5) return true;
      if (cp < 0x11ef5) return false;
      if (cp < 0x11ef7) return true;
      if (cp < 0x16a60) return false;
      if (cp < 0x16a6a) return true;
      if (cp < 0x16af0) return false;
      if (cp < 0x16af5) return true;
      if (cp < 0x16b30) return false;
      if (cp < 0x16b37) return true;
      if (cp < 0x16b50) return false;
      if (cp < 0x16b5a) return true;
      return false;
    }
    if (cp < 0x16f7f) return true;
    if (cp < 0x16f8f) return false;
    if (cp < 0x16f93) return true;
    if (cp < 0x1bc9d) return false;
    if (cp < 0x1bc9f) return true;
    if (cp < 0x1d165) return false;
    if (cp < 0x1d167) return true;
    if (cp < 0x1d167) return false;
    if (cp < 0x1d16a) return true;
    if (cp < 0x1d16d) return false;
    if (cp < 0x1d173) return true;
    if (cp < 0x1d17b) return false;
    if (cp < 0x1d183) return true;
    if (cp < 0x1d185) return false;
    if (cp < 0x1d18c) return true;
    if (cp < 0x1d1aa) return false;
    if (cp < 0x1d1ae) return true;
    return false;
  }
  if (cp < 0x1e000) {
    if (cp < 0x1d242) return false;
    if (cp < 0x1d245) return true;
    if (cp < 0x1d7ce) return false;
    if (cp < 0x1d800) return true;
    if (cp < 0x1da00) return false;
    if (cp < 0x1da37) return true;
    if (cp < 0x1da3b) return false;
    if (cp < 0x1da6d) return true;
    if (cp === 0x1da75) return true;
    if (cp === 0x1da84) return true;
    if (cp < 0x1da9b) return false;
    if (cp < 0x1daa0) return true;
    if (cp < 0x1daa1) return false;
    if (cp < 0x1dab0) return true;
    return false;
  }
  if (cp < 0x1e007) return true;
  if (cp < 0x1e008) return false;
  if (cp < 0x1e019) return true;
  if (cp < 0x1e01b) return false;
  if (cp < 0x1e022) return true;
  if (cp < 0x1e023) return false;
  if (cp < 0x1e025) return true;
  if (cp < 0x1e026) return false;
  if (cp < 0x1e02b) return true;
  if (cp < 0x1e8d0) return false;
  if (cp < 0x1e8d7) return true;
  if (cp < 0x1e944) return false;
  if (cp < 0x1e94b) return true;
  if (cp < 0x1e950) return false;
  if (cp < 0x1e95a) return true;
  if (cp < 0xe0100) return false;
  if (cp < 0xe01f0) return true;
  return false;
}
const PropertyData = {
  $LONE: new Set(["ASCII", "ASCII_Hex_Digit", "AHex", "Alphabetic", "Alpha", "Any", "Assigned", "Bidi_Control", "Bidi_C", "Bidi_Mirrored", "Bidi_M", "Case_Ignorable", "CI", "Cased", "Changes_When_Casefolded", "CWCF", "Changes_When_Casemapped", "CWCM", "Changes_When_Lowercased", "CWL", "Changes_When_NFKC_Casefolded", "CWKCF", "Changes_When_Titlecased", "CWT", "Changes_When_Uppercased", "CWU", "Dash", "Default_Ignorable_Code_Point", "DI", "Deprecated", "Dep", "Diacritic", "Dia", "Emoji", "Emoji_Component", "Emoji_Modifier", "Emoji_Modifier_Base", "Emoji_Presentation", "Extender", "Ext", "Grapheme_Base", "Gr_Base", "Grapheme_Extend", "Gr_Ext", "Hex_Digit", "Hex", "IDS_Binary_Operator", "IDSB", "IDS_Trinary_Operator", "IDST", "ID_Continue", "IDC", "ID_Start", "IDS", "Ideographic", "Ideo", "Join_Control", "Join_C", "Logical_Order_Exception", "LOE", "Lowercase", "Lower", "Math", "Noncharacter_Code_Point", "NChar", "Pattern_Syntax", "Pat_Syn", "Pattern_White_Space", "Pat_WS", "Quotation_Mark", "QMark", "Radical", "Regional_Indicator", "RI", "Sentence_Terminal", "STerm", "Soft_Dotted", "SD", "Terminal_Punctuation", "Term", "Unified_Ideograph", "UIdeo", "Uppercase", "Upper", "Variation_Selector", "VS", "White_Space", "space", "XID_Continue", "XIDC", "XID_Start", "XIDS"]),
  General_Category: new Set(["Cased_Letter", "LC", "Close_Punctuation", "Pe", "Connector_Punctuation", "Pc", "Control", "Cc", "cntrl", "Currency_Symbol", "Sc", "Dash_Punctuation", "Pd", "Decimal_Number", "Nd", "digit", "Enclosing_Mark", "Me", "Final_Punctuation", "Pf", "Format", "Cf", "Initial_Punctuation", "Pi", "Letter", "L", "Letter_Number", "Nl", "Line_Separator", "Zl", "Lowercase_Letter", "Ll", "Mark", "M", "Combining_Mark", "Math_Symbol", "Sm", "Modifier_Letter", "Lm", "Modifier_Symbol", "Sk", "Nonspacing_Mark", "Mn", "Number", "N", "Open_Punctuation", "Ps", "Other", "C", "Other_Letter", "Lo", "Other_Number", "No", "Other_Punctuation", "Po", "Other_Symbol", "So", "Paragraph_Separator", "Zp", "Private_Use", "Co", "Punctuation", "P", "punct", "Separator", "Z", "Space_Separator", "Zs", "Spacing_Mark", "Mc", "Surrogate", "Cs", "Symbol", "S", "Titlecase_Letter", "Lt", "Unassigned", "Cn", "Uppercase_Letter", "Lu"]),
  Script: new Set(["Adlam", "Adlm", "Ahom", "Anatolian_Hieroglyphs", "Hluw", "Arabic", "Arab", "Armenian", "Armn", "Avestan", "Avst", "Balinese", "Bali", "Bamum", "Bamu", "Bassa_Vah", "Bass", "Batak", "Batk", "Bengali", "Beng", "Bhaiksuki", "Bhks", "Bopomofo", "Bopo", "Brahmi", "Brah", "Braille", "Brai", "Buginese", "Bugi", "Buhid", "Buhd", "Canadian_Aboriginal", "Cans", "Carian", "Cari", "Caucasian_Albanian", "Aghb", "Chakma", "Cakm", "Cham", "Cherokee", "Cher", "Common", "Zyyy", "Coptic", "Copt", "Qaac", "Cuneiform", "Xsux", "Cypriot", "Cprt", "Cyrillic", "Cyrl", "Deseret", "Dsrt", "Devanagari", "Deva", "Duployan", "Dupl", "Egyptian_Hieroglyphs", "Egyp", "Elbasan", "Elba", "Ethiopic", "Ethi", "Georgian", "Geor", "Glagolitic", "Glag", "Gothic", "Goth", "Grantha", "Gran", "Greek", "Grek", "Gujarati", "Gujr", "Gurmukhi", "Guru", "Han", "Hani", "Hangul", "Hang", "Hanunoo", "Hano", "Hatran", "Hatr", "Hebrew", "Hebr", "Hiragana", "Hira", "Imperial_Aramaic", "Armi", "Inherited", "Zinh", "Qaai", "Inscriptional_Pahlavi", "Phli", "Inscriptional_Parthian", "Prti", "Javanese", "Java", "Kaithi", "Kthi", "Kannada", "Knda", "Katakana", "Kana", "Kayah_Li", "Kali", "Kharoshthi", "Khar", "Khmer", "Khmr", "Khojki", "Khoj", "Khudawadi", "Sind", "Lao", "Laoo", "Latin", "Latn", "Lepcha", "Lepc", "Limbu", "Limb", "Linear_A", "Lina", "Linear_B", "Linb", "Lisu", "Lycian", "Lyci", "Lydian", "Lydi", "Mahajani", "Mahj", "Malayalam", "Mlym", "Mandaic", "Mand", "Manichaean", "Mani", "Marchen", "Marc", "Masaram_Gondi", "Gonm", "Meetei_Mayek", "Mtei", "Mende_Kikakui", "Mend", "Meroitic_Cursive", "Merc", "Meroitic_Hieroglyphs", "Mero", "Miao", "Plrd", "Modi", "Mongolian", "Mong", "Mro", "Mroo", "Multani", "Mult", "Myanmar", "Mymr", "Nabataean", "Nbat", "New_Tai_Lue", "Talu", "Newa", "Nko", "Nkoo", "Nushu", "Nshu", "Ogham", "Ogam", "Ol_Chiki", "Olck", "Old_Hungarian", "Hung", "Old_Italic", "Ital", "Old_North_Arabian", "Narb", "Old_Permic", "Perm", "Old_Persian", "Xpeo", "Old_South_Arabian", "Sarb", "Old_Turkic", "Orkh", "Oriya", "Orya", "Osage", "Osge", "Osmanya", "Osma", "Pahawh_Hmong", "Hmng", "Palmyrene", "Palm", "Pau_Cin_Hau", "Pauc", "Phags_Pa", "Phag", "Phoenician", "Phnx", "Psalter_Pahlavi", "Phlp", "Rejang", "Rjng", "Runic", "Runr", "Samaritan", "Samr", "Saurashtra", "Saur", "Sharada", "Shrd", "Shavian", "Shaw", "Siddham", "Sidd", "SignWriting", "Sgnw", "Sinhala", "Sinh", "Sora_Sompeng", "Sora", "Soyombo", "Soyo", "Sundanese", "Sund", "Syloti_Nagri", "Sylo", "Syriac", "Syrc", "Tagalog", "Tglg", "Tagbanwa", "Tagb", "Tai_Le", "Tale", "Tai_Tham", "Lana", "Tai_Viet", "Tavt", "Takri", "Takr", "Tamil", "Taml", "Tangut", "Tang", "Telugu", "Telu", "Thaana", "Thaa", "Thai", "Tibetan", "Tibt", "Tifinagh", "Tfng", "Tirhuta", "Tirh", "Ugaritic", "Ugar", "Vai", "Vaii", "Warang_Citi", "Wara", "Yi", "Yiii", "Zanabazar_Square", "Zanb"])
};
PropertyData.gc = PropertyData.General_Category;
PropertyData.sc = PropertyData.Script_Extensions = PropertyData.scx = PropertyData.Script;
const Backspace = 0x08;
const CharacterTabulation = 0x09;
const LineFeed = 0x0a;
const LineTabulation = 0x0b;
const FormFeed = 0x0c;
const CarriageReturn = 0x0d;
const ExclamationMark = 0x21;
const DollarSign = 0x24;
const LeftParenthesis = 0x28;
const RightParenthesis = 0x29;
const Asterisk = 0x2a;
const PlusSign = 0x2b;
const Comma = 0x2c;
const HyphenMinus = 0x2d;
const FullStop = 0x2e;
const Solidus = 0x2f;
const DigitZero = 0x30;
const DigitOne = 0x31;
const DigitSeven = 0x37;
const DigitNine = 0x39;
const Colon = 0x3a;
const LessThanSign = 0x3c;
const EqualsSign = 0x3d;
const GreaterThanSign = 0x3e;
const QuestionMark = 0x3f;
const LatinCapitalLetterA = 0x41;
const LatinCapitalLetterB = 0x42;
const LatinCapitalLetterD = 0x44;
const LatinCapitalLetterF = 0x46;
const LatinCapitalLetterP = 0x50;
const LatinCapitalLetterS = 0x53;
const LatinCapitalLetterW = 0x57;
const LatinCapitalLetterZ = 0x5a;
const LowLine = 0x5f;
const LatinSmallLetterA = 0x61;
const LatinSmallLetterB = 0x62;
const LatinSmallLetterC = 0x63;
const LatinSmallLetterD = 0x64;
const LatinSmallLetterF = 0x66;
const LatinSmallLetterG = 0x67;
const LatinSmallLetterI = 0x69;
const LatinSmallLetterK = 0x6b;
const LatinSmallLetterM = 0x6d;
const LatinSmallLetterN = 0x6e;
const LatinSmallLetterP = 0x70;
const LatinSmallLetterR = 0x72;
const LatinSmallLetterS = 0x73;
const LatinSmallLetterT = 0x74;
const LatinSmallLetterU = 0x75;
const LatinSmallLetterV = 0x76;
const LatinSmallLetterW = 0x77;
const LatinSmallLetterX = 0x78;
const LatinSmallLetterY = 0x79;
const LatinSmallLetterZ = 0x7a;
const LeftSquareBracket = 0x5b;
const ReverseSolidus = 0x5c;
const RightSquareBracket = 0x5d;
const CircumflexAccent = 0x5e;
const LeftCurlyBracket = 0x7b;
const VerticalLine = 0x7c;
const RightCurlyBracket = 0x7d;
const ZeroWidthNonJoiner = 0x200c;
const ZeroWidthJoiner = 0x200d;
const LineSeparator = 0x2028;
const ParagraphSeparator = 0x2029;
const MinCodePoint = 0x00;
const MaxCodePoint = 0x10ffff;
function isLatinLetter(code) {
  return code >= LatinCapitalLetterA && code <= LatinCapitalLetterZ || code >= LatinSmallLetterA && code <= LatinSmallLetterZ;
}
function isDecimalDigit(code) {
  return code >= DigitZero && code <= DigitNine;
}
function isOctalDigit(code) {
  return code >= DigitZero && code <= DigitSeven;
}
function isHexDigit(code) {
  return code >= DigitZero && code <= DigitNine || code >= LatinCapitalLetterA && code <= LatinCapitalLetterF || code >= LatinSmallLetterA && code <= LatinSmallLetterF;
}
function isLineTerminator(code) {
  return code === LineFeed || code === CarriageReturn || code === LineSeparator || code === ParagraphSeparator;
}
function isValidUnicode(code) {
  return code >= MinCodePoint && code <= MaxCodePoint;
}
function digitToInt(code) {
  if (code >= LatinSmallLetterA && code <= LatinSmallLetterF) {
    return code - LatinSmallLetterA + 10;
  }
  if (code >= LatinCapitalLetterA && code <= LatinCapitalLetterF) {
    return code - LatinCapitalLetterA + 10;
  }
  return code - DigitZero;
}
const legacyImpl = {
  at(s, end, i) {
    return i < end ? s.charCodeAt(i) : -1;
  },
  width(c) {
    return 1;
  }
};
const unicodeImpl = {
  at(s, end, i) {
    return i < end ? s.codePointAt(i) : -1;
  },
  width(c) {
    return c > 0xffff ? 2 : 1;
  }
};
class Reader {
  constructor() {
    this._impl = legacyImpl;
    this._s = "";
    this._i = 0;
    this._end = 0;
    this._cp1 = -1;
    this._w1 = 1;
    this._cp2 = -1;
    this._w2 = 1;
    this._cp3 = -1;
    this._w3 = 1;
    this._cp4 = -1;
  }
  get source() {
    return this._s;
  }
  get index() {
    return this._i;
  }
  get currentCodePoint() {
    return this._cp1;
  }
  get nextCodePoint() {
    return this._cp2;
  }
  get nextCodePoint2() {
    return this._cp3;
  }
  get nextCodePoint3() {
    return this._cp4;
  }
  reset(source, start, end, uFlag) {
    this._impl = uFlag ? unicodeImpl : legacyImpl;
    this._s = source;
    this._end = end;
    this.rewind(start);
  }
  rewind(index) {
    const impl = this._impl;
    this._i = index;
    this._cp1 = impl.at(this._s, this._end, index);
    this._w1 = impl.width(this._cp1);
    this._cp2 = impl.at(this._s, this._end, index + this._w1);
    this._w2 = impl.width(this._cp2);
    this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);
    this._w3 = impl.width(this._cp3);
    this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);
  }
  advance() {
    if (this._cp1 !== -1) {
      const impl = this._impl;
      this._i += this._w1;
      this._cp1 = this._cp2;
      this._w1 = this._w2;
      this._cp2 = this._cp3;
      this._w2 = impl.width(this._cp2);
      this._cp3 = this._cp4;
      this._w3 = impl.width(this._cp3);
      this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
    }
  }
  eat(cp) {
    if (this._cp1 === cp) {
      this.advance();
      return true;
    }
    return false;
  }
  eat2(cp1, cp2) {
    if (this._cp1 === cp1 && this._cp2 === cp2) {
      this.advance();
      this.advance();
      return true;
    }
    return false;
  }
  eat3(cp1, cp2, cp3) {
    if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {
      this.advance();
      this.advance();
      this.advance();
      return true;
    }
    return false;
  }
}
class RegExpSyntaxError extends SyntaxError {
  constructor(source, uFlag, index, message) {
    if (source) {
      if (source[0] !== "/") {
        source = `/${source}/${uFlag ? "u" : ""}`;
      }
      source = `: ${source}`;
    }
    super(`Invalid regular expression${source}: ${message}`);
    this.index = index;
  }
}
function isSyntaxCharacter(cp) {
  return cp === CircumflexAccent || cp === DollarSign || cp === ReverseSolidus || cp === FullStop || cp === Asterisk || cp === PlusSign || cp === QuestionMark || cp === LeftParenthesis || cp === RightParenthesis || cp === LeftSquareBracket || cp === RightSquareBracket || cp === LeftCurlyBracket || cp === RightCurlyBracket || cp === VerticalLine;
}
function isRegExpIdentifierStart(cp) {
  return isIdStart(cp) || cp === DollarSign || cp === LowLine;
}
function isRegExpIdentifierPart(cp) {
  return isIdContinue(cp) || cp === DollarSign || cp === LowLine || cp === ZeroWidthNonJoiner || cp === ZeroWidthJoiner;
}
function isUnicodePropertyNameCharacter(cp) {
  return isLatinLetter(cp) || cp === LowLine;
}
function isUnicodePropertyValueCharacter(cp) {
  return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);
}
function isValidUnicodeProperty(name, value) {
  return PropertyData.hasOwnProperty(name) && PropertyData[name].has(value);
}
function isValidUnicodePropertyName(name) {
  return PropertyData.$LONE.has(name);
}
class RegExpValidator {
  constructor(options) {
    this._reader = new Reader();
    this._uFlag = false;
    this._nFlag = false;
    this._lastIntValue = 0;
    this._lastMinValue = 0;
    this._lastMaxValue = 0;
    this._lastStrValue = "";
    this._lastKeyValue = "";
    this._lastValValue = "";
    this._lastAssertionIsQuantifiable = false;
    this._numCapturingParens = 0;
    this._groupNames = new Set();
    this._backreferenceNames = new Set();
    this._options = options || {};
  }
  validateLiteral(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    this._uFlag = this._nFlag = false;
    this.reset(source, start, end);
    this.onLiteralEnter(start);
    if (this.eat(Solidus) && this.eatRegExpBody() && this.eat(Solidus)) {
      const flagStart = this.index;
      const uFlag = source.indexOf("u", flagStart) !== -1;
      this.validateFlags(source, flagStart, end);
      this.validatePattern(source, start + 1, flagStart - 1, uFlag);
    } else if (start >= end) {
      this.raise("Empty");
    } else {
      const c = String.fromCodePoint(this.currentCodePoint);
      this.raise(`Unexpected character '${c}'`);
    }
    this.onLiteralLeave(start, end);
  }
  validateFlags(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    const existingFlags = new Set();
    let global = false;
    let ignoreCase = false;
    let multiline = false;
    let sticky = false;
    let unicode = false;
    let dotAll = false;
    for (let i = start; i < end; ++i) {
      const flag = source.charCodeAt(i);
      if (existingFlags.has(flag)) {
        this.raise(`Duplicated flag '${source[i]}'`);
      }
      existingFlags.add(flag);
      if (flag === LatinSmallLetterG) {
        global = true;
      } else if (flag === LatinSmallLetterI) {
        ignoreCase = true;
      } else if (flag === LatinSmallLetterM) {
        multiline = true;
      } else if (flag === LatinSmallLetterU && this.ecmaVersion >= 2015) {
        unicode = true;
      } else if (flag === LatinSmallLetterY && this.ecmaVersion >= 2015) {
        sticky = true;
      } else if (flag === LatinSmallLetterS && this.ecmaVersion >= 2018) {
        dotAll = true;
      } else {
        this.raise(`Invalid flag '${source[i]}'`);
      }
    }
    this.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll);
  }
  validatePattern(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    let uFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    this._uFlag = uFlag && this.ecmaVersion >= 2015;
    this._nFlag = uFlag && this.ecmaVersion >= 2018;
    this.reset(source, start, end);
    this.pattern();
    if (!this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0) {
      this._nFlag = true;
      this.rewind(start);
      this.pattern();
    }
  }
  get strict() {
    return Boolean(this._options.strict || this._uFlag);
  }
  get ecmaVersion() {
    return this._options.ecmaVersion || 2018;
  }
  onLiteralEnter(start) {
    if (this._options.onLiteralEnter) {
      this._options.onLiteralEnter(start);
    }
  }
  onLiteralLeave(start, end) {
    if (this._options.onLiteralLeave) {
      this._options.onLiteralLeave(start, end);
    }
  }
  onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll) {
    if (this._options.onFlags) {
      this._options.onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll);
    }
  }
  onPatternEnter(start) {
    if (this._options.onPatternEnter) {
      this._options.onPatternEnter(start);
    }
  }
  onPatternLeave(start, end) {
    if (this._options.onPatternLeave) {
      this._options.onPatternLeave(start, end);
    }
  }
  onDisjunctionEnter(start) {
    if (this._options.onDisjunctionEnter) {
      this._options.onDisjunctionEnter(start);
    }
  }
  onDisjunctionLeave(start, end) {
    if (this._options.onDisjunctionLeave) {
      this._options.onDisjunctionLeave(start, end);
    }
  }
  onAlternativeEnter(start, index) {
    if (this._options.onAlternativeEnter) {
      this._options.onAlternativeEnter(start, index);
    }
  }
  onAlternativeLeave(start, end, index) {
    if (this._options.onAlternativeLeave) {
      this._options.onAlternativeLeave(start, end, index);
    }
  }
  onGroupEnter(start) {
    if (this._options.onGroupEnter) {
      this._options.onGroupEnter(start);
    }
  }
  onGroupLeave(start, end) {
    if (this._options.onGroupLeave) {
      this._options.onGroupLeave(start, end);
    }
  }
  onCapturingGroupEnter(start, name) {
    if (this._options.onCapturingGroupEnter) {
      this._options.onCapturingGroupEnter(start, name);
    }
  }
  onCapturingGroupLeave(start, end, name) {
    if (this._options.onCapturingGroupLeave) {
      this._options.onCapturingGroupLeave(start, end, name);
    }
  }
  onQuantifier(start, end, min, max, greedy) {
    if (this._options.onQuantifier) {
      this._options.onQuantifier(start, end, min, max, greedy);
    }
  }
  onLookaroundAssertionEnter(start, kind, negate) {
    if (this._options.onLookaroundAssertionEnter) {
      this._options.onLookaroundAssertionEnter(start, kind, negate);
    }
  }
  onLookaroundAssertionLeave(start, end, kind, negate) {
    if (this._options.onLookaroundAssertionLeave) {
      this._options.onLookaroundAssertionLeave(start, end, kind, negate);
    }
  }
  onEdgeAssertion(start, end, kind) {
    if (this._options.onEdgeAssertion) {
      this._options.onEdgeAssertion(start, end, kind);
    }
  }
  onWordBoundaryAssertion(start, end, kind, negate) {
    if (this._options.onWordBoundaryAssertion) {
      this._options.onWordBoundaryAssertion(start, end, kind, negate);
    }
  }
  onAnyCharacterSet(start, end, kind) {
    if (this._options.onAnyCharacterSet) {
      this._options.onAnyCharacterSet(start, end, kind);
    }
  }
  onEscapeCharacterSet(start, end, kind, negate) {
    if (this._options.onEscapeCharacterSet) {
      this._options.onEscapeCharacterSet(start, end, kind, negate);
    }
  }
  onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
    if (this._options.onUnicodePropertyCharacterSet) {
      this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate);
    }
  }
  onCharacter(start, end, value) {
    if (this._options.onCharacter) {
      this._options.onCharacter(start, end, value);
    }
  }
  onBackreference(start, end, ref) {
    if (this._options.onBackreference) {
      this._options.onBackreference(start, end, ref);
    }
  }
  onCharacterClassEnter(start, negate) {
    if (this._options.onCharacterClassEnter) {
      this._options.onCharacterClassEnter(start, negate);
    }
  }
  onCharacterClassLeave(start, end, negate) {
    if (this._options.onCharacterClassLeave) {
      this._options.onCharacterClassLeave(start, end, negate);
    }
  }
  onCharacterClassRange(start, end, min, max) {
    if (this._options.onCharacterClassRange) {
      this._options.onCharacterClassRange(start, end, min, max);
    }
  }
  get source() {
    return this._reader.source;
  }
  get index() {
    return this._reader.index;
  }
  get currentCodePoint() {
    return this._reader.currentCodePoint;
  }
  get nextCodePoint() {
    return this._reader.nextCodePoint;
  }
  get nextCodePoint2() {
    return this._reader.nextCodePoint2;
  }
  get nextCodePoint3() {
    return this._reader.nextCodePoint3;
  }
  reset(source, start, end) {
    this._reader.reset(source, start, end, this._uFlag);
  }
  rewind(index) {
    this._reader.rewind(index);
  }
  advance() {
    this._reader.advance();
  }
  eat(cp) {
    return this._reader.eat(cp);
  }
  eat2(cp1, cp2) {
    return this._reader.eat2(cp1, cp2);
  }
  eat3(cp1, cp2, cp3) {
    return this._reader.eat3(cp1, cp2, cp3);
  }
  raise(message) {
    throw new RegExpSyntaxError(this.source, this._uFlag, this.index, message);
  }
  eatRegExpBody() {
    const start = this.index;
    let inClass = false;
    let escaped = false;
    for (;;) {
      const cp = this.currentCodePoint;
      if (cp === -1 || isLineTerminator(cp)) {
        const kind = inClass ? "character class" : "regular expression";
        this.raise(`Unterminated ${kind}`);
      }
      if (escaped) {
        escaped = false;
      } else if (cp === ReverseSolidus) {
        escaped = true;
      } else if (cp === LeftSquareBracket) {
        inClass = true;
      } else if (cp === RightSquareBracket) {
        inClass = false;
      } else if (cp === Solidus && !inClass || cp === Asterisk && this.index === start) {
        break;
      }
      this.advance();
    }
    return this.index !== start;
  }
  pattern() {
    const start = this.index;
    this._numCapturingParens = this.countCapturingParens();
    this._groupNames.clear();
    this._backreferenceNames.clear();
    this.onPatternEnter(start);
    this.disjunction();
    const cp = this.currentCodePoint;
    if (this.currentCodePoint !== -1) {
      if (cp === RightParenthesis) {
        this.raise("Unmatched ')'");
      }
      if (cp === ReverseSolidus) {
        this.raise("\\ at end of pattern");
      }
      if (cp === RightSquareBracket || cp === RightCurlyBracket) {
        this.raise("Lone quantifier brackets");
      }
      const c = String.fromCodePoint(cp);
      this.raise(`Unexpected character '${c}'`);
    }
    for (const name of this._backreferenceNames) {
      if (!this._groupNames.has(name)) {
        this.raise("Invalid named capture referenced");
      }
    }
    this.onPatternLeave(start, this.index);
  }
  countCapturingParens() {
    const start = this.index;
    let inClass = false;
    let escaped = false;
    let count = 0;
    let cp = 0;
    while ((cp = this.currentCodePoint) !== -1) {
      if (escaped) {
        escaped = false;
      } else if (cp === ReverseSolidus) {
        escaped = true;
      } else if (cp === LeftSquareBracket) {
        inClass = true;
      } else if (cp === RightSquareBracket) {
        inClass = false;
      } else if (cp === LeftParenthesis && !inClass && (this.nextCodePoint !== QuestionMark || this.nextCodePoint2 === LessThanSign && this.nextCodePoint3 !== EqualsSign && this.nextCodePoint3 !== ExclamationMark)) {
        count += 1;
      }
      this.advance();
    }
    this.rewind(start);
    return count;
  }
  disjunction() {
    const start = this.index;
    let i = 0;
    this.onDisjunctionEnter(start);
    this.alternative(i++);
    while (this.eat(VerticalLine)) {
      this.alternative(i++);
    }
    if (this.eatQuantifier(true)) {
      this.raise("Nothing to repeat");
    }
    if (this.eat(LeftCurlyBracket)) {
      this.raise("Lone quantifier brackets");
    }
    this.onDisjunctionLeave(start, this.index);
  }
  alternative(i) {
    const start = this.index;
    this.onAlternativeEnter(start, i);
    while (this.currentCodePoint !== -1 && this.eatTerm()) {}
    this.onAlternativeLeave(start, this.index, i);
  }
  eatTerm() {
    if (this.eatAssertion()) {
      if (this._lastAssertionIsQuantifiable) {
        this.eatQuantifier();
      }
      return true;
    }
    if (this.strict ? this.eatAtom() : this.eatExtendedAtom()) {
      this.eatQuantifier();
      return true;
    }
    return false;
  }
  eatAssertion() {
    const start = this.index;
    this._lastAssertionIsQuantifiable = false;
    if (this.eat(CircumflexAccent)) {
      this.onEdgeAssertion(start, this.index, "start");
      return true;
    }
    if (this.eat(DollarSign)) {
      this.onEdgeAssertion(start, this.index, "end");
      return true;
    }
    if (this.eat2(ReverseSolidus, LatinCapitalLetterB)) {
      this.onWordBoundaryAssertion(start, this.index, "word", true);
      return true;
    }
    if (this.eat2(ReverseSolidus, LatinSmallLetterB)) {
      this.onWordBoundaryAssertion(start, this.index, "word", false);
      return true;
    }
    if (this.eat2(LeftParenthesis, QuestionMark)) {
      const lookbehind = this.ecmaVersion >= 2018 && this.eat(LessThanSign);
      let negate = false;
      if (this.eat(EqualsSign) || (negate = this.eat(ExclamationMark))) {
        const kind = lookbehind ? "lookbehind" : "lookahead";
        this.onLookaroundAssertionEnter(start, kind, negate);
        this.disjunction();
        if (!this.eat(RightParenthesis)) {
          this.raise("Unterminated group");
        }
        this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;
        this.onLookaroundAssertionLeave(start, this.index, kind, negate);
        return true;
      }
      this.rewind(start);
    }
    return false;
  }
  eatQuantifier() {
    let noError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const start = this.index;
    let min = 0;
    let max = 0;
    let greedy = false;
    if (this.eat(Asterisk)) {
      min = 0;
      max = Number.POSITIVE_INFINITY;
    } else if (this.eat(PlusSign)) {
      min = 1;
      max = Number.POSITIVE_INFINITY;
    } else if (this.eat(QuestionMark)) {
      min = 0;
      max = 1;
    } else if (this.eatBracedQuantifier(noError)) {
      min = this._lastMinValue;
      max = this._lastMaxValue;
    } else {
      return false;
    }
    greedy = !this.eat(QuestionMark);
    if (!noError) {
      this.onQuantifier(start, this.index, min, max, greedy);
    }
    return true;
  }
  eatBracedQuantifier(noError) {
    const start = this.index;
    if (this.eat(LeftCurlyBracket)) {
      this._lastMinValue = 0;
      this._lastMaxValue = Number.POSITIVE_INFINITY;
      if (this.eatDecimalDigits()) {
        this._lastMinValue = this._lastMaxValue = this._lastIntValue;
        if (this.eat(Comma)) {
          this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY;
        }
        if (this.eat(RightCurlyBracket)) {
          if (!noError && this._lastMaxValue < this._lastMinValue) {
            this.raise("numbers out of order in {} quantifier");
          }
          return true;
        }
      }
      if (!noError && this.strict) {
        this.raise("Incomplete quantifier");
      }
      this.rewind(start);
    }
    return false;
  }
  eatAtom() {
    return this.eatPatternCharacter() || this.eatDot() || this.eatReverseSolidusAtomEscape() || this.eatCharacterClass() || this.eatUncapturingGroup() || this.eatCapturingGroup();
  }
  eatDot() {
    if (this.eat(FullStop)) {
      this.onAnyCharacterSet(this.index - 1, this.index, "any");
      return true;
    }
    return false;
  }
  eatReverseSolidusAtomEscape() {
    const start = this.index;
    if (this.eat(ReverseSolidus)) {
      if (this.eatAtomEscape()) {
        return true;
      }
      this.rewind(start);
    }
    return false;
  }
  eatUncapturingGroup() {
    const start = this.index;
    if (this.eat3(LeftParenthesis, QuestionMark, Colon)) {
      this.onGroupEnter(start);
      this.disjunction();
      if (!this.eat(RightParenthesis)) {
        this.raise("Unterminated group");
      }
      this.onGroupLeave(start, this.index);
      return true;
    }
    return false;
  }
  eatCapturingGroup() {
    const start = this.index;
    if (this.eat(LeftParenthesis)) {
      this._lastStrValue = "";
      if (this.ecmaVersion >= 2018) {
        this.groupSpecifier();
      } else if (this.currentCodePoint === QuestionMark) {
        this.raise("Invalid group");
      }
      const name = this._lastStrValue || null;
      this.onCapturingGroupEnter(start, name);
      this.disjunction();
      if (!this.eat(RightParenthesis)) {
        this.raise("Unterminated group");
      }
      this.onCapturingGroupLeave(start, this.index, name);
      return true;
    }
    return false;
  }
  eatExtendedAtom() {
    return this.eatDot() || this.eatReverseSolidusAtomEscape() || this.eatReverseSolidusFollowedByC() || this.eatCharacterClass() || this.eatUncapturingGroup() || this.eatCapturingGroup() || this.eatInvalidBracedQuantifier() || this.eatExtendedPatternCharacter();
  }
  eatReverseSolidusFollowedByC() {
    if (this.currentCodePoint === ReverseSolidus && this.nextCodePoint === LatinSmallLetterC) {
      this._lastIntValue = this.currentCodePoint;
      this.advance();
      this.onCharacter(this.index - 1, this.index, ReverseSolidus);
      return true;
    }
    return false;
  }
  eatInvalidBracedQuantifier() {
    if (this.eatBracedQuantifier(true)) {
      this.raise("Nothing to repeat");
    }
    return false;
  }
  eatSyntaxCharacter() {
    if (isSyntaxCharacter(this.currentCodePoint)) {
      this._lastIntValue = this.currentCodePoint;
      this.advance();
      return true;
    }
    return false;
  }
  eatPatternCharacter() {
    const start = this.index;
    const cp = this.currentCodePoint;
    if (cp !== -1 && !isSyntaxCharacter(cp)) {
      this.advance();
      this.onCharacter(start, this.index, cp);
      return true;
    }
    return false;
  }
  eatExtendedPatternCharacter() {
    const start = this.index;
    const cp = this.currentCodePoint;
    if (cp !== -1 && cp !== CircumflexAccent && cp !== DollarSign && cp !== ReverseSolidus && cp !== FullStop && cp !== Asterisk && cp !== PlusSign && cp !== QuestionMark && cp !== LeftParenthesis && cp !== RightParenthesis && cp !== LeftSquareBracket && cp !== VerticalLine) {
      this.advance();
      this.onCharacter(start, this.index, cp);
      return true;
    }
    return false;
  }
  groupSpecifier() {
    this._lastStrValue = "";
    if (this.eat(QuestionMark)) {
      if (this.eatGroupName()) {
        if (!this._groupNames.has(this._lastStrValue)) {
          this._groupNames.add(this._lastStrValue);
          return;
        }
        this.raise("Duplicate capture group name");
      }
      this.raise("Invalid group");
    }
  }
  eatGroupName() {
    this._lastStrValue = "";
    if (this.eat(LessThanSign)) {
      if (this.eatRegExpIdentifierName() && this.eat(GreaterThanSign)) {
        return true;
      }
      this.raise("Invalid capture group name");
    }
    return false;
  }
  eatRegExpIdentifierName() {
    this._lastStrValue = "";
    if (this.eatRegExpIdentifierStart()) {
      this._lastStrValue += String.fromCodePoint(this._lastIntValue);
      while (this.eatRegExpIdentifierPart()) {
        this._lastStrValue += String.fromCodePoint(this._lastIntValue);
      }
      return true;
    }
    return false;
  }
  eatRegExpIdentifierStart() {
    const start = this.index;
    let cp = this.currentCodePoint;
    this.advance();
    if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence()) {
      cp = this._lastIntValue;
    }
    if (isRegExpIdentifierStart(cp)) {
      this._lastIntValue = cp;
      return true;
    }
    if (this.index !== start) {
      this.rewind(start);
    }
    return false;
  }
  eatRegExpIdentifierPart() {
    const start = this.index;
    let cp = this.currentCodePoint;
    this.advance();
    if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence()) {
      cp = this._lastIntValue;
    }
    if (isRegExpIdentifierPart(cp)) {
      this._lastIntValue = cp;
      return true;
    }
    if (this.index !== start) {
      this.rewind(start);
    }
    return false;
  }
  eatAtomEscape() {
    if (this.eatBackreference() || this.eatCharacterClassEscape() || this.eatCharacterEscape() || this._nFlag && this.eatKGroupName()) {
      return true;
    }
    if (this.strict || this._uFlag) {
      this.raise("Invalid escape");
    }
    return false;
  }
  eatBackreference() {
    const start = this.index;
    if (this.eatDecimalEscape()) {
      const n = this._lastIntValue;
      if (n <= this._numCapturingParens) {
        this.onBackreference(start - 1, this.index, n);
        return true;
      }
      if (this.strict) {
        this.raise("Invalid escape");
      }
      this.rewind(start);
    }
    return false;
  }
  eatKGroupName() {
    const start = this.index;
    if (this.eat(LatinSmallLetterK)) {
      if (this.eatGroupName()) {
        const groupName = this._lastStrValue;
        this._backreferenceNames.add(groupName);
        this.onBackreference(start - 1, this.index, groupName);
        return true;
      }
      this.raise("Invalid named reference");
    }
    return false;
  }
  eatCharacterEscape() {
    const start = this.index;
    if (this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape()) {
      this.onCharacter(start - 1, this.index, this._lastIntValue);
      return true;
    }
    return false;
  }
  eatCControlLetter() {
    const start = this.index;
    if (this.eat(LatinSmallLetterC)) {
      if (this.eatControlLetter()) {
        return true;
      }
      this.rewind(start);
    }
    return false;
  }
  eatZero() {
    if (this.currentCodePoint === DigitZero && !isDecimalDigit(this.nextCodePoint)) {
      this._lastIntValue = 0;
      this.advance();
      return true;
    }
    return false;
  }
  eatControlEscape() {
    if (this.eat(LatinSmallLetterT)) {
      this._lastIntValue = CharacterTabulation;
      return true;
    }
    if (this.eat(LatinSmallLetterN)) {
      this._lastIntValue = LineFeed;
      return true;
    }
    if (this.eat(LatinSmallLetterV)) {
      this._lastIntValue = LineTabulation;
      return true;
    }
    if (this.eat(LatinSmallLetterF)) {
      this._lastIntValue = FormFeed;
      return true;
    }
    if (this.eat(LatinSmallLetterR)) {
      this._lastIntValue = CarriageReturn;
      return true;
    }
    return false;
  }
  eatControlLetter() {
    const cp = this.currentCodePoint;
    if (isLatinLetter(cp)) {
      this.advance();
      this._lastIntValue = cp % 0x20;
      return true;
    }
    return false;
  }
  eatRegExpUnicodeEscapeSequence() {
    const start = this.index;
    if (this.eat(LatinSmallLetterU)) {
      if (this.eatFixedHexDigits(4)) {
        const lead = this._lastIntValue;
        if (this._uFlag && lead >= 0xd800 && lead <= 0xdbff) {
          const leadSurrogateEnd = this.index;
          if (this.eat(ReverseSolidus) && this.eat(LatinSmallLetterU) && this.eatFixedHexDigits(4)) {
            const trail = this._lastIntValue;
            if (trail >= 0xdc00 && trail <= 0xdfff) {
              this._lastIntValue = (lead - 0xd800) * 0x400 + (trail - 0xdc00) + 0x10000;
              return true;
            }
          }
          this.rewind(leadSurrogateEnd);
          this._lastIntValue = lead;
        }
        return true;
      }
      if (this._uFlag && this.eat(LeftCurlyBracket) && this.eatHexDigits() && this.eat(RightCurlyBracket) && isValidUnicode(this._lastIntValue)) {
        return true;
      }
      if (this.strict || this._uFlag) {
        this.raise("Invalid unicode escape");
      }
      this.rewind(start);
    }
    return false;
  }
  eatIdentityEscape() {
    if (this._uFlag) {
      if (this.eatSyntaxCharacter()) {
        return true;
      }
      if (this.eat(Solidus)) {
        this._lastIntValue = Solidus;
        return true;
      }
      return false;
    }
    if (this.isValidIdentityEscape(this.currentCodePoint)) {
      this._lastIntValue = this.currentCodePoint;
      this.advance();
      return true;
    }
    return false;
  }
  isValidIdentityEscape(cp) {
    if (cp === -1) {
      return false;
    }
    if (this.strict) {
      return !isIdContinue(cp);
    }
    return cp !== LatinSmallLetterC && (!this._nFlag || cp !== LatinSmallLetterK);
  }
  eatDecimalEscape() {
    this._lastIntValue = 0;
    let cp = this.currentCodePoint;
    if (cp >= DigitOne && cp <= DigitNine) {
      do {
        this._lastIntValue = 10 * this._lastIntValue + (cp - DigitZero);
        this.advance();
      } while ((cp = this.currentCodePoint) >= DigitZero && cp <= DigitNine);
      return true;
    }
    return false;
  }
  eatCharacterClassEscape() {
    const start = this.index;
    if (this.eat(LatinSmallLetterD)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "digit", false);
      return true;
    }
    if (this.eat(LatinCapitalLetterD)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "digit", true);
      return true;
    }
    if (this.eat(LatinSmallLetterS)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "space", false);
      return true;
    }
    if (this.eat(LatinCapitalLetterS)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "space", true);
      return true;
    }
    if (this.eat(LatinSmallLetterW)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "word", false);
      return true;
    }
    if (this.eat(LatinCapitalLetterW)) {
      this._lastIntValue = -1;
      this.onEscapeCharacterSet(start - 1, this.index, "word", true);
      return true;
    }
    let negate = false;
    if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(LatinSmallLetterP) || (negate = this.eat(LatinCapitalLetterP)))) {
      this._lastIntValue = -1;
      if (this.eat(LeftCurlyBracket) && this.eatUnicodePropertyValueExpression() && this.eat(RightCurlyBracket)) {
        this.onUnicodePropertyCharacterSet(start - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, negate);
        return true;
      }
      this.raise("Invalid property name");
    }
    return false;
  }
  eatUnicodePropertyValueExpression() {
    const start = this.index;
    if (this.eatUnicodePropertyName() && this.eat(EqualsSign)) {
      this._lastKeyValue = this._lastStrValue;
      if (this.eatUnicodePropertyValue()) {
        this._lastValValue = this._lastStrValue;
        if (isValidUnicodeProperty(this._lastKeyValue, this._lastValValue)) {
          return true;
        }
        this.raise("Invalid property name");
      }
    }
    this.rewind(start);
    if (this.eatLoneUnicodePropertyNameOrValue()) {
      const nameOrValue = this._lastStrValue;
      if (isValidUnicodeProperty("General_Category", nameOrValue)) {
        this._lastKeyValue = "General_Category";
        this._lastValValue = nameOrValue;
        return true;
      }
      if (isValidUnicodePropertyName(nameOrValue)) {
        this._lastKeyValue = nameOrValue;
        this._lastValValue = "";
        return true;
      }
      this.raise("Invalid property name");
    }
    return false;
  }
  eatUnicodePropertyName() {
    this._lastStrValue = "";
    while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
      this.advance();
    }
    return this._lastStrValue !== "";
  }
  eatUnicodePropertyValue() {
    this._lastStrValue = "";
    while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
      this.advance();
    }
    return this._lastStrValue !== "";
  }
  eatLoneUnicodePropertyNameOrValue() {
    return this.eatUnicodePropertyValue();
  }
  eatCharacterClass() {
    const start = this.index;
    if (this.eat(LeftSquareBracket)) {
      const negate = this.eat(CircumflexAccent);
      this.onCharacterClassEnter(start, negate);
      this.classRanges();
      if (!this.eat(RightSquareBracket)) {
        this.raise("Unterminated character class");
      }
      this.onCharacterClassLeave(start, this.index, negate);
      return true;
    }
    return false;
  }
  classRanges() {
    let start = this.index;
    while (this.eatClassAtom()) {
      const left = this._lastIntValue;
      const hyphenStart = this.index;
      if (this.eat(HyphenMinus)) {
        this.onCharacter(hyphenStart, this.index, HyphenMinus);
        if (this.eatClassAtom()) {
          const right = this._lastIntValue;
          if (left === -1 || right === -1) {
            if (this.strict) {
              this.raise("Invalid character class");
            }
          } else if (left > right) {
            this.raise("Range out of order in character class");
          } else {
            this.onCharacterClassRange(start, this.index, left, right);
          }
        }
      }
      start = this.index;
    }
  }
  eatClassAtom() {
    const start = this.index;
    if (this.eat(ReverseSolidus)) {
      if (this.eatClassEscape()) {
        return true;
      }
      if (this._uFlag) {
        this.raise("Invalid escape");
      }
      this.rewind(start);
    }
    const cp = this.currentCodePoint;
    if (cp !== -1 && cp !== RightSquareBracket) {
      this.advance();
      this._lastIntValue = cp;
      this.onCharacter(start, this.index, cp);
      return true;
    }
    return false;
  }
  eatClassEscape() {
    const start = this.index;
    if (this.eat(LatinSmallLetterB)) {
      this._lastIntValue = Backspace;
      this.onCharacter(start - 1, this.index, Backspace);
      return true;
    }
    if (this._uFlag && this.eat(HyphenMinus)) {
      this._lastIntValue = HyphenMinus;
      this.onCharacter(start - 1, this.index, HyphenMinus);
      return true;
    }
    if (!this._uFlag && this.eat(LatinSmallLetterC)) {
      if (this.eatClassControlLetter()) {
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      this.rewind(start);
    }
    return this.eatCharacterClassEscape() || this.eatCharacterEscape();
  }
  eatClassControlLetter() {
    const cp = this.currentCodePoint;
    if (isDecimalDigit(cp) || cp === LowLine) {
      this.advance();
      this._lastIntValue = cp % 0x20;
      return true;
    }
    return false;
  }
  eatHexEscapeSequence() {
    const start = this.index;
    if (this.eat(LatinSmallLetterX)) {
      if (this.eatFixedHexDigits(2)) {
        return true;
      }
      if (this._uFlag) {
        this.raise("Invalid escape");
      }
      this.rewind(start);
    }
    return false;
  }
  eatDecimalDigits() {
    const start = this.index;
    this._lastIntValue = 0;
    while (isDecimalDigit(this.currentCodePoint)) {
      this._lastIntValue = 10 * this._lastIntValue + digitToInt(this.currentCodePoint);
      this.advance();
    }
    return this.index !== start;
  }
  eatHexDigits() {
    const start = this.index;
    this._lastIntValue = 0;
    while (isHexDigit(this.currentCodePoint)) {
      this._lastIntValue = 16 * this._lastIntValue + digitToInt(this.currentCodePoint);
      this.advance();
    }
    return this.index !== start;
  }
  eatLegacyOctalEscapeSequence() {
    if (this.eatOctalDigit()) {
      const n1 = this._lastIntValue;
      if (this.eatOctalDigit()) {
        const n2 = this._lastIntValue;
        if (n1 <= 3 && this.eatOctalDigit()) {
          this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;
        } else {
          this._lastIntValue = n1 * 8 + n2;
        }
      } else {
        this._lastIntValue = n1;
      }
      return true;
    }
    return false;
  }
  eatOctalDigit() {
    const cp = this.currentCodePoint;
    if (isOctalDigit(cp)) {
      this.advance();
      this._lastIntValue = cp - DigitZero;
      return true;
    }
    this._lastIntValue = 0;
    return false;
  }
  eatFixedHexDigits(length) {
    const start = this.index;
    this._lastIntValue = 0;
    for (let i = 0; i < length; ++i) {
      const cp = this.currentCodePoint;
      if (!isHexDigit(cp)) {
        this.rewind(start);
        return false;
      }
      this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);
      this.advance();
    }
    return true;
  }
}
const DummyPattern = {};
const DummyFlags = {};
const DummyCapturingGroup = {};
class RegExpParserState {
  constructor(options) {
    this._node = DummyPattern;
    this._flags = DummyFlags;
    this._backreferences = [];
    this._capturingGroups = [];
    this.source = "";
    this.strict = Boolean(options && options.strict);
    this.ecmaVersion = options && options.ecmaVersion || 2018;
  }
  get pattern() {
    if (this._node.type !== "Pattern") {
      throw new Error("UnknownError");
    }
    return this._node;
  }
  get flags() {
    if (this._flags.type !== "Flags") {
      throw new Error("UnknownError");
    }
    return this._flags;
  }
  onFlags(start, end, global, ignoreCase, multiline, unicode, sticky, dotAll) {
    this._flags = {
      type: "Flags",
      parent: null,
      start,
      end,
      raw: this.source.slice(start, end),
      global,
      ignoreCase,
      multiline,
      unicode,
      sticky,
      dotAll
    };
  }
  onPatternEnter(start) {
    this._node = {
      type: "Pattern",
      parent: null,
      start,
      end: start,
      raw: "",
      alternatives: []
    };
    this._backreferences.length = 0;
    this._capturingGroups.length = 0;
  }
  onPatternLeave(start, end) {
    this._node.end = end;
    this._node.raw = this.source.slice(start, end);
    for (const reference of this._backreferences) {
      const ref = reference.ref;
      const group = typeof ref === "number" ? this._capturingGroups[ref - 1] : this._capturingGroups.find(g => g.name === ref);
      reference.resolved = group;
      group.references.push(reference);
    }
  }
  onAlternativeEnter(start) {
    const parent = this._node;
    if (parent.type !== "Assertion" && parent.type !== "CapturingGroup" && parent.type !== "Group" && parent.type !== "Pattern") {
      throw new Error("UnknownError");
    }
    this._node = {
      type: "Alternative",
      parent,
      start,
      end: start,
      raw: "",
      elements: []
    };
    parent.alternatives.push(this._node);
  }
  onAlternativeLeave(start, end) {
    const node = this._node;
    if (node.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }
  onGroupEnter(start) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    this._node = {
      type: "Group",
      parent,
      start,
      end: start,
      raw: "",
      alternatives: []
    };
    parent.elements.push(this._node);
  }
  onGroupLeave(start, end) {
    const node = this._node;
    if (node.type !== "Group" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }
  onCapturingGroupEnter(start, name) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    this._node = {
      type: "CapturingGroup",
      parent,
      start,
      end: start,
      raw: "",
      name,
      alternatives: [],
      references: []
    };
    parent.elements.push(this._node);
    this._capturingGroups.push(this._node);
  }
  onCapturingGroupLeave(start, end) {
    const node = this._node;
    if (node.type !== "CapturingGroup" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }
  onQuantifier(start, end, min, max, greedy) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    const element = parent.elements.pop();
    if (element == null || element.type === "Quantifier" || element.type === "Assertion" && element.kind !== "lookahead") {
      throw new Error("UnknownError");
    }
    const node = {
      type: "Quantifier",
      parent,
      start: element.start,
      end,
      raw: this.source.slice(element.start, end),
      min,
      max,
      greedy,
      element
    };
    parent.elements.push(node);
    element.parent = node;
  }
  onLookaroundAssertionEnter(start, kind, negate) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    this._node = {
      type: "Assertion",
      parent,
      start,
      end: start,
      raw: "",
      kind,
      negate,
      alternatives: []
    };
    parent.elements.push(this._node);
  }
  onLookaroundAssertionLeave(start, end) {
    const node = this._node;
    if (node.type !== "Assertion" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }
  onEdgeAssertion(start, end, kind) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "Assertion",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind
    });
  }
  onWordBoundaryAssertion(start, end, kind, negate) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "Assertion",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      negate
    });
  }
  onAnyCharacterSet(start, end, kind) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind
    });
  }
  onEscapeCharacterSet(start, end, kind, negate) {
    const parent = this._node;
    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      negate
    });
  }
  onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
    const parent = this._node;
    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "CharacterSet",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      kind,
      key,
      value,
      negate
    });
  }
  onCharacter(start, end, value) {
    const parent = this._node;
    if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }
    parent.elements.push({
      type: "Character",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      value
    });
  }
  onBackreference(start, end, ref) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    const node = {
      type: "Backreference",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      ref,
      resolved: DummyCapturingGroup
    };
    parent.elements.push(node);
    this._backreferences.push(node);
  }
  onCharacterClassEnter(start, negate) {
    const parent = this._node;
    if (parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    this._node = {
      type: "CharacterClass",
      parent,
      start,
      end: start,
      raw: "",
      negate,
      elements: []
    };
    parent.elements.push(this._node);
  }
  onCharacterClassLeave(start, end) {
    const node = this._node;
    if (node.type !== "CharacterClass" || node.parent.type !== "Alternative") {
      throw new Error("UnknownError");
    }
    node.end = end;
    node.raw = this.source.slice(start, end);
    this._node = node.parent;
  }
  onCharacterClassRange(start, end) {
    const parent = this._node;
    if (parent.type !== "CharacterClass") {
      throw new Error("UnknownError");
    }
    const elements = parent.elements;
    const max = elements.pop();
    const hyphen = elements.pop();
    const min = elements.pop();
    if (!min || !max || !hyphen || min.type !== "Character" || max.type !== "Character" || hyphen.type !== "Character" || hyphen.value !== HyphenMinus) {
      throw new Error("UnknownError");
    }
    const node = {
      type: "CharacterClassRange",
      parent,
      start,
      end,
      raw: this.source.slice(start, end),
      min,
      max
    };
    min.parent = node;
    max.parent = node;
    elements.push(node);
  }
}
class RegExpParser {
  constructor(options) {
    this._state = new RegExpParserState(options);
    this._validator = new RegExpValidator(this._state);
  }
  parseLiteral(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    this._state.source = source;
    this._validator.validateLiteral(source, start, end);
    const pattern = this._state.pattern;
    const flags = this._state.flags;
    const literal = {
      type: "RegExpLiteral",
      parent: null,
      start,
      end,
      raw: source,
      pattern,
      flags
    };
    pattern.parent = literal;
    flags.parent = literal;
    return literal;
  }
  parseFlags(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    this._state.source = source;
    this._validator.validateFlags(source, start, end);
    return this._state.flags;
  }
  parsePattern(source) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
    let uFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    this._state.source = source;
    this._validator.validatePattern(source, start, end, uFlag);
    return this._state.pattern;
  }
}
class RegExpVisitor {
  constructor(handlers) {
    this._handlers = handlers;
  }
  visit(node) {
    switch (node.type) {
      case "Alternative":
        this.visitAlternative(node);
        break;
      case "Assertion":
        this.visitAssertion(node);
        break;
      case "Backreference":
        this.visitBackreference(node);
        break;
      case "CapturingGroup":
        this.visitCapturingGroup(node);
        break;
      case "Character":
        this.visitCharacter(node);
        break;
      case "CharacterClass":
        this.visitCharacterClass(node);
        break;
      case "CharacterClassRange":
        this.visitCharacterClassRange(node);
        break;
      case "CharacterSet":
        this.visitCharacterSet(node);
        break;
      case "Flags":
        this.visitFlags(node);
        break;
      case "Group":
        this.visitGroup(node);
        break;
      case "Pattern":
        this.visitPattern(node);
        break;
      case "Quantifier":
        this.visitQuantifier(node);
        break;
      case "RegExpLiteral":
        this.visitRegExpLiteral(node);
        break;
      default:
        throw new Error(`Unknown type: ${node.type}`);
    }
  }
  visitAlternative(node) {
    if (this._handlers.onAlternativeEnter) {
      this._handlers.onAlternativeEnter(node);
    }
    node.elements.forEach(this.visit, this);
    if (this._handlers.onAlternativeLeave) {
      this._handlers.onAlternativeLeave(node);
    }
  }
  visitAssertion(node) {
    if (this._handlers.onAssertionEnter) {
      this._handlers.onAssertionEnter(node);
    }
    if (node.kind === "lookahead" || node.kind === "lookbehind") {
      node.alternatives.forEach(this.visit, this);
    }
    if (this._handlers.onAssertionLeave) {
      this._handlers.onAssertionLeave(node);
    }
  }
  visitBackreference(node) {
    if (this._handlers.onBackreferenceEnter) {
      this._handlers.onBackreferenceEnter(node);
    }
    if (this._handlers.onBackreferenceLeave) {
      this._handlers.onBackreferenceLeave(node);
    }
  }
  visitCapturingGroup(node) {
    if (this._handlers.onCapturingGroupEnter) {
      this._handlers.onCapturingGroupEnter(node);
    }
    node.alternatives.forEach(this.visit, this);
    if (this._handlers.onCapturingGroupLeave) {
      this._handlers.onCapturingGroupLeave(node);
    }
  }
  visitCharacter(node) {
    if (this._handlers.onCharacterEnter) {
      this._handlers.onCharacterEnter(node);
    }
    if (this._handlers.onCharacterLeave) {
      this._handlers.onCharacterLeave(node);
    }
  }
  visitCharacterClass(node) {
    if (this._handlers.onCharacterClassEnter) {
      this._handlers.onCharacterClassEnter(node);
    }
    node.elements.forEach(this.visit, this);
    if (this._handlers.onCharacterClassLeave) {
      this._handlers.onCharacterClassLeave(node);
    }
  }
  visitCharacterClassRange(node) {
    if (this._handlers.onCharacterClassRangeEnter) {
      this._handlers.onCharacterClassRangeEnter(node);
    }
    this.visitCharacter(node.min);
    this.visitCharacter(node.max);
    if (this._handlers.onCharacterClassRangeLeave) {
      this._handlers.onCharacterClassRangeLeave(node);
    }
  }
  visitCharacterSet(node) {
    if (this._handlers.onCharacterSetEnter) {
      this._handlers.onCharacterSetEnter(node);
    }
    if (this._handlers.onCharacterSetLeave) {
      this._handlers.onCharacterSetLeave(node);
    }
  }
  visitFlags(node) {
    if (this._handlers.onFlagsEnter) {
      this._handlers.onFlagsEnter(node);
    }
    if (this._handlers.onFlagsLeave) {
      this._handlers.onFlagsLeave(node);
    }
  }
  visitGroup(node) {
    if (this._handlers.onGroupEnter) {
      this._handlers.onGroupEnter(node);
    }
    node.alternatives.forEach(this.visit, this);
    if (this._handlers.onGroupLeave) {
      this._handlers.onGroupLeave(node);
    }
  }
  visitPattern(node) {
    if (this._handlers.onPatternEnter) {
      this._handlers.onPatternEnter(node);
    }
    node.alternatives.forEach(this.visit, this);
    if (this._handlers.onPatternLeave) {
      this._handlers.onPatternLeave(node);
    }
  }
  visitQuantifier(node) {
    if (this._handlers.onQuantifierEnter) {
      this._handlers.onQuantifierEnter(node);
    }
    this.visit(node.element);
    if (this._handlers.onQuantifierLeave) {
      this._handlers.onQuantifierLeave(node);
    }
  }
  visitRegExpLiteral(node) {
    if (this._handlers.onRegExpLiteralEnter) {
      this._handlers.onRegExpLiteralEnter(node);
    }
    this.visitPattern(node.pattern);
    this.visitFlags(node.flags);
    if (this._handlers.onRegExpLiteralLeave) {
      this._handlers.onRegExpLiteralLeave(node);
    }
  }
}
function parseRegExpLiteral(source, options) {
  return new RegExpParser(options).parseLiteral(String(source));
}
function validateRegExpLiteral(source, options) {
  return new RegExpValidator(options).validateLiteral(source);
}
function visitRegExpAST(node, handlers) {
  new RegExpVisitor(handlers).visit(node);
}
exports.AST = ast;
exports.RegExpParser = RegExpParser;
exports.RegExpValidator = RegExpValidator;
exports.parseRegExpLiteral = parseRegExpLiteral;
exports.validateRegExpLiteral = validateRegExpLiteral;
exports.visitRegExpAST = visitRegExpAST;

/***/ }),
/* 296 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of a debugger statement
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of `debugger`",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-debugger"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Unexpected 'debugger' statement."
    }
  },
  create(context) {
    return {
      DebuggerStatement(node) {
        context.report({
          node,
          messageId: "unexpected"
        });
      }
    };
  }
};

/***/ }),
/* 297 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when deleting variables
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow deleting variables",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-delete-var"
    },
    schema: [],
    messages: {
      unexpected: "Variables should not be deleted."
    }
  },
  create(context) {
    return {
      UnaryExpression(node) {
        if (node.operator === "delete" && node.argument.type === "Identifier") {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }
    };
  }
};

/***/ }),
/* 298 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for ambiguous div operator in regexes
 * @author Matt DuVall <http://www.mattduvall.com>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow division operators explicitly at the beginning of regular expressions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-div-regex"
    },
    schema: [],
    messages: {
      unexpected: "A regular expression literal can be confused with '/='."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node);
        if (token.type === "RegularExpression" && token.value[1] === "=") {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }
    };
  }
};

/***/ }),
/* 299 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag duplicate arguments
 * @author Jamund Ferguson
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate arguments in `function` definitions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-args"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate param '{{name}}'."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Checks whether or not a given definition is a parameter's.
     * @param {eslint-scope.DefEntry} def - A definition to check.
     * @returns {boolean} `true` if the definition is a parameter's.
     */
    function isParameter(def) {
      return def.type === "Parameter";
    }

    /**
     * Determines if a given node has duplicate parameters.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */
    function checkParams(node) {
      const variables = context.getDeclaredVariables(node);
      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];

        // Checks and reports duplications.
        const defs = variable.defs.filter(isParameter);
        if (defs.length >= 2) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              name: variable.name
            }
          });
        }
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      FunctionDeclaration: checkParams,
      FunctionExpression: checkParams
    };
  }
};

/***/ }),
/* 300 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to disallow duplicate name in class members.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate class members",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-class-members"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate name '{{name}}'."
    }
  },
  create(context) {
    let stack = [];

    /**
     * Gets state of a given member name.
     * @param {string} name - A name of a member.
     * @param {boolean} isStatic - A flag which specifies that is a static member.
     * @returns {Object} A state of a given member name.
     *   - retv.init {boolean} A flag which shows the name is declared as normal member.
     *   - retv.get {boolean} A flag which shows the name is declared as getter.
     *   - retv.set {boolean} A flag which shows the name is declared as setter.
     */
    function getState(name, isStatic) {
      const stateMap = stack[stack.length - 1];
      const key = `$${name}`; // to avoid "__proto__".

      if (!stateMap[key]) {
        stateMap[key] = {
          nonStatic: {
            init: false,
            get: false,
            set: false
          },
          static: {
            init: false,
            get: false,
            set: false
          }
        };
      }
      return stateMap[key][isStatic ? "static" : "nonStatic"];
    }

    /**
     * Gets the name text of a given node.
     *
     * @param {ASTNode} node - A node to get the name.
     * @returns {string} The name text of the node.
     */
    function getName(node) {
      switch (node.type) {
        case "Identifier":
          return node.name;
        case "Literal":
          return String(node.value);

        /* istanbul ignore next: syntax error */
        default:
          return "";
      }
    }
    return {
      // Initializes the stack of state of member declarations.
      Program() {
        stack = [];
      },
      // Initializes state of member declarations for the class.
      ClassBody() {
        stack.push(Object.create(null));
      },
      // Disposes the state for the class.
      "ClassBody:exit"() {
        stack.pop();
      },
      // Reports the node if its name has been declared already.
      MethodDefinition(node) {
        if (node.computed) {
          return;
        }
        const name = getName(node.key);
        const state = getState(name, node.static);
        let isDuplicate = false;
        if (node.kind === "get") {
          isDuplicate = state.init || state.get;
          state.get = true;
        } else if (node.kind === "set") {
          isDuplicate = state.init || state.set;
          state.set = true;
        } else {
          isDuplicate = state.init || state.get || state.set;
          state.init = true;
        }
        if (isDuplicate) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              name
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 301 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of duplicate keys in an object.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const GET_KIND = /^(?:init|get)$/u;
const SET_KIND = /^(?:init|set)$/u;

/**
 * The class which stores properties' information of an object.
 */
class ObjectInfo {
  /**
   * @param {ObjectInfo|null} upper - The information of the outer object.
   * @param {ASTNode} node - The ObjectExpression node of this information.
   */
  constructor(upper, node) {
    this.upper = upper;
    this.node = node;
    this.properties = new Map();
  }

  /**
   * Gets the information of the given Property node.
   * @param {ASTNode} node - The Property node to get.
   * @returns {{get: boolean, set: boolean}} The information of the property.
   */
  getPropertyInfo(node) {
    const name = astUtils.getStaticPropertyName(node);
    if (!this.properties.has(name)) {
      this.properties.set(name, {
        get: false,
        set: false
      });
    }
    return this.properties.get(name);
  }

  /**
   * Checks whether the given property has been defined already or not.
   * @param {ASTNode} node - The Property node to check.
   * @returns {boolean} `true` if the property has been defined.
   */
  isPropertyDefined(node) {
    const entry = this.getPropertyInfo(node);
    return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
  }

  /**
   * Defines the given property.
   * @param {ASTNode} node - The Property node to define.
   * @returns {void}
   */
  defineProperty(node) {
    const entry = this.getPropertyInfo(node);
    if (GET_KIND.test(node.kind)) {
      entry.get = true;
    }
    if (SET_KIND.test(node.kind)) {
      entry.set = true;
    }
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys in object literals",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-dupe-keys"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate key '{{name}}'."
    }
  },
  create(context) {
    let info = null;
    return {
      ObjectExpression(node) {
        info = new ObjectInfo(info, node);
      },
      "ObjectExpression:exit"() {
        info = info.upper;
      },
      Property(node) {
        const name = astUtils.getStaticPropertyName(node);

        // Skip destructuring.
        if (node.parent.type !== "ObjectExpression") {
          return;
        }

        // Skip if the name is not static.
        if (!name) {
          return;
        }

        // Reports if the name is defined already.
        if (info.isPropertyDefined(node)) {
          context.report({
            node: info.node,
            loc: node.key.loc,
            messageId: "unexpected",
            data: {
              name
            }
          });
        }

        // Update info.
        info.defineProperty(node);
      }
    };
  }
};

/***/ }),
/* 302 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow a duplicate case label.
 * @author Dieter Oberkofler
 * @author Burak Yigit Kaya
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate case labels",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-duplicate-case"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate case label."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      SwitchStatement(node) {
        const mapping = {};
        node.cases.forEach(switchCase => {
          const key = sourceCode.getText(switchCase.test);
          if (mapping[key]) {
            context.report({
              node: switchCase,
              messageId: "unexpected"
            });
          } else {
            mapping[key] = switchCase;
          }
        });
      }
    };
  }
};

/***/ }),
/* 303 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Restrict usage of duplicate imports.
 * @author Simen Bekkhus
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Returns the name of the module imported or re-exported.
 *
 * @param {ASTNode} node - A node to get.
 * @returns {string} the name of the module, or empty string if no name.
 */
function getValue(node) {
  if (node && node.source && node.source.value) {
    return node.source.value.trim();
  }
  return "";
}

/**
 * Checks if the name of the import or export exists in the given array, and reports if so.
 *
 * @param {RuleContext} context - The ESLint rule context object.
 * @param {ASTNode} node - A node to get.
 * @param {string} value - The name of the imported or exported module.
 * @param {string[]} array - The array containing other imports or exports in the file.
 * @param {string} messageId - A messageId to be reported after the name of the module
 *
 * @returns {void} No return value
 */
function checkAndReport(context, node, value, array, messageId) {
  if (array.indexOf(value) !== -1) {
    context.report({
      node,
      messageId,
      data: {
        module: value
      }
    });
  }
}

/**
 * @callback nodeCallback
 * @param {ASTNode} node - A node to handle.
 */

/**
 * Returns a function handling the imports of a given file
 *
 * @param {RuleContext} context - The ESLint rule context object.
 * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.
 * @param {string[]} importsInFile - The array containing other imports in the file.
 * @param {string[]} exportsInFile - The array containing other exports in the file.
 *
 * @returns {nodeCallback} A function passed to ESLint to handle the statement.
 */
function handleImports(context, includeExports, importsInFile, exportsInFile) {
  return function (node) {
    const value = getValue(node);
    if (value) {
      checkAndReport(context, node, value, importsInFile, "import");
      if (includeExports) {
        checkAndReport(context, node, value, exportsInFile, "importAs");
      }
      importsInFile.push(value);
    }
  };
}

/**
 * Returns a function handling the exports of a given file
 *
 * @param {RuleContext} context - The ESLint rule context object.
 * @param {string[]} importsInFile - The array containing other imports in the file.
 * @param {string[]} exportsInFile - The array containing other exports in the file.
 *
 * @returns {nodeCallback} A function passed to ESLint to handle the statement.
 */
function handleExports(context, importsInFile, exportsInFile) {
  return function (node) {
    const value = getValue(node);
    if (value) {
      checkAndReport(context, node, value, exportsInFile, "export");
      checkAndReport(context, node, value, importsInFile, "exportAs");
      exportsInFile.push(value);
    }
  };
}
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate module imports",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-duplicate-imports"
    },
    schema: [{
      type: "object",
      properties: {
        includeExports: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      import: "'{{module}}' import is duplicated.",
      importAs: "'{{module}}' import is duplicated as export.",
      export: "'{{module}}' export is duplicated.",
      exportAs: "'{{module}}' export is duplicated as import."
    }
  },
  create(context) {
    const includeExports = (context.options[0] || {}).includeExports,
      importsInFile = [],
      exportsInFile = [];
    const handlers = {
      ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
    };
    if (includeExports) {
      handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
      handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
    }
    return handlers;
  }
};

/***/ }),
/* 304 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag `else` after a `return` in `if`
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);
const FixTracker = __webpack_require__(305);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `else` blocks after `return` statements in `if` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-else-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowElseIf: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unexpected: "Unnecessary 'else' after 'return'."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Display the context report if rule is violated
     *
     * @param {Node} node The 'else' node
     * @returns {void}
     */
    function displayReport(node) {
      context.report({
        node,
        messageId: "unexpected",
        fix: fixer => {
          const sourceCode = context.getSourceCode();
          const startToken = sourceCode.getFirstToken(node);
          const elseToken = sourceCode.getTokenBefore(startToken);
          const source = sourceCode.getText(node);
          const lastIfToken = sourceCode.getTokenBefore(elseToken);
          let fixedSource, firstTokenOfElseBlock;
          if (startToken.type === "Punctuator" && startToken.value === "{") {
            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
          } else {
            firstTokenOfElseBlock = startToken;
          }

          /*
           * If the if block does not have curly braces and does not end in a semicolon
           * and the else block starts with (, [, /, +, ` or -, then it is not
           * safe to remove the else keyword, because ASI will not add a semicolon
           * after the if block
           */
          const ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);
          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
            return null;
          }
          const endToken = sourceCode.getLastToken(node);
          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);
          if (lastTokenOfElseBlock.value !== ";") {
            const nextToken = sourceCode.getTokenAfter(endToken);
            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;

            /*
             * If the else block contents does not end in a semicolon,
             * and the else block starts with (, [, /, +, ` or -, then it is not
             * safe to remove the else block, because ASI will not add a semicolon
             * after the remaining else block contents
             */
            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
              return null;
            }
          }
          if (startToken.type === "Punctuator" && startToken.value === "{") {
            fixedSource = source.slice(1, -1);
          } else {
            fixedSource = source;
          }

          /*
           * Extend the replacement range to include the entire
           * function to avoid conflicting with no-useless-return.
           * https://github.com/eslint/eslint/issues/8026
           */
          return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
        }
      });
    }

    /**
     * Check to see if the node is a ReturnStatement
     *
     * @param {Node} node The node being evaluated
     * @returns {boolean} True if node is a return
     */
    function checkForReturn(node) {
      return node.type === "ReturnStatement";
    }

    /**
     * Naive return checking, does not iterate through the whole
     * BlockStatement because we make the assumption that the ReturnStatement
     * will be the last node in the body of the BlockStatement.
     *
     * @param {Node} node The consequent/alternate node
     * @returns {boolean} True if it has a return
     */
    function naiveHasReturn(node) {
      if (node.type === "BlockStatement") {
        const body = node.body,
          lastChildNode = body[body.length - 1];
        return lastChildNode && checkForReturn(lastChildNode);
      }
      return checkForReturn(node);
    }

    /**
     * Check to see if the node is valid for evaluation,
     * meaning it has an else.
     *
     * @param {Node} node The node being evaluated
     * @returns {boolean} True if the node is valid
     */
    function hasElse(node) {
      return node.alternate && node.consequent;
    }

    /**
     * If the consequent is an IfStatement, check to see if it has an else
     * and both its consequent and alternate path return, meaning this is
     * a nested case of rule violation.  If-Else not considered currently.
     *
     * @param {Node} node The consequent node
     * @returns {boolean} True if this is a nested rule violation
     */
    function checkForIf(node) {
      return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
    }

    /**
     * Check the consequent/body node to make sure it is not
     * a ReturnStatement or an IfStatement that returns on both
     * code paths.
     *
     * @param {Node} node The consequent or body node
     * @returns {boolean} `true` if it is a Return/If node that always returns.
     */
    function checkForReturnOrIf(node) {
      return checkForReturn(node) || checkForIf(node);
    }

    /**
     * Check whether a node returns in every codepath.
     * @param {Node} node The node to be checked
     * @returns {boolean} `true` if it returns on every codepath.
     */
    function alwaysReturns(node) {
      if (node.type === "BlockStatement") {
        // If we have a BlockStatement, check each consequent body node.
        return node.body.some(checkForReturnOrIf);
      }

      /*
       * If not a block statement, make sure the consequent isn't a
       * ReturnStatement or an IfStatement with returns on both paths.
       */
      return checkForReturnOrIf(node);
    }

    /**
     * Check the if statement, but don't catch else-if blocks.
     * @returns {void}
     * @param {Node} node The node for the if statement to check
     * @private
     */
    function checkIfWithoutElse(node) {
      const parent = node.parent;

      /*
       * Fixing this would require splitting one statement into two, so no error should
       * be reported if this node is in a position where only one statement is allowed.
       */
      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
        return;
      }
      const consequents = [];
      let alternate;
      for (let currentNode = node; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) {
        if (!currentNode.alternate) {
          return;
        }
        consequents.push(currentNode.consequent);
        alternate = currentNode.alternate;
      }
      if (consequents.every(alwaysReturns)) {
        displayReport(alternate);
      }
    }

    /**
     * Check the if statement
     * @returns {void}
     * @param {Node} node The node for the if statement to check
     * @private
     */
    function checkIfWithElse(node) {
      const parent = node.parent;

      /*
       * Fixing this would require splitting one statement into two, so no error should
       * be reported if this node is in a position where only one statement is allowed.
       */
      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
        return;
      }
      const alternate = node.alternate;
      if (alternate && alwaysReturns(node.consequent)) {
        displayReport(alternate);
      }
    }
    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      "IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse
    };
  }
};

/***/ }),
/* 305 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Helper class to aid in constructing fix commands.
 * @author Alan Pierce
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A helper class to combine fix options into a fix command. Currently, it
 * exposes some "retain" methods that extend the range of the text being
 * replaced so that other fixes won't touch that region in the same pass.
 */
class FixTracker {
  /**
   * Create a new FixTracker.
   *
   * @param {ruleFixer} fixer A ruleFixer instance.
   * @param {SourceCode} sourceCode A SourceCode object for the current code.
   */
  constructor(fixer, sourceCode) {
    this.fixer = fixer;
    this.sourceCode = sourceCode;
    this.retainedRange = null;
  }

  /**
   * Mark the given range as "retained", meaning that other fixes may not
   * may not modify this region in the same pass.
   *
   * @param {int[]} range The range to retain.
   * @returns {FixTracker} The same RuleFixer, for chained calls.
   */
  retainRange(range) {
    this.retainedRange = range;
    return this;
  }

  /**
   * Given a node, find the function containing it (or the entire program) and
   * mark it as retained, meaning that other fixes may not modify it in this
   * pass. This is useful for avoiding conflicts in fixes that modify control
   * flow.
   *
   * @param {ASTNode} node The node to use as a starting point.
   * @returns {FixTracker} The same RuleFixer, for chained calls.
   */
  retainEnclosingFunction(node) {
    const functionNode = astUtils.getUpperFunction(node);
    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
  }

  /**
   * Given a node or token, find the token before and afterward, and mark that
   * range as retained, meaning that other fixes may not modify it in this
   * pass. This is useful for avoiding conflicts in fixes that make a small
   * change to the code where the AST should not be changed.
   *
   * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting
   *      point. The token to the left and right are use in the range.
   * @returns {FixTracker} The same RuleFixer, for chained calls.
   */
  retainSurroundingTokens(nodeOrToken) {
    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
  }

  /**
   * Create a fix command that replaces the given range with the given text,
   * accounting for any retained ranges.
   *
   * @param {int[]} range The range to remove in the fix.
   * @param {string} text The text to insert in place of the range.
   * @returns {Object} The fix command.
   */
  replaceTextRange(range, text) {
    let actualRange;
    if (this.retainedRange) {
      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];
    } else {
      actualRange = range;
    }
    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
  }

  /**
   * Create a fix command that removes the given node or token, accounting for
   * any retained ranges.
   *
   * @param {ASTNode|Token} nodeOrToken The node or token to remove.
   * @returns {Object} The fix command.
   */
  remove(nodeOrToken) {
    return this.replaceTextRange(nodeOrToken.range, "");
  }
}
module.exports = FixTracker;

/***/ }),
/* 306 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of an empty block statement
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty block statements",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty"
    },
    schema: [{
      type: "object",
      properties: {
        allowEmptyCatch: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Empty {{type}} statement."
    }
  },
  create(context) {
    const options = context.options[0] || {},
      allowEmptyCatch = options.allowEmptyCatch || false;
    const sourceCode = context.getSourceCode();
    return {
      BlockStatement(node) {
        // if the body is not empty, we can just return immediately
        if (node.body.length !== 0) {
          return;
        }

        // a function is generally allowed to be empty
        if (astUtils.isFunction(node.parent)) {
          return;
        }
        if (allowEmptyCatch && node.parent.type === "CatchClause") {
          return;
        }

        // any other block is only allowed to be empty, if it contains a comment
        if (sourceCode.getCommentsInside(node).length > 0) {
          return;
        }
        context.report({
          node,
          messageId: "unexpected",
          data: {
            type: "block"
          }
        });
      },
      SwitchStatement(node) {
        if (typeof node.cases === "undefined" || node.cases.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "switch"
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 307 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag the use of empty character classes in regular expressions
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/*
 * plain-English description of the following regexp:
 * 0. `^` fix the match at the beginning of the string
 * 1. `\/`: the `/` that begins the regexp
 * 2. `([^\\[]|\\.|\[([^\\\]]|\\.)+\])*`: regexp contents; 0 or more of the following
 * 2.0. `[^\\[]`: any character that's not a `\` or a `[` (anything but escape sequences and character classes)
 * 2.1. `\\.`: an escape sequence
 * 2.2. `\[([^\\\]]|\\.)+\]`: a character class that isn't empty
 * 3. `\/` the `/` that ends the regexp
 * 4. `[gimuy]*`: optional regexp flags
 * 5. `$`: fix the match at the end of the string
 */
const regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuys]*$/u;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty character classes in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty-character-class"
    },
    schema: [],
    messages: {
      unexpected: "Empty class."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node);
        if (token.type === "RegularExpression" && !regex.test(token.value)) {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }
    };
  }
};

/***/ }),
/* 308 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow empty functions.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const ALLOW_OPTIONS = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors"]);

/**
 * Gets the kind of a given function node.
 *
 * @param {ASTNode} node - A function node to get. This is one of
 *      an ArrowFunctionExpression, a FunctionDeclaration, or a
 *      FunctionExpression.
 * @returns {string} The kind of the function. This is one of "functions",
 *      "arrowFunctions", "generatorFunctions", "asyncFunctions", "methods",
 *      "generatorMethods", "asyncMethods", "getters", "setters", and
 *      "constructors".
 */
function getKind(node) {
  const parent = node.parent;
  let kind = "";
  if (node.type === "ArrowFunctionExpression") {
    return "arrowFunctions";
  }

  // Detects main kind.
  if (parent.type === "Property") {
    if (parent.kind === "get") {
      return "getters";
    }
    if (parent.kind === "set") {
      return "setters";
    }
    kind = parent.method ? "methods" : "functions";
  } else if (parent.type === "MethodDefinition") {
    if (parent.kind === "get") {
      return "getters";
    }
    if (parent.kind === "set") {
      return "setters";
    }
    if (parent.kind === "constructor") {
      return "constructors";
    }
    kind = "methods";
  } else {
    kind = "functions";
  }

  // Detects prefix.
  let prefix = "";
  if (node.generator) {
    prefix = "generator";
  } else if (node.async) {
    prefix = "async";
  } else {
    return kind;
  }
  return prefix + kind[0].toUpperCase() + kind.slice(1);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty functions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-empty-function"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: ALLOW_OPTIONS
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "Unexpected empty {{name}}."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const allowed = options.allow || [];
    const sourceCode = context.getSourceCode();

    /**
     * Reports a given function node if the node matches the following patterns.
     *
     * - Not allowed by options.
     * - The body is empty.
     * - The body doesn't have any comments.
     *
     * @param {ASTNode} node - A function node to report. This is one of
     *      an ArrowFunctionExpression, a FunctionDeclaration, or a
     *      FunctionExpression.
     * @returns {void}
     */
    function reportIfEmpty(node) {
      const kind = getKind(node);
      const name = astUtils.getFunctionNameWithKind(node);
      const innerComments = sourceCode.getTokens(node.body, {
        includeComments: true,
        filter: astUtils.isCommentToken
      });
      if (allowed.indexOf(kind) === -1 && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
        context.report({
          node,
          loc: node.body.loc.start,
          messageId: "unexpected",
          data: {
            name
          }
        });
      }
    }
    return {
      ArrowFunctionExpression: reportIfEmpty,
      FunctionDeclaration: reportIfEmpty,
      FunctionExpression: reportIfEmpty
    };
  }
};

/***/ }),
/* 309 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow an empty pattern
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty destructuring patterns",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-empty-pattern"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected empty {{type}} pattern."
    }
  },
  create(context) {
    return {
      ObjectPattern(node) {
        if (node.properties.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "object"
            }
          });
        }
      },
      ArrayPattern(node) {
        if (node.elements.length === 0) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              type: "array"
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 310 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag comparisons to null without a type-checking
 * operator.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `null` comparisons without type-checking operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-eq-null"
    },
    schema: [],
    messages: {
      unexpected: "Use '===' to compare with null."
    }
  },
  create(context) {
    return {
      BinaryExpression(node) {
        const badOperator = node.operator === "==" || node.operator === "!=";
        if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
          context.report({
            node,
            messageId: "unexpected"
          });
        }
      }
    };
  }
};

/***/ }),
/* 311 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of eval() statement
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const candidatesOfGlobalObject = Object.freeze(["global", "window"]);

/**
 * Checks a given node is a Identifier node of the specified name.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a Identifier node of the name.
 */
function isIdentifier(node, name) {
  return node.type === "Identifier" && node.name === name;
}

/**
 * Checks a given node is a Literal node of the specified string value.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a Literal node of the name.
 */
function isConstant(node, name) {
  switch (node.type) {
    case "Literal":
      return node.value === name;
    case "TemplateLiteral":
      return node.expressions.length === 0 && node.quasis[0].value.cooked === name;
    default:
      return false;
  }
}

/**
 * Checks a given node is a MemberExpression node which has the specified name's
 * property.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a MemberExpression node which has
 *      the specified name's property
 */
function isMember(node, name) {
  return node.type === "MemberExpression" && (node.computed ? isConstant : isIdentifier)(node.property, name);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-eval"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndirect: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "eval can be harmful."
    }
  },
  create(context) {
    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);
    const sourceCode = context.getSourceCode();
    let funcInfo = null;

    /**
     * Pushs a variable scope (Program or Function) information to the stack.
     *
     * This is used in order to check whether or not `this` binding is a
     * reference to the global object.
     *
     * @param {ASTNode} node - A node of the scope. This is one of Program,
     *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
     * @returns {void}
     */
    function enterVarScope(node) {
      const strict = context.getScope().isStrict;
      funcInfo = {
        upper: funcInfo,
        node,
        strict,
        defaultThis: false,
        initialized: strict
      };
    }

    /**
     * Pops a variable scope from the stack.
     *
     * @returns {void}
     */
    function exitVarScope() {
      funcInfo = funcInfo.upper;
    }

    /**
     * Reports a given node.
     *
     * `node` is `Identifier` or `MemberExpression`.
     * The parent of `node` might be `CallExpression`.
     *
     * The location of the report is always `eval` `Identifier` (or possibly
     * `Literal`). The type of the report is `CallExpression` if the parent is
     * `CallExpression`. Otherwise, it's the given node type.
     *
     * @param {ASTNode} node - A node to report.
     * @returns {void}
     */
    function report(node) {
      const parent = node.parent;
      const locationNode = node.type === "MemberExpression" ? node.property : node;
      const reportNode = parent.type === "CallExpression" && parent.callee === node ? parent : node;
      context.report({
        node: reportNode,
        loc: locationNode.loc.start,
        messageId: "unexpected"
      });
    }

    /**
     * Reports accesses of `eval` via the global object.
     *
     * @param {eslint-scope.Scope} globalScope - The global scope.
     * @returns {void}
     */
    function reportAccessingEvalViaGlobalObject(globalScope) {
      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
        const name = candidatesOfGlobalObject[i];
        const variable = astUtils.getVariableByName(globalScope, name);
        if (!variable) {
          continue;
        }
        const references = variable.references;
        for (let j = 0; j < references.length; ++j) {
          const identifier = references[j].identifier;
          let node = identifier.parent;

          // To detect code like `window.window.eval`.
          while (isMember(node, name)) {
            node = node.parent;
          }

          // Reports.
          if (isMember(node, "eval")) {
            report(node);
          }
        }
      }
    }

    /**
     * Reports all accesses of `eval` (excludes direct calls to eval).
     *
     * @param {eslint-scope.Scope} globalScope - The global scope.
     * @returns {void}
     */
    function reportAccessingEval(globalScope) {
      const variable = astUtils.getVariableByName(globalScope, "eval");
      if (!variable) {
        return;
      }
      const references = variable.references;
      for (let i = 0; i < references.length; ++i) {
        const reference = references[i];
        const id = reference.identifier;
        if (id.name === "eval" && !astUtils.isCallee(id)) {
          // Is accessing to eval (excludes direct calls to eval)
          report(id);
        }
      }
    }
    if (allowIndirect) {
      // Checks only direct calls to eval. It's simple!
      return {
        "CallExpression:exit"(node) {
          const callee = node.callee;
          if (isIdentifier(callee, "eval")) {
            report(callee);
          }
        }
      };
    }
    return {
      "CallExpression:exit"(node) {
        const callee = node.callee;
        if (isIdentifier(callee, "eval")) {
          report(callee);
        }
      },
      Program(node) {
        const scope = context.getScope(),
          features = context.parserOptions.ecmaFeatures || {},
          strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict;
        funcInfo = {
          upper: null,
          node,
          strict,
          defaultThis: true,
          initialized: true
        };
      },
      "Program:exit"() {
        const globalScope = context.getScope();
        exitVarScope();
        reportAccessingEval(globalScope);
        reportAccessingEvalViaGlobalObject(globalScope);
      },
      FunctionDeclaration: enterVarScope,
      "FunctionDeclaration:exit": exitVarScope,
      FunctionExpression: enterVarScope,
      "FunctionExpression:exit": exitVarScope,
      ArrowFunctionExpression: enterVarScope,
      "ArrowFunctionExpression:exit": exitVarScope,
      ThisExpression(node) {
        if (!isMember(node.parent, "eval")) {
          return;
        }

        /*
         * `this.eval` is found.
         * Checks whether or not the value of `this` is the global object.
         */
        if (!funcInfo.initialized) {
          funcInfo.initialized = true;
          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);
        }
        if (!funcInfo.strict && funcInfo.defaultThis) {
          // `this.eval` is possible built-in `eval`.
          report(node.parent);
        }
      }
    };
  }
};

/***/ }),
/* 312 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag assignment of the exception parameter
 * @author Stephen Murray <spmurrayzzz>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning exceptions in `catch` clauses",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-ex-assign"
    },
    schema: [],
    messages: {
      unexpected: "Do not assign to the exception parameter."
    }
  },
  create(context) {
    /**
     * Finds and reports references that are non initializer and writable.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      astUtils.getModifyingReferences(variable.references).forEach(reference => {
        context.report({
          node: reference.identifier,
          messageId: "unexpected"
        });
      });
    }
    return {
      CatchClause(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
      }
    };
  }
};

/***/ }),
/* 313 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag adding properties to native object's prototypes.
 * @author David Nelson
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);
const globals = __webpack_require__(176);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const propertyDefinitionMethods = new Set(["defineProperty", "defineProperties"]);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow extending native types",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extend-native"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpected: "{{builtin}} prototype is read only, properties should not be added."
    }
  },
  create(context) {
    const config = context.options[0] || {};
    const exceptions = new Set(config.exceptions || []);
    const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));

    /**
     * Reports a lint error for the given node.
     * @param {ASTNode} node The node to report.
     * @param {string} builtin The name of the native builtin being extended.
     * @returns {void}
     */
    function reportNode(node, builtin) {
      context.report({
        node,
        messageId: "unexpected",
        data: {
          builtin
        }
      });
    }

    /**
     * Check to see if the `prototype` property of the given object
     * identifier node is being accessed.
     * @param {ASTNode} identifierNode The Identifier representing the object
     * to check.
     * @returns {boolean} True if the identifier is the object of a
     * MemberExpression and its `prototype` property is being accessed,
     * false otherwise.
     */
    function isPrototypePropertyAccessed(identifierNode) {
      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype");
    }

    /**
     * Checks that an identifier is an object of a prototype whose member
     * is being assigned in an AssignmentExpression.
     * Example: Object.prototype.foo = "bar"
     * @param {ASTNode} identifierNode The identifier to check.
     * @returns {boolean} True if the identifier's prototype is modified.
     */
    function isInPrototypePropertyAssignment(identifierNode) {
      return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "MemberExpression" && identifierNode.parent.parent.parent.type === "AssignmentExpression" && identifierNode.parent.parent.parent.left === identifierNode.parent.parent);
    }

    /**
     * Checks that an identifier is an object of a prototype whose member
     * is being extended via the Object.defineProperty() or
     * Object.defineProperties() methods.
     * Example: Object.defineProperty(Array.prototype, "foo", ...)
     * Example: Object.defineProperties(Array.prototype, ...)
     * @param {ASTNode} identifierNode The identifier to check.
     * @returns {boolean} True if the identifier's prototype is modified.
     */
    function isInDefinePropertyCall(identifierNode) {
      return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "CallExpression" && identifierNode.parent.parent.arguments[0] === identifierNode.parent && identifierNode.parent.parent.callee.type === "MemberExpression" && identifierNode.parent.parent.callee.object.type === "Identifier" && identifierNode.parent.parent.callee.object.name === "Object" && identifierNode.parent.parent.callee.property.type === "Identifier" && propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name));
    }

    /**
     * Check to see if object prototype access is part of a prototype
     * extension. There are three ways a prototype can be extended:
     * 1. Assignment to prototype property (Object.prototype.foo = 1)
     * 2. Object.defineProperty()/Object.defineProperties() on a prototype
     * If prototype extension is detected, report the AssignmentExpression
     * or CallExpression node.
     * @param {ASTNode} identifierNode The Identifier representing the object
     * which prototype is being accessed and possibly extended.
     * @returns {void}
     */
    function checkAndReportPrototypeExtension(identifierNode) {
      if (isInPrototypePropertyAssignment(identifierNode)) {
        // Identifier --> MemberExpression --> MemberExpression --> AssignmentExpression
        reportNode(identifierNode.parent.parent.parent, identifierNode.name);
      } else if (isInDefinePropertyCall(identifierNode)) {
        // Identifier --> MemberExpression --> CallExpression
        reportNode(identifierNode.parent.parent, identifierNode.name);
      }
    }
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        modifiedBuiltins.forEach(builtin => {
          const builtinVar = globalScope.set.get(builtin);
          if (builtinVar && builtinVar.references) {
            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);
          }
        });
      }
    };
  }
};

/***/ }),
/* 314 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag unnecessary bind calls
 * @author Bence Dnyi <bence@danyi.me>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SIDE_EFFECT_FREE_NODE_TYPES = new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.bind()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-bind"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "The function binding is unnecessary."
    }
  },
  create(context) {
    let scopeInfo = null;

    /**
     * Checks if a node is free of side effects.
     *
     * This check is stricter than it needs to be, in order to keep the implementation simple.
     *
     * @param {ASTNode} node A node to check.
     * @returns {boolean} True if the node is known to be side-effect free, false otherwise.
     */
    function isSideEffectFree(node) {
      return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);
    }

    /**
     * Reports a given function node.
     *
     * @param {ASTNode} node - A node to report. This is a FunctionExpression or
     *      an ArrowFunctionExpression.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node: node.parent.parent,
        messageId: "unexpected",
        loc: node.parent.property.loc.start,
        fix(fixer) {
          if (node.parent.parent.arguments.length && !isSideEffectFree(node.parent.parent.arguments[0])) {
            return null;
          }
          const firstTokenToRemove = context.getSourceCode().getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);
          return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);
        }
      });
    }

    /**
     * Checks whether or not a given function node is the callee of `.bind()`
     * method.
     *
     * e.g. `(function() {}.bind(foo))`
     *
     * @param {ASTNode} node - A node to report. This is a FunctionExpression or
     *      an ArrowFunctionExpression.
     * @returns {boolean} `true` if the node is the callee of `.bind()` method.
     */
    function isCalleeOfBindMethod(node) {
      const parent = node.parent;
      const grandparent = parent.parent;
      return grandparent && grandparent.type === "CallExpression" && grandparent.callee === parent && grandparent.arguments.length === 1 && parent.type === "MemberExpression" && parent.object === node && astUtils.getStaticPropertyName(parent) === "bind";
    }

    /**
     * Adds a scope information object to the stack.
     *
     * @param {ASTNode} node - A node to add. This node is a FunctionExpression
     *      or a FunctionDeclaration node.
     * @returns {void}
     */
    function enterFunction(node) {
      scopeInfo = {
        isBound: isCalleeOfBindMethod(node),
        thisFound: false,
        upper: scopeInfo
      };
    }

    /**
     * Removes the scope information object from the top of the stack.
     * At the same time, this reports the function node if the function has
     * `.bind()` and the `this` keywords found.
     *
     * @param {ASTNode} node - A node to remove. This node is a
     *      FunctionExpression or a FunctionDeclaration node.
     * @returns {void}
     */
    function exitFunction(node) {
      if (scopeInfo.isBound && !scopeInfo.thisFound) {
        report(node);
      }
      scopeInfo = scopeInfo.upper;
    }

    /**
     * Reports a given arrow function if the function is callee of `.bind()`
     * method.
     *
     * @param {ASTNode} node - A node to report. This node is an
     *      ArrowFunctionExpression.
     * @returns {void}
     */
    function exitArrowFunction(node) {
      if (isCalleeOfBindMethod(node)) {
        report(node);
      }
    }

    /**
     * Set the mark as the `this` keyword was found in this scope.
     *
     * @returns {void}
     */
    function markAsThisFound() {
      if (scopeInfo) {
        scopeInfo.thisFound = true;
      }
    }
    return {
      "ArrowFunctionExpression:exit": exitArrowFunction,
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      ThisExpression: markAsThisFound
    };
  }
};

/***/ }),
/* 315 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary boolean casts",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-extra-boolean-cast"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedCall: "Redundant Boolean call.",
      unexpectedNegation: "Redundant double negation."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    // Node types which have a test which will coerce values to booleans.
    const BOOLEAN_NODE_TYPES = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];

    /**
     * Check if a node is in a context where its value would be coerced to a boolean at runtime.
     *
     * @param {Object} node The node
     * @param {Object} parent Its parent
     * @returns {boolean} If it is in a boolean context
     */
    function isInBooleanContext(node, parent) {
      return BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 && node === parent.test ||
      // !<bool>
      parent.type === "UnaryExpression" && parent.operator === "!";
    }
    return {
      UnaryExpression(node) {
        const ancestors = context.getAncestors(),
          parent = ancestors.pop(),
          grandparent = ancestors.pop();

        // Exit early if it's guaranteed not to match
        if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
          return;
        }
        if (isInBooleanContext(parent, grandparent) ||
        // Boolean(<bool>) and new Boolean(<bool>)
        (grandparent.type === "CallExpression" || grandparent.type === "NewExpression") && grandparent.callee.type === "Identifier" && grandparent.callee.name === "Boolean") {
          context.report({
            node,
            messageId: "unexpectedNegation",
            fix: fixer => fixer.replaceText(parent, sourceCode.getText(node.argument))
          });
        }
      },
      CallExpression(node) {
        const parent = node.parent;
        if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
          return;
        }
        if (isInBooleanContext(node, parent)) {
          context.report({
            node,
            messageId: "unexpectedCall",
            fix: fixer => {
              if (!node.arguments.length) {
                return fixer.replaceText(parent, "true");
              }
              if (node.arguments.length > 1 || node.arguments[0].type === "SpreadElement") {
                return null;
              }
              const argument = node.arguments[0];
              if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {
                return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);
              }
              return fixer.replaceText(node, sourceCode.getText(argument));
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 316 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow unnecessary labels
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary labels",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-label"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "This label '{{name}}' is unnecessary."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    /**
     * Creates a new scope with a breakable statement.
     *
     * @param {ASTNode} node - A node to create. This is a BreakableStatement.
     * @returns {void}
     */
    function enterBreakableStatement(node) {
      scopeInfo = {
        label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
        breakable: true,
        upper: scopeInfo
      };
    }

    /**
     * Removes the top scope of the stack.
     *
     * @returns {void}
     */
    function exitBreakableStatement() {
      scopeInfo = scopeInfo.upper;
    }

    /**
     * Creates a new scope with a labeled statement.
     *
     * This ignores it if the body is a breakable statement.
     * In this case it's handled in the `enterBreakableStatement` function.
     *
     * @param {ASTNode} node - A node to create. This is a LabeledStatement.
     * @returns {void}
     */
    function enterLabeledStatement(node) {
      if (!astUtils.isBreakableStatement(node.body)) {
        scopeInfo = {
          label: node.label,
          breakable: false,
          upper: scopeInfo
        };
      }
    }

    /**
     * Removes the top scope of the stack.
     *
     * This ignores it if the body is a breakable statement.
     * In this case it's handled in the `exitBreakableStatement` function.
     *
     * @param {ASTNode} node - A node. This is a LabeledStatement.
     * @returns {void}
     */
    function exitLabeledStatement(node) {
      if (!astUtils.isBreakableStatement(node.body)) {
        scopeInfo = scopeInfo.upper;
      }
    }

    /**
     * Reports a given control node if it's unnecessary.
     *
     * @param {ASTNode} node - A node. This is a BreakStatement or a
     *      ContinueStatement.
     * @returns {void}
     */
    function reportIfUnnecessary(node) {
      if (!node.label) {
        return;
      }
      const labelNode = node.label;
      for (let info = scopeInfo; info !== null; info = info.upper) {
        if (info.breakable || info.label && info.label.name === labelNode.name) {
          if (info.breakable && info.label && info.label.name === labelNode.name) {
            context.report({
              node: labelNode,
              messageId: "unexpected",
              data: labelNode,
              fix: fixer => fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]])
            });
          }
          return;
        }
      }
    }
    return {
      WhileStatement: enterBreakableStatement,
      "WhileStatement:exit": exitBreakableStatement,
      DoWhileStatement: enterBreakableStatement,
      "DoWhileStatement:exit": exitBreakableStatement,
      ForStatement: enterBreakableStatement,
      "ForStatement:exit": exitBreakableStatement,
      ForInStatement: enterBreakableStatement,
      "ForInStatement:exit": exitBreakableStatement,
      ForOfStatement: enterBreakableStatement,
      "ForOfStatement:exit": exitBreakableStatement,
      SwitchStatement: enterBreakableStatement,
      "SwitchStatement:exit": exitBreakableStatement,
      LabeledStatement: enterLabeledStatement,
      "LabeledStatement:exit": exitLabeledStatement,
      BreakStatement: reportIfUnnecessary,
      ContinueStatement: reportIfUnnecessary
    };
  }
};

/***/ }),
/* 317 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallow parenthesising higher precedence subexpressions.
 * @author Michael Ficarra
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow unnecessary parentheses",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-extra-parens"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["functions"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["all"]
        }, {
          type: "object",
          properties: {
            conditionalAssign: {
              type: "boolean"
            },
            nestedBinaryExpressions: {
              type: "boolean"
            },
            returnAssign: {
              type: "boolean"
            },
            ignoreJSX: {
              enum: ["none", "all", "single-line", "multi-line"]
            },
            enforceForArrowConditionals: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpected: "Unnecessary parentheses around expression."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const tokensToIgnore = new WeakSet();
    const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);
    const precedence = astUtils.getPrecedence;
    const ALL_NODES = context.options[0] !== "functions";
    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;
    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({
      type: "AssignmentExpression"
    });
    const PRECEDENCE_OF_UPDATE_EXPR = precedence({
      type: "UpdateExpression"
    });

    /**
     * Determines if this rule should be enforced for a node given the current configuration.
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the rule should be enforced for this node.
     * @private
     */
    function ruleApplies(node) {
      if (node.type === "JSXElement" || node.type === "JSXFragment") {
        const isSingleLine = node.loc.start.line === node.loc.end.line;
        switch (IGNORE_JSX) {
          // Exclude this JSX element from linting
          case "all":
            return false;

          // Exclude this JSX element if it is multi-line element
          case "multi-line":
            return isSingleLine;

          // Exclude this JSX element if it is single-line element
          case "single-line":
            return !isSingleLine;

          // Nothing special to be done for JSX elements
          case "none":
            break;

          // no default
        }
      }
      return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }

    /**
     * Determines if a node is surrounded by parentheses twice.
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is doubly parenthesised.
     * @private
     */
    function isParenthesisedTwice(node) {
      const previousToken = sourceCode.getTokenBefore(node, 1),
        nextToken = sourceCode.getTokenAfter(node, 1);
      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
    }

    /**
     * Determines if a node is surrounded by (potentially) invalid parentheses.
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is incorrectly parenthesised.
     * @private
     */
    function hasExcessParens(node) {
      return ruleApplies(node) && isParenthesised(node);
    }

    /**
     * Determines if a node that is expected to be parenthesised is surrounded by
     * (potentially) invalid extra parentheses.
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
     * @private
     */
    function hasDoubleExcessParens(node) {
      return ruleApplies(node) && isParenthesisedTwice(node);
    }

    /**
     * Determines if a node test expression is allowed to have a parenthesised assignment
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the assignment can be parenthesised.
     * @private
     */
    function isCondAssignException(node) {
      return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
    }

    /**
     * Determines if a node is in a return statement
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is in a return statement.
     * @private
     */
    function isInReturnStatement(node) {
      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
        if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") {
          return true;
        }
      }
      return false;
    }

    /**
     * Determines if a constructor function is newed-up with parens
     * @param {ASTNode} newExpression - The NewExpression node to be checked.
     * @returns {boolean} True if the constructor is called with parens.
     * @private
     */
    function isNewExpressionWithParens(newExpression) {
      const lastToken = sourceCode.getLastToken(newExpression);
      const penultimateToken = sourceCode.getTokenBefore(lastToken);
      return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);
    }

    /**
     * Determines if a node is or contains an assignment expression
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is or contains an assignment expression.
     * @private
     */
    function containsAssignment(node) {
      if (node.type === "AssignmentExpression") {
        return true;
      }
      if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
        return true;
      }
      if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
        return true;
      }
      return false;
    }

    /**
     * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the assignment can be parenthesised.
     * @private
     */
    function isReturnAssignException(node) {
      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
        return false;
      }
      if (node.type === "ReturnStatement") {
        return node.argument && containsAssignment(node.argument);
      }
      if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
        return containsAssignment(node.body);
      }
      return containsAssignment(node);
    }

    /**
     * Determines if a node following a [no LineTerminator here] restriction is
     * surrounded by (potentially) invalid extra parentheses.
     * @param {Token} token - The token preceding the [no LineTerminator here] restriction.
     * @param {ASTNode} node - The node to be checked.
     * @returns {boolean} True if the node is incorrectly parenthesised.
     * @private
     */
    function hasExcessParensNoLineTerminator(token, node) {
      if (token.loc.end.line === node.loc.start.line) {
        return hasExcessParens(node);
      }
      return hasDoubleExcessParens(node);
    }

    /**
     * Determines whether a node should be preceded by an additional space when removing parens
     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
     * @returns {boolean} `true` if a space should be inserted before the node
     * @private
     */
    function requiresLeadingSpace(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
      const firstToken = sourceCode.getFirstToken(node);
      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === firstToken.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);
    }

    /**
     * Determines whether a node should be followed by an additional space when removing parens
     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
     * @returns {boolean} `true` if a space should be inserted after the node
     * @private
     */
    function requiresTrailingSpace(node) {
      const nextTwoTokens = sourceCode.getTokensAfter(node, {
        count: 2
      });
      const rightParenToken = nextTwoTokens[0];
      const tokenAfterRightParen = nextTwoTokens[1];
      const tokenBeforeRightParen = sourceCode.getLastToken(node);
      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
    }

    /**
     * Determines if a given expression node is an IIFE
     * @param {ASTNode} node The node to check
     * @returns {boolean} `true` if the given node is an IIFE
     */
    function isIIFE(node) {
      return node.type === "CallExpression" && node.callee.type === "FunctionExpression";
    }

    /**
     * Report the node
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function report(node) {
      const leftParenToken = sourceCode.getTokenBefore(node);
      const rightParenToken = sourceCode.getTokenAfter(node);
      if (!isParenthesisedTwice(node)) {
        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
          return;
        }
        if (isIIFE(node) && !isParenthesised(node.callee)) {
          return;
        }
      }
      context.report({
        node,
        loc: leftParenToken.loc.start,
        messageId: "unexpected",
        fix(fixer) {
          const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
          return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
        }
      });
    }

    /**
     * Evaluate Unary update
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkUnaryUpdate(node) {
      if (node.type === "UnaryExpression" && node.argument.type === "BinaryExpression" && node.argument.operator === "**") {
        return;
      }
      if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
        report(node.argument);
      }
    }

    /**
     * Check if a member expression contains a call expression
     * @param {ASTNode} node MemberExpression node to evaluate
     * @returns {boolean} true if found, false if not
     */
    function doesMemberExpressionContainCallExpression(node) {
      let currentNode = node.object;
      let currentNodeType = node.object.type;
      while (currentNodeType === "MemberExpression") {
        currentNode = currentNode.object;
        currentNodeType = currentNode.type;
      }
      return currentNodeType === "CallExpression";
    }

    /**
     * Evaluate a new call
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkCallNew(node) {
      const callee = node.callee;
      if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {
        const hasNewParensException = callee.type === "NewExpression" && !isNewExpressionWithParens(callee);
        if (hasDoubleExcessParens(callee) || !isIIFE(node) && !hasNewParensException && !(
        /*
         * Allow extra parens around a new expression if
         * there are intervening parentheses.
         */
        callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee))) {
          report(node.callee);
        }
      }
      if (node.arguments.length === 1) {
        if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
          report(node.arguments[0]);
        }
      } else {
        node.arguments.filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR).forEach(report);
      }
    }

    /**
     * Evaluate binary logicals
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkBinaryLogical(node) {
      const prec = precedence(node);
      const leftPrecedence = precedence(node.left);
      const rightPrecedence = precedence(node.right);
      const isExponentiation = node.operator === "**";
      const shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression") || node.left.type === "UnaryExpression" && isExponentiation;
      const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");
      if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation)) {
        report(node.left);
      }
      if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation)) {
        report(node.right);
      }
    }

    /**
     * Check the parentheses around the super class of the given class definition.
     * @param {ASTNode} node The node of class declarations to check.
     * @returns {void}
     */
    function checkClass(node) {
      if (!node.superClass) {
        return;
      }

      /*
       * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.
       * Otherwise, parentheses are needed.
       */
      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);
      if (hasExtraParens) {
        report(node.superClass);
      }
    }

    /**
     * Check the parentheses around the argument of the given spread operator.
     * @param {ASTNode} node The node of spread elements/properties to check.
     * @returns {void}
     */
    function checkSpreadOperator(node) {
      const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR ? hasExcessParens(node.argument) : hasDoubleExcessParens(node.argument);
      if (hasExtraParens) {
        report(node.argument);
      }
    }

    /**
     * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration
     * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node
     * @returns {void}
     */
    function checkExpressionOrExportStatement(node) {
      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;
      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
        tokensToIgnore.add(secondToken);
      }
      if (hasExcessParens(node)) {
        report(node);
      }
    }
    return {
      ArrayExpression(node) {
        node.elements.filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR).forEach(report);
      },
      ArrowFunctionExpression(node) {
        if (isReturnAssignException(node)) {
          return;
        }
        if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS && !isParenthesisedTwice(node.body)) {
          return;
        }
        if (node.body.type !== "BlockStatement") {
          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);
          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
            tokensToIgnore.add(firstBodyToken);
          }
          if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
            report(node.body);
          }
        }
      },
      AssignmentExpression(node) {
        if (isReturnAssignException(node)) {
          return;
        }
        if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
          report(node.right);
        }
      },
      BinaryExpression: checkBinaryLogical,
      CallExpression: checkCallNew,
      ConditionalExpression(node) {
        if (isReturnAssignException(node)) {
          return;
        }
        if (hasExcessParens(node.test) && precedence(node.test) >= precedence({
          type: "LogicalExpression",
          operator: "||"
        })) {
          report(node.test);
        }
        if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
          report(node.consequent);
        }
        if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
          report(node.alternate);
        }
      },
      DoWhileStatement(node) {
        if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },
      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),
      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),
      "ForInStatement, ForOfStatement"(node) {
        if (node.left.type !== "VariableDeclarator") {
          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
          if (firstLeftToken.value === "let" && (
          /*
           * If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`
           * Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.
           */
          firstLeftToken.range[1] === node.left.range[1] ||
          /*
          * If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`
          * Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.
          */
          astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)))) {
            tokensToIgnore.add(firstLeftToken);
          }
        }
        if (!(node.type === "ForOfStatement" && node.right.type === "SequenceExpression") && hasExcessParens(node.right)) {
          report(node.right);
        }
        if (hasExcessParens(node.left)) {
          report(node.left);
        }
      },
      ForStatement(node) {
        if (node.init && hasExcessParens(node.init)) {
          report(node.init);
        }
        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
        if (node.update && hasExcessParens(node.update)) {
          report(node.update);
        }
      },
      IfStatement(node) {
        if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },
      LogicalExpression: checkBinaryLogical,
      MemberExpression(node) {
        const nodeObjHasExcessParens = hasExcessParens(node.object);
        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) ||
        // RegExp literal is allowed to have parens (#1589)
        node.object.type === "Literal" && node.object.regex))) {
          report(node.object);
        }
        if (nodeObjHasExcessParens && node.object.type === "CallExpression" && node.parent.type !== "NewExpression") {
          report(node.object);
        }
        if (node.computed && hasExcessParens(node.property)) {
          report(node.property);
        }
      },
      NewExpression: checkCallNew,
      ObjectExpression(node) {
        node.properties.filter(property => {
          const value = property.value;
          return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
        }).forEach(property => report(property.value));
      },
      ReturnStatement(node) {
        const returnToken = sourceCode.getFirstToken(node);
        if (isReturnAssignException(node)) {
          return;
        }
        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) &&
        // RegExp literal is allowed to have parens (#1589)
        !(node.argument.type === "Literal" && node.argument.regex)) {
          report(node.argument);
        }
      },
      SequenceExpression(node) {
        node.expressions.filter(e => hasExcessParens(e) && precedence(e) >= precedence(node)).forEach(report);
      },
      SwitchCase(node) {
        if (node.test && hasExcessParens(node.test)) {
          report(node.test);
        }
      },
      SwitchStatement(node) {
        if (hasDoubleExcessParens(node.discriminant)) {
          report(node.discriminant);
        }
      },
      ThrowStatement(node) {
        const throwToken = sourceCode.getFirstToken(node);
        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
          report(node.argument);
        }
      },
      UnaryExpression: checkUnaryUpdate,
      UpdateExpression: checkUnaryUpdate,
      AwaitExpression: checkUnaryUpdate,
      VariableDeclarator(node) {
        if (node.init && hasExcessParens(node.init) && precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&
        // RegExp literal is allowed to have parens (#1589)
        !(node.init.type === "Literal" && node.init.regex)) {
          report(node.init);
        }
      },
      WhileStatement(node) {
        if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
          report(node.test);
        }
      },
      WithStatement(node) {
        if (hasDoubleExcessParens(node.object)) {
          report(node.object);
        }
      },
      YieldExpression(node) {
        if (node.argument) {
          const yieldToken = sourceCode.getFirstToken(node);
          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
            report(node.argument);
          }
        }
      },
      ClassDeclaration: checkClass,
      ClassExpression: checkClass,
      SpreadElement: checkSpreadOperator,
      SpreadProperty: checkSpreadOperator,
      ExperimentalSpreadProperty: checkSpreadOperator
    };
  }
};

/***/ }),
/* 318 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of unnecessary semicolons
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const FixTracker = __webpack_require__(305);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary semicolons",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-extra-semi"
    },
    fixable: "code",
    schema: [],
    messages: {
      unexpected: "Unnecessary semicolon."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Reports an unnecessary semicolon error.
     * @param {Node|Token} nodeOrToken - A node or a token to be reported.
     * @returns {void}
     */
    function report(nodeOrToken) {
      context.report({
        node: nodeOrToken,
        messageId: "unexpected",
        fix(fixer) {
          /*
           * Expand the replacement range to include the surrounding
           * tokens to avoid conflicting with semi.
           * https://github.com/eslint/eslint/issues/7928
           */
          return new FixTracker(fixer, context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);
        }
      });
    }

    /**
     * Checks for a part of a class body.
     * This checks tokens from a specified token to a next MethodDefinition or the end of class body.
     *
     * @param {Token} firstToken - The first token to check.
     * @returns {void}
     */
    function checkForPartOfClassBody(firstToken) {
      for (let token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
        if (astUtils.isSemicolonToken(token)) {
          report(token);
        }
      }
    }
    return {
      /**
       * Reports this empty statement, except if the parent node is a loop.
       * @param {Node} node - A EmptyStatement node to be reported.
       * @returns {void}
       */
      EmptyStatement(node) {
        const parent = node.parent,
          allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"];
        if (allowedParentTypes.indexOf(parent.type) === -1) {
          report(node);
        }
      },
      /**
       * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
       * @param {Node} node - A ClassBody node to check.
       * @returns {void}
       */
      ClassBody(node) {
        checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.
      },
      /**
       * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
       * @param {Node} node - A MethodDefinition node of the start point.
       * @returns {void}
       */
      MethodDefinition(node) {
        checkForPartOfClassBody(sourceCode.getTokenAfter(node));
      }
    };
  }
};

/***/ }),
/* 319 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag fall-through cases in switch statements.
 * @author Matt DuVall <http://mattduvall.com/>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;

/**
 * Checks whether or not a given node has a fallthrough comment.
 * @param {ASTNode} node - A SwitchCase node to get comments.
 * @param {RuleContext} context - A rule context which stores comments.
 * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.
 * @returns {boolean} `true` if the node has a valid fallthrough comment.
 */
function hasFallthroughComment(node, context, fallthroughCommentPattern) {
  const sourceCode = context.getSourceCode();
  const comment = lodash.last(sourceCode.getCommentsBefore(node));
  return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}

/**
 * Checks whether or not a given code path segment is reachable.
 * @param {CodePathSegment} segment - A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is reachable.
 */
function isReachable(segment) {
  return segment.reachable;
}

/**
 * Checks whether a node and a token are separated by blank lines
 * @param {ASTNode} node - The node to check
 * @param {Token} token - The token to compare against
 * @returns {boolean} `true` if there are blank lines between node and token
 */
function hasBlankLinesBetween(node, token) {
  return token.loc.start.line > node.loc.end.line + 1;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow fallthrough of `case` statements",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-fallthrough"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: false
    }],
    messages: {
      case: "Expected a 'break' statement before 'case'.",
      default: "Expected a 'break' statement before 'default'."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    let currentCodePath = null;
    const sourceCode = context.getSourceCode();

    /*
     * We need to use leading comments of the next SwitchCase node because
     * trailing comments is wrong if semicolons are omitted.
     */
    let fallthroughCase = null;
    let fallthroughCommentPattern = null;
    if (options.commentPattern) {
      fallthroughCommentPattern = new RegExp(options.commentPattern); // eslint-disable-line require-unicode-regexp
    } else {
      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
    }
    return {
      onCodePathStart(codePath) {
        currentCodePath = codePath;
      },
      onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },
      SwitchCase(node) {
        /*
         * Checks whether or not there is a fallthrough comment.
         * And reports the previous fallthrough node if that does not exist.
         */
        if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
          context.report({
            messageId: node.test ? "case" : "default",
            node
          });
        }
        fallthroughCase = null;
      },
      "SwitchCase:exit"(node) {
        const nextToken = sourceCode.getTokenAfter(node);

        /*
         * `reachable` meant fall through because statements preceded by
         * `break`, `return`, or `throw` are unreachable.
         * And allows empty cases and the last case.
         */
        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash.last(node.parent.cases) !== node) {
          fallthroughCase = node;
        }
      }
    };
  }
};

/***/ }),
/* 320 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal
 * @author James Allardice
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow leading or trailing decimal points in numeric literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-floating-decimal"
    },
    schema: [],
    fixable: "code",
    messages: {
      leading: "A leading decimal point can be confused with a dot.",
      trailing: "A trailing decimal point can be confused with a dot."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        if (typeof node.value === "number") {
          if (node.raw.startsWith(".")) {
            context.report({
              node,
              messageId: "leading",
              fix(fixer) {
                const tokenBefore = sourceCode.getTokenBefore(node);
                const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
                return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
              }
            });
          }
          if (node.raw.indexOf(".") === node.raw.length - 1) {
            context.report({
              node,
              messageId: "trailing",
              fix: fixer => fixer.insertTextAfter(node, "0")
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 321 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of function declaration identifiers as variables.
 * @author Ian Christian Myers
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `function` declarations",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-func-assign"
    },
    schema: []
  },
  create(context) {
    /**
     * Reports a reference if is non initializer and writable.
     * @param {References} references - Collection of reference to check.
     * @returns {void}
     */
    function checkReference(references) {
      astUtils.getModifyingReferences(references).forEach(reference => {
        context.report({
          node: reference.identifier,
          message: "'{{name}}' is a function.",
          data: {
            name: reference.identifier.name
          }
        });
      });
    }

    /**
     * Finds and reports references that are non initializer and writable.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      if (variable.defs[0].type === "FunctionName") {
        checkReference(variable.references);
      }
    }

    /**
     * Checks parameters of a given function node.
     * @param {ASTNode} node - A function node to check.
     * @returns {void}
     */
    function checkForFunction(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }
    return {
      FunctionDeclaration: checkForFunction,
      FunctionExpression: checkForFunction
    };
  }
};

/***/ }),
/* 322 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-global-assign"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const config = context.options[0];
    const exceptions = config && config.exceptions || [];

    /**
     * Reports write references.
     * @param {Reference} reference - A reference to check.
     * @param {int} index - The index of the reference in the references.
     * @param {Reference[]} references - The array that the reference belongs to.
     * @returns {void}
     */
    function checkReference(reference, index, references) {
      const identifier = reference.identifier;
      if (reference.init === false && reference.isWrite() && (
      /*
       * Destructuring assignments can have multiple default value,
       * so possibly there are multiple writeable references for the same identifier.
       */
      index === 0 || references[index - 1].identifier !== identifier)) {
        context.report({
          node: identifier,
          message: "Read-only global '{{name}}' should not be modified.",
          data: identifier
        });
      }
    }

    /**
     * Reports write references if a given variable is read-only builtin.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
        variable.references.forEach(checkReference);
      }
    }
    return {
      Program() {
        const globalScope = context.getScope();
        globalScope.variables.forEach(checkVariable);
      }
    };
  }
};

/***/ }),
/* 323 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow the type conversions with shorter notations.
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
const ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];

/**
 * Parses and normalizes an option object.
 * @param {Object} options - An option object to parse.
 * @returns {Object} The parsed and normalized option object.
 */
function parseOptions(options) {
  return {
    boolean: "boolean" in options ? options.boolean : true,
    number: "number" in options ? options.number : true,
    string: "string" in options ? options.string : true,
    allow: options.allow || []
  };
}

/**
 * Checks whether or not a node is a double logical nigating.
 * @param {ASTNode} node - An UnaryExpression node to check.
 * @returns {boolean} Whether or not the node is a double logical nigating.
 */
function isDoubleLogicalNegating(node) {
  return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
}

/**
 * Checks whether or not a node is a binary negating of `.indexOf()` method calling.
 * @param {ASTNode} node - An UnaryExpression node to check.
 * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.
 */
function isBinaryNegatingOfIndexOf(node) {
  return node.operator === "~" && node.argument.type === "CallExpression" && node.argument.callee.type === "MemberExpression" && node.argument.callee.property.type === "Identifier" && INDEX_OF_PATTERN.test(node.argument.callee.property.name);
}

/**
 * Checks whether or not a node is a multiplying by one.
 * @param {BinaryExpression} node - A BinaryExpression node to check.
 * @returns {boolean} Whether or not the node is a multiplying by one.
 */
function isMultiplyByOne(node) {
  return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
}

/**
 * Checks whether the result of a node is numeric or not
 * @param {ASTNode} node The node to test
 * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call
 */
function isNumeric(node) {
  return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
}

/**
 * Returns the first non-numeric operand in a BinaryExpression. Designed to be
 * used from bottom to up since it walks up the BinaryExpression trees using
 * node.parent to find the result.
 * @param {BinaryExpression} node The BinaryExpression node to be walked up on
 * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null
 */
function getNonNumericOperand(node) {
  const left = node.left,
    right = node.right;
  if (right.type !== "BinaryExpression" && !isNumeric(right)) {
    return right;
  }
  if (left.type !== "BinaryExpression" && !isNumeric(left)) {
    return left;
  }
  return null;
}

/**
 * Checks whether a node is an empty string literal or not.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} Whether or not the passed in node is an
 * empty string literal or not.
 */
function isEmptyString(node) {
  return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
}

/**
 * Checks whether or not a node is a concatenating with an empty string.
 * @param {ASTNode} node - A BinaryExpression node to check.
 * @returns {boolean} Whether or not the node is a concatenating with an empty string.
 */
function isConcatWithEmptyString(node) {
  return node.operator === "+" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));
}

/**
 * Checks whether or not a node is appended with an empty string.
 * @param {ASTNode} node - An AssignmentExpression node to check.
 * @returns {boolean} Whether or not the node is appended with an empty string.
 */
function isAppendEmptyString(node) {
  return node.operator === "+=" && isEmptyString(node.right);
}

/**
 * Returns the operand that is not an empty string from a flagged BinaryExpression.
 * @param {ASTNode} node - The flagged BinaryExpression node to check.
 * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.
 */
function getNonEmptyOperand(node) {
  return isEmptyString(node.left) ? node.right : node.left;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow shorthand type conversions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implicit-coercion"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        boolean: {
          type: "boolean",
          default: true
        },
        number: {
          type: "boolean",
          default: true
        },
        string: {
          type: "boolean",
          default: true
        },
        allow: {
          type: "array",
          items: {
            enum: ALLOWABLE_OPERATORS
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = parseOptions(context.options[0] || {});
    const sourceCode = context.getSourceCode();

    /**
     * Reports an error and autofixes the node
     * @param {ASTNode} node - An ast node to report the error on.
     * @param {string} recommendation - The recommended code for the issue
     * @param {bool} shouldFix - Whether this report should fix the node
     * @returns {void}
     */
    function report(node, recommendation, shouldFix) {
      context.report({
        node,
        message: "use `{{recommendation}}` instead.",
        data: {
          recommendation
        },
        fix(fixer) {
          if (!shouldFix) {
            return null;
          }
          const tokenBefore = sourceCode.getTokenBefore(node);
          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
            return fixer.replaceText(node, ` ${recommendation}`);
          }
          return fixer.replaceText(node, recommendation);
        }
      });
    }
    return {
      UnaryExpression(node) {
        let operatorAllowed;

        // !!foo
        operatorAllowed = options.allow.indexOf("!!") >= 0;
        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
          report(node, recommendation, true);
        }

        // ~foo.indexOf(bar)
        operatorAllowed = options.allow.indexOf("~") >= 0;
        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
          const recommendation = `${sourceCode.getText(node.argument)} !== -1`;
          report(node, recommendation, false);
        }

        // +foo
        operatorAllowed = options.allow.indexOf("+") >= 0;
        if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
          const recommendation = `Number(${sourceCode.getText(node.argument)})`;
          report(node, recommendation, true);
        }
      },
      // Use `:exit` to prevent double reporting
      "BinaryExpression:exit"(node) {
        let operatorAllowed;

        // 1 * foo
        operatorAllowed = options.allow.indexOf("*") >= 0;
        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
        if (nonNumericOperand) {
          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
          report(node, recommendation, true);
        }

        // "" + foo
        operatorAllowed = options.allow.indexOf("+") >= 0;
        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
          report(node, recommendation, true);
        }
      },
      AssignmentExpression(node) {
        // foo += ""
        const operatorAllowed = options.allow.indexOf("+") >= 0;
        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
          const code = sourceCode.getText(getNonEmptyOperand(node));
          const recommendation = `${code} = String(${code})`;
          report(node, recommendation, true);
        }
      }
    };
  }
};

/***/ }),
/* 324 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for implicit global variables and functions.
 * @author Joshua Peek
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable and `function` declarations in the global scope",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implicit-globals"
    },
    schema: []
  },
  create(context) {
    return {
      Program() {
        const scope = context.getScope();
        scope.variables.forEach(variable => {
          if (variable.writeable) {
            return;
          }
          variable.defs.forEach(def => {
            if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
              context.report({
                node: def.node,
                message: "Implicit global variable, assign as global property instead."
              });
            }
          });
        });
        scope.implicit.variables.forEach(variable => {
          const scopeVariable = scope.set.get(variable.name);
          if (scopeVariable && scopeVariable.writeable) {
            return;
          }
          variable.defs.forEach(def => {
            context.report({
              node: def.node,
              message: "Implicit global variable, assign as global property instead."
            });
          });
        });
      }
    };
  }
};

/***/ }),
/* 325 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
 * @author James Allardice
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`-like methods",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-implied-eval"
    },
    schema: []
  },
  create(context) {
    const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/u;

    /*
     * Figures out if we should inspect a given binary expression. Is a stack
     * of stacks, where the first element in each substack is a CallExpression.
     */
    const impliedEvalAncestorsStack = [];

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Get the last element of an array, without modifying arr, like pop(), but non-destructive.
     * @param {Array} arr What to inspect
     * @returns {*} The last element of arr
     * @private
     */
    function last(arr) {
      return arr ? arr[arr.length - 1] : null;
    }

    /**
     * Checks if the given MemberExpression node is a potentially implied eval identifier on window.
     * @param {ASTNode} node The MemberExpression node to check.
     * @returns {boolean} Whether or not the given node is potentially an implied eval.
     * @private
     */
    function isImpliedEvalMemberExpression(node) {
      const object = node.object,
        property = node.property,
        hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);
      return object.name === "window" && hasImpliedEvalName;
    }

    /**
     * Determines if a node represents a call to a potentially implied eval.
     *
     * This checks the callee name and that there's an argument, but not the type of the argument.
     *
     * @param {ASTNode} node The CallExpression to check.
     * @returns {boolean} True if the node matches, false if not.
     * @private
     */
    function isImpliedEvalCallExpression(node) {
      const isMemberExpression = node.callee.type === "MemberExpression",
        isIdentifier = node.callee.type === "Identifier",
        isImpliedEvalCallee = isIdentifier && CALLEE_RE.test(node.callee.name) || isMemberExpression && isImpliedEvalMemberExpression(node.callee);
      return isImpliedEvalCallee && node.arguments.length;
    }

    /**
     * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.
     * @param {ASTNode} node The node to inspect the parent of.
     * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?
     * @private
     */
    function hasImpliedEvalParent(node) {
      // make sure our parent is marked
      return node.parent === last(last(impliedEvalAncestorsStack)) && (
      // if our parent is a CallExpression, make sure we're the first argument
      node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
    }

    /**
     * Checks if our parent is marked as part of an implied eval argument. If
     * so, collapses the top of impliedEvalAncestorsStack and reports on the
     * original CallExpression.
     * @param {ASTNode} node The CallExpression to check.
     * @returns {boolean} True if the node matches, false if not.
     * @private
     */
    function checkString(node) {
      if (hasImpliedEvalParent(node)) {
        // remove the entire substack, to avoid duplicate reports
        const substack = impliedEvalAncestorsStack.pop();
        context.report({
          node: substack[0],
          message: "Implied eval. Consider passing a function instead of a string."
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      CallExpression(node) {
        if (isImpliedEvalCallExpression(node)) {
          // call expressions create a new substack
          impliedEvalAncestorsStack.push([node]);
        }
      },
      "CallExpression:exit"(node) {
        if (node === last(last(impliedEvalAncestorsStack))) {
          /*
           * Destroys the entire sub-stack, rather than just using
           * last(impliedEvalAncestorsStack).pop(), as a CallExpression is
           * always the bottom of a impliedEvalAncestorsStack substack.
           */
          impliedEvalAncestorsStack.pop();
        }
      },
      BinaryExpression(node) {
        if (node.operator === "+" && hasImpliedEvalParent(node)) {
          last(impliedEvalAncestorsStack).push(node);
        }
      },
      "BinaryExpression:exit"(node) {
        if (node === last(last(impliedEvalAncestorsStack))) {
          last(impliedEvalAncestorsStack).pop();
        }
      },
      Literal(node) {
        if (typeof node.value === "string") {
          checkString(node);
        }
      },
      TemplateLiteral(node) {
        checkString(node);
      }
    };
  }
};

/***/ }),
/* 326 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Enforces or disallows inline comments.
 * @author Greg Cochard
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow inline comments after code",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-inline-comments"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Will check that comments are not on lines starting with or ending with code
     * @param {ASTNode} node The comment node to check
     * @private
     * @returns {void}
     */
    function testCodeAroundComment(node) {
      // Get the whole line and cut it off at the start of the comment
      const startLine = String(sourceCode.lines[node.loc.start.line - 1]);
      const endLine = String(sourceCode.lines[node.loc.end.line - 1]);
      const preamble = startLine.slice(0, node.loc.start.column).trim();

      // Also check after the comment
      const postamble = endLine.slice(node.loc.end.column).trim();

      // Check that this comment isn't an ESLint directive
      const isDirective = astUtils.isDirectiveComment(node);

      // Should be empty if there was only whitespace around the comment
      if (!isDirective && (preamble || postamble)) {
        context.report({
          node,
          message: "Unexpected comment inline with code."
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(testCodeAroundComment);
      }
    };
  }
};

/***/ }),
/* 327 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce declarations in program or function body root.
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow variable or `function` declarations in nested blocks",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-inner-declarations"
    },
    schema: [{
      enum: ["functions", "both"]
    }]
  },
  create(context) {
    /**
     * Find the nearest Program or Function ancestor node.
     * @returns {Object} Ancestor's type and distance from node.
     */
    function nearestBody() {
      const ancestors = context.getAncestors();
      let ancestor = ancestors.pop(),
        generation = 1;
      while (ancestor && ["Program", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(ancestor.type) < 0) {
        generation += 1;
        ancestor = ancestors.pop();
      }
      return {
        // Type of containing ancestor
        type: ancestor.type,
        // Separation between ancestor and node
        distance: generation
      };
    }

    /**
     * Ensure that a given node is at a program or function body's root.
     * @param {ASTNode} node Declaration node to check.
     * @returns {void}
     */
    function check(node) {
      const body = nearestBody(),
        valid = body.type === "Program" && body.distance === 1 || body.distance === 2;
      if (!valid) {
        context.report({
          node,
          message: "Move {{type}} declaration to {{body}} root.",
          data: {
            type: node.type === "FunctionDeclaration" ? "function" : "variable",
            body: body.type === "Program" ? "program" : "function body"
          }
        });
      }
    }
    return {
      FunctionDeclaration: check,
      VariableDeclaration(node) {
        if (context.options[0] === "both" && node.kind === "var") {
          check(node);
        }
      }
    };
  }
};

/***/ }),
/* 328 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Validate strings passed to the RegExp constructor
 * @author Michael Ficarra
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const RegExpValidator = (__webpack_require__(295).RegExpValidator);
const validator = new RegExpValidator({
  ecmaVersion: 2018
});
const validFlags = /[gimuys]/gu;
const undefined1 = void 0;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow invalid regular expression strings in `RegExp` constructors",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-invalid-regexp"
    },
    schema: [{
      type: "object",
      properties: {
        allowConstructorFlags: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = context.options[0];
    let allowedFlags = null;
    if (options && options.allowConstructorFlags) {
      const temp = options.allowConstructorFlags.join("").replace(validFlags, "");
      if (temp) {
        allowedFlags = new RegExp(`[${temp}]`, "giu");
      }
    }

    /**
     * Check if node is a string
     * @param {ASTNode} node node to evaluate
     * @returns {boolean} True if its a string
     * @private
     */
    function isString(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }

    /**
     * Check syntax error in a given pattern.
     * @param {string} pattern The RegExp pattern to validate.
     * @param {boolean} uFlag The Unicode flag.
     * @returns {string|null} The syntax error.
     */
    function validateRegExpPattern(pattern, uFlag) {
      try {
        validator.validatePattern(pattern, undefined1, undefined1, uFlag);
        return null;
      } catch (err) {
        return err.message;
      }
    }

    /**
     * Check syntax error in a given flags.
     * @param {string} flags The RegExp flags to validate.
     * @returns {string|null} The syntax error.
     */
    function validateRegExpFlags(flags) {
      try {
        validator.validateFlags(flags);
        return null;
      } catch (err) {
        return `Invalid flags supplied to RegExp constructor '${flags}'`;
      }
    }
    return {
      "CallExpression, NewExpression"(node) {
        if (node.callee.type !== "Identifier" || node.callee.name !== "RegExp" || !isString(node.arguments[0])) {
          return;
        }
        const pattern = node.arguments[0].value;
        let flags = isString(node.arguments[1]) ? node.arguments[1].value : "";
        if (allowedFlags) {
          flags = flags.replace(allowedFlags, "");
        }

        // If flags are unknown, check both are errored or not.
        const message = validateRegExpFlags(flags) || (flags ? validateRegExpPattern(pattern, flags.indexOf("u") !== -1) : validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false));
        if (message) {
          context.report({
            node,
            message: "{{message}}.",
            data: {
              message
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 329 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `this` keywords outside of classes or class-like objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-invalid-this"
    },
    schema: []
  },
  create(context) {
    const stack = [],
      sourceCode = context.getSourceCode();

    /**
     * Gets the current checking context.
     *
     * The return value has a flag that whether or not `this` keyword is valid.
     * The flag is initialized when got at the first time.
     *
     * @returns {{valid: boolean}}
     *   an object which has a flag that whether or not `this` keyword is valid.
     */
    stack.getCurrent = function () {
      const current = this[this.length - 1];
      if (!current.init) {
        current.init = true;
        current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode);
      }
      return current;
    };

    /**
     * Pushs new checking context into the stack.
     *
     * The checking context is not initialized yet.
     * Because most functions don't have `this` keyword.
     * When `this` keyword was found, the checking context is initialized.
     *
     * @param {ASTNode} node - A function node that was entered.
     * @returns {void}
     */
    function enterFunction(node) {
      // `this` can be invalid only under strict mode.
      stack.push({
        init: !context.getScope().isStrict,
        node,
        valid: true
      });
    }

    /**
     * Pops the current checking context from the stack.
     * @returns {void}
     */
    function exitFunction() {
      stack.pop();
    }
    return {
      /*
       * `this` is invalid only under strict mode.
       * Modules is always strict mode.
       */
      Program(node) {
        const scope = context.getScope(),
          features = context.parserOptions.ecmaFeatures || {};
        stack.push({
          init: true,
          node,
          valid: !(scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
        });
      },
      "Program:exit"() {
        stack.pop();
      },
      FunctionDeclaration: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      FunctionExpression: enterFunction,
      "FunctionExpression:exit": exitFunction,
      // Reports if `this` of the current context is invalid.
      ThisExpression(node) {
        const current = stack.getCurrent();
        if (current && !current.valid) {
          context.report({
            node,
            message: "Unexpected 'this'."
          });
        }
      }
    };
  }
};

/***/ }),
/* 330 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed
 * @author Jonathan Kingston
 * @author Christophe Porteneuve
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;
const IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu;
const IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mgu;
const LINE_BREAK = astUtils.createGlobalLinebreakMatcher();

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow irregular whitespace",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-irregular-whitespace"
    },
    schema: [{
      type: "object",
      properties: {
        skipComments: {
          type: "boolean",
          default: false
        },
        skipStrings: {
          type: "boolean",
          default: true
        },
        skipTemplates: {
          type: "boolean",
          default: false
        },
        skipRegExps: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    // Module store of errors that we have found
    let errors = [];

    // Lookup the `skipComments` option, which defaults to `false`.
    const options = context.options[0] || {};
    const skipComments = !!options.skipComments;
    const skipStrings = options.skipStrings !== false;
    const skipRegExps = !!options.skipRegExps;
    const skipTemplates = !!options.skipTemplates;
    const sourceCode = context.getSourceCode();
    const commentNodes = sourceCode.getAllComments();

    /**
     * Removes errors that occur inside a string node
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */
    function removeWhitespaceError(node) {
      const locStart = node.loc.start;
      const locEnd = node.loc.end;
      errors = errors.filter(_ref => {
        let {
          loc: errorLoc
        } = _ref;
        if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
          if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
            return false;
          }
        }
        return true;
      });
    }

    /**
     * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */
    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
      const shouldCheckStrings = skipStrings && typeof node.value === "string";
      const shouldCheckRegExps = skipRegExps && Boolean(node.regex);
      if (shouldCheckStrings || shouldCheckRegExps) {
        // If we have irregular characters remove them from the errors list
        if (ALL_IRREGULARS.test(node.raw)) {
          removeWhitespaceError(node);
        }
      }
    }

    /**
     * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */
    function removeInvalidNodeErrorsInTemplateLiteral(node) {
      if (typeof node.value.raw === "string") {
        if (ALL_IRREGULARS.test(node.value.raw)) {
          removeWhitespaceError(node);
        }
      }
    }

    /**
     * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
     * @param {ASTNode} node to check for matching errors.
     * @returns {void}
     * @private
     */
    function removeInvalidNodeErrorsInComment(node) {
      if (ALL_IRREGULARS.test(node.value)) {
        removeWhitespaceError(node);
      }
    }

    /**
     * Checks the program source for irregular whitespace
     * @param {ASTNode} node The program node
     * @returns {void}
     * @private
     */
    function checkForIrregularWhitespace(node) {
      const sourceLines = sourceCode.lines;
      sourceLines.forEach((sourceLine, lineIndex) => {
        const lineNumber = lineIndex + 1;
        let match;
        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
          const location = {
            line: lineNumber,
            column: match.index
          };
          errors.push({
            node,
            message: "Irregular whitespace not allowed.",
            loc: location
          });
        }
      });
    }

    /**
     * Checks the program source for irregular line terminators
     * @param {ASTNode} node The program node
     * @returns {void}
     * @private
     */
    function checkForIrregularLineTerminators(node) {
      const source = sourceCode.getText(),
        sourceLines = sourceCode.lines,
        linebreaks = source.match(LINE_BREAK);
      let lastLineIndex = -1,
        match;
      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
        const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
        const location = {
          line: lineIndex + 1,
          column: sourceLines[lineIndex].length
        };
        errors.push({
          node,
          message: "Irregular whitespace not allowed.",
          loc: location
        });
        lastLineIndex = lineIndex;
      }
    }

    /**
     * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.
     * @returns {void}
     * @private
     */
    function noop() {}
    const nodes = {};
    if (ALL_IRREGULARS.test(sourceCode.getText())) {
      nodes.Program = function (node) {
        /*
         * As we can easily fire warnings for all white space issues with
         * all the source its simpler to fire them here.
         * This means we can check all the application code without having
         * to worry about issues caused in the parser tokens.
         * When writing this code also evaluating per node was missing out
         * connecting tokens in some cases.
         * We can later filter the errors when they are found to be not an
         * issue in nodes we don't care about.
         */
        checkForIrregularWhitespace(node);
        checkForIrregularLineTerminators(node);
      };
      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
      nodes["Program:exit"] = function () {
        if (skipComments) {
          // First strip errors occurring in comment nodes.
          commentNodes.forEach(removeInvalidNodeErrorsInComment);
        }

        // If we have any errors remaining report on them
        errors.forEach(error => context.report(error));
      };
    } else {
      nodes.Program = noop;
    }
    return nodes;
  }
};

/***/ }),
/* 331 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag usage of __iterator__ property
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__iterator__` property",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-iterator"
    },
    schema: []
  },
  create(context) {
    return {
      MemberExpression(node) {
        if (node.property && node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed || node.property.type === "Literal" && node.property.value === "__iterator__") {
          context.report({
            node,
            message: "Reserved name '__iterator__'."
          });
        }
      }
    };
  }
};

/***/ }),
/* 332 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag labels that are the same as an identifier
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labels that share a name with a variable",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-label-var"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Check if the identifier is present inside current scope
     * @param {Object} scope current scope
     * @param {string} name To evaluate
     * @returns {boolean} True if its present
     * @private
     */
    function findIdentifier(scope, name) {
      return astUtils.getVariableByName(scope, name) !== null;
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      LabeledStatement(node) {
        // Fetch the innermost scope.
        const scope = context.getScope();

        /*
         * Recursively find the identifier walking up the scope, starting
         * with the innermost scope.
         */
        if (findIdentifier(scope, node.label.name)) {
          context.report({
            node,
            message: "Found identifier with same name as label."
          });
        }
      }
    };
  }
};

/***/ }),
/* 333 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallow Labeled Statements
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labeled statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-labels"
    },
    schema: [{
      type: "object",
      properties: {
        allowLoop: {
          type: "boolean",
          default: false
        },
        allowSwitch: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = context.options[0];
    const allowLoop = options && options.allowLoop;
    const allowSwitch = options && options.allowSwitch;
    let scopeInfo = null;

    /**
     * Gets the kind of a given node.
     *
     * @param {ASTNode} node - A node to get.
     * @returns {string} The kind of the node.
     */
    function getBodyKind(node) {
      if (astUtils.isLoop(node)) {
        return "loop";
      }
      if (node.type === "SwitchStatement") {
        return "switch";
      }
      return "other";
    }

    /**
     * Checks whether the label of a given kind is allowed or not.
     *
     * @param {string} kind - A kind to check.
     * @returns {boolean} `true` if the kind is allowed.
     */
    function isAllowed(kind) {
      switch (kind) {
        case "loop":
          return allowLoop;
        case "switch":
          return allowSwitch;
        default:
          return false;
      }
    }

    /**
     * Checks whether a given name is a label of a loop or not.
     *
     * @param {string} label - A name of a label to check.
     * @returns {boolean} `true` if the name is a label of a loop.
     */
    function getKind(label) {
      let info = scopeInfo;
      while (info) {
        if (info.label === label) {
          return info.kind;
        }
        info = info.upper;
      }

      /* istanbul ignore next: syntax error */
      return "other";
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      LabeledStatement(node) {
        scopeInfo = {
          label: node.label.name,
          kind: getBodyKind(node.body),
          upper: scopeInfo
        };
      },
      "LabeledStatement:exit"(node) {
        if (!isAllowed(scopeInfo.kind)) {
          context.report({
            node,
            message: "Unexpected labeled statement."
          });
        }
        scopeInfo = scopeInfo.upper;
      },
      BreakStatement(node) {
        if (node.label && !isAllowed(getKind(node.label.name))) {
          context.report({
            node,
            message: "Unexpected label in break statement."
          });
        }
      },
      ContinueStatement(node) {
        if (node.label && !isAllowed(getKind(node.label.name))) {
          context.report({
            node,
            message: "Unexpected label in continue statement."
          });
        }
      }
    };
  }
};

/***/ }),
/* 334 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag blocks with no reason to exist
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary nested blocks",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-lone-blocks"
    },
    schema: []
  },
  create(context) {
    // A stack of lone blocks to be checked for block-level bindings
    const loneBlocks = [];
    let ruleDef;

    /**
     * Reports a node as invalid.
     * @param {ASTNode} node - The node to be reported.
     * @returns {void}
     */
    function report(node) {
      const message = node.parent.type === "BlockStatement" ? "Nested block is redundant." : "Block is redundant.";
      context.report({
        node,
        message
      });
    }

    /**
     * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear
     * @param {ASTNode} node The node to check
     * @returns {boolean} True if the node is a lone block.
     */
    function isLoneBlock(node) {
      return node.parent.type === "BlockStatement" || node.parent.type === "Program" ||
      // Don't report blocks in switch cases if the block is the only statement of the case.
      node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
    }

    /**
     * Checks the enclosing block of the current node for block-level bindings,
     * and "marks it" as valid if any.
     * @returns {void}
     */
    function markLoneBlock() {
      if (loneBlocks.length === 0) {
        return;
      }
      const block = context.getAncestors().pop();
      if (loneBlocks[loneBlocks.length - 1] === block) {
        loneBlocks.pop();
      }
    }

    // Default rule definition: report all lone blocks
    ruleDef = {
      BlockStatement(node) {
        if (isLoneBlock(node)) {
          report(node);
        }
      }
    };

    // ES6: report blocks without block-level bindings
    if (context.parserOptions.ecmaVersion >= 6) {
      ruleDef = {
        BlockStatement(node) {
          if (isLoneBlock(node)) {
            loneBlocks.push(node);
          }
        },
        "BlockStatement:exit"(node) {
          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
            loneBlocks.pop();
            report(node);
          }
        }
      };
      ruleDef.VariableDeclaration = function (node) {
        if (node.kind === "let" || node.kind === "const") {
          markLoneBlock();
        }
      };
      ruleDef.FunctionDeclaration = function () {
        if (context.getScope().isStrict) {
          markLoneBlock();
        }
      };
      ruleDef.ClassDeclaration = markLoneBlock;
    }
    return ruleDef;
  }
};

/***/ }),
/* 335 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow if as the only statmenet in an else block
 * @author Brandon Mills
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `if` statements as the only statement in `else` blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-lonely-if"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      IfStatement(node) {
        const ancestors = context.getAncestors(),
          parent = ancestors.pop(),
          grandparent = ancestors.pop();
        if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
          context.report({
            node,
            message: "Unexpected if as the only statement in an else block.",
            fix(fixer) {
              const openingElseCurly = sourceCode.getFirstToken(parent);
              const closingElseCurly = sourceCode.getLastToken(parent);
              const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
              const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
              const lastIfToken = sourceCode.getLastToken(node.consequent);
              const sourceText = sourceCode.getText();
              if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)
                return null;
              }
              if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
                /*
                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing
                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.
                 */
                return null;
              }
              return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node));
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 336 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag creation of function inside a loop
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the containing loop node of a specified node.
 *
 * We don't need to check nested functions, so this ignores those.
 * `Scope.through` contains references of nested functions.
 *
 * @param {ASTNode} node - An AST node to get.
 * @returns {ASTNode|null} The containing loop node of the specified node, or
 *      `null`.
 */
function getContainingLoopNode(node) {
  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {
    const parent = currentNode.parent;
    switch (parent.type) {
      case "WhileStatement":
      case "DoWhileStatement":
        return parent;
      case "ForStatement":
        // `init` is outside of the loop.
        if (parent.init !== currentNode) {
          return parent;
        }
        break;
      case "ForInStatement":
      case "ForOfStatement":
        // `right` is outside of the loop.
        if (parent.right !== currentNode) {
          return parent;
        }
        break;
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration":
        // We don't need to check nested functions.
        return null;
      default:
        break;
    }
  }
  return null;
}

/**
 * Gets the containing loop node of a given node.
 * If the loop was nested, this returns the most outer loop.
 *
 * @param {ASTNode} node - A node to get. This is a loop node.
 * @param {ASTNode|null} excludedNode - A node that the result node should not
 *      include.
 * @returns {ASTNode} The most outer loop node.
 */
function getTopLoopNode(node, excludedNode) {
  const border = excludedNode ? excludedNode.range[1] : 0;
  let retv = node;
  let containingLoopNode = node;
  while (containingLoopNode && containingLoopNode.range[0] >= border) {
    retv = containingLoopNode;
    containingLoopNode = getContainingLoopNode(containingLoopNode);
  }
  return retv;
}

/**
 * Checks whether a given reference which refers to an upper scope's variable is
 * safe or not.
 *
 * @param {ASTNode} loopNode - A containing loop node.
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the reference is safe or not.
 */
function isSafe(loopNode, reference) {
  const variable = reference.resolved;
  const definition = variable && variable.defs[0];
  const declaration = definition && definition.parent;
  const kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";

  // Variables which are declared by `const` is safe.
  if (kind === "const") {
    return true;
  }

  /*
   * Variables which are declared by `let` in the loop is safe.
   * It's a different instance from the next loop step's.
   */
  if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
    return true;
  }

  /*
   * WriteReferences which exist after this border are unsafe because those
   * can modify the variable.
   */
  const border = getTopLoopNode(loopNode, kind === "let" ? declaration : null).range[0];

  /**
   * Checks whether a given reference is safe or not.
   * The reference is every reference of the upper scope's variable we are
   * looking now.
   *
   * It's safeafe if the reference matches one of the following condition.
   * - is readonly.
   * - doesn't exist inside a local function and after the border.
   *
   * @param {eslint-scope.Reference} upperRef - A reference to check.
   * @returns {boolean} `true` if the reference is safe.
   */
  function isSafeReference(upperRef) {
    const id = upperRef.identifier;
    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
  }
  return Boolean(variable) && variable.references.every(isSafeReference);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `function` declarations and expressions inside loop statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-loop-func"
    },
    schema: []
  },
  create(context) {
    /**
     * Reports functions which match the following condition:
     *
     * - has a loop node in ancestors.
     * - has any references which refers to an unsafe variable.
     *
     * @param {ASTNode} node The AST node to check.
     * @returns {boolean} Whether or not the node is within a loop.
     */
    function checkForLoops(node) {
      const loopNode = getContainingLoopNode(node);
      if (!loopNode) {
        return;
      }
      const references = context.getScope().through;
      if (references.length > 0 && !references.every(isSafe.bind(null, loopNode))) {
        context.report({
          node,
          message: "Don't make functions within a loop."
        });
      }
    }
    return {
      ArrowFunctionExpression: checkForLoops,
      FunctionExpression: checkForLoops,
      FunctionDeclaration: checkForLoops
    };
  }
};

/***/ }),
/* 337 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)
 * @author Vincent Lemeunier
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow magic numbers",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-magic-numbers"
    },
    schema: [{
      type: "object",
      properties: {
        detectObjects: {
          type: "boolean",
          default: false
        },
        enforceConst: {
          type: "boolean",
          default: false
        },
        ignore: {
          type: "array",
          items: {
            type: "number"
          },
          uniqueItems: true
        },
        ignoreArrayIndexes: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      useConst: "Number constants declarations must use 'const'.",
      noMagic: "No magic number: {{raw}}."
    }
  },
  create(context) {
    const config = context.options[0] || {},
      detectObjects = !!config.detectObjects,
      enforceConst = !!config.enforceConst,
      ignore = config.ignore || [],
      ignoreArrayIndexes = !!config.ignoreArrayIndexes;

    /**
     * Returns whether the node is number literal
     * @param {Node} node - the node literal being evaluated
     * @returns {boolean} true if the node is a number literal
     */
    function isNumber(node) {
      return typeof node.value === "number";
    }

    /**
     * Returns whether the number should be ignored
     * @param {number} num - the number
     * @returns {boolean} true if the number should be ignored
     */
    function shouldIgnoreNumber(num) {
      return ignore.indexOf(num) !== -1;
    }

    /**
     * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()
     * @param {ASTNode} parent - the non-"UnaryExpression" parent
     * @param {ASTNode} node - the node literal being evaluated
     * @returns {boolean} true if the number should be ignored
     */
    function shouldIgnoreParseInt(parent, node) {
      return parent.type === "CallExpression" && node === parent.arguments[1] && (parent.callee.name === "parseInt" || parent.callee.type === "MemberExpression" && parent.callee.object.name === "Number" && parent.callee.property.name === "parseInt");
    }

    /**
     * Returns whether the number should be ignored when used to define a JSX prop
     * @param {ASTNode} parent - the non-"UnaryExpression" parent
     * @returns {boolean} true if the number should be ignored
     */
    function shouldIgnoreJSXNumbers(parent) {
      return parent.type.indexOf("JSX") === 0;
    }

    /**
     * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.
     * @param {ASTNode} parent - the non-"UnaryExpression" parent.
     * @returns {boolean} true if the number should be ignored
     */
    function shouldIgnoreArrayIndexes(parent) {
      return parent.type === "MemberExpression" && ignoreArrayIndexes;
    }
    return {
      Literal(node) {
        const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
        if (!isNumber(node)) {
          return;
        }
        let fullNumberNode;
        let parent;
        let value;
        let raw;

        // For negative magic numbers: update the value and parent node
        if (node.parent.type === "UnaryExpression" && node.parent.operator === "-") {
          fullNumberNode = node.parent;
          parent = fullNumberNode.parent;
          value = -node.value;
          raw = `-${node.raw}`;
        } else {
          fullNumberNode = node;
          parent = node.parent;
          value = node.value;
          raw = node.raw;
        }
        if (shouldIgnoreNumber(value) || shouldIgnoreParseInt(parent, fullNumberNode) || shouldIgnoreArrayIndexes(parent) || shouldIgnoreJSXNumbers(parent)) {
          return;
        }
        if (parent.type === "VariableDeclarator") {
          if (enforceConst && parent.parent.kind !== "const") {
            context.report({
              node: fullNumberNode,
              messageId: "useConst"
            });
          }
        } else if (okTypes.indexOf(parent.type) === -1 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
          context.report({
            node: fullNumberNode,
            messageId: "noMagic",
            data: {
              raw
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 338 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */


const {
  CALL,
  CONSTRUCT,
  ReferenceTracker,
  getStringIfConstant
} = __webpack_require__(339);
const {
  RegExpParser,
  visitRegExpAST
} = __webpack_require__(295);
const {
  isCombiningCharacter,
  isEmojiModifier,
  isRegionalIndicatorSymbol,
  isSurrogatePair
} = __webpack_require__(340);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Iterate character sequences of a given nodes.
 *
 * CharacterClassRange syntax can steal a part of character sequence,
 * so this function reverts CharacterClassRange syntax and restore the sequence.
 *
 * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.
 * @returns {IterableIterator<number[]>} The list of character sequences.
 */
function* iterateCharacterSequence(nodes) {
  let seq = [];
  for (const node of nodes) {
    switch (node.type) {
      case "Character":
        seq.push(node.value);
        break;
      case "CharacterClassRange":
        seq.push(node.min.value);
        yield seq;
        seq = [node.max.value];
        break;
      case "CharacterSet":
        if (seq.length > 0) {
          yield seq;
          seq = [];
        }
        break;

      // no default
    }
  }
  if (seq.length > 0) {
    yield seq;
  }
}
const hasCharacterSequence = {
  surrogatePairWithoutUFlag(chars) {
    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));
  },
  combiningClass(chars) {
    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));
  },
  emojiModifier(chars) {
    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));
  },
  regionalIndicatorSymbol(chars) {
    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));
  },
  zwj(chars) {
    const lastIndex = chars.length - 1;
    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);
  }
};
const kinds = Object.keys(hasCharacterSequence);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow characters which are made with multiple code points in character class syntax",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-misleading-character-class"
    },
    schema: [],
    messages: {
      surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
      combiningClass: "Unexpected combined character in character class.",
      emojiModifier: "Unexpected modified Emoji in character class.",
      regionalIndicatorSymbol: "Unexpected national flag in character class.",
      zwj: "Unexpected joined character sequence in character class."
    }
  },
  create(context) {
    const parser = new RegExpParser();

    /**
     * Verify a given regular expression.
     * @param {Node} node The node to report.
     * @param {string} pattern The regular expression pattern to verify.
     * @param {string} flags The flags of the regular expression.
     * @returns {void}
     */
    function verify(node, pattern, flags) {
      const patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
      const has = {
        surrogatePairWithoutUFlag: false,
        combiningClass: false,
        variationSelector: false,
        emojiModifier: false,
        regionalIndicatorSymbol: false,
        zwj: false
      };
      visitRegExpAST(patternNode, {
        onCharacterClassEnter(ccNode) {
          for (const chars of iterateCharacterSequence(ccNode.elements)) {
            for (const kind of kinds) {
              has[kind] = has[kind] || hasCharacterSequence[kind](chars);
            }
          }
        }
      });
      for (const kind of kinds) {
        if (has[kind]) {
          context.report({
            node,
            messageId: kind
          });
        }
      }
    }
    return {
      "Literal[regex]"(node) {
        verify(node, node.regex.pattern, node.regex.flags);
      },
      "Program"() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker(scope);

        /*
         * Iterate calls of RegExp.
         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,
         *       `const {RegExp: a} = window; new a()`, etc...
         */
        for (const {
          node
        } of tracker.iterateGlobalReferences({
          RegExp: {
            [CALL]: true,
            [CONSTRUCT]: true
          }
        })) {
          const [patternNode, flagsNode] = node.arguments;
          const pattern = getStringIfConstant(patternNode, scope);
          const flags = getStringIfConstant(flagsNode, scope);
          if (typeof pattern === "string") {
            verify(node, pattern, flags || "");
          }
        }
      }
    };
  }
};

/***/ }),
/* 339 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*! @author Toru Nagashima <https://github.com/mysticatea> */


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
var evk = _interopDefault(__webpack_require__(89));

/**
 * Get the innermost scope which contains a given location.
 * @param {Scope} initialScope The initial scope to search.
 * @param {Node} node The location to search.
 * @returns {Scope} The innermost scope.
 */
function getInnermostScope(initialScope, node) {
  const location = node.range[0];
  let scope = initialScope;
  let found = false;
  do {
    found = false;
    for (const childScope of scope.childScopes) {
      const range = childScope.block.range;
      if (range[0] <= location && location < range[1]) {
        scope = childScope;
        found = true;
        break;
      }
    }
  } while (found);
  return scope;
}

/**
 * Find the variable of a given name.
 * @param {Scope} initialScope The scope to start finding.
 * @param {string|Node} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.
 * @returns {Variable|null} The found variable or null.
 */
function findVariable(initialScope, nameOrNode) {
  let name = "";
  let scope = initialScope;
  if (typeof nameOrNode === "string") {
    name = nameOrNode;
  } else {
    name = nameOrNode.name;
    scope = getInnermostScope(scope, nameOrNode);
  }
  while (scope != null) {
    const variable = scope.set.get(name);
    if (variable != null) {
      return variable;
    }
    scope = scope.upper;
  }
  return null;
}

/**
 * Negate the result of `this` calling.
 * @param {Token} token The token to check.
 * @returns {boolean} `true` if the result of `this(token)` is `false`.
 */
function negate0(token) {
  return !this(token); //eslint-disable-line no-invalid-this
}

/**
 * Creates the negate function of the given function.
 * @param {function(Token):boolean} f - The function to negate.
 * @returns {function(Token):boolean} Negated function.
 */
function negate(f) {
  return negate0.bind(f);
}

/**
 * Checks if the given token is an arrow token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an arrow token.
 */
function isArrowToken(token) {
  return token.value === "=>" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comma token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comma token.
 */
function isCommaToken(token) {
  return token.value === "," && token.type === "Punctuator";
}

/**
 * Checks if the given token is a semicolon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a semicolon token.
 */
function isSemicolonToken(token) {
  return token.value === ";" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a colon token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a colon token.
 */
function isColonToken(token) {
  return token.value === ":" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening parenthesis token.
 */
function isOpeningParenToken(token) {
  return token.value === "(" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing parenthesis token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing parenthesis token.
 */
function isClosingParenToken(token) {
  return token.value === ")" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening square bracket token.
 */
function isOpeningBracketToken(token) {
  return token.value === "[" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing square bracket token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing square bracket token.
 */
function isClosingBracketToken(token) {
  return token.value === "]" && token.type === "Punctuator";
}

/**
 * Checks if the given token is an opening brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is an opening brace token.
 */
function isOpeningBraceToken(token) {
  return token.value === "{" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a closing brace token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a closing brace token.
 */
function isClosingBraceToken(token) {
  return token.value === "}" && token.type === "Punctuator";
}

/**
 * Checks if the given token is a comment token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a comment token.
 */
function isCommentToken(token) {
  return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}
const isNotArrowToken = negate(isArrowToken);
const isNotCommaToken = negate(isCommaToken);
const isNotSemicolonToken = negate(isSemicolonToken);
const isNotColonToken = negate(isColonToken);
const isNotOpeningParenToken = negate(isOpeningParenToken);
const isNotClosingParenToken = negate(isClosingParenToken);
const isNotOpeningBracketToken = negate(isOpeningBracketToken);
const isNotClosingBracketToken = negate(isClosingBracketToken);
const isNotOpeningBraceToken = negate(isOpeningBraceToken);
const isNotClosingBraceToken = negate(isClosingBraceToken);
const isNotCommentToken = negate(isCommentToken);

/**
 * Get the `(` token of the given function node.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {Token} `(` token.
 */
function getOpeningParenOfParams(node, sourceCode) {
  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
}

/**
 * Get the location of the given function node for reporting.
 * @param {Node} node - The function node to get.
 * @param {SourceCode} sourceCode - The source code object to get tokens.
 * @returns {string} The location of the function node for reporting.
 */
function getFunctionHeadLocation(node, sourceCode) {
  const parent = node.parent;
  let start = null;
  let end = null;
  if (node.type === "ArrowFunctionExpression") {
    const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
    start = arrowToken.loc.start;
    end = arrowToken.loc.end;
  } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
    start = parent.loc.start;
    end = getOpeningParenOfParams(node, sourceCode).loc.start;
  } else {
    start = node.loc.start;
    end = getOpeningParenOfParams(node, sourceCode).loc.start;
  }
  return {
    start: Object.assign({}, start),
    end: Object.assign({}, end)
  };
}

/* globals BigInt, globalThis, global, self, window */

const globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {};
const builtinNames = Object.freeze(new Set(["Array", "ArrayBuffer", "BigInt", "BigInt64Array", "BigUint64Array", "Boolean", "DataView", "Date", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "Float32Array", "Float64Array", "Function", "Infinity", "Int16Array", "Int32Array", "Int8Array", "isFinite", "isNaN", "isPrototypeOf", "JSON", "Map", "Math", "NaN", "Number", "Object", "parseFloat", "parseInt", "Promise", "Proxy", "Reflect", "RegExp", "Set", "String", "Symbol", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "undefined", "unescape", "WeakMap", "WeakSet"]));
const callAllowed = new Set([Array.isArray, typeof BigInt === "function" ? BigInt : undefined, Boolean, Date, Date.parse, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, escape, isFinite, isNaN, isPrototypeOf, ...Object.getOwnPropertyNames(Math).map(k => Math[k]).filter(f => typeof f === "function"), Number, Number.isFinite, Number.isNaN, Number.parseFloat, Number.parseInt, Object, Object.entries, Object.is, Object.isExtensible, Object.isFrozen, Object.isSealed, Object.keys, Object.values, parseFloat, parseInt, RegExp, String, String.fromCharCode, String.fromCodePoint, String.raw, Symbol, Symbol.for, Symbol.keyFor, unescape].filter(f => typeof f === "function"));
const callPassThrough = new Set([Object.freeze, Object.preventExtensions, Object.seal]);

/**
 * Get the property descriptor.
 * @param {object} object The object to get.
 * @param {string|number|symbol} name The property name to get.
 */
function getPropertyDescriptor(object, name) {
  let x = object;
  while ((typeof x === "object" || typeof x === "function") && x !== null) {
    const d = Object.getOwnPropertyDescriptor(x, name);
    if (d) {
      return d;
    }
    x = Object.getPrototypeOf(x);
  }
  return null;
}

/**
 * Check if a property is getter or not.
 * @param {object} object The object to check.
 * @param {string|number|symbol} name The property name to check.
 */
function isGetter(object, name) {
  const d = getPropertyDescriptor(object, name);
  return d != null && d.get != null;
}

/**
 * Get the element values of a given node list.
 * @param {Node[]} nodeList The node list to get values.
 * @param {Scope|undefined} initialScope The initial scope to find variables.
 * @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.
 */
function getElementValues(nodeList, initialScope) {
  const valueList = [];
  for (let i = 0; i < nodeList.length; ++i) {
    const elementNode = nodeList[i];
    if (elementNode == null) {
      valueList.length = i + 1;
    } else if (elementNode.type === "SpreadElement") {
      const argument = getStaticValueR(elementNode.argument, initialScope);
      if (argument == null) {
        return null;
      }
      valueList.push(...argument.value);
    } else {
      const element = getStaticValueR(elementNode, initialScope);
      if (element == null) {
        return null;
      }
      valueList.push(element.value);
    }
  }
  return valueList;
}
const operations = Object.freeze({
  ArrayExpression(node, initialScope) {
    const elements = getElementValues(node.elements, initialScope);
    return elements != null ? {
      value: elements
    } : null;
  },
  AssignmentExpression(node, initialScope) {
    if (node.operator === "=") {
      return getStaticValueR(node.right, initialScope);
    }
    return null;
  },
  //eslint-disable-next-line complexity
  BinaryExpression(node, initialScope) {
    if (node.operator === "in" || node.operator === "instanceof") {
      // Not supported.
      return null;
    }
    const left = getStaticValueR(node.left, initialScope);
    const right = getStaticValueR(node.right, initialScope);
    if (left != null && right != null) {
      switch (node.operator) {
        case "==":
          return {
            value: left.value == right.value
          };
        //eslint-disable-line eqeqeq
        case "!=":
          return {
            value: left.value != right.value
          };
        //eslint-disable-line eqeqeq
        case "===":
          return {
            value: left.value === right.value
          };
        case "!==":
          return {
            value: left.value !== right.value
          };
        case "<":
          return {
            value: left.value < right.value
          };
        case "<=":
          return {
            value: left.value <= right.value
          };
        case ">":
          return {
            value: left.value > right.value
          };
        case ">=":
          return {
            value: left.value >= right.value
          };
        case "<<":
          return {
            value: left.value << right.value
          };
        case ">>":
          return {
            value: left.value >> right.value
          };
        case ">>>":
          return {
            value: left.value >>> right.value
          };
        case "+":
          return {
            value: left.value + right.value
          };
        case "-":
          return {
            value: left.value - right.value
          };
        case "*":
          return {
            value: left.value * right.value
          };
        case "/":
          return {
            value: left.value / right.value
          };
        case "%":
          return {
            value: left.value % right.value
          };
        case "**":
          return {
            value: Math.pow(left.value, right.value)
          };
        case "|":
          return {
            value: left.value | right.value
          };
        case "^":
          return {
            value: left.value ^ right.value
          };
        case "&":
          return {
            value: left.value & right.value
          };

        // no default
      }
    }
    return null;
  },
  CallExpression(node, initialScope) {
    const calleeNode = node.callee;
    const args = getElementValues(node.arguments, initialScope);
    if (args != null) {
      if (calleeNode.type === "MemberExpression") {
        const object = getStaticValueR(calleeNode.object, initialScope);
        const property = calleeNode.computed ? getStaticValueR(calleeNode.property, initialScope) : {
          value: calleeNode.property.name
        };
        if (object != null && property != null) {
          const receiver = object.value;
          const methodName = property.value;
          if (callAllowed.has(receiver[methodName])) {
            return {
              value: receiver[methodName](...args)
            };
          }
          if (callPassThrough.has(receiver[methodName])) {
            return {
              value: args[0]
            };
          }
        }
      } else {
        const callee = getStaticValueR(calleeNode, initialScope);
        if (callee != null) {
          const func = callee.value;
          if (callAllowed.has(func)) {
            return {
              value: func(...args)
            };
          }
          if (callPassThrough.has(func)) {
            return {
              value: args[0]
            };
          }
        }
      }
    }
    return null;
  },
  ConditionalExpression(node, initialScope) {
    const test = getStaticValueR(node.test, initialScope);
    if (test != null) {
      return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
    }
    return null;
  },
  ExpressionStatement(node, initialScope) {
    return getStaticValueR(node.expression, initialScope);
  },
  Identifier(node, initialScope) {
    if (initialScope != null) {
      const variable = findVariable(initialScope, node);

      // Built-in globals.
      if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
        return {
          value: globalObject[variable.name]
        };
      }

      // Constants.
      if (variable != null && variable.defs.length === 1) {
        const def = variable.defs[0];
        if (def.parent && def.parent.kind === "const" &&
        // TODO(mysticatea): don't support destructuring here.
        def.node.id.type === "Identifier") {
          return getStaticValueR(def.node.init, initialScope);
        }
      }
    }
    return null;
  },
  Literal(node) {
    //istanbul ignore if : this is implementation-specific behavior.
    if ((node.regex != null || node.bigint != null) && node.value == null) {
      // It was a RegExp/BigInt literal, but Node.js didn't support it.
      return null;
    }
    return {
      value: node.value
    };
  },
  LogicalExpression(node, initialScope) {
    const left = getStaticValueR(node.left, initialScope);
    if (left != null) {
      if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false) {
        return left;
      }
      const right = getStaticValueR(node.right, initialScope);
      if (right != null) {
        return right;
      }
    }
    return null;
  },
  MemberExpression(node, initialScope) {
    const object = getStaticValueR(node.object, initialScope);
    const property = node.computed ? getStaticValueR(node.property, initialScope) : {
      value: node.property.name
    };
    if (object != null && property != null && !isGetter(object.value, property.value)) {
      return {
        value: object.value[property.value]
      };
    }
    return null;
  },
  NewExpression(node, initialScope) {
    const callee = getStaticValueR(node.callee, initialScope);
    const args = getElementValues(node.arguments, initialScope);
    if (callee != null && args != null) {
      const Func = callee.value;
      if (callAllowed.has(Func)) {
        return {
          value: new Func(...args)
        };
      }
    }
    return null;
  },
  ObjectExpression(node, initialScope) {
    const object = {};
    for (const propertyNode of node.properties) {
      if (propertyNode.type === "Property") {
        if (propertyNode.kind !== "init") {
          return null;
        }
        const key = propertyNode.computed ? getStaticValueR(propertyNode.key, initialScope) : {
          value: propertyNode.key.name
        };
        const value = getStaticValueR(propertyNode.value, initialScope);
        if (key == null || value == null) {
          return null;
        }
        object[key.value] = value.value;
      } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
        const argument = getStaticValueR(propertyNode.argument, initialScope);
        if (argument == null) {
          return null;
        }
        Object.assign(object, argument.value);
      } else {
        return null;
      }
    }
    return {
      value: object
    };
  },
  SequenceExpression(node, initialScope) {
    const last = node.expressions[node.expressions.length - 1];
    return getStaticValueR(last, initialScope);
  },
  TaggedTemplateExpression(node, initialScope) {
    const tag = getStaticValueR(node.tag, initialScope);
    const expressions = getElementValues(node.quasi.expressions, initialScope);
    if (tag != null && expressions != null) {
      const func = tag.value;
      const strings = node.quasi.quasis.map(q => q.value.cooked);
      strings.raw = node.quasi.quasis.map(q => q.value.raw);
      if (func === String.raw) {
        return {
          value: func(strings, ...expressions)
        };
      }
    }
    return null;
  },
  TemplateLiteral(node, initialScope) {
    const expressions = getElementValues(node.expressions, initialScope);
    if (expressions != null) {
      let value = node.quasis[0].value.cooked;
      for (let i = 0; i < expressions.length; ++i) {
        value += expressions[i];
        value += node.quasis[i + 1].value.cooked;
      }
      return {
        value
      };
    }
    return null;
  },
  UnaryExpression(node, initialScope) {
    if (node.operator === "delete") {
      // Not supported.
      return null;
    }
    if (node.operator === "void") {
      return {
        value: undefined
      };
    }
    const arg = getStaticValueR(node.argument, initialScope);
    if (arg != null) {
      switch (node.operator) {
        case "-":
          return {
            value: -arg.value
          };
        case "+":
          return {
            value: +arg.value
          };
        //eslint-disable-line no-implicit-coercion
        case "!":
          return {
            value: !arg.value
          };
        case "~":
          return {
            value: ~arg.value
          };
        case "typeof":
          return {
            value: typeof arg.value
          };

        // no default
      }
    }
    return null;
  }
});

/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope|undefined} initialScope The scope to start finding variable.
 * @returns {{value:any}|null} The static value of the node, or `null`.
 */
function getStaticValueR(node, initialScope) {
  if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
    return operations[node.type](node, initialScope);
  }
  return null;
}

/**
 * Get the value of a given node if it's a static value.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.
 * @returns {{value:any}|null} The static value of the node, or `null`.
 */
function getStaticValue(node) {
  let initialScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  try {
    return getStaticValueR(node, initialScope);
  } catch (_error) {
    return null;
  }
}

/**
 * Get the value of a given node if it's a literal or a template literal.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.
 * @returns {string|null} The value of the node, or `null`.
 */
function getStringIfConstant(node) {
  let initialScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  // Handle the literals that the platform doesn't support natively.
  if (node && node.type === "Literal" && node.value === null) {
    if (node.regex) {
      return `/${node.regex.pattern}/${node.regex.flags}`;
    }
    if (node.bigint) {
      return node.bigint;
    }
  }
  const evaluated = getStaticValue(node, initialScope);
  return evaluated && String(evaluated.value);
}

/**
 * Get the property name from a MemberExpression node or a Property node.
 * @param {Node} node The node to get.
 * @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.
 * @returns {string|null} The property name of the node.
 */
function getPropertyName(node, initialScope) {
  switch (node.type) {
    case "MemberExpression":
      if (node.computed) {
        return getStringIfConstant(node.property, initialScope);
      }
      return node.property.name;
    case "Property":
    case "MethodDefinition":
      if (node.computed) {
        return getStringIfConstant(node.key, initialScope);
      }
      if (node.key.type === "Literal") {
        return String(node.key.value);
      }
      return node.key.name;

    // no default
  }
  return null;
}

/**
 * Get the name and kind of the given function node.
 * @param {ASTNode} node - The function node to get.
 * @returns {string} The name and kind of the function node.
 */
function getFunctionNameWithKind(node) {
  const parent = node.parent;
  const tokens = [];
  if (parent.type === "MethodDefinition" && parent.static) {
    tokens.push("static");
  }
  if (node.async) {
    tokens.push("async");
  }
  if (node.generator) {
    tokens.push("generator");
  }
  if (node.type === "ArrowFunctionExpression") {
    tokens.push("arrow", "function");
  } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
    if (parent.kind === "constructor") {
      return "constructor";
    }
    if (parent.kind === "get") {
      tokens.push("getter");
    } else if (parent.kind === "set") {
      tokens.push("setter");
    } else {
      tokens.push("method");
    }
  } else {
    tokens.push("function");
  }
  if (node.id) {
    tokens.push(`'${node.id.name}'`);
  } else {
    const name = getPropertyName(parent);
    if (name) {
      tokens.push(`'${name}'`);
    }
  }
  return tokens.join(" ");
}
const typeConversionBinaryOps = Object.freeze(new Set(["==", "!=", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "|", "^", "&", "in"]));
const typeConversionUnaryOps = Object.freeze(new Set(["-", "+", "!", "~"]));
const visitor = Object.freeze(Object.assign(Object.create(null), {
  $visit(node, options, visitorKeys) {
    const {
      type
    } = node;
    if (typeof this[type] === "function") {
      return this[type](node, options, visitorKeys);
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  $visitChildren(node, options, visitorKeys) {
    const {
      type
    } = node;
    for (const key of visitorKeys[type] || evk.getKeys(node)) {
      const value = node[key];
      if (Array.isArray(value)) {
        for (const element of value) {
          if (element && this.$visit(element, options, visitorKeys)) {
            return true;
          }
        }
      } else if (value && this.$visit(value, options, visitorKeys)) {
        return true;
      }
    }
    return false;
  },
  ArrowFunctionExpression() {
    return false;
  },
  AssignmentExpression() {
    return true;
  },
  AwaitExpression() {
    return true;
  },
  BinaryExpression(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
      return true;
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  CallExpression() {
    return true;
  },
  FunctionExpression() {
    return false;
  },
  ImportExpression() {
    return true;
  },
  MemberExpression(node, options, visitorKeys) {
    if (options.considerGetters) {
      return true;
    }
    if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
      return true;
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  MethodDefinition(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
      return true;
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  NewExpression() {
    return true;
  },
  Property(node, options, visitorKeys) {
    if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
      return true;
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  UnaryExpression(node, options, visitorKeys) {
    if (node.operator === "delete") {
      return true;
    }
    if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
      return true;
    }
    return this.$visitChildren(node, options, visitorKeys);
  },
  UpdateExpression() {
    return true;
  },
  YieldExpression() {
    return true;
  }
}));

/**
 * Check whether a given node has any side effect or not.
 * @param {Node} node The node to get.
 * @param {SourceCode} sourceCode The source code object.
 * @param {object} [options] The option object.
 * @param {boolean} [options.considerGetters=false] If `true` then it considers member accesses as the node which has side effects.
 * @param {boolean} [options.considerImplicitTypeConversion=false] If `true` then it considers implicit type conversion as the node which has side effects.
 * @param {object} [options.visitorKeys=evk.KEYS] The keys to traverse nodes. Use `context.getSourceCode().visitorKeys`.
 * @returns {boolean} `true` if the node has a certain side effect.
 */
function hasSideEffect(node, sourceCode) {
  let {
    considerGetters = false,
    considerImplicitTypeConversion = false
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return visitor.$visit(node, {
    considerGetters,
    considerImplicitTypeConversion
  }, sourceCode.visitorKeys || evk.KEYS);
}

/**
 * Get the left parenthesis of the parent node syntax if it exists.
 * E.g., `if (a) {}` then the `(`.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token|null} The left parenthesis of the parent node syntax
 */
function getParentSyntaxParen(node, sourceCode) {
  const parent = node.parent;
  switch (parent.type) {
    case "CallExpression":
    case "NewExpression":
      if (parent.arguments.length === 1 && parent.arguments[0] === node) {
        return sourceCode.getTokenAfter(parent.callee, isOpeningParenToken);
      }
      return null;
    case "DoWhileStatement":
      if (parent.test === node) {
        return sourceCode.getTokenAfter(parent.body, isOpeningParenToken);
      }
      return null;
    case "IfStatement":
    case "WhileStatement":
      if (parent.test === node) {
        return sourceCode.getFirstToken(parent, 1);
      }
      return null;
    case "ImportExpression":
      if (parent.source === node) {
        return sourceCode.getFirstToken(parent, 1);
      }
      return null;
    case "SwitchStatement":
      if (parent.discriminant === node) {
        return sourceCode.getFirstToken(parent, 1);
      }
      return null;
    case "WithStatement":
      if (parent.object === node) {
        return sourceCode.getFirstToken(parent, 1);
      }
      return null;
    default:
      return null;
  }
}

/**
 * Check whether a given node is parenthesized or not.
 * @param {number} times The number of parantheses.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is parenthesized the given times.
 */
/**
 * Check whether a given node is parenthesized or not.
 * @param {Node} node The AST node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is parenthesized.
 */
function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
  let times, node, sourceCode, maybeLeftParen, maybeRightParen;
  if (typeof timesOrNode === "number") {
    times = timesOrNode | 0;
    node = nodeOrSourceCode;
    sourceCode = optionalSourceCode;
    if (!(times >= 1)) {
      throw new TypeError("'times' should be a positive integer.");
    }
  } else {
    times = 1;
    node = timesOrNode;
    sourceCode = nodeOrSourceCode;
  }
  if (node == null) {
    return false;
  }
  maybeLeftParen = maybeRightParen = node;
  do {
    maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
    maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
  } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) &&
  // Avoid false positive such as `if (a) {}`
  maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);
  return times === 0;
}

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

const placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;

/** @type {WeakMap<PatternMatcher, {pattern:RegExp,escaped:boolean}>} */
const internal = new WeakMap();

/**
 * Check whether a given character is escaped or not.
 * @param {string} str The string to check.
 * @param {number} index The location of the character to check.
 * @returns {boolean} `true` if the character is escaped.
 */
function isEscaped(str, index) {
  let escaped = false;
  for (let i = index - 1; i >= 0 && str.charCodeAt(i) === 0x5c; --i) {
    escaped = !escaped;
  }
  return escaped;
}

/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {string} replacement The new substring to replace each matched part.
 * @returns {string} The replaced string.
 */
function replaceS(matcher, str, replacement) {
  const chunks = [];
  let index = 0;

  /** @type {RegExpExecArray} */
  let match = null;

  /**
   * @param {string} key The placeholder.
   * @returns {string} The replaced string.
   */
  function replacer(key) {
    switch (key) {
      case "$$":
        return "$";
      case "$&":
        return match[0];
      case "$`":
        return str.slice(0, match.index);
      case "$'":
        return str.slice(match.index + match[0].length);
      default:
        {
          const i = key.slice(1);
          if (i in match) {
            return match[i];
          }
          return key;
        }
    }
  }
  for (match of matcher.execAll(str)) {
    chunks.push(str.slice(index, match.index));
    chunks.push(replacement.replace(placeholder, replacer));
    index = match.index + match[0].length;
  }
  chunks.push(str.slice(index));
  return chunks.join("");
}

/**
 * Replace a given string by a given matcher.
 * @param {PatternMatcher} matcher The pattern matcher.
 * @param {string} str The string to be replaced.
 * @param {(...strs[])=>string} replace The function to replace each matched part.
 * @returns {string} The replaced string.
 */
function replaceF(matcher, str, replace) {
  const chunks = [];
  let index = 0;
  for (const match of matcher.execAll(str)) {
    chunks.push(str.slice(index, match.index));
    chunks.push(String(replace(...match, match.index, match.input)));
    index = match.index + match[0].length;
  }
  chunks.push(str.slice(index));
  return chunks.join("");
}

/**
 * The class to find patterns as considering escape sequences.
 */
class PatternMatcher {
  /**
   * Initialize this matcher.
   * @param {RegExp} pattern The pattern to match.
   * @param {{escaped:boolean}} options The options.
   */
  constructor(pattern) {
    let {
      escaped = false
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!(pattern instanceof RegExp)) {
      throw new TypeError("'pattern' should be a RegExp instance.");
    }
    if (!pattern.flags.includes("g")) {
      throw new Error("'pattern' should contains 'g' flag.");
    }
    internal.set(this, {
      pattern: new RegExp(pattern.source, pattern.flags),
      escaped: Boolean(escaped)
    });
  }

  /**
   * Find the pattern in a given string.
   * @param {string} str The string to find.
   * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
   */
  *execAll(str) {
    const {
      pattern,
      escaped
    } = internal.get(this);
    let match = null;
    let lastIndex = 0;
    pattern.lastIndex = 0;
    while ((match = pattern.exec(str)) != null) {
      if (escaped || !isEscaped(str, match.index)) {
        lastIndex = pattern.lastIndex;
        yield match;
        pattern.lastIndex = lastIndex;
      }
    }
  }

  /**
   * Check whether the pattern is found in a given string.
   * @param {string} str The string to check.
   * @returns {boolean} `true` if the pattern was found in the string.
   */
  test(str) {
    const it = this.execAll(str);
    const ret = it.next();
    return !ret.done;
  }

  /**
   * Replace a given string.
   * @param {string} str The string to be replaced.
   * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
   * @returns {string} The replaced string.
   */
  [Symbol.replace](str, replacer) {
    return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
  }
}
const IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
const has = Function.call.bind(Object.hasOwnProperty);
const READ = Symbol("read");
const CALL = Symbol("call");
const CONSTRUCT = Symbol("construct");
const ESM = Symbol("esm");
const requireCall = {
  require: {
    [CALL]: true
  }
};

/**
 * Check whether a given variable is modified or not.
 * @param {Variable} variable The variable to check.
 * @returns {boolean} `true` if the variable is modified.
 */
function isModifiedGlobal(variable) {
  return variable == null || variable.defs.length !== 0 || variable.references.some(r => r.isWrite());
}

/**
 * Check if the value of a given node is passed through to the parent syntax as-is.
 * For example, `a` and `b` in (`a || b` and `c ? a : b`) are passed through.
 * @param {Node} node A node to check.
 * @returns {boolean} `true` if the node is passed through.
 */
function isPassThrough(node) {
  const parent = node.parent;
  switch (parent && parent.type) {
    case "ConditionalExpression":
      return parent.consequent === node || parent.alternate === node;
    case "LogicalExpression":
      return true;
    case "SequenceExpression":
      return parent.expressions[parent.expressions.length - 1] === node;
    default:
      return false;
  }
}

/**
 * The reference tracker.
 */
class ReferenceTracker {
  /**
   * Initialize this tracker.
   * @param {Scope} globalScope The global scope.
   * @param {object} [options] The options.
   * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
   * @param {string[]} [options.globalObjectNames=["global","self","window"]] The variable names for Global Object.
   */
  constructor(globalScope) {
    let {
      mode = "strict",
      globalObjectNames = ["global", "self", "window"]
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.variableStack = [];
    this.globalScope = globalScope;
    this.mode = mode;
    this.globalObjectNames = globalObjectNames.slice(0);
  }

  /**
   * Iterate the references of global variables.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateGlobalReferences(traceMap) {
    for (const key of Object.keys(traceMap)) {
      const nextTraceMap = traceMap[key];
      const path = [key];
      const variable = this.globalScope.set.get(key);
      if (isModifiedGlobal(variable)) {
        continue;
      }
      yield* this._iterateVariableReferences(variable, path, nextTraceMap, true);
    }
    for (const key of this.globalObjectNames) {
      const path = [];
      const variable = this.globalScope.set.get(key);
      if (isModifiedGlobal(variable)) {
        continue;
      }
      yield* this._iterateVariableReferences(variable, path, traceMap, false);
    }
  }

  /**
   * Iterate the references of CommonJS modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateCjsReferences(traceMap) {
    for (const {
      node
    } of this.iterateGlobalReferences(requireCall)) {
      const key = getStringIfConstant(node.arguments[0]);
      if (key == null || !has(traceMap, key)) {
        continue;
      }
      const nextTraceMap = traceMap[key];
      const path = [key];
      if (nextTraceMap[READ]) {
        yield {
          node,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
      yield* this._iteratePropertyReferences(node, path, nextTraceMap);
    }
  }

  /**
   * Iterate the references of ES modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateEsmReferences(traceMap) {
    const programNode = this.globalScope.block;
    for (const node of programNode.body) {
      if (!IMPORT_TYPE.test(node.type) || node.source == null) {
        continue;
      }
      const moduleId = node.source.value;
      if (!has(traceMap, moduleId)) {
        continue;
      }
      const nextTraceMap = traceMap[moduleId];
      const path = [moduleId];
      if (nextTraceMap[READ]) {
        yield {
          node,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
      if (node.type === "ExportAllDeclaration") {
        for (const key of Object.keys(nextTraceMap)) {
          const exportTraceMap = nextTraceMap[key];
          if (exportTraceMap[READ]) {
            yield {
              node,
              path: path.concat(key),
              type: READ,
              info: exportTraceMap[READ]
            };
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          const esm = has(nextTraceMap, ESM);
          const it = this._iterateImportReferences(specifier, path, esm ? nextTraceMap : this.mode === "legacy" ? Object.assign({
            default: nextTraceMap
          }, nextTraceMap) : {
            default: nextTraceMap
          });
          if (esm) {
            yield* it;
          } else {
            for (const report of it) {
              report.path = report.path.filter(exceptDefault);
              if (report.path.length >= 2 || report.type !== READ) {
                yield report;
              }
            }
          }
        }
      }
    }
  }

  /**
   * Iterate the references for a given variable.
   * @param {Variable} variable The variable to iterate that references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @param {boolean} shouldReport = The flag to report those references.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
    if (this.variableStack.includes(variable)) {
      return;
    }
    this.variableStack.push(variable);
    try {
      for (const reference of variable.references) {
        if (!reference.isRead()) {
          continue;
        }
        const node = reference.identifier;
        if (shouldReport && traceMap[READ]) {
          yield {
            node,
            path,
            type: READ,
            info: traceMap[READ]
          };
        }
        yield* this._iteratePropertyReferences(node, path, traceMap);
      }
    } finally {
      this.variableStack.pop();
    }
  }

  /**
   * Iterate the references for a given AST node.
   * @param rootNode The AST node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  //eslint-disable-next-line complexity
  *_iteratePropertyReferences(rootNode, path, traceMap) {
    let node = rootNode;
    while (isPassThrough(node)) {
      node = node.parent;
    }
    const parent = node.parent;
    if (parent.type === "MemberExpression") {
      if (parent.object === node) {
        const key = getPropertyName(parent);
        if (key == null || !has(traceMap, key)) {
          return;
        }
        path = path.concat(key); //eslint-disable-line no-param-reassign
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: parent,
            path,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iteratePropertyReferences(parent, path, nextTraceMap);
      }
      return;
    }
    if (parent.type === "CallExpression") {
      if (parent.callee === node && traceMap[CALL]) {
        yield {
          node: parent,
          path,
          type: CALL,
          info: traceMap[CALL]
        };
      }
      return;
    }
    if (parent.type === "NewExpression") {
      if (parent.callee === node && traceMap[CONSTRUCT]) {
        yield {
          node: parent,
          path,
          type: CONSTRUCT,
          info: traceMap[CONSTRUCT]
        };
      }
      return;
    }
    if (parent.type === "AssignmentExpression") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
        yield* this._iteratePropertyReferences(parent, path, traceMap);
      }
      return;
    }
    if (parent.type === "AssignmentPattern") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
      }
      return;
    }
    if (parent.type === "VariableDeclarator") {
      if (parent.init === node) {
        yield* this._iterateLhsReferences(parent.id, path, traceMap);
      }
    }
  }

  /**
   * Iterate the references for a given Pattern node.
   * @param {Node} patternNode The Pattern node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateLhsReferences(patternNode, path, traceMap) {
    if (patternNode.type === "Identifier") {
      const variable = findVariable(this.globalScope, patternNode);
      if (variable != null) {
        yield* this._iterateVariableReferences(variable, path, traceMap, false);
      }
      return;
    }
    if (patternNode.type === "ObjectPattern") {
      for (const property of patternNode.properties) {
        const key = getPropertyName(property);
        if (key == null || !has(traceMap, key)) {
          continue;
        }
        const nextPath = path.concat(key);
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: property,
            path: nextPath,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iterateLhsReferences(property.value, nextPath, nextTraceMap);
      }
      return;
    }
    if (patternNode.type === "AssignmentPattern") {
      yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
    }
  }

  /**
   * Iterate the references for a given ModuleSpecifier node.
   * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateImportReferences(specifierNode, path, traceMap) {
    const type = specifierNode.type;
    if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
      const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
      if (!has(traceMap, key)) {
        return;
      }
      path = path.concat(key); //eslint-disable-line no-param-reassign
      const nextTraceMap = traceMap[key];
      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
      yield* this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path, nextTraceMap, false);
      return;
    }
    if (type === "ImportNamespaceSpecifier") {
      yield* this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path, traceMap, false);
      return;
    }
    if (type === "ExportSpecifier") {
      const key = specifierNode.local.name;
      if (!has(traceMap, key)) {
        return;
      }
      path = path.concat(key); //eslint-disable-line no-param-reassign
      const nextTraceMap = traceMap[key];
      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
    }
  }
}
ReferenceTracker.READ = READ;
ReferenceTracker.CALL = CALL;
ReferenceTracker.CONSTRUCT = CONSTRUCT;
ReferenceTracker.ESM = ESM;

/**
 * This is a predicate function for Array#filter.
 * @param {string} name A name part.
 * @param {number} index The index of the name.
 * @returns {boolean} `false` if it's default.
 */
function exceptDefault(name, index) {
  return !(index === 1 && name === "default");
}
var index = {
  CALL,
  CONSTRUCT,
  ESM,
  findVariable,
  getFunctionHeadLocation,
  getFunctionNameWithKind,
  getInnermostScope,
  getPropertyName,
  getStaticValue,
  getStringIfConstant,
  hasSideEffect,
  isArrowToken,
  isClosingBraceToken,
  isClosingBracketToken,
  isClosingParenToken,
  isColonToken,
  isCommaToken,
  isCommentToken,
  isNotArrowToken,
  isNotClosingBraceToken,
  isNotClosingBracketToken,
  isNotClosingParenToken,
  isNotColonToken,
  isNotCommaToken,
  isNotCommentToken,
  isNotOpeningBraceToken,
  isNotOpeningBracketToken,
  isNotOpeningParenToken,
  isNotSemicolonToken,
  isOpeningBraceToken,
  isOpeningBracketToken,
  isOpeningParenToken,
  isParenthesized,
  isSemicolonToken,
  PatternMatcher,
  READ,
  ReferenceTracker
};
exports.CALL = CALL;
exports.CONSTRUCT = CONSTRUCT;
exports.ESM = ESM;
exports.PatternMatcher = PatternMatcher;
exports.READ = READ;
exports.ReferenceTracker = ReferenceTracker;
exports["default"] = index;
exports.findVariable = findVariable;
exports.getFunctionHeadLocation = getFunctionHeadLocation;
exports.getFunctionNameWithKind = getFunctionNameWithKind;
exports.getInnermostScope = getInnermostScope;
exports.getPropertyName = getPropertyName;
exports.getStaticValue = getStaticValue;
exports.getStringIfConstant = getStringIfConstant;
exports.hasSideEffect = hasSideEffect;
exports.isArrowToken = isArrowToken;
exports.isClosingBraceToken = isClosingBraceToken;
exports.isClosingBracketToken = isClosingBracketToken;
exports.isClosingParenToken = isClosingParenToken;
exports.isColonToken = isColonToken;
exports.isCommaToken = isCommaToken;
exports.isCommentToken = isCommentToken;
exports.isNotArrowToken = isNotArrowToken;
exports.isNotClosingBraceToken = isNotClosingBraceToken;
exports.isNotClosingBracketToken = isNotClosingBracketToken;
exports.isNotClosingParenToken = isNotClosingParenToken;
exports.isNotColonToken = isNotColonToken;
exports.isNotCommaToken = isNotCommaToken;
exports.isNotCommentToken = isNotCommentToken;
exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
exports.isNotOpeningParenToken = isNotOpeningParenToken;
exports.isNotSemicolonToken = isNotSemicolonToken;
exports.isOpeningBraceToken = isOpeningBraceToken;
exports.isOpeningBracketToken = isOpeningBracketToken;
exports.isOpeningParenToken = isOpeningParenToken;
exports.isParenthesized = isParenthesized;
exports.isSemicolonToken = isSemicolonToken;

/***/ }),
/* 340 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */


module.exports = {
  isCombiningCharacter: __webpack_require__(341),
  isEmojiModifier: __webpack_require__(342),
  isRegionalIndicatorSymbol: __webpack_require__(343),
  isSurrogatePair: __webpack_require__(344)
};

/***/ }),
/* 341 */
/***/ ((module) => {

"use strict";
// THIS FILE WAS GENERATED BY 'tools/update-unicode-utils.js'


const combiningChars = new Set([768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1471, 1473, 1474, 1476, 1477, 1479, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1648, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1759, 1760, 1761, 1762, 1763, 1764, 1767, 1768, 1770, 1771, 1772, 1773, 1809, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2070, 2071, 2072, 2073, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2085, 2086, 2087, 2089, 2090, 2091, 2092, 2093, 2137, 2138, 2139, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2362, 2363, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2402, 2403, 2433, 2434, 2435, 2492, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2503, 2504, 2507, 2508, 2509, 2519, 2530, 2531, 2561, 2562, 2563, 2620, 2622, 2623, 2624, 2625, 2626, 2631, 2632, 2635, 2636, 2637, 2641, 2672, 2673, 2677, 2689, 2690, 2691, 2748, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2759, 2760, 2761, 2763, 2764, 2765, 2786, 2787, 2810, 2811, 2812, 2813, 2814, 2815, 2817, 2818, 2819, 2876, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2887, 2888, 2891, 2892, 2893, 2902, 2903, 2914, 2915, 2946, 3006, 3007, 3008, 3009, 3010, 3014, 3015, 3016, 3018, 3019, 3020, 3021, 3031, 3072, 3073, 3074, 3075, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3142, 3143, 3144, 3146, 3147, 3148, 3149, 3157, 3158, 3170, 3171, 3201, 3202, 3203, 3260, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3270, 3271, 3272, 3274, 3275, 3276, 3277, 3285, 3286, 3298, 3299, 3328, 3329, 3330, 3331, 3387, 3388, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3398, 3399, 3400, 3402, 3403, 3404, 3405, 3415, 3426, 3427, 3458, 3459, 3530, 3535, 3536, 3537, 3538, 3539, 3540, 3542, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3570, 3571, 3633, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3761, 3764, 3765, 3766, 3767, 3768, 3769, 3771, 3772, 3784, 3785, 3786, 3787, 3788, 3789, 3864, 3865, 3893, 3895, 3897, 3902, 3903, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3974, 3975, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4038, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4182, 4183, 4184, 4185, 4190, 4191, 4192, 4194, 4195, 4196, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4209, 4210, 4211, 4212, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4239, 4250, 4251, 4252, 4253, 4957, 4958, 4959, 5906, 5907, 5908, 5938, 5939, 5940, 5970, 5971, 6002, 6003, 6068, 6069, 6070, 6071, 6072, 6073, 6074, 6075, 6076, 6077, 6078, 6079, 6080, 6081, 6082, 6083, 6084, 6085, 6086, 6087, 6088, 6089, 6090, 6091, 6092, 6093, 6094, 6095, 6096, 6097, 6098, 6099, 6109, 6155, 6156, 6157, 6277, 6278, 6313, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6448, 6449, 6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6679, 6680, 6681, 6682, 6683, 6741, 6742, 6743, 6744, 6745, 6746, 6747, 6748, 6749, 6750, 6752, 6753, 6754, 6755, 6756, 6757, 6758, 6759, 6760, 6761, 6762, 6763, 6764, 6765, 6766, 6767, 6768, 6769, 6770, 6771, 6772, 6773, 6774, 6775, 6776, 6777, 6778, 6779, 6780, 6783, 6832, 6833, 6834, 6835, 6836, 6837, 6838, 6839, 6840, 6841, 6842, 6843, 6844, 6845, 6846, 6912, 6913, 6914, 6915, 6916, 6964, 6965, 6966, 6967, 6968, 6969, 6970, 6971, 6972, 6973, 6974, 6975, 6976, 6977, 6978, 6979, 6980, 7019, 7020, 7021, 7022, 7023, 7024, 7025, 7026, 7027, 7040, 7041, 7042, 7073, 7074, 7075, 7076, 7077, 7078, 7079, 7080, 7081, 7082, 7083, 7084, 7085, 7142, 7143, 7144, 7145, 7146, 7147, 7148, 7149, 7150, 7151, 7152, 7153, 7154, 7155, 7204, 7205, 7206, 7207, 7208, 7209, 7210, 7211, 7212, 7213, 7214, 7215, 7216, 7217, 7218, 7219, 7220, 7221, 7222, 7223, 7376, 7377, 7378, 7380, 7381, 7382, 7383, 7384, 7385, 7386, 7387, 7388, 7389, 7390, 7391, 7392, 7393, 7394, 7395, 7396, 7397, 7398, 7399, 7400, 7405, 7410, 7411, 7412, 7415, 7416, 7417, 7616, 7617, 7618, 7619, 7620, 7621, 7622, 7623, 7624, 7625, 7626, 7627, 7628, 7629, 7630, 7631, 7632, 7633, 7634, 7635, 7636, 7637, 7638, 7639, 7640, 7641, 7642, 7643, 7644, 7645, 7646, 7647, 7648, 7649, 7650, 7651, 7652, 7653, 7654, 7655, 7656, 7657, 7658, 7659, 7660, 7661, 7662, 7663, 7664, 7665, 7666, 7667, 7668, 7669, 7670, 7671, 7672, 7673, 7675, 7676, 7677, 7678, 7679, 8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 11503, 11504, 11505, 11647, 11744, 11745, 11746, 11747, 11748, 11749, 11750, 11751, 11752, 11753, 11754, 11755, 11756, 11757, 11758, 11759, 11760, 11761, 11762, 11763, 11764, 11765, 11766, 11767, 11768, 11769, 11770, 11771, 11772, 11773, 11774, 11775, 12330, 12331, 12332, 12333, 12334, 12335, 12441, 12442, 42607, 42608, 42609, 42610, 42612, 42613, 42614, 42615, 42616, 42617, 42618, 42619, 42620, 42621, 42654, 42655, 42736, 42737, 43010, 43014, 43019, 43043, 43044, 43045, 43046, 43047, 43136, 43137, 43188, 43189, 43190, 43191, 43192, 43193, 43194, 43195, 43196, 43197, 43198, 43199, 43200, 43201, 43202, 43203, 43204, 43205, 43232, 43233, 43234, 43235, 43236, 43237, 43238, 43239, 43240, 43241, 43242, 43243, 43244, 43245, 43246, 43247, 43248, 43249, 43302, 43303, 43304, 43305, 43306, 43307, 43308, 43309, 43335, 43336, 43337, 43338, 43339, 43340, 43341, 43342, 43343, 43344, 43345, 43346, 43347, 43392, 43393, 43394, 43395, 43443, 43444, 43445, 43446, 43447, 43448, 43449, 43450, 43451, 43452, 43453, 43454, 43455, 43456, 43493, 43561, 43562, 43563, 43564, 43565, 43566, 43567, 43568, 43569, 43570, 43571, 43572, 43573, 43574, 43587, 43596, 43597, 43643, 43644, 43645, 43696, 43698, 43699, 43700, 43703, 43704, 43710, 43711, 43713, 43755, 43756, 43757, 43758, 43759, 43765, 43766, 44003, 44004, 44005, 44006, 44007, 44008, 44009, 44010, 44012, 44013, 64286, 65024, 65025, 65026, 65027, 65028, 65029, 65030, 65031, 65032, 65033, 65034, 65035, 65036, 65037, 65038, 65039, 65056, 65057, 65058, 65059, 65060, 65061, 65062, 65063, 65064, 65065, 65066, 65067, 65068, 65069, 65070, 65071, 66045, 66272, 66422, 66423, 66424, 66425, 66426, 68097, 68098, 68099, 68101, 68102, 68108, 68109, 68110, 68111, 68152, 68153, 68154, 68159, 68325, 68326, 69632, 69633, 69634, 69688, 69689, 69690, 69691, 69692, 69693, 69694, 69695, 69696, 69697, 69698, 69699, 69700, 69701, 69702, 69759, 69760, 69761, 69762, 69808, 69809, 69810, 69811, 69812, 69813, 69814, 69815, 69816, 69817, 69818, 69888, 69889, 69890, 69927, 69928, 69929, 69930, 69931, 69932, 69933, 69934, 69935, 69936, 69937, 69938, 69939, 69940, 70003, 70016, 70017, 70018, 70067, 70068, 70069, 70070, 70071, 70072, 70073, 70074, 70075, 70076, 70077, 70078, 70079, 70080, 70090, 70091, 70092, 70188, 70189, 70190, 70191, 70192, 70193, 70194, 70195, 70196, 70197, 70198, 70199, 70206, 70367, 70368, 70369, 70370, 70371, 70372, 70373, 70374, 70375, 70376, 70377, 70378, 70400, 70401, 70402, 70403, 70460, 70462, 70463, 70464, 70465, 70466, 70467, 70468, 70471, 70472, 70475, 70476, 70477, 70487, 70498, 70499, 70502, 70503, 70504, 70505, 70506, 70507, 70508, 70512, 70513, 70514, 70515, 70516, 70709, 70710, 70711, 70712, 70713, 70714, 70715, 70716, 70717, 70718, 70719, 70720, 70721, 70722, 70723, 70724, 70725, 70726, 70832, 70833, 70834, 70835, 70836, 70837, 70838, 70839, 70840, 70841, 70842, 70843, 70844, 70845, 70846, 70847, 70848, 70849, 70850, 70851, 71087, 71088, 71089, 71090, 71091, 71092, 71093, 71096, 71097, 71098, 71099, 71100, 71101, 71102, 71103, 71104, 71132, 71133, 71216, 71217, 71218, 71219, 71220, 71221, 71222, 71223, 71224, 71225, 71226, 71227, 71228, 71229, 71230, 71231, 71232, 71339, 71340, 71341, 71342, 71343, 71344, 71345, 71346, 71347, 71348, 71349, 71350, 71351, 71453, 71454, 71455, 71456, 71457, 71458, 71459, 71460, 71461, 71462, 71463, 71464, 71465, 71466, 71467, 72193, 72194, 72195, 72196, 72197, 72198, 72199, 72200, 72201, 72202, 72243, 72244, 72245, 72246, 72247, 72248, 72249, 72251, 72252, 72253, 72254, 72263, 72273, 72274, 72275, 72276, 72277, 72278, 72279, 72280, 72281, 72282, 72283, 72330, 72331, 72332, 72333, 72334, 72335, 72336, 72337, 72338, 72339, 72340, 72341, 72342, 72343, 72344, 72345, 72751, 72752, 72753, 72754, 72755, 72756, 72757, 72758, 72760, 72761, 72762, 72763, 72764, 72765, 72766, 72767, 72850, 72851, 72852, 72853, 72854, 72855, 72856, 72857, 72858, 72859, 72860, 72861, 72862, 72863, 72864, 72865, 72866, 72867, 72868, 72869, 72870, 72871, 72873, 72874, 72875, 72876, 72877, 72878, 72879, 72880, 72881, 72882, 72883, 72884, 72885, 72886, 73009, 73010, 73011, 73012, 73013, 73014, 73018, 73020, 73021, 73023, 73024, 73025, 73026, 73027, 73028, 73029, 73031, 92912, 92913, 92914, 92915, 92916, 92976, 92977, 92978, 92979, 92980, 92981, 92982, 94033, 94034, 94035, 94036, 94037, 94038, 94039, 94040, 94041, 94042, 94043, 94044, 94045, 94046, 94047, 94048, 94049, 94050, 94051, 94052, 94053, 94054, 94055, 94056, 94057, 94058, 94059, 94060, 94061, 94062, 94063, 94064, 94065, 94066, 94067, 94068, 94069, 94070, 94071, 94072, 94073, 94074, 94075, 94076, 94077, 94078, 94095, 94096, 94097, 94098, 113821, 113822, 119141, 119142, 119143, 119144, 119145, 119149, 119150, 119151, 119152, 119153, 119154, 119163, 119164, 119165, 119166, 119167, 119168, 119169, 119170, 119173, 119174, 119175, 119176, 119177, 119178, 119179, 119210, 119211, 119212, 119213, 119362, 119363, 119364, 121344, 121345, 121346, 121347, 121348, 121349, 121350, 121351, 121352, 121353, 121354, 121355, 121356, 121357, 121358, 121359, 121360, 121361, 121362, 121363, 121364, 121365, 121366, 121367, 121368, 121369, 121370, 121371, 121372, 121373, 121374, 121375, 121376, 121377, 121378, 121379, 121380, 121381, 121382, 121383, 121384, 121385, 121386, 121387, 121388, 121389, 121390, 121391, 121392, 121393, 121394, 121395, 121396, 121397, 121398, 121403, 121404, 121405, 121406, 121407, 121408, 121409, 121410, 121411, 121412, 121413, 121414, 121415, 121416, 121417, 121418, 121419, 121420, 121421, 121422, 121423, 121424, 121425, 121426, 121427, 121428, 121429, 121430, 121431, 121432, 121433, 121434, 121435, 121436, 121437, 121438, 121439, 121440, 121441, 121442, 121443, 121444, 121445, 121446, 121447, 121448, 121449, 121450, 121451, 121452, 121461, 121476, 121499, 121500, 121501, 121502, 121503, 121505, 121506, 121507, 121508, 121509, 121510, 121511, 121512, 121513, 121514, 121515, 121516, 121517, 121518, 121519, 122880, 122881, 122882, 122883, 122884, 122885, 122886, 122888, 122889, 122890, 122891, 122892, 122893, 122894, 122895, 122896, 122897, 122898, 122899, 122900, 122901, 122902, 122903, 122904, 122907, 122908, 122909, 122910, 122911, 122912, 122913, 122915, 122916, 122918, 122919, 122920, 122921, 122922, 125136, 125137, 125138, 125139, 125140, 125141, 125142, 125252, 125253, 125254, 125255, 125256, 125257, 125258, 917760, 917761, 917762, 917763, 917764, 917765, 917766, 917767, 917768, 917769, 917770, 917771, 917772, 917773, 917774, 917775, 917776, 917777, 917778, 917779, 917780, 917781, 917782, 917783, 917784, 917785, 917786, 917787, 917788, 917789, 917790, 917791, 917792, 917793, 917794, 917795, 917796, 917797, 917798, 917799, 917800, 917801, 917802, 917803, 917804, 917805, 917806, 917807, 917808, 917809, 917810, 917811, 917812, 917813, 917814, 917815, 917816, 917817, 917818, 917819, 917820, 917821, 917822, 917823, 917824, 917825, 917826, 917827, 917828, 917829, 917830, 917831, 917832, 917833, 917834, 917835, 917836, 917837, 917838, 917839, 917840, 917841, 917842, 917843, 917844, 917845, 917846, 917847, 917848, 917849, 917850, 917851, 917852, 917853, 917854, 917855, 917856, 917857, 917858, 917859, 917860, 917861, 917862, 917863, 917864, 917865, 917866, 917867, 917868, 917869, 917870, 917871, 917872, 917873, 917874, 917875, 917876, 917877, 917878, 917879, 917880, 917881, 917882, 917883, 917884, 917885, 917886, 917887, 917888, 917889, 917890, 917891, 917892, 917893, 917894, 917895, 917896, 917897, 917898, 917899, 917900, 917901, 917902, 917903, 917904, 917905, 917906, 917907, 917908, 917909, 917910, 917911, 917912, 917913, 917914, 917915, 917916, 917917, 917918, 917919, 917920, 917921, 917922, 917923, 917924, 917925, 917926, 917927, 917928, 917929, 917930, 917931, 917932, 917933, 917934, 917935, 917936, 917937, 917938, 917939, 917940, 917941, 917942, 917943, 917944, 917945, 917946, 917947, 917948, 917949, 917950, 917951, 917952, 917953, 917954, 917955, 917956, 917957, 917958, 917959, 917960, 917961, 917962, 917963, 917964, 917965, 917966, 917967, 917968, 917969, 917970, 917971, 917972, 917973, 917974, 917975, 917976, 917977, 917978, 917979, 917980, 917981, 917982, 917983, 917984, 917985, 917986, 917987, 917988, 917989, 917990, 917991, 917992, 917993, 917994, 917995, 917996, 917997, 917998, 917999]);

/**
 * Check whether a given character is a combining mark or not.
 * @param {number} c The character code to check.
 * @returns {boolean} `true` if the character belongs to the category, one of `Mc`, `Me`, and `Mn`.
 */
module.exports = function isCombiningCharacter(c) {
  return combiningChars.has(c);
};

/***/ }),
/* 342 */
/***/ ((module) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */


/**
 * Check whether a given character is an emoji modifier.
 * @param {number} code The character code to check.
 * @returns {boolean} `true` if the character is an emoji modifier.
 */
module.exports = function isEmojiModifier(code) {
  return code >= 0x1F3FB && code <= 0x1F3FF;
};

/***/ }),
/* 343 */
/***/ ((module) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */


/**
 * Check whether a given character is a regional indicator symbol.
 * @param {number} code The character code to check.
 * @returns {boolean} `true` if the character is a regional indicator symbol.
 */
module.exports = function isRegionalIndicatorSymbol(code) {
  return code >= 0x1F1E6 && code <= 0x1F1FF;
};

/***/ }),
/* 344 */
/***/ ((module) => {

"use strict";
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */


/**
 * Check whether given two characters are a surrogate pair.
 * @param {number} lead The code of the lead character.
 * @param {number} tail The code of the tail character.
 * @returns {boolean} `true` if the character pair is a surrogate pair.
 */
module.exports = function isSurrogatePair(lead, tail) {
  return lead >= 0xD800 && lead < 0xDC00 && tail >= 0xDC00 && tail < 0xE000;
};

/***/ }),
/* 345 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow mixed binary operators.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
const LOGICAL_OPERATORS = ["&&", "||"];
const RELATIONAL_OPERATORS = ["in", "instanceof"];
const ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS);
const DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];
const TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/u;

/**
 * Normalizes options.
 *
 * @param {Object|undefined} options - A options object to normalize.
 * @returns {Object} Normalized option object.
 */
function normalizeOptions() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const hasGroups = options.groups && options.groups.length > 0;
  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
  const allowSamePrecedence = options.allowSamePrecedence !== false;
  return {
    groups,
    allowSamePrecedence
  };
}

/**
 * Checks whether any group which includes both given operator exists or not.
 *
 * @param {Array.<string[]>} groups - A list of groups to check.
 * @param {string} left - An operator.
 * @param {string} right - Another operator.
 * @returns {boolean} `true` if such group existed.
 */
function includesBothInAGroup(groups, left, right) {
  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow mixed binary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-mixed-operators"
    },
    schema: [{
      type: "object",
      properties: {
        groups: {
          type: "array",
          items: {
            type: "array",
            items: {
              enum: ALL_OPERATORS
            },
            minItems: 2,
            uniqueItems: true
          },
          uniqueItems: true
        },
        allowSamePrecedence: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const options = normalizeOptions(context.options[0]);

    /**
     * Checks whether a given node should be ignored by options or not.
     *
     * @param {ASTNode} node - A node to check. This is a BinaryExpression
     *      node or a LogicalExpression node. This parent node is one of
     *      them, too.
     * @returns {boolean} `true` if the node should be ignored.
     */
    function shouldIgnore(node) {
      const a = node;
      const b = node.parent;
      return !includesBothInAGroup(options.groups, a.operator, b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
    }

    /**
     * Checks whether the operator of a given node is mixed with parent
     * node's operator or not.
     *
     * @param {ASTNode} node - A node to check. This is a BinaryExpression
     *      node or a LogicalExpression node. This parent node is one of
     *      them, too.
     * @returns {boolean} `true` if the node was mixed.
     */
    function isMixedWithParent(node) {
      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
    }

    /**
     * Gets the operator token of a given node.
     *
     * @param {ASTNode} node - A node to check. This is a BinaryExpression
     *      node or a LogicalExpression node.
     * @returns {Token} The operator token of the node.
     */
    function getOperatorToken(node) {
      return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
    }

    /**
     * Reports both the operator of a given node and the operator of the
     * parent node.
     *
     * @param {ASTNode} node - A node to check. This is a BinaryExpression
     *      node or a LogicalExpression node. This parent node is one of
     *      them, too.
     * @returns {void}
     */
    function reportBothOperators(node) {
      const parent = node.parent;
      const left = parent.left === node ? node : parent;
      const right = parent.left !== node ? node : parent;
      const message = "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
      const data = {
        leftOperator: left.operator,
        rightOperator: right.operator
      };
      context.report({
        node: left,
        loc: getOperatorToken(left).loc.start,
        message,
        data
      });
      context.report({
        node: right,
        loc: getOperatorToken(right).loc.start,
        message,
        data
      });
    }

    /**
     * Checks between the operator of this node and the operator of the
     * parent node.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function check(node) {
      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
        reportBothOperators(node);
      }
    }
    return {
      BinaryExpression: check,
      LogicalExpression: check
    };
  }
};

/***/ }),
/* 346 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce grouped require statements for Node.JS
 * @author Raphael Pigulla
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `require` calls to be mixed with regular variable declarations",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-mixed-requires"
    },
    schema: [{
      oneOf: [{
        type: "boolean"
      }, {
        type: "object",
        properties: {
          grouping: {
            type: "boolean"
          },
          allowCall: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const options = context.options[0];
    let grouping = false,
      allowCall = false;
    if (typeof options === "object") {
      grouping = options.grouping;
      allowCall = options.allowCall;
    } else {
      grouping = !!options;
    }

    /**
     * Returns the list of built-in modules.
     *
     * @returns {string[]} An array of built-in Node.js modules.
     */
    function getBuiltinModules() {
      /*
       * This list is generated using:
       * `require("repl")._builtinLibs.concat('repl').sort()`
       * This particular list is as per nodejs v0.12.2 and iojs v0.7.1
       */
      return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
    }
    const BUILTIN_MODULES = getBuiltinModules();
    const DECL_REQUIRE = "require",
      DECL_UNINITIALIZED = "uninitialized",
      DECL_OTHER = "other";
    const REQ_CORE = "core",
      REQ_FILE = "file",
      REQ_MODULE = "module",
      REQ_COMPUTED = "computed";

    /**
     * Determines the type of a declaration statement.
     * @param {ASTNode} initExpression The init node of the VariableDeclarator.
     * @returns {string} The type of declaration represented by the expression.
     */
    function getDeclarationType(initExpression) {
      if (!initExpression) {
        // "var x;"
        return DECL_UNINITIALIZED;
      }
      if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
        // "var x = require('util');"
        return DECL_REQUIRE;
      }
      if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
        // "var x = require('diagnose')('sub-module');"
        return getDeclarationType(initExpression.callee);
      }
      if (initExpression.type === "MemberExpression") {
        // "var x = require('glob').Glob;"
        return getDeclarationType(initExpression.object);
      }

      // "var x = 42;"
      return DECL_OTHER;
    }

    /**
     * Determines the type of module that is loaded via require.
     * @param {ASTNode} initExpression The init node of the VariableDeclarator.
     * @returns {string} The module type.
     */
    function inferModuleType(initExpression) {
      if (initExpression.type === "MemberExpression") {
        // "var x = require('glob').Glob;"
        return inferModuleType(initExpression.object);
      }
      if (initExpression.arguments.length === 0) {
        // "var x = require();"
        return REQ_COMPUTED;
      }
      const arg = initExpression.arguments[0];
      if (arg.type !== "Literal" || typeof arg.value !== "string") {
        // "var x = require(42);"
        return REQ_COMPUTED;
      }
      if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
        // "var fs = require('fs');"
        return REQ_CORE;
      }
      if (/^\.{0,2}\//u.test(arg.value)) {
        // "var utils = require('./utils');"
        return REQ_FILE;
      }

      // "var async = require('async');"
      return REQ_MODULE;
    }

    /**
     * Check if the list of variable declarations is mixed, i.e. whether it
     * contains both require and other declarations.
     * @param {ASTNode} declarations The list of VariableDeclarators.
     * @returns {boolean} True if the declarations are mixed, false if not.
     */
    function isMixed(declarations) {
      const contains = {};
      declarations.forEach(declaration => {
        const type = getDeclarationType(declaration.init);
        contains[type] = true;
      });
      return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
    }

    /**
     * Check if all require declarations in the given list are of the same
     * type.
     * @param {ASTNode} declarations The list of VariableDeclarators.
     * @returns {boolean} True if the declarations are grouped, false if not.
     */
    function isGrouped(declarations) {
      const found = {};
      declarations.forEach(declaration => {
        if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
          found[inferModuleType(declaration.init)] = true;
        }
      });
      return Object.keys(found).length <= 1;
    }
    return {
      VariableDeclaration(node) {
        if (isMixed(node.declarations)) {
          context.report({
            node,
            message: "Do not mix 'require' and other declarations."
          });
        } else if (grouping && !isGrouped(node.declarations)) {
          context.report({
            node,
            message: "Do not mix core, module, file and computed requires."
          });
        }
      }
    };
  }
};

/***/ }),
/* 347 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow mixed spaces and tabs for indentation
 * @author Jary Niebur
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow mixed spaces and tabs for indentation",
      category: "Stylistic Issues",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"
    },
    schema: [{
      enum: ["smart-tabs", true, false]
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let smartTabs;
    const ignoredLocs = [];
    switch (context.options[0]) {
      case true: // Support old syntax, maybe add deprecation warning here
      case "smart-tabs":
        smartTabs = true;
        break;
      default:
        smartTabs = false;
    }

    /**
     * Determines if a given line and column are before a location.
     * @param {Location} loc The location object from an AST node.
     * @param {int} line The line to check.
     * @param {int} column The column to check.
     * @returns {boolean} True if the line and column are before the location, false if not.
     * @private
     */
    function beforeLoc(loc, line, column) {
      if (line < loc.start.line) {
        return true;
      }
      return line === loc.start.line && column < loc.start.column;
    }

    /**
     * Determines if a given line and column are after a location.
     * @param {Location} loc The location object from an AST node.
     * @param {int} line The line to check.
     * @param {int} column The column to check.
     * @returns {boolean} True if the line and column are after the location, false if not.
     * @private
     */
    function afterLoc(loc, line, column) {
      if (line > loc.end.line) {
        return true;
      }
      return line === loc.end.line && column > loc.end.column;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      TemplateElement(node) {
        ignoredLocs.push(node.loc);
      },
      "Program:exit"(node) {
        /*
         * At least one space followed by a tab
         * or the reverse before non-tab/-space
         * characters begin.
         */
        let regex = /^(?=[\t ]*(\t | \t))/u;
        const lines = sourceCode.lines,
          comments = sourceCode.getAllComments();
        comments.forEach(comment => {
          ignoredLocs.push(comment.loc);
        });
        ignoredLocs.sort((first, second) => {
          if (beforeLoc(first, second.start.line, second.start.column)) {
            return 1;
          }
          if (beforeLoc(second, first.start.line, second.start.column)) {
            return -1;
          }
          return 0;
        });
        if (smartTabs) {
          /*
           * At least one space followed by a tab
           * before non-tab/-space characters begin.
           */
          regex = /^(?=[\t ]* \t)/u;
        }
        lines.forEach((line, i) => {
          const match = regex.exec(line);
          if (match) {
            const lineNumber = i + 1,
              column = match.index + 1;
            for (let j = 0; j < ignoredLocs.length; j++) {
              if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
                continue;
              }
              if (afterLoc(ignoredLocs[j], lineNumber, column)) {
                continue;
              }
              return;
            }
            context.report({
              node,
              loc: {
                line: lineNumber,
                column
              },
              message: "Mixed spaces and tabs."
            });
          }
        });
      }
    };
  }
};

/***/ }),
/* 348 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check use of chained assignment expressions
 * @author Stewart Rand
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow use of chained assignment expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-assign"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      AssignmentExpression(node) {
        if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
          context.report({
            node,
            message: "Unexpected chained assignment."
          });
        }
      }
    };
  }
};

/***/ }),
/* 349 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallow use of multiple spaces.
 * @author Nicholas C. Zakas
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple spaces",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          patternProperties: {
            "^([A-Z][a-z]*)+$": {
              type: "boolean"
            }
          },
          additionalProperties: false
        },
        ignoreEOLComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {};
    const ignoreEOLComments = options.ignoreEOLComments;
    const exceptions = Object.assign({
      Property: true
    }, options.exceptions);
    const hasExceptions = Object.keys(exceptions).filter(key => exceptions[key]).length > 0;

    /**
     * Formats value of given comment token for error message by truncating its length.
     * @param {Token} token comment token
     * @returns {string} formatted value
     * @private
     */
    function formatReportedCommentValue(token) {
      const valueLines = token.value.split("\n");
      const value = valueLines[0];
      const formattedValue = `${value.slice(0, 12)}...`;
      return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program() {
        sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
          if (leftIndex === tokensAndComments.length - 1) {
            return;
          }
          const rightToken = tokensAndComments[leftIndex + 1];

          // Ignore tokens that don't have 2 spaces between them or are on different lines
          if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
            return;
          }

          // Ignore comments that are the last token on their line if `ignoreEOLComments` is active.
          if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
            return;
          }

          // Ignore tokens that are in a node in the "exceptions" object
          if (hasExceptions) {
            const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);
            if (parentNode && exceptions[parentNode.type]) {
              return;
            }
          }
          let displayValue;
          if (rightToken.type === "Block") {
            displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
          } else if (rightToken.type === "Line") {
            displayValue = `//${formatReportedCommentValue(rightToken)}`;
          } else {
            displayValue = rightToken.value;
          }
          context.report({
            node: rightToken,
            loc: rightToken.loc.start,
            message: "Multiple spaces found before '{{displayValue}}'.",
            data: {
              displayValue
            },
            fix: fixer => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
          });
        });
      }
    };
  }
};

/***/ }),
/* 350 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when using multiline strings
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiline strings",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multi-str"
    },
    schema: []
  },
  create(context) {
    /**
     * Determines if a given node is part of JSX syntax.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} True if the node is a JSX node, false if not.
     * @private
     */
    function isJSXElement(node) {
      return node.type.indexOf("JSX") === 0;
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      Literal(node) {
        if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
          context.report({
            node,
            message: "Multiline support is limited to browsers supporting ES5 only."
          });
        }
      }
    };
  }
};

/***/ }),
/* 351 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallows multiple blank lines.
 * implementation adapted from the no-trailing-spaces rule.
 * @author Greg Cochard
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple empty lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-multiple-empty-lines"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 0
        },
        maxEOF: {
          type: "integer",
          minimum: 0
        },
        maxBOF: {
          type: "integer",
          minimum: 0
        }
      },
      required: ["max"],
      additionalProperties: false
    }]
  },
  create(context) {
    // Use options.max or 2 as default
    let max = 2,
      maxEOF = max,
      maxBOF = max;
    if (context.options.length) {
      max = context.options[0].max;
      maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
      maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
    }
    const sourceCode = context.getSourceCode();

    // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue
    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
    const templateLiteralLines = new Set();

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      TemplateLiteral(node) {
        node.quasis.forEach(literalPart => {
          // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.
          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
            templateLiteralLines.add(ignoredLine);
          }
        });
      },
      "Program:exit"(node) {
        return allLines

        // Given a list of lines, first get a list of line numbers that are non-empty.
        .reduce((nonEmptyLineNumbers, line, index) => {
          if (line.trim() || templateLiteralLines.has(index + 1)) {
            nonEmptyLineNumbers.push(index + 1);
          }
          return nonEmptyLineNumbers;
        }, [])

        // Add a value at the end to allow trailing empty lines to be checked.
        .concat(allLines.length + 1)

        // Given two line numbers of non-empty lines, report the lines between if the difference is too large.
        .reduce((lastLineNumber, lineNumber) => {
          let message, maxAllowed;
          if (lastLineNumber === 0) {
            message = "Too many blank lines at the beginning of file. Max of {{max}} allowed.";
            maxAllowed = maxBOF;
          } else if (lineNumber === allLines.length + 1) {
            message = "Too many blank lines at the end of file. Max of {{max}} allowed.";
            maxAllowed = maxEOF;
          } else {
            message = "More than {{max}} blank {{pluralizedLines}} not allowed.";
            maxAllowed = max;
          }
          if (lineNumber - lastLineNumber - 1 > maxAllowed) {
            context.report({
              node,
              loc: {
                start: {
                  line: lastLineNumber + 1,
                  column: 0
                },
                end: {
                  line: lineNumber,
                  column: 0
                }
              },
              message,
              data: {
                max: maxAllowed,
                pluralizedLines: maxAllowed === 1 ? "line" : "lines"
              },
              fix(fixer) {
                const rangeStart = sourceCode.getIndexFromLoc({
                  line: lastLineNumber + 1,
                  column: 0
                });

                /*
                 * The end of the removal range is usually the start index of the next line.
                 * However, at the end of the file there is no next line, so the end of the
                 * range is just the length of the text.
                 */
                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({
                  line: lineNumberAfterRemovedLines,
                  column: 0
                }) : sourceCode.text.length;
                return fixer.removeRange([rangeStart, rangeEnd]);
              }
            });
          }
          return lineNumber;
        }, 0);
      }
    };
  }
};

/***/ }),
/* 352 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
 * @author Ilya Volodin
 * @deprecated in ESLint v3.3.0
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-native-reassign"
    },
    deprecated: true,
    replacedBy: ["no-global-assign"],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const config = context.options[0];
    const exceptions = config && config.exceptions || [];

    /**
     * Reports write references.
     * @param {Reference} reference - A reference to check.
     * @param {int} index - The index of the reference in the references.
     * @param {Reference[]} references - The array that the reference belongs to.
     * @returns {void}
     */
    function checkReference(reference, index, references) {
      const identifier = reference.identifier;
      if (reference.init === false && reference.isWrite() && (
      /*
       * Destructuring assignments can have multiple default value,
       * so possibly there are multiple writeable references for the same identifier.
       */
      index === 0 || references[index - 1].identifier !== identifier)) {
        context.report({
          node: identifier,
          message: "Read-only global '{{name}}' should not be modified.",
          data: identifier
        });
      }
    }

    /**
     * Reports write references if a given variable is read-only builtin.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
        variable.references.forEach(checkReference);
      }
    }
    return {
      Program() {
        const globalScope = context.getScope();
        globalScope.variables.forEach(checkVariable);
      }
    };
  }
};

/***/ }),
/* 353 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow a negated condition
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow negated conditions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-negated-condition"
    },
    schema: []
  },
  create(context) {
    /**
     * Determines if a given node is an if-else without a condition on the else
     * @param {ASTNode} node The node to check.
     * @returns {boolean} True if the node has an else without an if.
     * @private
     */
    function hasElseWithoutCondition(node) {
      return node.alternate && node.alternate.type !== "IfStatement";
    }

    /**
     * Determines if a given node is a negated unary expression
     * @param {Object} test The test object to check.
     * @returns {boolean} True if the node is a negated unary expression.
     * @private
     */
    function isNegatedUnaryExpression(test) {
      return test.type === "UnaryExpression" && test.operator === "!";
    }

    /**
     * Determines if a given node is a negated binary expression
     * @param {Test} test The test to check.
     * @returns {boolean} True if the node is a negated binary expression.
     * @private
     */
    function isNegatedBinaryExpression(test) {
      return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
    }

    /**
     * Determines if a given node has a negated if expression
     * @param {ASTNode} node The node to check.
     * @returns {boolean} True if the node has a negated if expression.
     * @private
     */
    function isNegatedIf(node) {
      return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
    }
    return {
      IfStatement(node) {
        if (!hasElseWithoutCondition(node)) {
          return;
        }
        if (isNegatedIf(node)) {
          context.report({
            node,
            message: "Unexpected negated condition."
          });
        }
      },
      ConditionalExpression(node) {
        if (isNegatedIf(node)) {
          context.report({
            node,
            message: "Unexpected negated condition."
          });
        }
      }
    };
  }
};

/***/ }),
/* 354 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to disallow negated left operands of the `in` operator
 * @author Michael Ficarra
 * @deprecated in ESLint v3.3.0
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand in `in` expressions",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-negated-in-lhs"
    },
    replacedBy: ["no-unsafe-negation"],
    deprecated: true,
    schema: []
  },
  create(context) {
    return {
      BinaryExpression(node) {
        if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
          context.report({
            node,
            message: "The 'in' expression's left operand is negated."
          });
        }
      }
    };
  }
};

/***/ }),
/* 355 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag nested ternary expressions
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow nested ternary expressions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-nested-ternary"
    },
    schema: []
  },
  create(context) {
    return {
      ConditionalExpression(node) {
        if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
          context.report({
            node,
            message: "Do not nest ternary expressions."
          });
        }
      }
    };
  }
};

/***/ }),
/* 356 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag statements with function invocation preceded by
 * "new" and not part of assignment
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators outside of assignments or comparisons",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new"
    },
    schema: []
  },
  create(context) {
    return {
      "ExpressionStatement > NewExpression"(node) {
        context.report({
          node: node.parent,
          message: "Do not use 'new' for side effects."
        });
      }
    };
  }
};

/***/ }),
/* 357 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when using new Function
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `Function` object",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-func"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports a node.
     * @param {ASTNode} node The node to report
     * @returns {void}
     * @private
     */
    function report(node) {
      context.report({
        node,
        message: "The Function constructor is eval."
      });
    }
    return {
      "NewExpression[callee.name = 'Function']": report,
      "CallExpression[callee.name = 'Function']": report
    };
  }
};

/***/ }),
/* 358 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to disallow calls to the Object constructor
 * @author Matt DuVall <http://www.mattduvall.com/>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Object` constructors",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-object"
    },
    schema: []
  },
  create(context) {
    return {
      NewExpression(node) {
        if (node.callee.name === "Object") {
          context.report({
            node,
            message: "The object literal notation {} is preferrable."
          });
        }
      }
    };
  }
};

/***/ }),
/* 359 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow use of new operator with the `require` function
 * @author Wil Moore III
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with calls to `require`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-require"
    },
    schema: []
  },
  create(context) {
    return {
      NewExpression(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "require") {
          context.report({
            node,
            message: "Unexpected use of new with require."
          });
        }
      }
    };
  }
};

/***/ }),
/* 360 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow use of the new operator with the `Symbol` object
 * @author Alberto Rodrguez
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `new` operators with the `Symbol` object",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-new-symbol"
    },
    schema: []
  },
  create(context) {
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const variable = globalScope.set.get("Symbol");
        if (variable && variable.defs.length === 0) {
          variable.references.forEach(ref => {
            const node = ref.identifier;
            if (node.parent && node.parent.type === "NewExpression") {
              context.report({
                node,
                message: "`Symbol` cannot be called as a constructor."
              });
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 361 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when using constructor for wrapper objects
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-new-wrappers"
    },
    schema: []
  },
  create(context) {
    return {
      NewExpression(node) {
        const wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
        if (wrapperObjects.indexOf(node.callee.name) > -1) {
          context.report({
            node,
            message: "Do not use {{fn}} as a constructor.",
            data: {
              fn: node.callee.name
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 362 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function
 * @author James Allardice
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling global object properties as functions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-obj-calls"
    },
    schema: []
  },
  create(context) {
    return {
      CallExpression(node) {
        if (node.callee.type === "Identifier") {
          const name = node.callee.name;
          if (name === "Math" || name === "JSON" || name === "Reflect") {
            context.report({
              node,
              message: "'{{name}}' is not a function.",
              data: {
                name
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 363 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when initializing octal literal
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal literals",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-octal"
    },
    schema: []
  },
  create(context) {
    return {
      Literal(node) {
        if (typeof node.value === "number" && /^0[0-7]/u.test(node.raw)) {
          context.report({
            node,
            message: "Octal literals should not be used."
          });
        }
      }
    };
  }
};

/***/ }),
/* 364 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag octal escape sequences in string literals.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal escape sequences in string literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-octal-escape"
    },
    schema: []
  },
  create(context) {
    return {
      Literal(node) {
        if (typeof node.value !== "string") {
          return;
        }
        const match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/u);
        if (match) {
          const octalDigit = match[2];

          // \0 is actually not considered an octal
          if (match[2] !== "0" || typeof match[3] !== "undefined") {
            context.report({
              node,
              message: "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.",
              data: {
                octalDigit
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 365 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow reassignment of function parameters.
 * @author Nat Burns
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow reassigning `function` parameters",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-param-reassign"
    },
    schema: [{
      oneOf: [{
        type: "object",
        properties: {
          props: {
            enum: [false]
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          props: {
            enum: [true]
          },
          ignorePropertyModificationsFor: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const props = context.options[0] && context.options[0].props;
    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];

    /**
     * Checks whether or not the reference modifies properties of its variable.
     * @param {Reference} reference - A reference to check.
     * @returns {boolean} Whether or not the reference modifies properties of its variable.
     */
    function isModifyingProp(reference) {
      let node = reference.identifier;
      let parent = node.parent;
      while (parent && !stopNodePattern.test(parent.type)) {
        switch (parent.type) {
          // e.g. foo.a = 0;
          case "AssignmentExpression":
            return parent.left === node;

          // e.g. ++foo.a;
          case "UpdateExpression":
            return true;

          // e.g. delete foo.a;
          case "UnaryExpression":
            if (parent.operator === "delete") {
              return true;
            }
            break;

          // EXCLUDES: e.g. cache.get(foo.a).b = 0;
          case "CallExpression":
            if (parent.callee !== node) {
              return false;
            }
            break;

          // EXCLUDES: e.g. cache[foo.a] = 0;
          case "MemberExpression":
            if (parent.property === node) {
              return false;
            }
            break;

          // EXCLUDES: e.g. ({ [foo]: a }) = bar;
          case "Property":
            if (parent.key === node) {
              return false;
            }
            break;

          // EXCLUDES: e.g. (foo ? a : b).c = bar;
          case "ConditionalExpression":
            if (parent.test === node) {
              return false;
            }
            break;

          // no default
        }
        node = parent;
        parent = node.parent;
      }
      return false;
    }

    /**
     * Reports a reference if is non initializer and writable.
     * @param {Reference} reference - A reference to check.
     * @param {int} index - The index of the reference in the references.
     * @param {Reference[]} references - The array that the reference belongs to.
     * @returns {void}
     */
    function checkReference(reference, index, references) {
      const identifier = reference.identifier;
      if (identifier && !reference.init && (
      /*
       * Destructuring assignments can have multiple default value,
       * so possibly there are multiple writeable references for the same identifier.
       */
      index === 0 || references[index - 1].identifier !== identifier)) {
        if (reference.isWrite()) {
          context.report({
            node: identifier,
            message: "Assignment to function parameter '{{name}}'.",
            data: {
              name: identifier.name
            }
          });
        } else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {
          context.report({
            node: identifier,
            message: "Assignment to property of function parameter '{{name}}'.",
            data: {
              name: identifier.name
            }
          });
        }
      }
    }

    /**
     * Finds and reports references that are non initializer and writable.
     * @param {Variable} variable - A variable to check.
     * @returns {void}
     */
    function checkVariable(variable) {
      if (variable.defs[0].type === "Parameter") {
        variable.references.forEach(checkReference);
      }
    }

    /**
     * Checks parameters of a given function node.
     * @param {ASTNode} node - A function node to check.
     * @returns {void}
     */
    function checkForFunction(node) {
      context.getDeclaredVariables(node).forEach(checkVariable);
    }
    return {
      // `:exit` is needed for the `node.parent` property of identifier nodes.
      "FunctionDeclaration:exit": checkForFunction,
      "FunctionExpression:exit": checkForFunction,
      "ArrowFunctionExpression:exit": checkForFunction
    };
  }
};

/***/ }),
/* 366 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow string concatenation when using __dirname and __filename
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow string concatenation with `__dirname` and `__filename`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-path-concat"
    },
    schema: []
  },
  create(context) {
    const MATCHER = /^__(?:dir|file)name$/u;

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      BinaryExpression(node) {
        const left = node.left,
          right = node.right;
        if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {
          context.report({
            node,
            message: "Use path.join() or path.resolve() instead of + to create paths."
          });
        }
      }
    };
  }
};

/***/ }),
/* 367 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of unary increment and decrement operators.
 * @author Ian Christian Myers
 * @author Brody McKee (github.com/mrmckeb)
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the unary operators `++` and `--`",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-plusplus"
    },
    schema: [{
      type: "object",
      properties: {
        allowForLoopAfterthoughts: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const config = context.options[0];
    let allowInForAfterthought = false;
    if (typeof config === "object") {
      allowInForAfterthought = config.allowForLoopAfterthoughts === true;
    }
    return {
      UpdateExpression(node) {
        if (allowInForAfterthought && node.parent.type === "ForStatement") {
          return;
        }
        context.report({
          node,
          message: "Unary operator '{{operator}}' used.",
          data: {
            operator: node.operator
          }
        });
      }
    };
  }
};

/***/ }),
/* 368 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow the use of process.env()
 * @author Vignesh Anand
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.env`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-process-env"
    },
    schema: []
  },
  create(context) {
    return {
      MemberExpression(node) {
        const objectName = node.object.name,
          propertyName = node.property.name;
        if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
          context.report({
            node,
            message: "Unexpected use of process.env."
          });
        }
      }
    };
  }
};

/***/ }),
/* 369 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow the use of process.exit()
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.exit()`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-process-exit"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node) {
        context.report({
          node: node.parent,
          message: "Don't use process.exit(); throw an error instead."
        });
      }
    };
  }
};

/***/ }),
/* 370 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag usage of __proto__ property
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__proto__` property",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-proto"
    },
    schema: []
  },
  create(context) {
    return {
      MemberExpression(node) {
        if (node.property && node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed || node.property.type === "Literal" && node.property.value === "__proto__") {
          context.report({
            node,
            message: "The '__proto__' property is deprecated."
          });
        }
      }
    };
  }
};

/***/ }),
/* 371 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow use of Object.prototype builtins on objects
 * @author Andrew Levine
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling some `Object.prototype` methods directly on objects",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-prototype-builtins"
    },
    schema: []
  },
  create(context) {
    const DISALLOWED_PROPS = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];

    /**
     * Reports if a disallowed property is used in a CallExpression
     * @param {ASTNode} node The CallExpression node.
     * @returns {void}
     */
    function disallowBuiltIns(node) {
      if (node.callee.type !== "MemberExpression" || node.callee.computed) {
        return;
      }
      const propName = node.callee.property.name;
      if (DISALLOWED_PROPS.indexOf(propName) > -1) {
        context.report({
          message: "Do not access Object.prototype method '{{prop}}' from target object.",
          loc: node.callee.property.loc.start,
          data: {
            prop: propName
          },
          node
        });
      }
    }
    return {
      CallExpression: disallowBuiltIns
    };
  }
};

/***/ }),
/* 372 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when the same variable is declared more then once.
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable redeclaration",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-redeclare"
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = {
      builtinGlobals: context.options[0] && context.options[0].builtinGlobals
    };

    /**
     * Find variables in a given scope and flag redeclared ones.
     * @param {Scope} scope - An eslint-scope scope object.
     * @returns {void}
     * @private
     */
    function findVariablesInScope(scope) {
      scope.variables.forEach(variable => {
        const hasBuiltin = options.builtinGlobals && "writeable" in variable;
        const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;
        if (count >= 2) {
          variable.identifiers.sort((a, b) => a.range[1] - b.range[1]);
          for (let i = hasBuiltin ? 0 : 1, l = variable.identifiers.length; i < l; i++) {
            context.report({
              node: variable.identifiers[i],
              message: "'{{a}}' is already defined.",
              data: {
                a: variable.name
              }
            });
          }
        }
      });
    }

    /**
     * Find variables in the current scope.
     * @param {ASTNode} node - The Program node.
     * @returns {void}
     * @private
     */
    function checkForGlobal(node) {
      const scope = context.getScope(),
        parserOptions = context.parserOptions,
        ecmaFeatures = parserOptions.ecmaFeatures || {};

      // Nodejs env or modules has a special scope.
      if (ecmaFeatures.globalReturn || node.sourceType === "module") {
        findVariablesInScope(scope.childScopes[0]);
      } else {
        findVariablesInScope(scope);
      }
    }

    /**
     * Find variables in the current scope.
     * @returns {void}
     * @private
     */
    function checkForBlock() {
      findVariablesInScope(context.getScope());
    }
    if (context.parserOptions.ecmaVersion >= 6) {
      return {
        Program: checkForGlobal,
        BlockStatement: checkForBlock,
        SwitchStatement: checkForBlock
      };
    }
    return {
      Program: checkForGlobal,
      FunctionDeclaration: checkForBlock,
      FunctionExpression: checkForBlock,
      ArrowFunctionExpression: checkForBlock
    };
  }
};

/***/ }),
/* 373 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to count multiple spaces in regular expressions
 * @author Matt DuVall <http://www.mattduvall.com/>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiple spaces in regular expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-regex-spaces"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Validate regular expressions
     * @param {ASTNode} node node to validate
     * @param {string} value regular expression to validate
     * @param {number} valueStart The start location of the regex/string literal. It will always be the case that
     * `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`
     * @returns {void}
     * @private
     */
    function checkRegex(node, value, valueStart) {
      const multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/u,
        regexResults = multipleSpacesRegex.exec(value);
      if (regexResults !== null) {
        const count = regexResults[1].length;
        context.report({
          node,
          message: "Spaces are hard to count. Use {{{count}}}.",
          data: {
            count
          },
          fix(fixer) {
            return fixer.replaceTextRange([valueStart + regexResults.index, valueStart + regexResults.index + count], ` {${count}}`);
          }
        });

        /*
         * TODO: (platinumazure) Fix message to use rule message
         * substitution when api.report is fixed in lib/eslint.js.
         */
      }
    }

    /**
     * Validate regular expression literals
     * @param {ASTNode} node node to validate
     * @returns {void}
     * @private
     */
    function checkLiteral(node) {
      const token = sourceCode.getFirstToken(node),
        nodeType = token.type,
        nodeValue = token.value;
      if (nodeType === "RegularExpression") {
        checkRegex(node, nodeValue, token.range[0]);
      }
    }

    /**
     * Check if node is a string
     * @param {ASTNode} node node to evaluate
     * @returns {boolean} True if its a string
     * @private
     */
    function isString(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }

    /**
     * Validate strings passed to the RegExp constructor
     * @param {ASTNode} node node to validate
     * @returns {void}
     * @private
     */
    function checkFunction(node) {
      const scope = context.getScope();
      const regExpVar = astUtils.getVariableByName(scope, "RegExp");
      const shadowed = regExpVar && regExpVar.defs.length > 0;
      if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) {
        checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
      }
    }
    return {
      Literal: checkLiteral,
      CallExpression: checkFunction,
      NewExpression: checkFunction
    };
  }
};

/***/ }),
/* 374 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Restrict usage of specified globals.
 * @author Benot Zugmeyer
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const DEFAULT_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'.",
  CUSTOM_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'. {{customMessage}}";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified global variables",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-globals"
    },
    schema: {
      type: "array",
      items: {
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["name"],
          additionalProperties: false
        }]
      },
      uniqueItems: true,
      minItems: 0
    }
  },
  create(context) {
    // If no globals are restricted, we don't need to do anything
    if (context.options.length === 0) {
      return {};
    }
    const restrictedGlobalMessages = context.options.reduce((memo, option) => {
      if (typeof option === "string") {
        memo[option] = null;
      } else {
        memo[option.name] = option.message;
      }
      return memo;
    }, {});

    /**
     * Report a variable to be used as a restricted global.
     * @param {Reference} reference the variable reference
     * @returns {void}
     * @private
     */
    function reportReference(reference) {
      const name = reference.identifier.name,
        customMessage = restrictedGlobalMessages[name],
        message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;
      context.report({
        node: reference.identifier,
        message,
        data: {
          name,
          customMessage
        }
      });
    }

    /**
     * Check if the given name is a restricted global name.
     * @param {string} name name of a variable
     * @returns {boolean} whether the variable is a restricted global or not
     * @private
     */
    function isRestricted(name) {
      return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);
    }
    return {
      Program() {
        const scope = context.getScope();

        // Report variables declared elsewhere (ex: variables defined as "global" by eslint)
        scope.variables.forEach(variable => {
          if (!variable.defs.length && isRestricted(variable.name)) {
            variable.references.forEach(reportReference);
          }
        });

        // Report variables not declared at all
        scope.through.forEach(reference => {
          if (isRestricted(reference.identifier.name)) {
            reportReference(reference);
          }
        });
      }
    };
  }
};

/***/ }),
/* 375 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Restrict usage of specified node imports.
 * @author Guy Ellis
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const DEFAULT_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used.";
const CUSTOM_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used. {{customMessage}}";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ignore = __webpack_require__(376);
const arrayOfStrings = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: true
};
const arrayOfStringsOrObjects = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        },
        importNames: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false,
      required: ["name"]
    }]
  },
  uniqueItems: true
};
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `import`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-imports"
    },
    schema: {
      anyOf: [arrayOfStringsOrObjects, {
        type: "array",
        items: {
          type: "object",
          properties: {
            paths: arrayOfStringsOrObjects,
            patterns: arrayOfStrings
          },
          additionalProperties: false
        },
        additionalItems: false
      }]
    }
  },
  create(context) {
    const options = Array.isArray(context.options) ? context.options : [];
    const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {
      if (typeof importSource === "string") {
        memo[importSource] = {
          message: null
        };
      } else {
        memo[importSource.name] = {
          message: importSource.message,
          importNames: importSource.importNames
        };
      }
      return memo;
    }, {});

    // if no imports are restricted we don"t need to check
    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
      return {};
    }
    const restrictedPatternsMatcher = ignore().add(restrictedPatterns);

    /**
     * Checks to see if "*" is being used to import everything.
     * @param {Set.<string>} importNames - Set of import names that are being imported
     * @returns {boolean} whether everything is imported or not
     */
    function isEverythingImported(importNames) {
      return importNames.has("*");
    }

    /**
     * Report a restricted path.
     * @param {node} node representing the restricted path reference
     * @returns {void}
     * @private
     */
    function reportPath(node) {
      const importSource = node.source.value.trim();
      const customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;
      const message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;
      context.report({
        node,
        message,
        data: {
          importSource,
          customMessage
        }
      });
    }

    /**
     * Report a restricted path specifically for patterns.
     * @param {node} node - representing the restricted path reference
     * @returns {void}
     * @private
     */
    function reportPathForPatterns(node) {
      const importSource = node.source.value.trim();
      context.report({
        node,
        message: "'{{importSource}}' import is restricted from being used by a pattern.",
        data: {
          importSource
        }
      });
    }

    /**
     * Report a restricted path specifically when using the '*' import.
     * @param {string} importSource - path of the import
     * @param {node} node - representing the restricted path reference
     * @returns {void}
     * @private
     */
    function reportPathForEverythingImported(importSource, node) {
      const importNames = restrictedPathMessages[importSource].importNames;
      context.report({
        node,
        message: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
        data: {
          importSource,
          importNames
        }
      });
    }

    /**
     * Check if the given importSource is restricted because '*' is being imported.
     * @param {string} importSource - path of the import
     * @param {Set.<string>} importNames - Set of import names that are being imported
     * @returns {boolean} whether the path is restricted
     * @private
     */
    function isRestrictedForEverythingImported(importSource, importNames) {
      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) && restrictedPathMessages[importSource].importNames && isEverythingImported(importNames);
    }

    /**
     * Check if the given importNames are restricted given a list of restrictedImportNames.
     * @param {Set.<string>} importNames - Set of import names that are being imported
     * @param {string[]} restrictedImportNames - array of import names that are restricted for this import
     * @returns {boolean} whether the objectName is restricted
     * @private
     */
    function isRestrictedObject(importNames, restrictedImportNames) {
      return restrictedImportNames.some(restrictedObjectName => importNames.has(restrictedObjectName));
    }

    /**
     * Check if the given importSource is a restricted path.
     * @param {string} importSource - path of the import
     * @param {Set.<string>} importNames - Set of import names that are being imported
     * @returns {boolean} whether the variable is a restricted path or not
     * @private
     */
    function isRestrictedPath(importSource, importNames) {
      let isRestricted = false;
      if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
        if (restrictedPathMessages[importSource].importNames) {
          isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);
        } else {
          isRestricted = true;
        }
      }
      return isRestricted;
    }

    /**
     * Check if the given importSource is restricted by a pattern.
     * @param {string} importSource - path of the import
     * @returns {boolean} whether the variable is a restricted pattern or not
     * @private
     */
    function isRestrictedPattern(importSource) {
      return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
    }

    /**
     * Checks a node to see if any problems should be reported.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     * @private
     */
    function checkNode(node) {
      const importSource = node.source.value.trim();
      const importNames = node.specifiers ? node.specifiers.reduce((set, specifier) => {
        if (specifier.type === "ImportDefaultSpecifier") {
          set.add("default");
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          set.add("*");
        } else if (specifier.imported) {
          set.add(specifier.imported.name);
        } else if (specifier.local) {
          set.add(specifier.local.name);
        }
        return set;
      }, new Set()) : new Set();
      if (isRestrictedForEverythingImported(importSource, importNames)) {
        reportPathForEverythingImported(importSource, node);
      }
      if (isRestrictedPath(importSource, importNames)) {
        reportPath(node);
      }
      if (isRestrictedPattern(importSource)) {
        reportPathForPatterns(node);
      }
    }
    return {
      ImportDeclaration: checkNode,
      ExportNamedDeclaration(node) {
        if (node.source) {
          checkNode(node);
        }
      },
      ExportAllDeclaration: checkNode
    };
  }
};

/***/ }),
/* 376 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(6);
// A simple implementation of make-array
function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}
const REGEX_BLANK_LINE = /^\s+$/;
const REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
const REGEX_LEADING_EXCAPED_HASH = /^\\#/;
const SLASH = '/';
const KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
/* istanbul ignore next */ : 'node-ignore';
const define = (object, key, value) => Object.defineProperty(object, key, {
  value
});
const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match
// Invalid range (out of order) which is ok for gitignore rules but
//   fatal for JavaScript regular expression, so eliminate it.
: '');

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const DEFAULT_REPLACER_PREFIX = [
// > Trailing spaces are ignored unless they are quoted with backslash ("\")
[
// (a\ ) -> (a )
// (a  ) -> (a)
// (a \ ) -> (a  )
/\\?\s+$/, match => match.indexOf('\\') === 0 ? ' ' : ''],
// replace (\ ) with ' '
[/\\\s/g, () => ' '],
// Escape metacharacters
// which is written down by users but means special for regular expressions.

// > There are 12 characters with special meanings:
// > - the backslash \,
// > - the caret ^,
// > - the dollar sign $,
// > - the period or dot .,
// > - the vertical bar or pipe symbol |,
// > - the question mark ?,
// > - the asterisk or star *,
// > - the plus sign +,
// > - the opening parenthesis (,
// > - the closing parenthesis ),
// > - and the opening square bracket [,
// > - the opening curly brace {,
// > These special characters are often called "metacharacters".
[/[\\^$.|*+(){]/g, match => `\\${match}`], [
// > [abc] matches any character inside the brackets
// >    (in this case a, b, or c);
/\[([^\]/]*)($|\])/g, (match, p1, p2) => p2 === ']' ? `[${sanitizeRange(p1)}]` : `\\${match}`], [
// > a question mark (?) matches a single character
/(?!\\)\?/g, () => '[^/]'],
// leading slash
[
// > A leading slash matches the beginning of the pathname.
// > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
// A leading slash matches the beginning of the pathname
/^\//, () => '^'],
// replace special metacharacter slash after the leading slash
[/\//g, () => '\\/'], [
// > A leading "**" followed by a slash means match in all directories.
// > For example, "**/foo" matches file or directory "foo" anywhere,
// > the same as pattern "foo".
// > "**/foo/bar" matches file or directory "bar" anywhere that is directly
// >   under directory "foo".
// Notice that the '*'s have been replaced as '\\*'
/^\^*\\\*\\\*\\\//,
// '**/foo' <-> 'foo'
() => '^(?:.*\\/)?']];
const DEFAULT_REPLACER_SUFFIX = [
// starting
[
// there will be no leading '/'
//   (which has been replaced by section "leading slash")
// If starts with '**', adding a '^' to the regular expression also works
/^(?=[^^])/, function startingReplacer() {
  return !/\/(?!$)/.test(this)
  // > If the pattern does not contain a slash /,
  // >   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern
  ? '(?:^|\\/)'

  // > Otherwise, Git treats the pattern as a shell glob suitable for
  // >   consumption by fnmatch(3)
  : '^';
}],
// two globstars
[
// Use lookahead assertions so that we could match more than one `'/**'`
/\\\/\\\*\\\*(?=\\\/|$)/g,
// Zero, one or several directories
// should not use '*', or it will be replaced by the next replacer

// Check if it is not the last `'/**'`
(match, index, str) => index + 6 < str.length

// case: /**/
// > A slash followed by two consecutive asterisks then a slash matches
// >   zero or more directories.
// > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
// '/**/'
? '(?:\\/[^\\/]+)*'

// case: /**
// > A trailing `"/**"` matches everything inside.

// #21: everything inside but it should not include the current folder
: '\\/.+'],
// intermediate wildcards
[
// Never replace escaped '*'
// ignore rule '\*' will match the path '*'

// 'abc.*/' -> go
// 'abc.*'  -> skip this rule
/(^|[^\\]+)\\\*(?=.+)/g,
// '*.js' matches '.js'
// '*.js' doesn't match 'abc'
(match, p1) => `${p1}[^\\/]*`],
// trailing wildcard
[/(\^|\\\/)?\\\*$/, (match, p1) => {
  const prefix = p1
  // '\^':
  // '/*' does not match ''
  // '/*' does not match everything

  // '\\\/':
  // 'abc/*' does not match 'abc/'
  ? `${p1}[^/]+`

  // 'a*' matches 'a'
  // 'a*' matches 'aa'
  : '[^/]*';
  return `${prefix}(?=$|\\/$)`;
}], [
// unescape
/\\\\\\/g, () => '\\']];
const POSITIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX,
// 'f'
// matches
// - /f(end)
// - /f/
// - (start)f(end)
// - (start)f/
// doesn't match
// - oof
// - foo
// pseudo:
// -> (^|/)f(/|$)

// ending
[
// 'js' will not match 'js.'
// 'ab' will not match 'abc'
/(?:[^*/])$/,
// 'js*' will not match 'a.js'
// 'js/' will not match 'a.js'
// 'js' will match 'a.js' and 'a.js/'
match => `${match}(?=$|\\/)`], ...DEFAULT_REPLACER_SUFFIX];
const NEGATIVE_REPLACERS = [...DEFAULT_REPLACER_PREFIX,
// #24, #38
// The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)
// A negative pattern without a trailing wildcard should not
// re-include the things inside that directory.

// eg:
// ['node_modules/*', '!node_modules']
// should ignore `node_modules/a.js`
[/(?:[^*])$/, match => `${match}(?=$|\\/$)`], ...DEFAULT_REPLACER_SUFFIX];

// A simple cache, because an ignore rule only has only one certain meaning
const cache = Object.create(null);

// @param {pattern}
const make_regex = (pattern, negative, ignorecase) => {
  const r = cache[pattern];
  if (r) {
    return r;
  }
  const replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;
  const source = replacers.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
  return cache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);
};

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)

// > A line starting with # serves as a comment.
&& pattern.indexOf('#') !== 0;
const createRule = (pattern, ignorecase) => {
  const origin = pattern;
  let negative = false;

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true;
    pattern = pattern.substr(1);
  }
  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_LEADING_EXCAPED_HASH, '#');
  const regex = make_regex(pattern, negative, ignorecase);
  return {
    origin,
    pattern,
    negative,
    regex
  };
};
class IgnoreBase {
  constructor() {
    let {
      ignorecase = true
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._rules = [];
    this._ignorecase = ignorecase;
    define(this, KEY_IGNORE, true);
    this._initCache();
  }
  _initCache() {
    this._cache = Object.create(null);
  }

  // @param {Array.<string>|string|Ignore} pattern
  add(pattern) {
    this._added = false;
    if (typeof pattern === 'string') {
      pattern = pattern.split(/\r?\n/g);
    }
    make_array(pattern).forEach(this._addPattern, this);

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache();
    }
    return this;
  }

  // legacy
  addPattern(pattern) {
    return this.add(pattern);
  }
  _addPattern(pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules);
      this._added = true;
      return;
    }
    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignorecase);
      this._added = true;
      this._rules.push(rule);
    }
  }
  filter(paths) {
    return make_array(paths).filter(path => this._filter(path));
  }
  createFilter() {
    return path => this._filter(path);
  }
  ignores(path) {
    return !this._filter(path);
  }

  // @returns `Boolean` true if the `path` is NOT ignored
  _filter(path, slices) {
    if (!path) {
      return false;
    }
    if (path in this._cache) {
      return this._cache[path];
    }
    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH);
    }
    slices.pop();
    return this._cache[path] = slices.length
    // > It is not possible to re-include a file if a parent directory of
    // >   that file is excluded.
    // If the path contains a parent directory, check the parent first
    ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)

    // Or only test the path
    : this._test(path);
  }

  // @returns {Boolean} true if a file is NOT ignored
  _test(path) {
    // Explicitly define variable type by setting matched to `0`
    let matched = 0;
    this._rules.forEach(rule => {
      // if matched = true, then we only test negative rules
      // if matched = false, then we test non-negative rules
      if (!(matched ^ rule.negative)) {
        matched = rule.negative ^ rule.regex.test(path);
      }
    });
    return !matched;
  }
}

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
// Detect `process` so that it can run in browsers.
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {
  const filter = IgnoreBase.prototype._filter;

  /* eslint no-control-regex: "off" */
  const make_posix = str => /^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/');
  IgnoreBase.prototype._filter = function filterWin32(path, slices) {
    path = make_posix(path);
    return filter.call(this, path, slices);
  };
}
module.exports = options => new IgnoreBase(options);

/***/ }),
/* 377 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Restrict usage of specified node modules.
 * @author Christian Schulz
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const DEFAULT_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used.";
const CUSTOM_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used. {{customMessage}}";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ignore = __webpack_require__(376);
const arrayOfStrings = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: true
};
const arrayOfStringsOrObjects = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        }
      },
      additionalProperties: false,
      required: ["name"]
    }]
  },
  uniqueItems: true
};
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `require`",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-modules"
    },
    schema: {
      anyOf: [arrayOfStringsOrObjects, {
        type: "array",
        items: {
          type: "object",
          properties: {
            paths: arrayOfStringsOrObjects,
            patterns: arrayOfStrings
          },
          additionalProperties: false
        },
        additionalItems: false
      }]
    }
  },
  create(context) {
    const options = Array.isArray(context.options) ? context.options : [];
    const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
    const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {
      if (typeof importName === "string") {
        memo[importName] = null;
      } else {
        memo[importName.name] = importName.message;
      }
      return memo;
    }, {});

    // if no imports are restricted we don"t need to check
    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
      return {};
    }
    const ig = ignore().add(restrictedPatterns);

    /**
     * Function to check if a node is a string literal.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} If the node is a string literal.
     */
    function isString(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }

    /**
     * Function to check if a node is a require call.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} If the node is a require call.
     */
    function isRequireCall(node) {
      return node.callee.type === "Identifier" && node.callee.name === "require";
    }

    /**
     * Report a restricted path.
     * @param {node} node representing the restricted path reference
     * @returns {void}
     * @private
     */
    function reportPath(node) {
      const moduleName = node.arguments[0].value.trim();
      const customMessage = restrictedPathMessages[moduleName];
      const message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;
      context.report({
        node,
        message,
        data: {
          moduleName,
          customMessage
        }
      });
    }

    /**
     * Check if the given name is a restricted path name
     * @param {string} name name of a variable
     * @returns {boolean} whether the variable is a restricted path or not
     * @private
     */
    function isRestrictedPath(name) {
      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
    }
    return {
      CallExpression(node) {
        if (isRequireCall(node)) {
          // node has arguments and first argument is string
          if (node.arguments.length && isString(node.arguments[0])) {
            const moduleName = node.arguments[0].value.trim();

            // check if argument value is in restricted modules array
            if (isRestrictedPath(moduleName)) {
              reportPath(node);
            }
            if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {
              context.report({
                node,
                message: "'{{moduleName}}' module is restricted from being used by a pattern.",
                data: {
                  moduleName
                }
              });
            }
          }
        }
      }
    };
  }
};

/***/ }),
/* 378 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow certain object properties
 * @author Will Klein & Eli White
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow certain properties on certain objects",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-properties"
    },
    schema: {
      type: "array",
      items: {
        anyOf: [
        // `object` and `property` are both optional, but at least one of them must be provided.
        {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["object"]
        }, {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: false,
          required: ["property"]
        }]
      },
      uniqueItems: true
    }
  },
  create(context) {
    const restrictedCalls = context.options;
    if (restrictedCalls.length === 0) {
      return {};
    }
    const restrictedProperties = new Map();
    const globallyRestrictedObjects = new Map();
    const globallyRestrictedProperties = new Map();
    restrictedCalls.forEach(option => {
      const objectName = option.object;
      const propertyName = option.property;
      if (typeof objectName === "undefined") {
        globallyRestrictedProperties.set(propertyName, {
          message: option.message
        });
      } else if (typeof propertyName === "undefined") {
        globallyRestrictedObjects.set(objectName, {
          message: option.message
        });
      } else {
        if (!restrictedProperties.has(objectName)) {
          restrictedProperties.set(objectName, new Map());
        }
        restrictedProperties.get(objectName).set(propertyName, {
          message: option.message
        });
      }
    });

    /**
     * Checks to see whether a property access is restricted, and reports it if so.
     * @param {ASTNode} node The node to report
     * @param {string} objectName The name of the object
     * @param {string} propertyName The name of the property
     * @returns {undefined}
     */
    function checkPropertyAccess(node, objectName, propertyName) {
      if (propertyName === null) {
        return;
      }
      const matchedObject = restrictedProperties.get(objectName);
      const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
      const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);
      if (matchedObjectProperty) {
        const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
        context.report({
          node,
          // eslint-disable-next-line eslint-plugin/report-message-format
          message: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
          data: {
            objectName,
            propertyName,
            message
          }
        });
      } else if (globalMatchedProperty) {
        const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
        context.report({
          node,
          // eslint-disable-next-line eslint-plugin/report-message-format
          message: "'{{propertyName}}' is restricted from being used.{{message}}",
          data: {
            propertyName,
            message
          }
        });
      }
    }

    /**
     * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`
     * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node
     * @returns {undefined}
     */
    function checkDestructuringAssignment(node) {
      if (node.right.type === "Identifier") {
        const objectName = node.right.name;
        if (node.left.type === "ObjectPattern") {
          node.left.properties.forEach(property => {
            checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
          });
        }
      }
    }
    return {
      MemberExpression(node) {
        checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
      },
      VariableDeclarator(node) {
        if (node.init && node.init.type === "Identifier") {
          const objectName = node.init.name;
          if (node.id.type === "ObjectPattern") {
            node.id.properties.forEach(property => {
              checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
            });
          }
        }
      },
      AssignmentExpression: checkDestructuringAssignment,
      AssignmentPattern: checkDestructuringAssignment
    };
  }
};

/***/ }),
/* 379 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of certain node types
 * @author Burak Yigit Kaya
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified syntax",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-restricted-syntax"
    },
    schema: {
      type: "array",
      items: [{
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            selector: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["selector"],
          additionalProperties: false
        }]
      }],
      uniqueItems: true,
      minItems: 0
    }
  },
  create(context) {
    return context.options.reduce((result, selectorOrObject) => {
      const isStringFormat = typeof selectorOrObject === "string";
      const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
      const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
      const message = hasCustomMessage ? selectorOrObject.message : "Using '{{selector}}' is not allowed.";
      return Object.assign(result, {
        [selector](node) {
          context.report({
            node,
            message,
            data: hasCustomMessage ? {} : {
              selector
            }
          });
        }
      });
    }, {});
  }
};

/***/ }),
/* 380 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when return statement contains assignment
 * @author Ilya Volodin
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignment operators in `return` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-return-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }]
  },
  create(context) {
    const always = (context.options[0] || "except-parens") !== "except-parens";
    const sourceCode = context.getSourceCode();
    return {
      AssignmentExpression(node) {
        if (!always && astUtils.isParenthesised(sourceCode, node)) {
          return;
        }
        let currentChild = node;
        let parent = currentChild.parent;

        // Find ReturnStatement or ArrowFunctionExpression in ancestors.
        while (parent && !SENTINEL_TYPE.test(parent.type)) {
          currentChild = parent;
          parent = parent.parent;
        }

        // Reports.
        if (parent && parent.type === "ReturnStatement") {
          context.report({
            node: parent,
            message: "Return statement should not contain assignment."
          });
        } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === currentChild) {
          context.report({
            node: parent,
            message: "Arrow function should not return assignment."
          });
        }
      }
    };
  }
};

/***/ }),
/* 381 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallows unnecessary `return await`
 * @author Jordan Harband
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const message = "Redundant use of `await` on a return value.";
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `return await`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-return-await"
    },
    fixable: null,
    schema: []
  },
  create(context) {
    /**
     * Reports a found unnecessary `await` expression.
     * @param {ASTNode} node The node representing the `await` expression to report
     * @returns {void}
     */
    function reportUnnecessaryAwait(node) {
      context.report({
        node: context.getSourceCode().getFirstToken(node),
        loc: node.loc,
        message
      });
    }

    /**
     * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting
     * this function. For example, a statement in a `try` block will always have an error handler. A statement in
     * a `catch` block will only have an error handler if there is also a `finally` block.
     * @param {ASTNode} node A node representing a location where an could be thrown
     * @returns {boolean} `true` if a thrown error will be caught/handled in this function
     */
    function hasErrorHandler(node) {
      let ancestor = node;
      while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
        if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
          return true;
        }
        ancestor = ancestor.parent;
      }
      return false;
    }

    /**
     * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,
     * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.
     * @param {ASTNode} node A node representing the `await` expression to check
     * @returns {boolean} The checking result
     */
    function isInTailCallPosition(node) {
      if (node.parent.type === "ArrowFunctionExpression") {
        return true;
      }
      if (node.parent.type === "ReturnStatement") {
        return !hasErrorHandler(node.parent);
      }
      if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
        return isInTailCallPosition(node.parent);
      }
      if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
        return isInTailCallPosition(node.parent);
      }
      if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
        return isInTailCallPosition(node.parent);
      }
      return false;
    }
    return {
      AwaitExpression(node) {
        if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
          reportUnnecessaryAwait(node);
        }
      }
    };
  }
};

/***/ }),
/* 382 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when using javascript: urls
 * @author Ilya Volodin
 */
/* jshint scripturl: true */
/* eslint no-script-url: 0 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `javascript:` urls",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-script-url"
    },
    schema: []
  },
  create(context) {
    return {
      Literal(node) {
        if (node.value && typeof node.value === "string") {
          const value = node.value.toLowerCase();
          if (value.indexOf("javascript:") === 0) {
            context.report({
              node,
              message: "Script URL is a form of eval."
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 383 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow assignments where both sides are exactly the same
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SPACES = /\s+/gu;

/**
 * Checks whether the property of 2 given member expression nodes are the same
 * property or not.
 *
 * @param {ASTNode} left - A member expression node to check.
 * @param {ASTNode} right - Another member expression node to check.
 * @returns {boolean} `true` if the member expressions have the same property.
 */
function isSameProperty(left, right) {
  if (left.property.type === "Identifier" && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {
    return true;
  }
  const lname = astUtils.getStaticPropertyName(left);
  const rname = astUtils.getStaticPropertyName(right);
  return lname !== null && lname === rname;
}

/**
 * Checks whether 2 given member expression nodes are the reference to the same
 * property or not.
 *
 * @param {ASTNode} left - A member expression node to check.
 * @param {ASTNode} right - Another member expression node to check.
 * @returns {boolean} `true` if the member expressions are the reference to the
 *  same property or not.
 */
function isSameMember(left, right) {
  if (!isSameProperty(left, right)) {
    return false;
  }
  const lobj = left.object;
  const robj = right.object;
  if (lobj.type !== robj.type) {
    return false;
  }
  if (lobj.type === "MemberExpression") {
    return isSameMember(lobj, robj);
  }
  return lobj.type === "Identifier" && lobj.name === robj.name;
}

/**
 * Traverses 2 Pattern nodes in parallel, then reports self-assignments.
 *
 * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or
 *      a Property.
 * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or
 *      a Property.
 * @param {boolean} props - The flag to check member expressions as well.
 * @param {Function} report - A callback function to report.
 * @returns {void}
 */
function eachSelfAssignment(left, right, props, report) {
  if (!left || !right) {

    // do nothing
  } else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
    report(right);
  } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
    const end = Math.min(left.elements.length, right.elements.length);
    for (let i = 0; i < end; ++i) {
      const rightElement = right.elements[i];
      eachSelfAssignment(left.elements[i], rightElement, props, report);

      // After a spread element, those indices are unknown.
      if (rightElement && rightElement.type === "SpreadElement") {
        break;
      }
    }
  } else if (left.type === "RestElement" && right.type === "SpreadElement") {
    eachSelfAssignment(left.argument, right.argument, props, report);
  } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
    /*
     * Gets the index of the last spread property.
     * It's possible to overwrite properties followed by it.
     */
    let startJ = 0;
    for (let i = right.properties.length - 1; i >= 0; --i) {
      const propType = right.properties[i].type;
      if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
        startJ = i + 1;
        break;
      }
    }
    for (let i = 0; i < left.properties.length; ++i) {
      for (let j = startJ; j < right.properties.length; ++j) {
        eachSelfAssignment(left.properties[i], right.properties[j], props, report);
      }
    }
  } else if (left.type === "Property" && right.type === "Property" && !left.computed && !right.computed && right.kind === "init" && !right.method && left.key.name === right.key.name) {
    eachSelfAssignment(left.value, right.value, props, report);
  } else if (props && left.type === "MemberExpression" && right.type === "MemberExpression" && isSameMember(left, right)) {
    report(right);
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments where both sides are exactly the same",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-self-assign"
    },
    schema: [{
      type: "object",
      properties: {
        props: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const [{
      props = true
    } = {}] = context.options;

    /**
     * Reports a given node as self assignments.
     *
     * @param {ASTNode} node - A node to report. This is an Identifier node.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node,
        message: "'{{name}}' is assigned to itself.",
        data: {
          name: sourceCode.getText(node).replace(SPACES, "")
        }
      });
    }
    return {
      AssignmentExpression(node) {
        if (node.operator === "=") {
          eachSelfAssignment(node.left, node.right, props, report);
        }
      }
    };
  }
};

/***/ }),
/* 384 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag comparison where left part is the same as the right
 * part.
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparisons where both sides are exactly the same",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-self-compare"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Determines whether two nodes are composed of the same tokens.
     * @param {ASTNode} nodeA The first node
     * @param {ASTNode} nodeB The second node
     * @returns {boolean} true if the nodes have identical token representations
     */
    function hasSameTokens(nodeA, nodeB) {
      const tokensA = sourceCode.getTokens(nodeA);
      const tokensB = sourceCode.getTokens(nodeB);
      return tokensA.length === tokensB.length && tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);
    }
    return {
      BinaryExpression(node) {
        const operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);
        if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
          context.report({
            node,
            message: "Comparing to itself is potentially pointless."
          });
        }
      }
    };
  }
};

/***/ }),
/* 385 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of comma operator
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow comma operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-sequences"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Parts of the grammar that are required to have parens.
     */
    const parenthesized = {
      DoWhileStatement: "test",
      IfStatement: "test",
      SwitchStatement: "discriminant",
      WhileStatement: "test",
      WithStatement: "object",
      ArrowFunctionExpression: "body"

      /*
       * Omitting CallExpression - commas are parsed as argument separators
       * Omitting NewExpression - commas are parsed as argument separators
       * Omitting ForInStatement - parts aren't individually parenthesised
       * Omitting ForStatement - parts aren't individually parenthesised
       */
    };

    /**
     * Determines whether a node is required by the grammar to be wrapped in
     * parens, e.g. the test of an if statement.
     * @param {ASTNode} node - The AST node
     * @returns {boolean} True if parens around node belong to parent node.
     */
    function requiresExtraParens(node) {
      return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
    }

    /**
     * Check if a node is wrapped in parens.
     * @param {ASTNode} node - The AST node
     * @returns {boolean} True if the node has a paren on each side.
     */
    function isParenthesised(node) {
      return astUtils.isParenthesised(sourceCode, node);
    }

    /**
     * Check if a node is wrapped in two levels of parens.
     * @param {ASTNode} node - The AST node
     * @returns {boolean} True if two parens surround the node on each side.
     */
    function isParenthesisedTwice(node) {
      const previousToken = sourceCode.getTokenBefore(node, 1),
        nextToken = sourceCode.getTokenAfter(node, 1);
      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
    }
    return {
      SequenceExpression(node) {
        // Always allow sequences in for statement update
        if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
          return;
        }

        // Wrapping a sequence in extra parens indicates intent
        if (requiresExtraParens(node)) {
          if (isParenthesisedTwice(node)) {
            return;
          }
        } else {
          if (isParenthesised(node)) {
            return;
          }
        }
        const child = sourceCode.getTokenAfter(node.expressions[0]);
        context.report({
          node,
          loc: child.loc.start,
          message: "Unexpected use of comma operator."
        });
      }
    };
  }
};

/***/ }),
/* 386 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag on declaring variables already declared in the outer scope
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable declarations from shadowing variables declared in the outer scope",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-shadow"
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: false
        },
        hoist: {
          enum: ["all", "functions", "never"],
          default: "functions"
        },
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = {
      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,
      hoist: context.options[0] && context.options[0].hoist || "functions",
      allow: context.options[0] && context.options[0].allow || []
    };

    /**
     * Check if variable name is allowed.
     *
     * @param  {ASTNode} variable The variable to check.
     * @returns {boolean} Whether or not the variable name is allowed.
     */
    function isAllowed(variable) {
      return options.allow.indexOf(variable.name) !== -1;
    }

    /**
     * Checks if a variable of the class name in the class scope of ClassDeclaration.
     *
     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
     * So we should ignore the variable in the class scope.
     *
     * @param {Object} variable The variable to check.
     * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.
     */
    function isDuplicatedClassNameVariable(variable) {
      const block = variable.scope.block;
      return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
    }

    /**
     * Checks if a variable is inside the initializer of scopeVar.
     *
     * To avoid reporting at declarations such as `var a = function a() {};`.
     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
     *
     * @param {Object} variable The variable to check.
     * @param {Object} scopeVar The scope variable to look for.
     * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.
     */
    function isOnInitializer(variable, scopeVar) {
      const outerScope = scopeVar.scope;
      const outerDef = scopeVar.defs[0];
      const outer = outerDef && outerDef.parent && outerDef.parent.range;
      const innerScope = variable.scope;
      const innerDef = variable.defs[0];
      const inner = innerDef && innerDef.name.range;
      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
    }

    /**
     * Get a range of a variable's identifier node.
     * @param {Object} variable The variable to get.
     * @returns {Array|undefined} The range of the variable's identifier node.
     */
    function getNameRange(variable) {
      const def = variable.defs[0];
      return def && def.name.range;
    }

    /**
     * Checks if a variable is in TDZ of scopeVar.
     * @param {Object} variable The variable to check.
     * @param {Object} scopeVar The variable of TDZ.
     * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.
     */
    function isInTdz(variable, scopeVar) {
      const outerDef = scopeVar.defs[0];
      const inner = getNameRange(variable);
      const outer = getNameRange(scopeVar);
      return inner && outer && inner[1] < outer[0] && (
      // Excepts FunctionDeclaration if is {"hoist":"function"}.
      options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
    }

    /**
     * Checks the current context for shadowed variables.
     * @param {Scope} scope - Fixme
     * @returns {void}
     */
    function checkForShadows(scope) {
      const variables = scope.variables;
      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];

        // Skips "arguments" or variables of a class name in the class scope of ClassDeclaration.
        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
          continue;
        }

        // Gets shadowed variable.
        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);
        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
          context.report({
            node: variable.identifiers[0],
            message: "'{{name}}' is already declared in the upper scope.",
            data: variable
          });
        }
      }
    }
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const stack = globalScope.childScopes.slice();
        while (stack.length) {
          const scope = stack.pop();
          stack.push(...scope.childScopes);
          checkForShadows(scope);
        }
      }
    };
  }
};

/***/ }),
/* 387 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)
 * @author Michael Ficarra
 */


/**
 * Determines if a variable safely shadows undefined.
 * This is the case when a variable named `undefined` is never assigned to a value (i.e. it always shares the same value
 * as the global).
 * @param {eslintScope.Variable} variable The variable to check
 * @returns {boolean} true if this variable safely shadows `undefined`
 */
function safelyShadowsUndefined(variable) {
  return variable.name === "undefined" && variable.references.every(ref => !ref.isWrite()) && variable.defs.every(def => def.node.type === "VariableDeclarator" && def.node.init === null);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow identifiers from shadowing restricted names",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-shadow-restricted-names"
    },
    schema: []
  },
  create(context) {
    const RESTRICTED = new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
    return {
      "VariableDeclaration, :function, CatchClause"(node) {
        for (const variable of context.getDeclaredVariables(node)) {
          if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {
            context.report({
              node: variable.defs[0].name,
              message: "Shadowing of global property '{{idName}}'.",
              data: {
                idName: variable.name
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 388 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check that spaced function application
 * @author Matt DuVall <http://www.mattduvall.com>
 * @deprecated in ESLint v3.3.0
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow spacing between function identifiers and their applications (deprecated)",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-spaced-func"
    },
    deprecated: true,
    replacedBy: ["func-call-spacing"],
    fixable: "whitespace",
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Check if open space is present in a function name
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function detectOpenSpaces(node) {
      const lastCalleeToken = sourceCode.getLastToken(node.callee);
      let prevToken = lastCalleeToken,
        parenToken = sourceCode.getTokenAfter(lastCalleeToken);

      // advances to an open parenthesis.
      while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
        prevToken = parenToken;
        parenToken = sourceCode.getTokenAfter(parenToken);
      }

      // look for a space between the callee and the open paren
      if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
        context.report({
          node,
          loc: lastCalleeToken.loc.start,
          message: "Unexpected space between function name and paren.",
          fix(fixer) {
            return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
          }
        });
      }
    }
    return {
      CallExpression: detectOpenSpaces,
      NewExpression: detectOpenSpaces
    };
  }
};

/***/ }),
/* 389 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow sparse arrays
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow sparse arrays",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-sparse-arrays"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ArrayExpression(node) {
        const emptySpot = node.elements.indexOf(null) > -1;
        if (emptySpot) {
          context.report({
            node,
            message: "Unexpected comma in middle of array."
          });
        }
      }
    };
  }
};

/***/ }),
/* 390 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for properties whose identifier ends with the string Sync
 * @author Matt DuVall<http://mattduvall.com/>
 */

/* jshint node:true */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow synchronous methods",
      category: "Node.js and CommonJS",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-sync"
    },
    schema: [{
      type: "object",
      properties: {
        allowAtRootLevel: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
    return {
      [selector](node) {
        context.report({
          node,
          message: "Unexpected sync method: '{{propertyName}}'.",
          data: {
            propertyName: node.property.name
          }
        });
      }
    };
  }
};

/***/ }),
/* 391 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for tabs inside a file
 * @author Gyandeep Singh
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const tabRegex = /\t+/gu;
const anyNonWhitespaceRegex = /\S/u;

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow all tabs",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-tabs"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndentationTabs: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;
    return {
      Program(node) {
        sourceCode.getLines().forEach((line, index) => {
          let match;
          while ((match = tabRegex.exec(line)) !== null) {
            if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {
              continue;
            }
            context.report({
              node,
              loc: {
                line: index + 1,
                column: match.index
              },
              message: "Unexpected tab character."
            });
          }
        });
      }
    };
  }
};

/***/ }),
/* 392 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Warn when using template string syntax in regular strings
 * @author Jeroen Engels
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow template literal placeholder syntax in regular strings",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-template-curly-in-string"
    },
    schema: []
  },
  create(context) {
    const regex = /\$\{[^}]+\}/u;
    return {
      Literal(node) {
        if (typeof node.value === "string" && regex.test(node.value)) {
          context.report({
            node,
            message: "Unexpected template string expression."
          });
        }
      }
    };
  }
};

/***/ }),
/* 393 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of ternary operators.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-ternary"
    },
    schema: []
  },
  create(context) {
    return {
      ConditionalExpression(node) {
        context.report({
          node,
          message: "Ternary operator used."
        });
      }
    };
  }
};

/***/ }),
/* 394 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow using `this`/`super` before `super()`.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a constructor.
 * @param {ASTNode} node - A node to check. This node type is one of
 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
 *   `ArrowFunctionExpression`.
 * @returns {boolean} `true` if the node is a constructor.
 */
function isConstructorFunction(node) {
  return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `this`/`super` before calling `super()` in constructors",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-this-before-super"
    },
    schema: []
  },
  create(context) {
    /*
     * Information for each constructor.
     * - upper:      Information of the upper constructor.
     * - hasExtends: A flag which shows whether the owner class has a valid
     *   `extends` part.
     * - scope:      The scope of the owner class.
     * - codePath:   The code path of this constructor.
     */
    let funcInfo = null;

    /*
     * Information for each code path segment.
     * Each key is the id of a code path segment.
     * Each value is an object:
     * - superCalled:  The flag which shows `super()` called in all code paths.
     * - invalidNodes: The array of invalid ThisExpression and Super nodes.
     */
    let segInfoMap = Object.create(null);

    /**
     * Gets whether or not `super()` is called in a given code path segment.
     * @param {CodePathSegment} segment - A code path segment to get.
     * @returns {boolean} `true` if `super()` is called.
     */
    function isCalled(segment) {
      return !segment.reachable || segInfoMap[segment.id].superCalled;
    }

    /**
     * Checks whether or not this is in a constructor.
     * @returns {boolean} `true` if this is in a constructor.
     */
    function isInConstructorOfDerivedClass() {
      return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
    }

    /**
     * Checks whether or not this is before `super()` is called.
     * @returns {boolean} `true` if this is before `super()` is called.
     */
    function isBeforeCallOfSuper() {
      return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
    }

    /**
     * Sets a given node as invalid.
     * @param {ASTNode} node - A node to set as invalid. This is one of
     *      a ThisExpression and a Super.
     * @returns {void}
     */
    function setInvalid(node) {
      const segments = funcInfo.codePath.currentSegments;
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (segment.reachable) {
          segInfoMap[segment.id].invalidNodes.push(node);
        }
      }
    }

    /**
     * Sets the current segment as `super` was called.
     * @returns {void}
     */
    function setSuperCalled() {
      const segments = funcInfo.codePath.currentSegments;
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (segment.reachable) {
          segInfoMap[segment.id].superCalled = true;
        }
      }
    }
    return {
      /**
       * Adds information of a constructor into the stack.
       * @param {CodePath} codePath - A code path which was started.
       * @param {ASTNode} node - The current node.
       * @returns {void}
       */
      onCodePathStart(codePath, node) {
        if (isConstructorFunction(node)) {
          // Class > ClassBody > MethodDefinition > FunctionExpression
          const classNode = node.parent.parent.parent;
          funcInfo = {
            upper: funcInfo,
            isConstructor: true,
            hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
            codePath
          };
        } else {
          funcInfo = {
            upper: funcInfo,
            isConstructor: false,
            hasExtends: false,
            codePath
          };
        }
      },
      /**
       * Removes the top of stack item.
       *
       * And this treverses all segments of this code path then reports every
       * invalid node.
       *
       * @param {CodePath} codePath - A code path which was ended.
       * @returns {void}
       */
      onCodePathEnd(codePath) {
        const isDerivedClass = funcInfo.hasExtends;
        funcInfo = funcInfo.upper;
        if (!isDerivedClass) {
          return;
        }
        codePath.traverseSegments((segment, controller) => {
          const info = segInfoMap[segment.id];
          for (let i = 0; i < info.invalidNodes.length; ++i) {
            const invalidNode = info.invalidNodes[i];
            context.report({
              message: "'{{kind}}' is not allowed before 'super()'.",
              node: invalidNode,
              data: {
                kind: invalidNode.type === "Super" ? "super" : "this"
              }
            });
          }
          if (info.superCalled) {
            controller.skip();
          }
        });
      },
      /**
       * Initialize information of a given code path segment.
       * @param {CodePathSegment} segment - A code path segment to initialize.
       * @returns {void}
       */
      onCodePathSegmentStart(segment) {
        if (!isInConstructorOfDerivedClass()) {
          return;
        }

        // Initialize info.
        segInfoMap[segment.id] = {
          superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
          invalidNodes: []
        };
      },
      /**
       * Update information of the code path segment when a code path was
       * looped.
       * @param {CodePathSegment} fromSegment - The code path segment of the
       *      end of a loop.
       * @param {CodePathSegment} toSegment - A code path segment of the head
       *      of a loop.
       * @returns {void}
       */
      onCodePathSegmentLoop(fromSegment, toSegment) {
        if (!isInConstructorOfDerivedClass()) {
          return;
        }

        // Update information inside of the loop.
        funcInfo.codePath.traverseSegments({
          first: toSegment,
          last: fromSegment
        }, (segment, controller) => {
          const info = segInfoMap[segment.id];
          if (info.superCalled) {
            info.invalidNodes = [];
            controller.skip();
          } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
            info.superCalled = true;
            info.invalidNodes = [];
          }
        });
      },
      /**
       * Reports if this is before `super()`.
       * @param {ASTNode} node - A target node.
       * @returns {void}
       */
      ThisExpression(node) {
        if (isBeforeCallOfSuper()) {
          setInvalid(node);
        }
      },
      /**
       * Reports if this is before `super()`.
       * @param {ASTNode} node - A target node.
       * @returns {void}
       */
      Super(node) {
        if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
          setInvalid(node);
        }
      },
      /**
       * Marks `super()` called.
       * @param {ASTNode} node - A target node.
       * @returns {void}
       */
      "CallExpression:exit"(node) {
        if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
          setSuperCalled();
        }
      },
      /**
       * Resets state.
       * @returns {void}
       */
      "Program:exit"() {
        segInfoMap = Object.create(null);
      }
    };
  }
};

/***/ }),
/* 395 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to restrict what can be thrown as an exception.
 * @author Dieter Oberkofler
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow throwing literals as exceptions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-throw-literal"
    },
    schema: []
  },
  create(context) {
    return {
      ThrowStatement(node) {
        if (!astUtils.couldBeError(node.argument)) {
          context.report({
            node,
            message: "Expected an object to be thrown."
          });
        } else if (node.argument.type === "Identifier") {
          if (node.argument.name === "undefined") {
            context.report({
              node,
              message: "Do not throw undefined."
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 396 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallow trailing spaces at the end of lines.
 * @author Nodeca Team <https://github.com/nodeca>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow trailing whitespace at the end of lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-trailing-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        skipBlankLines: {
          type: "boolean",
          default: false
        },
        ignoreComments: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u3000]",
      SKIP_BLANK = `^${BLANK_CLASS}*$`,
      NONBLANK = `${BLANK_CLASS}+$`;
    const options = context.options[0] || {},
      skipBlankLines = options.skipBlankLines || false,
      ignoreComments = options.ignoreComments || false;

    /**
     * Report the error message
     * @param {ASTNode} node node to report
     * @param {int[]} location range information
     * @param {int[]} fixRange Range based on the whole program
     * @returns {void}
     */
    function report(node, location, fixRange) {
      /*
       * Passing node is a bit dirty, because message data will contain big
       * text in `source`. But... who cares :) ?
       * One more kludge will not make worse the bloody wizardry of this
       * plugin.
       */
      context.report({
        node,
        loc: location,
        message: "Trailing spaces not allowed.",
        fix(fixer) {
          return fixer.removeRange(fixRange);
        }
      });
    }

    /**
     * Given a list of comment nodes, return the line numbers for those comments.
     * @param {Array} comments An array of comment nodes.
     * @returns {number[]} An array of line numbers containing comments.
     */
    function getCommentLineNumbers(comments) {
      const lines = new Set();
      comments.forEach(comment => {
        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
          lines.add(i);
        }
      });
      return lines;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: function checkTrailingSpaces(node) {
        /*
         * Let's hack. Since Espree does not return whitespace nodes,
         * fetch the source code and do matching via regexps.
         */

        const re = new RegExp(NONBLANK, "u"),
          skipMatch = new RegExp(SKIP_BLANK, "u"),
          lines = sourceCode.lines,
          linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
          comments = sourceCode.getAllComments(),
          commentLineNumbers = getCommentLineNumbers(comments);
        let totalLength = 0,
          fixRange = [];
        for (let i = 0, ii = lines.length; i < ii; i++) {
          const matches = re.exec(lines[i]);

          /*
           * Always add linebreak length to line length to accommodate for line break (\n or \r\n)
           * Because during the fix time they also reserve one spot in the array.
           * Usually linebreak length is 2 for \r\n (CRLF) and 1 for \n (LF)
           */
          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
          const lineLength = lines[i].length + linebreakLength;
          if (matches) {
            const location = {
              line: i + 1,
              column: matches.index
            };
            const rangeStart = totalLength + location.column;
            const rangeEnd = totalLength + lineLength - linebreakLength;
            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
            if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
              totalLength += lineLength;
              continue;
            }

            /*
             * If the line has only whitespace, and skipBlankLines
             * is true, don't report it
             */
            if (skipBlankLines && skipMatch.test(lines[i])) {
              totalLength += lineLength;
              continue;
            }
            fixRange = [rangeStart, rangeEnd];
            if (!ignoreComments || !commentLineNumbers.has(location.line)) {
              report(node, location, fixRange);
            }
          }
          totalLength += lineLength;
        }
      }
    };
  }
};

/***/ }),
/* 397 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag references to undeclared variables.
 * @author Mark Macdonald
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks if the given node is the argument of a typeof operator.
 * @param {ASTNode} node The AST node being checked.
 * @returns {boolean} Whether or not the node is the argument of a typeof operator.
 */
function hasTypeOfOperator(node) {
  const parent = node.parent;
  return parent.type === "UnaryExpression" && parent.operator === "typeof";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-undef"
    },
    schema: [{
      type: "object",
      properties: {
        typeof: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      undef: "'{{name}}' is not defined."
    }
  },
  create(context) {
    const options = context.options[0];
    const considerTypeOf = options && options.typeof === true || false;
    return {
      "Program:exit"(/* node */
      ) {
        const globalScope = context.getScope();
        globalScope.through.forEach(ref => {
          const identifier = ref.identifier;
          if (!considerTypeOf && hasTypeOfOperator(identifier)) {
            return;
          }
          context.report({
            node: identifier,
            messageId: "undef",
            data: identifier
          });
        });
      }
    };
  }
};

/***/ }),
/* 398 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when initializing to undefined
 * @author Ilya Volodin
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow initializing variables to `undefined`",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-undef-init"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      VariableDeclarator(node) {
        const name = sourceCode.getText(node.id),
          init = node.init && node.init.name,
          scope = context.getScope(),
          undefinedVar = astUtils.getVariableByName(scope, "undefined"),
          shadowed = undefinedVar && undefinedVar.defs.length > 0;
        if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
          context.report({
            node,
            message: "It's not necessary to initialize '{{name}}' to undefined.",
            data: {
              name
            },
            fix(fixer) {
              if (node.parent.kind === "var") {
                return null;
              }
              if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
                // Don't fix destructuring assignment to `undefined`.
                return null;
              }
              return fixer.removeRange([node.id.range[1], node.range[1]]);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 399 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag references to the undefined variable.
 * @author Michael Ficarra
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `undefined` as an identifier",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-undefined"
    },
    schema: []
  },
  create(context) {
    /**
     * Report an invalid "undefined" identifier node.
     * @param {ASTNode} node The node to report.
     * @returns {void}
     */
    function report(node) {
      context.report({
        node,
        message: "Unexpected use of undefined."
      });
    }

    /**
     * Checks the given scope for references to `undefined` and reports
     * all references found.
     * @param {eslint-scope.Scope} scope The scope to check.
     * @returns {void}
     */
    function checkScope(scope) {
      const undefinedVar = scope.set.get("undefined");
      if (!undefinedVar) {
        return;
      }
      const references = undefinedVar.references;
      const defs = undefinedVar.defs;

      // Report non-initializing references (those are covered in defs below)
      references.filter(ref => !ref.init).forEach(ref => report(ref.identifier));
      defs.forEach(def => report(def.name));
    }
    return {
      "Program:exit"() {
        const globalScope = context.getScope();
        const stack = [globalScope];
        while (stack.length) {
          const scope = stack.pop();
          stack.push(...scope.childScopes);
          checkScope(scope);
        }
      }
    };
  }
};

/***/ }),
/* 400 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag trailing underscores in variable declarations.
 * @author Matt DuVall <http://www.mattduvall.com>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow dangling underscores in identifiers",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-underscore-dangle"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        },
        allowAfterThis: {
          type: "boolean",
          default: false
        },
        allowAfterSuper: {
          type: "boolean",
          default: false
        },
        enforceInMethodNames: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = context.options[0] || {};
    const ALLOWED_VARIABLES = options.allow ? options.allow : [];
    const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
    const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
    const enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;

    //-------------------------------------------------------------------------
    // Helpers
    //-------------------------------------------------------------------------

    /**
     * Check if identifier is present inside the allowed option
     * @param {string} identifier name of the node
     * @returns {boolean} true if its is present
     * @private
     */
    function isAllowed(identifier) {
      return ALLOWED_VARIABLES.some(ident => ident === identifier);
    }

    /**
     * Check if identifier has a underscore at the end
     * @param {ASTNode} identifier node to evaluate
     * @returns {boolean} true if its is present
     * @private
     */
    function hasTrailingUnderscore(identifier) {
      const len = identifier.length;
      return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
    }

    /**
     * Check if identifier is a special case member expression
     * @param {ASTNode} identifier node to evaluate
     * @returns {boolean} true if its is a special case
     * @private
     */
    function isSpecialCaseIdentifierForMemberExpression(identifier) {
      return identifier === "__proto__";
    }

    /**
     * Check if identifier is a special case variable expression
     * @param {ASTNode} identifier node to evaluate
     * @returns {boolean} true if its is a special case
     * @private
     */
    function isSpecialCaseIdentifierInVariableExpression(identifier) {
      // Checks for the underscore library usage here
      return identifier === "_";
    }

    /**
     * Check if function has a underscore at the end
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkForTrailingUnderscoreInFunctionDeclaration(node) {
      if (node.id) {
        const identifier = node.id.name;
        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
          context.report({
            node,
            message: "Unexpected dangling '_' in '{{identifier}}'.",
            data: {
              identifier
            }
          });
        }
      }
    }

    /**
     * Check if variable expression has a underscore at the end
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkForTrailingUnderscoreInVariableExpression(node) {
      const identifier = node.id.name;
      if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
        context.report({
          node,
          message: "Unexpected dangling '_' in '{{identifier}}'.",
          data: {
            identifier
          }
        });
      }
    }

    /**
     * Check if member expression has a underscore at the end
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkForTrailingUnderscoreInMemberExpression(node) {
      const identifier = node.property.name,
        isMemberOfThis = node.object.type === "ThisExpression",
        isMemberOfSuper = node.object.type === "Super";
      if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
        context.report({
          node,
          message: "Unexpected dangling '_' in '{{identifier}}'.",
          data: {
            identifier
          }
        });
      }
    }

    /**
     * Check if method declaration or method property has a underscore at the end
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkForTrailingUnderscoreInMethod(node) {
      const identifier = node.key.name;
      const isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;
      if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {
        context.report({
          node,
          message: "Unexpected dangling '_' in '{{identifier}}'.",
          data: {
            identifier
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,
      VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,
      MemberExpression: checkForTrailingUnderscoreInMemberExpression,
      MethodDefinition: checkForTrailingUnderscoreInMethod,
      Property: checkForTrailingUnderscoreInMethod
    };
  }
};

/***/ }),
/* 401 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.
 * @author Glen Mailer
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow confusing multiline expressions",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unexpected-multiline"
    },
    schema: [],
    messages: {
      function: "Unexpected newline between function and ( of function call.",
      property: "Unexpected newline between object and [ of property access.",
      taggedTemplate: "Unexpected newline between template tag and template literal.",
      division: "Unexpected newline between numerator and division operator."
    }
  },
  create(context) {
    const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;
    const sourceCode = context.getSourceCode();

    /**
     * Check to see if there is a newline between the node and the following open bracket
     * line's expression
     * @param {ASTNode} node The node to check.
     * @param {string} messageId The error messageId to use.
     * @returns {void}
     * @private
     */
    function checkForBreakAfter(node, messageId) {
      const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
      const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);
      if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
        context.report({
          node,
          loc: openParen.loc.start,
          messageId,
          data: {
            char: openParen.value
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      MemberExpression(node) {
        if (!node.computed) {
          return;
        }
        checkForBreakAfter(node.object, "property");
      },
      TaggedTemplateExpression(node) {
        if (node.tag.loc.end.line === node.quasi.loc.start.line) {
          return;
        }
        context.report({
          node,
          loc: node.loc.start,
          messageId: "taggedTemplate"
        });
      },
      CallExpression(node) {
        if (node.arguments.length === 0) {
          return;
        }
        checkForBreakAfter(node.callee, "function");
      },
      "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node) {
        const secondSlash = sourceCode.getTokenAfter(node, token => token.value === "/");
        const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);
        if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
          checkForBreakAfter(node.left, "division");
        }
      }
    };
  }
};

/***/ }),
/* 402 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow use of unmodified expressions in loop conditions
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const Traverser = __webpack_require__(196),
  astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.
const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;

/**
 * @typedef {Object} LoopConditionInfo
 * @property {eslint-scope.Reference} reference - The reference.
 * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes
 *      that the reference is belonging to.
 * @property {Function} isInLoop - The predicate which checks a given reference
 *      is in this loop.
 * @property {boolean} modified - The flag that the reference is modified in
 *      this loop.
 */

/**
 * Checks whether or not a given reference is a write reference.
 *
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the reference is a write reference.
 */
function isWriteReference(reference) {
  if (reference.init) {
    const def = reference.resolved && reference.resolved.defs[0];
    if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
      return false;
    }
  }
  return reference.isWrite();
}

/**
 * Checks whether or not a given loop condition info does not have the modified
 * flag.
 *
 * @param {LoopConditionInfo} condition - A loop condition info to check.
 * @returns {boolean} `true` if the loop condition info is "unmodified".
 */
function isUnmodified(condition) {
  return !condition.modified;
}

/**
 * Checks whether or not a given loop condition info does not have the modified
 * flag and does not have the group this condition belongs to.
 *
 * @param {LoopConditionInfo} condition - A loop condition info to check.
 * @returns {boolean} `true` if the loop condition info is "unmodified".
 */
function isUnmodifiedAndNotBelongToGroup(condition) {
  return !(condition.modified || condition.group);
}

/**
 * Checks whether or not a given reference is inside of a given node.
 *
 * @param {ASTNode} node - A node to check.
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the reference is inside of the node.
 */
function isInRange(node, reference) {
  const or = node.range;
  const ir = reference.identifier.range;
  return or[0] <= ir[0] && ir[1] <= or[1];
}

/**
 * Checks whether or not a given reference is inside of a loop node's condition.
 *
 * @param {ASTNode} node - A node to check.
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the reference is inside of the loop node's
 *      condition.
 */
const isInLoop = {
  WhileStatement: isInRange,
  DoWhileStatement: isInRange,
  ForStatement(node, reference) {
    return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
  }
};

/**
 * Gets the function which encloses a given reference.
 * This supports only FunctionDeclaration.
 *
 * @param {eslint-scope.Reference} reference - A reference to get.
 * @returns {ASTNode|null} The function node or null.
 */
function getEncloseFunctionDeclaration(reference) {
  let node = reference.identifier;
  while (node) {
    if (node.type === "FunctionDeclaration") {
      return node.id ? node : null;
    }
    node = node.parent;
  }
  return null;
}

/**
 * Updates the "modified" flags of given loop conditions with given modifiers.
 *
 * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.
 * @param {eslint-scope.Reference[]} modifiers - The references to update.
 * @returns {void}
 */
function updateModifiedFlag(conditions, modifiers) {
  for (let i = 0; i < conditions.length; ++i) {
    const condition = conditions[i];
    for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
      const modifier = modifiers[j];
      let funcNode, funcVar;

      /*
       * Besides checking for the condition being in the loop, we want to
       * check the function that this modifier is belonging to is called
       * in the loop.
       * FIXME: This should probably be extracted to a function.
       */
      const inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));
      condition.modified = inLoop;
    }
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unmodified loop conditions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unmodified-loop-condition"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let groupMap = null;

    /**
     * Reports a given condition info.
     *
     * @param {LoopConditionInfo} condition - A loop condition info to report.
     * @returns {void}
     */
    function report(condition) {
      const node = condition.reference.identifier;
      context.report({
        node,
        message: "'{{name}}' is not modified in this loop.",
        data: node
      });
    }

    /**
     * Registers given conditions to the group the condition belongs to.
     *
     * @param {LoopConditionInfo[]} conditions - A loop condition info to
     *      register.
     * @returns {void}
     */
    function registerConditionsToGroup(conditions) {
      for (let i = 0; i < conditions.length; ++i) {
        const condition = conditions[i];
        if (condition.group) {
          let group = groupMap.get(condition.group);
          if (!group) {
            group = [];
            groupMap.set(condition.group, group);
          }
          group.push(condition);
        }
      }
    }

    /**
     * Reports references which are inside of unmodified groups.
     *
     * @param {LoopConditionInfo[]} conditions - A loop condition info to report.
     * @returns {void}
     */
    function checkConditionsInGroup(conditions) {
      if (conditions.every(isUnmodified)) {
        conditions.forEach(report);
      }
    }

    /**
     * Checks whether or not a given group node has any dynamic elements.
     *
     * @param {ASTNode} root - A node to check.
     *      This node is one of BinaryExpression or ConditionalExpression.
     * @returns {boolean} `true` if the node is dynamic.
     */
    function hasDynamicExpressions(root) {
      let retv = false;
      Traverser.traverse(root, {
        visitorKeys: sourceCode.visitorKeys,
        enter(node) {
          if (DYNAMIC_PATTERN.test(node.type)) {
            retv = true;
            this.break();
          } else if (SKIP_PATTERN.test(node.type)) {
            this.skip();
          }
        }
      });
      return retv;
    }

    /**
     * Creates the loop condition information from a given reference.
     *
     * @param {eslint-scope.Reference} reference - A reference to create.
     * @returns {LoopConditionInfo|null} Created loop condition info, or null.
     */
    function toLoopCondition(reference) {
      if (reference.init) {
        return null;
      }
      let group = null;
      let child = reference.identifier;
      let node = child.parent;
      while (node) {
        if (SENTINEL_PATTERN.test(node.type)) {
          if (LOOP_PATTERN.test(node.type) && node.test === child) {
            // This reference is inside of a loop condition.
            return {
              reference,
              group,
              isInLoop: isInLoop[node.type].bind(null, node),
              modified: false
            };
          }

          // This reference is outside of a loop condition.
          break;
        }

        /*
         * If it's inside of a group, OK if either operand is modified.
         * So stores the group this reference belongs to.
         */
        if (GROUP_PATTERN.test(node.type)) {
          // If this expression is dynamic, no need to check.
          if (hasDynamicExpressions(node)) {
            break;
          } else {
            group = node;
          }
        }
        child = node;
        node = node.parent;
      }
      return null;
    }

    /**
     * Finds unmodified references which are inside of a loop condition.
     * Then reports the references which are outside of groups.
     *
     * @param {eslint-scope.Variable} variable - A variable to report.
     * @returns {void}
     */
    function checkReferences(variable) {
      // Gets references that exist in loop conditions.
      const conditions = variable.references.map(toLoopCondition).filter(Boolean);
      if (conditions.length === 0) {
        return;
      }

      // Registers the conditions to belonging groups.
      registerConditionsToGroup(conditions);

      // Check the conditions are modified.
      const modifiers = variable.references.filter(isWriteReference);
      if (modifiers.length > 0) {
        updateModifiedFlag(conditions, modifiers);
      }

      /*
       * Reports the conditions which are not belonging to groups.
       * Others will be reported after all variables are done.
       */
      conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
    }
    return {
      "Program:exit"() {
        const queue = [context.getScope()];
        groupMap = new Map();
        let scope;
        while (scope = queue.pop()) {
          queue.push(...scope.childScopes);
          scope.variables.forEach(checkReferences);
        }
        groupMap.forEach(checkConditionsInGroup);
        groupMap = null;
      }
    };
  }
};

/***/ }),
/* 403 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag no-unneeded-ternary
 * @author Gyandeep Singh
 */



const astUtils = __webpack_require__(110);

// Operators that always result in a boolean value
const BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
const OPERATOR_INVERSES = {
  "==": "!=",
  "!=": "==",
  "===": "!==",
  "!==": "==="

  // Operators like < and >= are not true inverses, since both will return false with NaN.
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators when simpler alternatives exist",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unneeded-ternary"
    },
    schema: [{
      type: "object",
      properties: {
        defaultAssignment: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create(context) {
    const options = context.options[0] || {};
    const defaultAssignment = options.defaultAssignment !== false;
    const sourceCode = context.getSourceCode();

    /**
     * Test if the node is a boolean literal
     * @param {ASTNode} node - The node to report.
     * @returns {boolean} True if the its a boolean literal
     * @private
     */
    function isBooleanLiteral(node) {
      return node.type === "Literal" && typeof node.value === "boolean";
    }

    /**
     * Creates an expression that represents the boolean inverse of the expression represented by the original node
     * @param {ASTNode} node A node representing an expression
     * @returns {string} A string representing an inverted expression
     */
    function invertExpression(node) {
      if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        const text = sourceCode.getText();
        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
      }
      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({
        type: "UnaryExpression"
      })) {
        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
      }
      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
    }

    /**
     * Tests if a given node always evaluates to a boolean value
     * @param {ASTNode} node - An expression node
     * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value
     */
    function isBooleanExpression(node) {
      return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
    }

    /**
     * Test if the node matches the pattern id ? id : expression
     * @param {ASTNode} node - The ConditionalExpression to check.
     * @returns {boolean} True if the pattern is matched, and false otherwise
     * @private
     */
    function matchesDefaultAssignment(node) {
      return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
    }
    return {
      ConditionalExpression(node) {
        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
          context.report({
            node,
            loc: node.consequent.loc.start,
            message: "Unnecessary use of boolean literals in conditional expression.",
            fix(fixer) {
              if (node.consequent.value === node.alternate.value) {
                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`
                return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
              }
              if (node.alternate.value) {
                // Replace `foo() ? false : true` with `!(foo())`
                return fixer.replaceText(node, invertExpression(node.test));
              }

              // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.

              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
            }
          });
        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
          context.report({
            node,
            loc: node.consequent.loc.start,
            message: "Unnecessary use of conditional expression for default assignment.",
            fix: fixer => {
              let nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);
              if (node.alternate.type === "ConditionalExpression" || node.alternate.type === "YieldExpression") {
                const isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);
                nodeAlternate = isAlternateParenthesised ? nodeAlternate : `(${nodeAlternate})`;
              }
              return fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} || ${nodeAlternate}`);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 404 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
 * @author Joel Feenstra
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable declarator has the initializer.
 * @param {ASTNode} node - A VariableDeclarator node to check.
 * @returns {boolean} `true` if the node has the initializer.
 */
function isInitialized(node) {
  return Boolean(node.init);
}

/**
 * Checks whether or not a given code path segment is unreachable.
 * @param {CodePathSegment} segment - A CodePathSegment to check.
 * @returns {boolean} `true` if the segment is unreachable.
 */
function isUnreachable(segment) {
  return !segment.reachable;
}

/**
 * The class to distinguish consecutive unreachable statements.
 */
class ConsecutiveRange {
  constructor(sourceCode) {
    this.sourceCode = sourceCode;
    this.startNode = null;
    this.endNode = null;
  }

  /**
   * The location object of this range.
   * @type {Object}
   */
  get location() {
    return {
      start: this.startNode.loc.start,
      end: this.endNode.loc.end
    };
  }

  /**
   * `true` if this range is empty.
   * @type {boolean}
   */
  get isEmpty() {
    return !(this.startNode && this.endNode);
  }

  /**
   * Checks whether the given node is inside of this range.
   * @param {ASTNode|Token} node - The node to check.
   * @returns {boolean} `true` if the node is inside of this range.
   */
  contains(node) {
    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
  }

  /**
   * Checks whether the given node is consecutive to this range.
   * @param {ASTNode} node - The node to check.
   * @returns {boolean} `true` if the node is consecutive to this range.
   */
  isConsecutive(node) {
    return this.contains(this.sourceCode.getTokenBefore(node));
  }

  /**
   * Merges the given node to this range.
   * @param {ASTNode} node - The node to merge.
   * @returns {void}
   */
  merge(node) {
    this.endNode = node;
  }

  /**
   * Resets this range by the given node or null.
   * @param {ASTNode|null} node - The node to reset, or null.
   * @returns {void}
   */
  reset(node) {
    this.startNode = this.endNode = node;
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unreachable"
    },
    schema: []
  },
  create(context) {
    let currentCodePath = null;
    const range = new ConsecutiveRange(context.getSourceCode());

    /**
     * Reports a given node if it's unreachable.
     * @param {ASTNode} node - A statement node to report.
     * @returns {void}
     */
    function reportIfUnreachable(node) {
      let nextNode = null;
      if (node && currentCodePath.currentSegments.every(isUnreachable)) {
        // Store this statement to distinguish consecutive statements.
        if (range.isEmpty) {
          range.reset(node);
          return;
        }

        // Skip if this statement is inside of the current range.
        if (range.contains(node)) {
          return;
        }

        // Merge if this statement is consecutive to the current range.
        if (range.isConsecutive(node)) {
          range.merge(node);
          return;
        }
        nextNode = node;
      }

      /*
       * Report the current range since this statement is reachable or is
       * not consecutive to the current range.
       */
      if (!range.isEmpty) {
        context.report({
          message: "Unreachable code.",
          loc: range.location,
          node: range.startNode
        });
      }

      // Update the current range.
      range.reset(nextNode);
    }
    return {
      // Manages the current code path.
      onCodePathStart(codePath) {
        currentCodePath = codePath;
      },
      onCodePathEnd() {
        currentCodePath = currentCodePath.upper;
      },
      // Registers for all statement nodes (excludes FunctionDeclaration).
      BlockStatement: reportIfUnreachable,
      BreakStatement: reportIfUnreachable,
      ClassDeclaration: reportIfUnreachable,
      ContinueStatement: reportIfUnreachable,
      DebuggerStatement: reportIfUnreachable,
      DoWhileStatement: reportIfUnreachable,
      ExpressionStatement: reportIfUnreachable,
      ForInStatement: reportIfUnreachable,
      ForOfStatement: reportIfUnreachable,
      ForStatement: reportIfUnreachable,
      IfStatement: reportIfUnreachable,
      ImportDeclaration: reportIfUnreachable,
      LabeledStatement: reportIfUnreachable,
      ReturnStatement: reportIfUnreachable,
      SwitchStatement: reportIfUnreachable,
      ThrowStatement: reportIfUnreachable,
      TryStatement: reportIfUnreachable,
      VariableDeclaration(node) {
        if (node.kind !== "var" || node.declarations.some(isInitialized)) {
          reportIfUnreachable(node);
        }
      },
      WhileStatement: reportIfUnreachable,
      WithStatement: reportIfUnreachable,
      ExportNamedDeclaration: reportIfUnreachable,
      ExportDefaultDeclaration: reportIfUnreachable,
      ExportAllDeclaration: reportIfUnreachable,
      "Program:exit"() {
        reportIfUnreachable();
      }
    };
  }
};

/***/ }),
/* 405 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag unsafe statements in finally block
 * @author Onur Temizkan
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
const SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;
const SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control flow statements in `finally` blocks",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unsafe-finally"
    },
    schema: []
  },
  create(context) {
    /**
     * Checks if the node is the finalizer of a TryStatement
     *
     * @param {ASTNode} node - node to check.
     * @returns {boolean} - true if the node is the finalizer of a TryStatement
     */
    function isFinallyBlock(node) {
      return node.parent.type === "TryStatement" && node.parent.finalizer === node;
    }

    /**
     * Climbs up the tree if the node is not a sentinel node
     *
     * @param {ASTNode} node - node to check.
     * @param {string} label - label of the break or continue statement
     * @returns {boolean} - return whether the node is a finally block or a sentinel node
     */
    function isInFinallyBlock(node, label) {
      let labelInside = false;
      let sentinelNodeType;
      if (node.type === "BreakStatement" && !node.label) {
        sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
      } else if (node.type === "ContinueStatement") {
        sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
      } else {
        sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
      }
      for (let currentNode = node; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {
        if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {
          labelInside = true;
        }
        if (isFinallyBlock(currentNode)) {
          if (label && labelInside) {
            return false;
          }
          return true;
        }
      }
      return false;
    }

    /**
     * Checks whether the possibly-unsafe statement is inside a finally block.
     *
     * @param {ASTNode} node - node to check.
     * @returns {void}
     */
    function check(node) {
      if (isInFinallyBlock(node, node.label)) {
        context.report({
          message: "Unsafe usage of {{nodeType}}.",
          data: {
            nodeType: node.type
          },
          node,
          line: node.loc.line,
          column: node.loc.column
        });
      }
    }
    return {
      ReturnStatement: check,
      ThrowStatement: check,
      BreakStatement: check,
      ContinueStatement: check
    };
  }
};

/***/ }),
/* 406 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow negating the left operand of relational operators
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether the given operator is a relational operator or not.
 *
 * @param {string} op - The operator type to check.
 * @returns {boolean} `true` if the operator is a relational operator.
 */
function isRelationalOperator(op) {
  return op === "in" || op === "instanceof";
}

/**
 * Checks whether the given node is a logical negation expression or not.
 *
 * @param {ASTNode} node - The node to check.
 * @returns {boolean} `true` if the node is a logical negation expression.
 */
function isNegation(node) {
  return node.type === "UnaryExpression" && node.operator === "!";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand of relational operators",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unsafe-negation"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "Unexpected negating the left operand of '{{operator}}' operator."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      BinaryExpression(node) {
        if (isRelationalOperator(node.operator) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
          context.report({
            node,
            loc: node.left.loc,
            messageId: "unexpected",
            data: {
              operator: node.operator
            },
            fix(fixer) {
              const negationToken = sourceCode.getFirstToken(node.left);
              const fixRange = [negationToken.range[1], node.range[1]];
              const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
              return fixer.replaceTextRange(fixRange, `(${text})`);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 407 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Flag expressions in statement position that do not side effect
 * @author Michael Ficarra
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused expressions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-unused-expressions"
    },
    schema: [{
      type: "object",
      properties: {
        allowShortCircuit: {
          type: "boolean",
          default: false
        },
        allowTernary: {
          type: "boolean",
          default: false
        },
        allowTaggedTemplates: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const config = context.options[0] || {},
      allowShortCircuit = config.allowShortCircuit || false,
      allowTernary = config.allowTernary || false,
      allowTaggedTemplates = config.allowTaggedTemplates || false;

    /**
     * @param {ASTNode} node - any node
     * @returns {boolean} whether the given node structurally represents a directive
     */
    function looksLikeDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    /**
     * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination
     * @param {a[]} list - the input list
     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate
     */
    function takeWhile(predicate, list) {
      for (let i = 0; i < list.length; ++i) {
        if (!predicate(list[i])) {
          return list.slice(0, i);
        }
      }
      return list.slice();
    }

    /**
     * @param {ASTNode} node - a Program or BlockStatement node
     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body
     */
    function directives(node) {
      return takeWhile(looksLikeDirective, node.body);
    }

    /**
     * @param {ASTNode} node - any node
     * @param {ASTNode[]} ancestors - the given node's ancestors
     * @returns {boolean} whether the given node is considered a directive in its current position
     */
    function isDirective(node, ancestors) {
      const parent = ancestors[ancestors.length - 1],
        grandparent = ancestors[ancestors.length - 2];
      return (parent.type === "Program" || parent.type === "BlockStatement" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;
    }

    /**
     * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.
     * @param {ASTNode} node - any node
     * @returns {boolean} whether the given node is a valid expression
     */
    function isValidExpression(node) {
      if (allowTernary) {
        // Recursive check for ternary and logical expressions
        if (node.type === "ConditionalExpression") {
          return isValidExpression(node.consequent) && isValidExpression(node.alternate);
        }
      }
      if (allowShortCircuit) {
        if (node.type === "LogicalExpression") {
          return isValidExpression(node.right);
        }
      }
      if (allowTaggedTemplates && node.type === "TaggedTemplateExpression") {
        return true;
      }
      return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/u.test(node.type) || node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0;
    }
    return {
      ExpressionStatement(node) {
        if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
          context.report({
            node,
            message: "Expected an assignment or function call and instead saw an expression."
          });
        }
      }
    };
  }
};

/***/ }),
/* 408 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow unused labels.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused labels",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unused-labels"
    },
    schema: [],
    fixable: "code",
    messages: {
      unused: "'{{name}}:' is defined but never used."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    /**
     * Adds a scope info to the stack.
     *
     * @param {ASTNode} node - A node to add. This is a LabeledStatement.
     * @returns {void}
     */
    function enterLabeledScope(node) {
      scopeInfo = {
        label: node.label.name,
        used: false,
        upper: scopeInfo
      };
    }

    /**
     * Removes the top of the stack.
     * At the same time, this reports the label if it's never used.
     *
     * @param {ASTNode} node - A node to report. This is a LabeledStatement.
     * @returns {void}
     */
    function exitLabeledScope(node) {
      if (!scopeInfo.used) {
        context.report({
          node: node.label,
          messageId: "unused",
          data: node.label,
          fix(fixer) {
            /*
             * Only perform a fix if there are no comments between the label and the body. This will be the case
             * when there is exactly one token/comment (the ":") between the label and the body.
             */
            if (sourceCode.getTokenAfter(node.label, {
              includeComments: true
            }) === sourceCode.getTokenBefore(node.body, {
              includeComments: true
            })) {
              return fixer.removeRange([node.range[0], node.body.range[0]]);
            }
            return null;
          }
        });
      }
      scopeInfo = scopeInfo.upper;
    }

    /**
     * Marks the label of a given node as used.
     *
     * @param {ASTNode} node - A node to mark. This is a BreakStatement or
     *      ContinueStatement.
     * @returns {void}
     */
    function markAsUsed(node) {
      if (!node.label) {
        return;
      }
      const label = node.label.name;
      let info = scopeInfo;
      while (info) {
        if (info.label === label) {
          info.used = true;
          break;
        }
        info = info.upper;
      }
    }
    return {
      LabeledStatement: enterLabeledScope,
      "LabeledStatement:exit": exitLabeledScope,
      BreakStatement: markAsUsed,
      ContinueStatement: markAsUsed
    };
  }
};

/***/ }),
/* 409 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag declared but unused variables
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused variables",
      category: "Variables",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-unused-vars"
    },
    schema: [{
      oneOf: [{
        enum: ["all", "local"]
      }, {
        type: "object",
        properties: {
          vars: {
            enum: ["all", "local"]
          },
          varsIgnorePattern: {
            type: "string"
          },
          args: {
            enum: ["all", "after-used", "none"]
          },
          ignoreRestSiblings: {
            type: "boolean"
          },
          argsIgnorePattern: {
            type: "string"
          },
          caughtErrors: {
            enum: ["all", "none"]
          },
          caughtErrorsIgnorePattern: {
            type: "string"
          }
        }
      }]
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;
    const config = {
      vars: "all",
      args: "after-used",
      ignoreRestSiblings: false,
      caughtErrors: "none"
    };
    const firstOption = context.options[0];
    if (firstOption) {
      if (typeof firstOption === "string") {
        config.vars = firstOption;
      } else {
        config.vars = firstOption.vars || config.vars;
        config.args = firstOption.args || config.args;
        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
        if (firstOption.varsIgnorePattern) {
          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern); // eslint-disable-line require-unicode-regexp
        }
        if (firstOption.argsIgnorePattern) {
          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern); // eslint-disable-line require-unicode-regexp
        }
        if (firstOption.caughtErrorsIgnorePattern) {
          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern); // eslint-disable-line require-unicode-regexp
        }
      }
    }

    /**
     * Generate the warning message about the variable being
     * defined and unused, including the ignore pattern if configured.
     * @param {Variable} unusedVar - eslint-scope variable object.
     * @returns {string} The warning message to be used with this unused variable.
     */
    function getDefinedMessage(unusedVar) {
      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;
      let type;
      let pattern;
      if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
        type = "args";
        pattern = config.caughtErrorsIgnorePattern.toString();
      } else if (defType === "Parameter" && config.argsIgnorePattern) {
        type = "args";
        pattern = config.argsIgnorePattern.toString();
      } else if (defType !== "Parameter" && config.varsIgnorePattern) {
        type = "vars";
        pattern = config.varsIgnorePattern.toString();
      }
      const additional = type ? ` Allowed unused ${type} must match ${pattern}.` : "";
      return `'{{name}}' is defined but never used.${additional}`;
    }

    /**
     * Generate the warning message about the variable being
     * assigned and unused, including the ignore pattern if configured.
     * @returns {string} The warning message to be used with this unused variable.
     */
    function getAssignedMessage() {
      const additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : "";
      return `'{{name}}' is assigned a value but never used.${additional}`;
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;

    /**
     * Determines if a given variable is being exported from a module.
     * @param {Variable} variable - eslint-scope variable object.
     * @returns {boolean} True if the variable is exported, false if not.
     * @private
     */
    function isExported(variable) {
      const definition = variable.defs[0];
      if (definition) {
        let node = definition.node;
        if (node.type === "VariableDeclarator") {
          node = node.parent;
        } else if (definition.type === "Parameter") {
          return false;
        }
        return node.parent.type.indexOf("Export") === 0;
      }
      return false;
    }

    /**
     * Determines if a variable has a sibling rest property
     * @param {Variable} variable - eslint-scope variable object.
     * @returns {boolean} True if the variable is exported, false if not.
     * @private
     */
    function hasRestSpreadSibling(variable) {
      if (config.ignoreRestSiblings) {
        return variable.defs.some(def => {
          const propertyNode = def.name.parent;
          const patternNode = propertyNode.parent;
          return propertyNode.type === "Property" && patternNode.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
        });
      }
      return false;
    }

    /**
     * Determines if a reference is a read operation.
     * @param {Reference} ref - An eslint-scope Reference
     * @returns {boolean} whether the given reference represents a read operation
     * @private
     */
    function isReadRef(ref) {
      return ref.isRead();
    }

    /**
     * Determine if an identifier is referencing an enclosing function name.
     * @param {Reference} ref - The reference to check.
     * @param {ASTNode[]} nodes - The candidate function nodes.
     * @returns {boolean} True if it's a self-reference, false if not.
     * @private
     */
    function isSelfReference(ref, nodes) {
      let scope = ref.from;
      while (scope) {
        if (nodes.indexOf(scope.block) >= 0) {
          return true;
        }
        scope = scope.upper;
      }
      return false;
    }

    /**
     * Gets a list of function definitions for a specified variable.
     * @param {Variable} variable - eslint-scope variable object.
     * @returns {ASTNode[]} Function nodes.
     * @private
     */
    function getFunctionDefinitions(variable) {
      const functionDefinitions = [];
      variable.defs.forEach(def => {
        const {
          type,
          node
        } = def;

        // FunctionDeclarations
        if (type === "FunctionName") {
          functionDefinitions.push(node);
        }

        // FunctionExpressions
        if (type === "Variable" && node.init && (node.init.type === "FunctionExpression" || node.init.type === "ArrowFunctionExpression")) {
          functionDefinitions.push(node.init);
        }
      });
      return functionDefinitions;
    }

    /**
     * Checks the position of given nodes.
     *
     * @param {ASTNode} inner - A node which is expected as inside.
     * @param {ASTNode} outer - A node which is expected as outside.
     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.
     * @private
     */
    function isInside(inner, outer) {
      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
    }

    /**
     * If a given reference is left-hand side of an assignment, this gets
     * the right-hand side node of the assignment.
     *
     * In the following cases, this returns null.
     *
     * - The reference is not the LHS of an assignment expression.
     * - The reference is inside of a loop.
     * - The reference is inside of a function scope which is different from
     *   the declaration.
     *
     * @param {eslint-scope.Reference} ref - A reference to check.
     * @param {ASTNode} prevRhsNode - The previous RHS node.
     * @returns {ASTNode|null} The RHS node or null.
     * @private
     */
    function getRhsNode(ref, prevRhsNode) {
      const id = ref.identifier;
      const parent = id.parent;
      const granpa = parent.parent;
      const refScope = ref.from.variableScope;
      const varScope = ref.resolved.scope.variableScope;
      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);

      /*
       * Inherits the previous node if this reference is in the node.
       * This is for `a = a + a`-like code.
       */
      if (prevRhsNode && isInside(id, prevRhsNode)) {
        return prevRhsNode;
      }
      if (parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && id === parent.left && !canBeUsedLater) {
        return parent.right;
      }
      return null;
    }

    /**
     * Checks whether a given function node is stored to somewhere or not.
     * If the function node is stored, the function can be used later.
     *
     * @param {ASTNode} funcNode - A function node to check.
     * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
     * @returns {boolean} `true` if under the following conditions:
     *      - the funcNode is assigned to a variable.
     *      - the funcNode is bound as an argument of a function call.
     *      - the function is bound to a property and the object satisfies above conditions.
     * @private
     */
    function isStorableFunction(funcNode, rhsNode) {
      let node = funcNode;
      let parent = funcNode.parent;
      while (parent && isInside(parent, rhsNode)) {
        switch (parent.type) {
          case "SequenceExpression":
            if (parent.expressions[parent.expressions.length - 1] !== node) {
              return false;
            }
            break;
          case "CallExpression":
          case "NewExpression":
            return parent.callee !== node;
          case "AssignmentExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
            return true;
          default:
            if (STATEMENT_TYPE.test(parent.type)) {
              /*
               * If it encountered statements, this is a complex pattern.
               * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.
               */
              return true;
            }
        }
        node = parent;
        parent = parent.parent;
      }
      return false;
    }

    /**
     * Checks whether a given Identifier node exists inside of a function node which can be used later.
     *
     * "can be used later" means:
     * - the function is assigned to a variable.
     * - the function is bound to a property and the object can be used later.
     * - the function is bound as an argument of a function call.
     *
     * If a reference exists in a function which can be used later, the reference is read when the function is called.
     *
     * @param {ASTNode} id - An Identifier node to check.
     * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.
     * @private
     */
    function isInsideOfStorableFunction(id, rhsNode) {
      const funcNode = astUtils.getUpperFunction(id);
      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
    }

    /**
     * Checks whether a given reference is a read to update itself or not.
     *
     * @param {eslint-scope.Reference} ref - A reference to check.
     * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
     * @returns {boolean} The reference is a read to update itself.
     * @private
     */
    function isReadForItself(ref, rhsNode) {
      const id = ref.identifier;
      const parent = id.parent;
      const granpa = parent.parent;
      return ref.isRead() && (
      // self update. e.g. `a += 1`, `a++`
      // in RHS of an assignment for itself. e.g. `a = a + 1`
      parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && parent.left === id || parent.type === "UpdateExpression" && granpa.type === "ExpressionStatement" || rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
    }

    /**
     * Determine if an identifier is used either in for-in loops.
     *
     * @param {Reference} ref - The reference to check.
     * @returns {boolean} whether reference is used in the for-in loops
     * @private
     */
    function isForInRef(ref) {
      let target = ref.identifier.parent;

      // "for (var ...) { return; }"
      if (target.type === "VariableDeclarator") {
        target = target.parent.parent;
      }
      if (target.type !== "ForInStatement") {
        return false;
      }

      // "for (...) { return; }"
      if (target.body.type === "BlockStatement") {
        target = target.body.body[0];

        // "for (...) return;"
      } else {
        target = target.body;
      }

      // For empty loop body
      if (!target) {
        return false;
      }
      return target.type === "ReturnStatement";
    }

    /**
     * Determines if the variable is used.
     * @param {Variable} variable - The variable to check.
     * @returns {boolean} True if the variable is used
     * @private
     */
    function isUsedVariable(variable) {
      const functionNodes = getFunctionDefinitions(variable),
        isFunctionDefinition = functionNodes.length > 0;
      let rhsNode = null;
      return variable.references.some(ref => {
        if (isForInRef(ref)) {
          return true;
        }
        const forItself = isReadForItself(ref, rhsNode);
        rhsNode = getRhsNode(ref, rhsNode);
        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
      });
    }

    /**
     * Checks whether the given variable is after the last used parameter.
     *
     * @param {eslint-scope.Variable} variable - The variable to check.
     * @returns {boolean} `true` if the variable is defined after the last
     * used parameter.
     */
    function isAfterLastUsedArg(variable) {
      const def = variable.defs[0];
      const params = context.getDeclaredVariables(def.node);
      const posteriorParams = params.slice(params.indexOf(variable) + 1);

      // If any used parameters occur after this parameter, do not report.
      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);
    }

    /**
     * Gets an array of variables without read references.
     * @param {Scope} scope - an eslint-scope Scope object.
     * @param {Variable[]} unusedVars - an array that saving result.
     * @returns {Variable[]} unused variables of the scope and descendant scopes.
     * @private
     */
    function collectUnusedVariables(scope, unusedVars) {
      const variables = scope.variables;
      const childScopes = scope.childScopes;
      let i, l;
      if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
        for (i = 0, l = variables.length; i < l; ++i) {
          const variable = variables[i];

          // skip a variable of class itself name in the class scope
          if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
            continue;
          }

          // skip function expression names and variables marked with markVariableAsUsed()
          if (scope.functionExpressionScope || variable.eslintUsed) {
            continue;
          }

          // skip implicit "arguments" variable
          if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
            continue;
          }

          // explicit global variables don't have definitions.
          const def = variable.defs[0];
          if (def) {
            const type = def.type;

            // skip catch variables
            if (type === "CatchClause") {
              if (config.caughtErrors === "none") {
                continue;
              }

              // skip ignored parameters
              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
                continue;
              }
            }
            if (type === "Parameter") {
              // skip any setter argument
              if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
                continue;
              }

              // if "args" option is "none", skip any parameter
              if (config.args === "none") {
                continue;
              }

              // skip ignored parameters
              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                continue;
              }

              // if "args" option is "after-used", skip used variables
              if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                continue;
              }
            } else {
              // skip ignored variables
              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                continue;
              }
            }
          }
          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
            unusedVars.push(variable);
          }
        }
      }
      for (i = 0, l = childScopes.length; i < l; ++i) {
        collectUnusedVariables(childScopes[i], unusedVars);
      }
      return unusedVars;
    }

    /**
     * Gets the index of a given variable name in a given comment.
     * @param {eslint-scope.Variable} variable - A variable to get.
     * @param {ASTNode} comment - A comment node which includes the variable name.
     * @returns {number} The index of the variable name's location.
     * @private
     */
    function getColumnInComment(variable, comment) {
      const namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\s,:])`, "gu");

      // To ignore the first text "global".
      namePattern.lastIndex = comment.value.indexOf("global") + 6;

      // Search a given variable name.
      const match = namePattern.exec(comment.value);
      return match ? match.index + 1 : 0;
    }

    /**
     * Creates the correct location of a given variables.
     * The location is at its name string in a `/*global` comment.
     *
     * @param {eslint-scope.Variable} variable - A variable to get its location.
     * @returns {{line: number, column: number}} The location object for the variable.
     * @private
     */
    function getLocation(variable) {
      const comment = variable.eslintExplicitGlobalComment;
      return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      "Program:exit"(programNode) {
        const unusedVars = collectUnusedVariables(context.getScope(), []);
        for (let i = 0, l = unusedVars.length; i < l; ++i) {
          const unusedVar = unusedVars[i];
          if (unusedVar.eslintExplicitGlobal) {
            context.report({
              node: programNode,
              loc: getLocation(unusedVar),
              message: getDefinedMessage(unusedVar),
              data: unusedVar
            });
          } else if (unusedVar.defs.length > 0) {
            context.report({
              node: unusedVar.identifiers[0],
              message: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessage() : getDefinedMessage(unusedVar),
              data: unusedVar
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 410 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of variables before they are defined
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;

/**
 * Parses a given value as options.
 *
 * @param {any} options - A value to parse.
 * @returns {Object} The parsed options.
 */
function parseOptions(options) {
  let functions = true;
  let classes = true;
  let variables = true;
  if (typeof options === "string") {
    functions = options !== "nofunc";
  } else if (typeof options === "object" && options !== null) {
    functions = options.functions !== false;
    classes = options.classes !== false;
    variables = options.variables !== false;
  }
  return {
    functions,
    classes,
    variables
  };
}

/**
 * Checks whether or not a given variable is a function declaration.
 *
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is a function declaration.
 */
function isFunction(variable) {
  return variable.defs[0].type === "FunctionName";
}

/**
 * Checks whether or not a given variable is a class declaration in an upper function scope.
 *
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the variable is a class declaration.
 */
function isOuterClass(variable, reference) {
  return variable.defs[0].type === "ClassName" && variable.scope.variableScope !== reference.from.variableScope;
}

/**
 * Checks whether or not a given variable is a variable declaration in an upper function scope.
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @param {eslint-scope.Reference} reference - A reference to check.
 * @returns {boolean} `true` if the variable is a variable declaration.
 */
function isOuterVariable(variable, reference) {
  return variable.defs[0].type === "Variable" && variable.scope.variableScope !== reference.from.variableScope;
}

/**
 * Checks whether or not a given location is inside of the range of a given node.
 *
 * @param {ASTNode} node - An node to check.
 * @param {number} location - A location to check.
 * @returns {boolean} `true` if the location is inside of the range of the node.
 */
function isInRange(node, location) {
  return node && node.range[0] <= location && location <= node.range[1];
}

/**
 * Checks whether or not a given reference is inside of the initializers of a given variable.
 *
 * This returns `true` in the following cases:
 *
 *     var a = a
 *     var [a = a] = list
 *     var {a = a} = obj
 *     for (var a in a) {}
 *     for (var a of a) {}
 *
 * @param {Variable} variable - A variable to check.
 * @param {Reference} reference - A reference to check.
 * @returns {boolean} `true` if the reference is inside of the initializers.
 */
function isInInitializer(variable, reference) {
  if (variable.scope !== reference.from) {
    return false;
  }
  let node = variable.identifiers[0].parent;
  const location = reference.identifier.range[1];
  while (node) {
    if (node.type === "VariableDeclarator") {
      if (isInRange(node.init, location)) {
        return true;
      }
      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
        return true;
      }
      break;
    } else if (node.type === "AssignmentPattern") {
      if (isInRange(node.right, location)) {
        return true;
      }
    } else if (SENTINEL_TYPE.test(node.type)) {
      break;
    }
    node = node.parent;
  }
  return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of variables before they are defined",
      category: "Variables",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-use-before-define"
    },
    schema: [{
      oneOf: [{
        enum: ["nofunc"]
      }, {
        type: "object",
        properties: {
          functions: {
            type: "boolean"
          },
          classes: {
            type: "boolean"
          },
          variables: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const options = parseOptions(context.options[0]);

    /**
     * Determines whether a given use-before-define case should be reported according to the options.
     * @param {eslint-scope.Variable} variable The variable that gets used before being defined
     * @param {eslint-scope.Reference} reference The reference to the variable
     * @returns {boolean} `true` if the usage should be reported
     */
    function isForbidden(variable, reference) {
      if (isFunction(variable)) {
        return options.functions;
      }
      if (isOuterClass(variable, reference)) {
        return options.classes;
      }
      if (isOuterVariable(variable, reference)) {
        return options.variables;
      }
      return true;
    }

    /**
     * Finds and validates all variables in a given scope.
     * @param {Scope} scope The scope object.
     * @returns {void}
     * @private
     */
    function findVariablesInScope(scope) {
      scope.references.forEach(reference => {
        const variable = reference.resolved;

        /*
         * Skips when the reference is:
         * - initialization's.
         * - referring to an undefined variable.
         * - referring to a global environment variable (there're no identifiers).
         * - located preceded by the variable (except in initializers).
         * - allowed by options.
         */
        if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {
          return;
        }

        // Reports.
        context.report({
          node: reference.identifier,
          message: "'{{name}}' was used before it was defined.",
          data: reference.identifier
        });
      });
      scope.childScopes.forEach(findVariablesInScope);
    }
    return {
      Program() {
        findVariablesInScope(context.getScope());
      }
    };
  }
};

/***/ }),
/* 411 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a node is a `.call()`/`.apply()`.
 * @param {ASTNode} node - A CallExpression node to check.
 * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.
 */
function isCallOrNonVariadicApply(node) {
  return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.computed === false && (node.callee.property.name === "call" && node.arguments.length >= 1 || node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
}

/**
 * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.
 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.
 * @param {SourceCode} sourceCode - The ESLint source code object.
 * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.
 */
function isValidThisArg(expectedThis, thisArg, sourceCode) {
  if (!expectedThis) {
    return astUtils.isNullOrUndefined(thisArg);
  }
  return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.call()` and `.apply()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-call"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      CallExpression(node) {
        if (!isCallOrNonVariadicApply(node)) {
          return;
        }
        const applied = node.callee.object;
        const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
        const thisArg = node.arguments[0];
        if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
          context.report({
            node,
            message: "unnecessary '.{{name}}()'.",
            data: {
              name: node.callee.property.name
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 412 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Reports useless `catch` clauses that just rethrow their error.
 * @author Teddy Katz
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `catch` clauses",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-catch"
    },
    schema: []
  },
  create(context) {
    return {
      CatchClause(node) {
        if (node.param && node.param.type === "Identifier" && node.body.body.length && node.body.body[0].type === "ThrowStatement" && node.body.body[0].argument.type === "Identifier" && node.body.body[0].argument.name === node.param.name) {
          if (node.parent.finalizer) {
            context.report({
              node,
              message: "Unnecessary catch clause."
            });
          } else {
            context.report({
              node: node.parent,
              message: "Unnecessary try/catch wrapper."
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 413 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow unnecessary computed property keys in object literals
 * @author Burak Yigit Kaya
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary computed property keys in object literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-computed-key"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Property(node) {
        if (!node.computed) {
          return;
        }
        const key = node.key,
          nodeType = typeof key.value;
        if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== "__proto__") {
          context.report({
            node,
            message: MESSAGE_UNNECESSARY_COMPUTED,
            data: {
              property: sourceCode.getText(key)
            },
            fix(fixer) {
              const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
              const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
              const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);
              if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {
                // If there are comments between the brackets and the property name, don't do a fix.
                return null;
              }
              const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);

              // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })
              const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
              const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
              return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 414 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview disallow unncessary concatenation of template strings
 * @author Henry Zhu
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a concatenation.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a concatenation.
 */
function isConcatenation(node) {
  return node.type === "BinaryExpression" && node.operator === "+";
}

/**
 * Checks if the given token is a `+` token or not.
 * @param {Token} token - The token to check.
 * @returns {boolean} `true` if the token is a `+` token.
 */
function isConcatOperatorToken(token) {
  return token.value === "+" && token.type === "Punctuator";
}

/**
 * Get's the right most node on the left side of a BinaryExpression with + operator.
 * @param {ASTNode} node - A BinaryExpression node to check.
 * @returns {ASTNode} node
 */
function getLeft(node) {
  let left = node.left;
  while (isConcatenation(left)) {
    left = left.right;
  }
  return left;
}

/**
 * Get's the left most node on the right side of a BinaryExpression with + operator.
 * @param {ASTNode} node - A BinaryExpression node to check.
 * @returns {ASTNode} node
 */
function getRight(node) {
  let right = node.right;
  while (isConcatenation(right)) {
    right = right.left;
  }
  return right;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary concatenation of literals or template literals",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-concat"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      BinaryExpression(node) {
        // check if not concatenation
        if (node.operator !== "+") {
          return;
        }

        // account for the `foo + "a" + "b"` case
        const left = getLeft(node);
        const right = getRight(node);
        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);
          context.report({
            node,
            loc: operatorToken.loc.start,
            message: "Unexpected string concatenation of literals."
          });
        }
      }
    };
  }
};

/***/ }),
/* 415 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag the use of redundant constructors in classes.
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a given array of statements is a single call of `super`.
 *
 * @param {ASTNode[]} body - An array of statements to check.
 * @returns {boolean} `true` if the body is a single call of `super`.
 */
function isSingleSuperCall(body) {
  return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
}

/**
 * Checks whether a given node is a pattern which doesn't have any side effects.
 * Default parameters and Destructuring parameters can have side effects.
 *
 * @param {ASTNode} node - A pattern node.
 * @returns {boolean} `true` if the node doesn't have any side effects.
 */
function isSimple(node) {
  return node.type === "Identifier" || node.type === "RestElement";
}

/**
 * Checks whether a given array of expressions is `...arguments` or not.
 * `super(...arguments)` passes all arguments through.
 *
 * @param {ASTNode[]} superArgs - An array of expressions to check.
 * @returns {boolean} `true` if the superArgs is `...arguments`.
 */
function isSpreadArguments(superArgs) {
  return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
}

/**
 * Checks whether given 2 nodes are identifiers which have the same name or not.
 *
 * @param {ASTNode} ctorParam - A node to check.
 * @param {ASTNode} superArg - A node to check.
 * @returns {boolean} `true` if the nodes are identifiers which have the same
 *      name.
 */
function isValidIdentifierPair(ctorParam, superArg) {
  return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
}

/**
 * Checks whether given 2 nodes are a rest/spread pair which has the same values.
 *
 * @param {ASTNode} ctorParam - A node to check.
 * @param {ASTNode} superArg - A node to check.
 * @returns {boolean} `true` if the nodes are a rest/spread pair which has the
 *      same values.
 */
function isValidRestSpreadPair(ctorParam, superArg) {
  return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
}

/**
 * Checks whether given 2 nodes have the same value or not.
 *
 * @param {ASTNode} ctorParam - A node to check.
 * @param {ASTNode} superArg - A node to check.
 * @returns {boolean} `true` if the nodes have the same value or not.
 */
function isValidPair(ctorParam, superArg) {
  return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
}

/**
 * Checks whether the parameters of a constructor and the arguments of `super()`
 * have the same values or not.
 *
 * @param {ASTNode} ctorParams - The parameters of a constructor to check.
 * @param {ASTNode} superArgs - The arguments of `super()` to check.
 * @returns {boolean} `true` if those have the same values.
 */
function isPassingThrough(ctorParams, superArgs) {
  if (ctorParams.length !== superArgs.length) {
    return false;
  }
  for (let i = 0; i < ctorParams.length; ++i) {
    if (!isValidPair(ctorParams[i], superArgs[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Checks whether the constructor body is a redundant super call.
 *
 * @param {Array} body - constructor body content.
 * @param {Array} ctorParams - The params to check against super call.
 * @returns {boolean} true if the construtor body is redundant
 */
function isRedundantSuperCall(body, ctorParams) {
  return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary constructors",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-constructor"
    },
    schema: []
  },
  create(context) {
    /**
     * Checks whether a node is a redundant constructor
     * @param {ASTNode} node - node to check
     * @returns {void}
     */
    function checkForConstructor(node) {
      if (node.kind !== "constructor") {
        return;
      }
      const body = node.value.body.body;
      const ctorParams = node.value.params;
      const superClass = node.parent.parent.superClass;
      if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
        context.report({
          node,
          message: "Useless constructor."
        });
      }
    }
    return {
      MethodDefinition: checkForConstructor
    };
  }
};

/***/ }),
/* 416 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Look for useless escapes in strings and regexes
 * @author Onur Temizkan
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Returns the union of two sets.
 * @param {Set} setA The first set
 * @param {Set} setB The second set
 * @returns {Set} The union of the two sets
 */
function union(setA, setB) {
  return new Set(function* () {
    yield* setA;
    yield* setB;
  }());
}
const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()Bk"));

/**
 * Parses a regular expression into a list of characters with character class info.
 * @param {string} regExpText The raw text used to create the regular expression
 * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.
 * @example
 *
 * parseRegExp('a\\b[cd-]')
 *
 * returns:
 * [
 *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},
 *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},
 *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},
 *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},
 *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}
 * ]
 */
function parseRegExp(regExpText) {
  const charList = [];
  regExpText.split("").reduce((state, char, index) => {
    if (!state.escapeNextChar) {
      if (char === "\\") {
        return Object.assign(state, {
          escapeNextChar: true
        });
      }
      if (char === "[" && !state.inCharClass) {
        return Object.assign(state, {
          inCharClass: true,
          startingCharClass: true
        });
      }
      if (char === "]" && state.inCharClass) {
        if (charList.length && charList[charList.length - 1].inCharClass) {
          charList[charList.length - 1].endsCharClass = true;
        }
        return Object.assign(state, {
          inCharClass: false,
          startingCharClass: false
        });
      }
    }
    charList.push({
      text: char,
      index,
      escaped: state.escapeNextChar,
      inCharClass: state.inCharClass,
      startsCharClass: state.startingCharClass,
      endsCharClass: false
    });
    return Object.assign(state, {
      escapeNextChar: false,
      startingCharClass: false
    });
  }, {
    escapeNextChar: false,
    inCharClass: false,
    startingCharClass: false
  });
  return charList;
}
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary escape characters",
      category: "Best Practices",
      recommended: true,
      url: "https://eslint.org/docs/rules/no-useless-escape"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Reports a node
     * @param {ASTNode} node The node to report
     * @param {number} startOffset The backslash's offset from the start of the node
     * @param {string} character The uselessly escaped character (not including the backslash)
     * @returns {void}
     */
    function report(node, startOffset, character) {
      context.report({
        node,
        loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),
        message: "Unnecessary escape character: \\{{character}}.",
        data: {
          character
        }
      });
    }

    /**
     * Checks if the escape character in given string slice is unnecessary.
     *
     * @private
     * @param {ASTNode} node - node to validate.
     * @param {string} match - string slice to validate.
     * @returns {void}
     */
    function validateString(node, match) {
      const isTemplateElement = node.type === "TemplateElement";
      const escapedChar = match[0][1];
      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
      let isQuoteEscape;
      if (isTemplateElement) {
        isQuoteEscape = escapedChar === "`";
        if (escapedChar === "$") {
          // Warn if `\$` is not followed by `{`
          isUnnecessaryEscape = match.input[match.index + 2] !== "{";
        } else if (escapedChar === "{") {
          /*
           * Warn if `\{` is not preceded by `$`. If preceded by `$`, escaping
           * is necessary and the rule should not warn. If preceded by `/$`, the rule
           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
           */
          isUnnecessaryEscape = match.input[match.index - 1] !== "$";
        }
      } else {
        isQuoteEscape = escapedChar === node.raw[0];
      }
      if (isUnnecessaryEscape && !isQuoteEscape) {
        report(node, match.index + 1, match[0].slice(1));
      }
    }

    /**
     * Checks if a node has an escape.
     *
     * @param {ASTNode} node - node to check.
     * @returns {void}
     */
    function check(node) {
      const isTemplateElement = node.type === "TemplateElement";
      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
        // Don't report tagged template literals, because the backslash character is accessible to the tag function.
        return;
      }
      if (typeof node.value === "string" || isTemplateElement) {
        /*
         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
         */
        if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") {
          return;
        }
        const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
        const pattern = /\\[^\d]/gu;
        let match;
        while (match = pattern.exec(value)) {
          validateString(node, match);
        }
      } else if (node.regex) {
        parseRegExp(node.regex.pattern)

        /*
         * The '-' character is a special case, because it's only valid to escape it if it's in a character
         * class, and is not at either edge of the character class. To account for this, don't consider '-'
         * characters to be valid in general, and filter out '-' characters that appear in the middle of a
         * character class.
         */.filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))

        /*
         * The '^' character is also a special case; it must always be escaped outside of character classes, but
         * it only needs to be escaped in character classes if it's at the beginning of the character class. To
         * account for this, consider it to be a valid escape character outside of character classes, and filter
         * out '^' characters that appear at the start of a character class.
         */.filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass))

        // Filter out characters that aren't escaped.
        .filter(charInfo => charInfo.escaped)

        // Filter out characters that are valid to escape, based on their position in the regular expression.
        .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))

        // Report all the remaining characters.
        .forEach(charInfo => report(node, charInfo.index, charInfo.text));
      }
    }
    return {
      Literal: check,
      TemplateElement: check
    };
  }
};

/***/ }),
/* 417 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.
 * @author Kai Cataldo
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow renaming import, export, and destructured assignments to the same name",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-rename"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: false
        },
        ignoreImport: {
          type: "boolean",
          default: false
        },
        ignoreExport: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const options = context.options[0] || {},
      ignoreDestructuring = options.ignoreDestructuring === true,
      ignoreImport = options.ignoreImport === true,
      ignoreExport = options.ignoreExport === true;

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports error for unnecessarily renamed assignments
     * @param {ASTNode} node - node to report
     * @param {ASTNode} initial - node with initial name value
     * @param {ASTNode} result - node with new name value
     * @param {string} type - the type of the offending node
     * @returns {void}
     */
    function reportError(node, initial, result, type) {
      const name = initial.type === "Identifier" ? initial.name : initial.value;
      return context.report({
        node,
        message: "{{type}} {{name}} unnecessarily renamed.",
        data: {
          name,
          type
        },
        fix(fixer) {
          return fixer.replaceTextRange([initial.range[0], result.range[1]], name);
        }
      });
    }

    /**
     * Checks whether a destructured assignment is unnecessarily renamed
     * @param {ASTNode} node - node to check
     * @returns {void}
     */
    function checkDestructured(node) {
      if (ignoreDestructuring) {
        return;
      }
      const properties = node.properties;
      for (let i = 0; i < properties.length; i++) {
        if (properties[i].shorthand) {
          continue;
        }

        /**
         * If an ObjectPattern property is computed, we have no idea
         * if a rename is useless or not. If an ObjectPattern property
         * lacks a key, it is likely an ExperimentalRestProperty and
         * so there is no "renaming" occurring here.
         */
        if (properties[i].computed || !properties[i].key) {
          continue;
        }
        if (properties[i].key.type === "Identifier" && properties[i].key.name === properties[i].value.name || properties[i].key.type === "Literal" && properties[i].key.value === properties[i].value.name) {
          reportError(properties[i], properties[i].key, properties[i].value, "Destructuring assignment");
        }
      }
    }

    /**
     * Checks whether an import is unnecessarily renamed
     * @param {ASTNode} node - node to check
     * @returns {void}
     */
    function checkImport(node) {
      if (ignoreImport) {
        return;
      }
      if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {
        reportError(node, node.imported, node.local, "Import");
      }
    }

    /**
     * Checks whether an export is unnecessarily renamed
     * @param {ASTNode} node - node to check
     * @returns {void}
     */
    function checkExport(node) {
      if (ignoreExport) {
        return;
      }
      if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {
        reportError(node, node.local, node.exported, "Export");
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ObjectPattern: checkDestructured,
      ImportSpecifier: checkImport,
      ExportSpecifier: checkExport
    };
  }
};

/***/ }),
/* 418 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallow redundant return statements
 * @author Teddy Katz
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110),
  FixTracker = __webpack_require__(305);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Removes the given element from the array.
 *
 * @param {Array} array - The source array to remove.
 * @param {any} element - The target item to remove.
 * @returns {void}
 */
function remove(array, element) {
  const index = array.indexOf(element);
  if (index !== -1) {
    array.splice(index, 1);
  }
}

/**
 * Checks whether it can remove the given return statement or not.
 *
 * @param {ASTNode} node - The return statement node to check.
 * @returns {boolean} `true` if the node is removeable.
 */
function isRemovable(node) {
  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}

/**
 * Checks whether the given return statement is in a `finally` block or not.
 *
 * @param {ASTNode} node - The return statement node to check.
 * @returns {boolean} `true` if the node is in a `finally` block.
 */
function isInFinally(node) {
  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {
    if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
      return true;
    }
  }
  return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow redundant return statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-useless-return"
    },
    fixable: "code",
    schema: []
  },
  create(context) {
    const segmentInfoMap = new WeakMap();
    const usedUnreachableSegments = new WeakSet();
    let scopeInfo = null;

    /**
     * Checks whether the given segment is terminated by a return statement or not.
     *
     * @param {CodePathSegment} segment - The segment to check.
     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
     */
    function isReturned(segment) {
      const info = segmentInfoMap.get(segment);
      return !info || info.returned;
    }

    /**
     * Collects useless return statements from the given previous segments.
     *
     * A previous segment may be an unreachable segment.
     * In that case, the information object of the unreachable segment is not
     * initialized because `onCodePathSegmentStart` event is not notified for
     * unreachable segments.
     * This goes to the previous segments of the unreachable segment recursively
     * if the unreachable segment was generated by a return statement. Otherwise,
     * this ignores the unreachable segment.
     *
     * This behavior would simulate code paths for the case that the return
     * statement does not exist.
     *
     * @param {ASTNode[]} uselessReturns - The collected return statements.
     * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.
     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call
     * @returns {ASTNode[]} `uselessReturns`.
     */
    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
      const traversedSegments = providedTraversedSegments || new WeakSet();
      for (const segment of prevSegments) {
        if (!segment.reachable) {
          if (!traversedSegments.has(segment)) {
            traversedSegments.add(segment);
            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
          }
          continue;
        }
        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);
      }
      return uselessReturns;
    }

    /**
     * Removes the return statements on the given segment from the useless return
     * statement list.
     *
     * This segment may be an unreachable segment.
     * In that case, the information object of the unreachable segment is not
     * initialized because `onCodePathSegmentStart` event is not notified for
     * unreachable segments.
     * This goes to the previous segments of the unreachable segment recursively
     * if the unreachable segment was generated by a return statement. Otherwise,
     * this ignores the unreachable segment.
     *
     * This behavior would simulate code paths for the case that the return
     * statement does not exist.
     *
     * @param {CodePathSegment} segment - The segment to get return statements.
     * @returns {void}
     */
    function markReturnStatementsOnSegmentAsUsed(segment) {
      if (!segment.reachable) {
        usedUnreachableSegments.add(segment);
        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);
        return;
      }
      const info = segmentInfoMap.get(segment);
      for (const node of info.uselessReturns) {
        remove(scopeInfo.uselessReturns, node);
      }
      info.uselessReturns = [];
    }

    /**
     * Removes the return statements on the current segments from the useless
     * return statement list.
     *
     * This function will be called at every statement except FunctionDeclaration,
     * BlockStatement, and BreakStatement.
     *
     * - FunctionDeclarations are always executed whether it's returned or not.
     * - BlockStatements do nothing.
     * - BreakStatements go the next merely.
     *
     * @returns {void}
     */
    function markReturnStatementsOnCurrentSegmentsAsUsed() {
      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      // Makes and pushs a new scope information.
      onCodePathStart(codePath) {
        scopeInfo = {
          upper: scopeInfo,
          uselessReturns: [],
          codePath
        };
      },
      // Reports useless return statements if exist.
      onCodePathEnd() {
        for (const node of scopeInfo.uselessReturns) {
          context.report({
            node,
            loc: node.loc,
            message: "Unnecessary return statement.",
            fix(fixer) {
              if (isRemovable(node)) {
                /*
                 * Extend the replacement range to include the
                 * entire function to avoid conflicting with
                 * no-else-return.
                 * https://github.com/eslint/eslint/issues/8026
                 */
                return new FixTracker(fixer, context.getSourceCode()).retainEnclosingFunction(node).remove(node);
              }
              return null;
            }
          });
        }
        scopeInfo = scopeInfo.upper;
      },
      /*
       * Initializes segments.
       * NOTE: This event is notified for only reachable segments.
       */
      onCodePathSegmentStart(segment) {
        const info = {
          uselessReturns: getUselessReturns([], segment.allPrevSegments),
          returned: false
        };

        // Stores the info.
        segmentInfoMap.set(segment, info);
      },
      // Adds ReturnStatement node to check whether it's useless or not.
      ReturnStatement(node) {
        if (node.argument) {
          markReturnStatementsOnCurrentSegmentsAsUsed();
        }
        if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {
          return;
        }
        for (const segment of scopeInfo.codePath.currentSegments) {
          const info = segmentInfoMap.get(segment);
          if (info) {
            info.uselessReturns.push(node);
            info.returned = true;
          }
        }
        scopeInfo.uselessReturns.push(node);
      },
      /*
       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
       * Removes return statements of the current segments from the useless return statement list.
       */
      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
    };
  }
};

/***/ }),
/* 419 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to check for the usage of var.
 * @author Jamund Ferguson
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Check whether a given variable is a global variable or not.
 * @param {eslint-scope.Variable} variable The variable to check.
 * @returns {boolean} `true` if the variable is a global variable.
 */
function isGlobal(variable) {
  return Boolean(variable.scope) && variable.scope.type === "global";
}

/**
 * Finds the nearest function scope or global scope walking up the scope
 * hierarchy.
 *
 * @param {eslint-scope.Scope} scope - The scope to traverse.
 * @returns {eslint-scope.Scope} a function scope or global scope containing the given
 *      scope.
 */
function getEnclosingFunctionScope(scope) {
  let currentScope = scope;
  while (currentScope.type !== "function" && currentScope.type !== "global") {
    currentScope = currentScope.upper;
  }
  return currentScope;
}

/**
 * Checks whether the given variable has any references from a more specific
 * function expression (i.e. a closure).
 *
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is used from a closure.
 */
function isReferencedInClosure(variable) {
  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);
}

/**
 * Checks whether the given node is the assignee of a loop.
 *
 * @param {ASTNode} node - A VariableDeclaration node to check.
 * @returns {boolean} `true` if the declaration is assigned as part of loop
 *      iteration.
 */
function isLoopAssignee(node) {
  return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
}

/**
 * Checks whether the given variable declaration is immediately initialized.
 *
 * @param {ASTNode} node - A VariableDeclaration node to check.
 * @returns {boolean} `true` if the declaration has an initializer.
 */
function isDeclarationInitialized(node) {
  return node.declarations.every(declarator => declarator.init !== null);
}
const SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;

/**
 * Gets the scope node which directly contains a given node.
 *
 * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or
 *      an `Identifier`.
 * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,
 *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and
 *      `ForOfStatement`.
 */
function getScopeNode(node) {
  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
    if (SCOPE_NODE_TYPE.test(currentNode.type)) {
      return currentNode;
    }
  }

  /* istanbul ignore next : unreachable */
  return null;
}

/**
 * Checks whether a given variable is redeclared or not.
 *
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is redeclared.
 */
function isRedeclared(variable) {
  return variable.defs.length >= 2;
}

/**
 * Checks whether a given variable is used from outside of the specified scope.
 *
 * @param {ASTNode} scopeNode - A scope node to check.
 * @returns {Function} The predicate function which checks whether a given
 *      variable is used from outside of the specified scope.
 */
function isUsedFromOutsideOf(scopeNode) {
  /**
   * Checks whether a given reference is inside of the specified scope or not.
   *
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is inside of the specified
   *      scope.
   */
  function isOutsideOfScope(reference) {
    const scope = scopeNode.range;
    const id = reference.identifier.range;
    return id[0] < scope[0] || id[1] > scope[1];
  }
  return function (variable) {
    return variable.references.some(isOutsideOfScope);
  };
}

/**
 * Creates the predicate function which checks whether a variable has their references in TDZ.
 *
 * The predicate function would return `true`:
 *
 * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)
 * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)
 * - if a reference is in the expression of their initializer.  E.g. (var a = a;)
 *
 * @param {ASTNode} node - The initializer node of VariableDeclarator.
 * @returns {Function} The predicate function.
 * @private
 */
function hasReferenceInTDZ(node) {
  const initStart = node.range[0];
  const initEnd = node.range[1];
  return variable => {
    const id = variable.defs[0].name;
    const idStart = id.range[0];
    const defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
    const defaultStart = defaultValue && defaultValue.range[0];
    const defaultEnd = defaultValue && defaultValue.range[1];
    return variable.references.some(reference => {
      const start = reference.identifier.range[0];
      const end = reference.identifier.range[1];
      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);
    });
  };
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `let` or `const` instead of `var`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-var"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Checks whether the variables which are defined by the given declarator node have their references in TDZ.
     *
     * @param {ASTNode} declarator - The VariableDeclarator node to check.
     * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.
     */
    function hasSelfReferenceInTDZ(declarator) {
      if (!declarator.init) {
        return false;
      }
      const variables = context.getDeclaredVariables(declarator);
      return variables.some(hasReferenceInTDZ(declarator.init));
    }

    /**
     * Checks whether it can fix a given variable declaration or not.
     * It cannot fix if the following cases:
     *
     * - A variable is a global variable.
     * - A variable is declared on a SwitchCase node.
     * - A variable is redeclared.
     * - A variable is used from outside the scope.
     * - A variable is used from a closure within a loop.
     * - A variable might be used before it is assigned within a loop.
     * - A variable might be used in TDZ.
     * - A variable is declared in statement position (e.g. a single-line `IfStatement`)
     *
     * ## A variable is declared on a SwitchCase node.
     *
     * If this rule modifies 'var' declarations on a SwitchCase node, it
     * would generate the warnings of 'no-case-declarations' rule. And the
     * 'eslint:recommended' preset includes 'no-case-declarations' rule, so
     * this rule doesn't modify those declarations.
     *
     * ## A variable is redeclared.
     *
     * The language spec disallows redeclarations of `let` declarations.
     * Those variables would cause syntax errors.
     *
     * ## A variable is used from outside the scope.
     *
     * The language spec disallows accesses from outside of the scope for
     * `let` declarations. Those variables would cause reference errors.
     *
     * ## A variable is used from a closure within a loop.
     *
     * A `var` declaration within a loop shares the same variable instance
     * across all loop iterations, while a `let` declaration creates a new
     * instance for each iteration. This means if a variable in a loop is
     * referenced by any closure, changing it from `var` to `let` would
     * change the behavior in a way that is generally unsafe.
     *
     * ## A variable might be used before it is assigned within a loop.
     *
     * Within a loop, a `let` declaration without an initializer will be
     * initialized to null, while a `var` declaration will retain its value
     * from the previous iteration, so it is only safe to change `var` to
     * `let` if we can statically determine that the variable is always
     * assigned a value before its first access in the loop body. To keep
     * the implementation simple, we only convert `var` to `let` within
     * loops when the variable is a loop assignee or the declaration has an
     * initializer.
     *
     * @param {ASTNode} node - A variable declaration node to check.
     * @returns {boolean} `true` if it can fix the node.
     */
    function canFix(node) {
      const variables = context.getDeclaredVariables(node);
      const scopeNode = getScopeNode(node);
      if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode))) {
        return false;
      }
      if (astUtils.isInLoop(node)) {
        if (variables.some(isReferencedInClosure)) {
          return false;
        }
        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
          return false;
        }
      }
      if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
        // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.
        return false;
      }
      return true;
    }

    /**
     * Reports a given variable declaration node.
     *
     * @param {ASTNode} node - A variable declaration node to report.
     * @returns {void}
     */
    function report(node) {
      const varToken = sourceCode.getFirstToken(node);
      context.report({
        node,
        message: "Unexpected var, use let or const instead.",
        fix(fixer) {
          if (canFix(node)) {
            return fixer.replaceText(varToken, "let");
          }
          return null;
        }
      });
    }
    return {
      "VariableDeclaration:exit"(node) {
        if (node.kind === "var") {
          report(node);
        }
      }
    };
  }
};

/***/ }),
/* 420 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow use of void operator.
 * @author Mike Sidorov
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `void` operators",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-void"
    },
    schema: []
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      UnaryExpression(node) {
        if (node.operator === "void") {
          context.report({
            node,
            message: "Expected 'undefined' and instead saw 'void'."
          });
        }
      }
    };
  }
};

/***/ }),
/* 421 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule that warns about used warning comments
 * @author Alexander Schmidt <https://github.com/lxanders>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified warning terms in comments",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-warning-comments"
    },
    schema: [{
      type: "object",
      properties: {
        terms: {
          type: "array",
          items: {
            type: "string"
          }
        },
        location: {
          enum: ["start", "anywhere"]
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode(),
      configuration = context.options[0] || {},
      warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
      location = configuration.location || "start",
      selfConfigRegEx = /\bno-warning-comments\b/u;

    /**
     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
     * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
     * require word boundaries on that side.
     *
     * @param {string} term A term to convert to a RegExp
     * @returns {RegExp} The term converted to a RegExp
     */
    function convertToRegExp(term) {
      const escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/gu, "\\$&");
      const wordBoundary = "\\b";
      const eitherOrWordBoundary = `|${wordBoundary}`;
      let prefix;

      /*
       * If the term ends in a word character (a-z0-9_), ensure a word
       * boundary at the end, so that substrings do not get falsely
       * matched. eg "todo" in a string such as "mastodon".
       * If the term ends in a non-word character, then \b won't match on
       * the boundary to the next non-word character, which would likely
       * be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
       * In these cases, use no bounding match. Same applies for the
       * prefix, handled below.
       */
      const suffix = /\w$/u.test(term) ? "\\b" : "";
      if (location === "start") {
        /*
         * When matching at the start, ignore leading whitespace, and
         * there's no need to worry about word boundaries.
         */
        prefix = "^\\s*";
      } else if (/^\w/u.test(term)) {
        prefix = wordBoundary;
      } else {
        prefix = "";
      }
      if (location === "start") {
        /*
         * For location "start" the regex should be
         * ^\s*TERM\b.  This checks the word boundary
         * at the beginning of the comment.
         */
        return new RegExp(prefix + escaped + suffix, "i"); // eslint-disable-line require-unicode-regexp
      }

      /*
       * For location "anywhere" the regex should be
       * \bTERM\b|\bTERM\b, this checks the entire comment
       * for the term.
       */
      return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, "i"); // eslint-disable-line require-unicode-regexp
    }
    const warningRegExps = warningTerms.map(convertToRegExp);

    /**
     * Checks the specified comment for matches of the configured warning terms and returns the matches.
     * @param {string} comment The comment which is checked.
     * @returns {Array} All matched warning terms for this comment.
     */
    function commentContainsWarningTerm(comment) {
      const matches = [];
      warningRegExps.forEach((regex, index) => {
        if (regex.test(comment)) {
          matches.push(warningTerms[index]);
        }
      });
      return matches;
    }

    /**
     * Checks the specified node for matching warning comments and reports them.
     * @param {ASTNode} node The AST node being checked.
     * @returns {void} undefined.
     */
    function checkComment(node) {
      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
        return;
      }
      const matches = commentContainsWarningTerm(node.value);
      matches.forEach(matchedTerm => {
        context.report({
          node,
          message: "Unexpected '{{matchedTerm}}' comment.",
          data: {
            matchedTerm
          }
        });
      });
    }
    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(checkComment);
      }
    };
  }
};

/***/ }),
/* 422 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow whitespace before properties
 * @author Kai Cataldo
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow whitespace before properties",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-whitespace-before-property"
    },
    fixable: "whitespace",
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports whitespace before property token
     * @param {ASTNode} node - the node to report in the event of an error
     * @param {Token} leftToken - the left token
     * @param {Token} rightToken - the right token
     * @returns {void}
     * @private
     */
    function reportError(node, leftToken, rightToken) {
      const replacementText = node.computed ? "" : ".";
      context.report({
        node,
        message: "Unexpected whitespace before property {{propName}}.",
        data: {
          propName: sourceCode.getText(node.property)
        },
        fix(fixer) {
          if (!node.computed && astUtils.isDecimalInteger(node.object)) {
            /*
             * If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.
             * Don't fix this case.
             */
            return null;
          }
          return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
        }
      });
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      MemberExpression(node) {
        let rightToken;
        let leftToken;
        if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
          return;
        }
        if (node.computed) {
          rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
          leftToken = sourceCode.getTokenBefore(rightToken);
        } else {
          rightToken = sourceCode.getFirstToken(node.property);
          leftToken = sourceCode.getTokenBefore(rightToken, 1);
        }
        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
          reportError(node, leftToken, rightToken);
        }
      }
    };
  }
};

/***/ }),
/* 423 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag use of with statement
 * @author Nicholas C. Zakas
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `with` statements",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/no-with"
    },
    schema: []
  },
  create(context) {
    return {
      WithStatement(node) {
        context.report({
          node,
          message: "Unexpected use of 'with' statement."
        });
      }
    };
  }
};

/***/ }),
/* 424 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview enforce the location of single-line statements
 * @author Teddy Katz
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const POSITION_SCHEMA = {
  enum: ["beside", "below", "any"]
};
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of single-line statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
    },
    fixable: "whitespace",
    schema: [POSITION_SCHEMA, {
      properties: {
        overrides: {
          properties: {
            if: POSITION_SCHEMA,
            else: POSITION_SCHEMA,
            while: POSITION_SCHEMA,
            do: POSITION_SCHEMA,
            for: POSITION_SCHEMA
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Gets the applicable preference for a particular keyword
     * @param {string} keywordName The name of a keyword, e.g. 'if'
     * @returns {string} The applicable option for the keyword, e.g. 'beside'
     */
    function getOption(keywordName) {
      return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
    }

    /**
     * Validates the location of a single-line statement
     * @param {ASTNode} node The single-line statement
     * @param {string} keywordName The applicable keyword name for the single-line statement
     * @returns {void}
     */
    function validateStatement(node, keywordName) {
      const option = getOption(keywordName);
      if (node.type === "BlockStatement" || option === "any") {
        return;
      }
      const tokenBefore = sourceCode.getTokenBefore(node);
      if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
        context.report({
          node,
          message: "Expected a linebreak before this statement.",
          fix: fixer => fixer.insertTextBefore(node, "\n")
        });
      } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
        context.report({
          node,
          message: "Expected no linebreak before this statement.",
          fix(fixer) {
            if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
              return null;
            }
            return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
          }
        });
      }
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      IfStatement(node) {
        validateStatement(node.consequent, "if");

        // Check the `else` node, but don't check 'else if' statements.
        if (node.alternate && node.alternate.type !== "IfStatement") {
          validateStatement(node.alternate, "else");
        }
      },
      WhileStatement: node => validateStatement(node.body, "while"),
      DoWhileStatement: node => validateStatement(node.body, "do"),
      ForStatement: node => validateStatement(node.body, "for"),
      ForInStatement: node => validateStatement(node.body, "for"),
      ForOfStatement: node => validateStatement(node.body, "for")
    };
  }
};

/***/ }),
/* 425 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require or disallow line breaks inside braces.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);
const lodash = __webpack_require__(99);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

// Schema objects.
const OPTION_VALUE = {
  oneOf: [{
    enum: ["always", "never"]
  }, {
    type: "object",
    properties: {
      multiline: {
        type: "boolean"
      },
      minProperties: {
        type: "integer",
        minimum: 0
      },
      consistent: {
        type: "boolean"
      }
    },
    additionalProperties: false,
    minProperties: 1
  }]
};

/**
 * Normalizes a given option value.
 *
 * @param {string|Object|undefined} value - An option value to parse.
 * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.
 */
function normalizeOptionValue(value) {
  let multiline = false;
  let minProperties = Number.POSITIVE_INFINITY;
  let consistent = false;
  if (value) {
    if (value === "always") {
      minProperties = 0;
    } else if (value === "never") {
      minProperties = Number.POSITIVE_INFINITY;
    } else {
      multiline = Boolean(value.multiline);
      minProperties = value.minProperties || Number.POSITIVE_INFINITY;
      consistent = Boolean(value.consistent);
    }
  } else {
    consistent = true;
  }
  return {
    multiline,
    minProperties,
    consistent
  };
}

/**
 * Normalizes a given option value.
 *
 * @param {string|Object|undefined} options - An option value to parse.
 * @returns {{
 *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},
 *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},
 *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},
 *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}
 * }} Normalized option object.
 */
function normalizeOptions(options) {
  const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);
  if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) {
    return {
      ObjectExpression: normalizeOptionValue(options.ObjectExpression),
      ObjectPattern: normalizeOptionValue(options.ObjectPattern),
      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
    };
  }
  const value = normalizeOptionValue(options);
  return {
    ObjectExpression: value,
    ObjectPattern: value,
    ImportDeclaration: value,
    ExportNamedDeclaration: value
  };
}

/**
 * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration
 * node needs to be checked for missing line breaks
 *
 * @param {ASTNode} node - Node under inspection
 * @param {Object} options - option specific to node type
 * @param {Token} first - First object property
 * @param {Token} last - Last object property
 * @returns {boolean} `true` if node needs to be checked for missing line breaks
 */
function areLineBreaksRequired(node, options, first, last) {
  let objectProperties;
  if (node.type === "ObjectExpression" || node.type === "ObjectPattern") {
    objectProperties = node.properties;
  } else {
    // is ImportDeclaration or ExportNamedDeclaration
    objectProperties = node.specifiers.filter(s => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
  }
  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks inside braces",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-curly-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [OPTION_VALUE, {
        type: "object",
        properties: {
          ObjectExpression: OPTION_VALUE,
          ObjectPattern: OPTION_VALUE,
          ImportDeclaration: OPTION_VALUE,
          ExportDeclaration: OPTION_VALUE
        },
        additionalProperties: false,
        minProperties: 1
      }]
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const normalizedOptions = normalizeOptions(context.options[0]);

    /**
     * Reports a given node if it violated this rule.
     * @param {ASTNode} node - A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.
     * @returns {void}
     */
    function check(node) {
      const options = normalizedOptions[node.type];
      if (node.type === "ImportDeclaration" && !node.specifiers.some(specifier => specifier.type === "ImportSpecifier") || node.type === "ExportNamedDeclaration" && !node.specifiers.some(specifier => specifier.type === "ExportSpecifier")) {
        return;
      }
      const openBrace = sourceCode.getFirstToken(node, token => token.value === "{");
      let closeBrace;
      if (node.typeAnnotation) {
        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
      } else {
        closeBrace = sourceCode.getLastToken(node, token => token.value === "}");
      }
      let first = sourceCode.getTokenAfter(openBrace, {
        includeComments: true
      });
      let last = sourceCode.getTokenBefore(closeBrace, {
        includeComments: true
      });
      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);
      const hasCommentsFirstToken = astUtils.isCommentToken(first);
      const hasCommentsLastToken = astUtils.isCommentToken(last);

      /*
       * Use tokens or comments to check multiline or not.
       * But use only tokens to check whether line breaks are needed.
       * This allows:
       *     var obj = { // eslint-disable-line foo
       *         a: 1
       *     }
       */
      first = sourceCode.getTokenAfter(openBrace);
      last = sourceCode.getTokenBefore(closeBrace);
      if (needsLineBreaks) {
        if (astUtils.isTokenOnSameLine(openBrace, first)) {
          context.report({
            message: "Expected a line break after this opening brace.",
            node,
            loc: openBrace.loc.start,
            fix(fixer) {
              if (hasCommentsFirstToken) {
                return null;
              }
              return fixer.insertTextAfter(openBrace, "\n");
            }
          });
        }
        if (astUtils.isTokenOnSameLine(last, closeBrace)) {
          context.report({
            message: "Expected a line break before this closing brace.",
            node,
            loc: closeBrace.loc.start,
            fix(fixer) {
              if (hasCommentsLastToken) {
                return null;
              }
              return fixer.insertTextBefore(closeBrace, "\n");
            }
          });
        }
      } else {
        const consistent = options.consistent;
        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);
        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
          context.report({
            message: "Unexpected line break after this opening brace.",
            node,
            loc: openBrace.loc.start,
            fix(fixer) {
              if (hasCommentsFirstToken) {
                return null;
              }
              return fixer.removeRange([openBrace.range[1], first.range[0]]);
            }
          });
        }
        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
          context.report({
            message: "Unexpected line break before this closing brace.",
            node,
            loc: closeBrace.loc.start,
            fix(fixer) {
              if (hasCommentsLastToken) {
                return null;
              }
              return fixer.removeRange([last.range[1], closeBrace.range[0]]);
            }
          });
        }
      }
    }
    return {
      ObjectExpression: check,
      ObjectPattern: check,
      ImportDeclaration: check,
      ExportNamedDeclaration: check
    };
  }
};

/***/ }),
/* 426 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside of object literals.
 * @author Jamund Ferguson
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside braces",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        arraysInObjects: {
          type: "boolean"
        },
        objectsInObjects: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const spaced = context.options[0] === "always",
      sourceCode = context.getSourceCode();

    /**
     * Determines whether an option is set, relative to the spacing option.
     * If spaced is "always", then check whether option is set to false.
     * If spaced is "never", then check whether option is set to true.
     * @param {Object} option - The option to exclude.
     * @returns {boolean} Whether or not the property is excluded.
     */
    function isOptionSet(option) {
      return context.options[1] ? context.options[1][option] === !spaced : false;
    }
    const options = {
      spaced,
      arraysInObjectsException: isOptionSet("arraysInObjects"),
      objectsInObjectsException: isOptionSet("objectsInObjects")
    };

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports that there shouldn't be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        message: "There should be no space after '{{token}}'.",
        data: {
          token: token.value
        },
        fix(fixer) {
          const nextToken = context.getSourceCode().getTokenAfter(token);
          return fixer.removeRange([token.range[1], nextToken.range[0]]);
        }
      });
    }

    /**
     * Reports that there shouldn't be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportNoEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        message: "There should be no space before '{{token}}'.",
        data: {
          token: token.value
        },
        fix(fixer) {
          const previousToken = context.getSourceCode().getTokenBefore(token);
          return fixer.removeRange([previousToken.range[1], token.range[0]]);
        }
      });
    }

    /**
     * Reports that there should be a space after the first token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredBeginningSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        message: "A space is required after '{{token}}'.",
        data: {
          token: token.value
        },
        fix(fixer) {
          return fixer.insertTextAfter(token, " ");
        }
      });
    }

    /**
     * Reports that there should be a space before the last token
     * @param {ASTNode} node - The node to report in the event of an error.
     * @param {Token} token - The token to use for the report.
     * @returns {void}
     */
    function reportRequiredEndingSpace(node, token) {
      context.report({
        node,
        loc: token.loc.start,
        message: "A space is required before '{{token}}'.",
        data: {
          token: token.value
        },
        fix(fixer) {
          return fixer.insertTextBefore(token, " ");
        }
      });
    }

    /**
     * Determines if spacing in curly braces is valid.
     * @param {ASTNode} node The AST node to check.
     * @param {Token} first The first token to check (should be the opening brace)
     * @param {Token} second The second token to check (should be first after the opening brace)
     * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
     * @param {Token} last The last token to check (should be closing brace)
     * @returns {void}
     */
    function validateBraceSpacing(node, first, second, penultimate, last) {
      if (astUtils.isTokenOnSameLine(first, second)) {
        const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
        if (options.spaced && !firstSpaced) {
          reportRequiredBeginningSpace(node, first);
        }
        if (!options.spaced && firstSpaced) {
          reportNoBeginningSpace(node, first);
        }
      }
      if (astUtils.isTokenOnSameLine(penultimate, last)) {
        const shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
        const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
        const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;
        const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
        if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
          reportRequiredEndingSpace(node, last);
        }
        if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
          reportNoEndingSpace(node, last);
        }
      }
    }

    /**
     * Gets '}' token of an object node.
     *
     * Because the last token of object patterns might be a type annotation,
     * this traverses tokens preceded by the last property, then returns the
     * first '}' token.
     *
     * @param {ASTNode} node - The node to get. This node is an
     *      ObjectExpression or an ObjectPattern. And this node has one or
     *      more properties.
     * @returns {Token} '}' token.
     */
    function getClosingBraceOfObject(node) {
      const lastProperty = node.properties[node.properties.length - 1];
      return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
    }

    /**
     * Reports a given object node if spacing in curly braces is invalid.
     * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.
     * @returns {void}
     */
    function checkForObject(node) {
      if (node.properties.length === 0) {
        return;
      }
      const first = sourceCode.getFirstToken(node),
        last = getClosingBraceOfObject(node),
        second = sourceCode.getTokenAfter(first),
        penultimate = sourceCode.getTokenBefore(last);
      validateBraceSpacing(node, first, second, penultimate, last);
    }

    /**
     * Reports a given import node if spacing in curly braces is invalid.
     * @param {ASTNode} node - An ImportDeclaration node to check.
     * @returns {void}
     */
    function checkForImport(node) {
      if (node.specifiers.length === 0) {
        return;
      }
      let firstSpecifier = node.specifiers[0];
      const lastSpecifier = node.specifiers[node.specifiers.length - 1];
      if (lastSpecifier.type !== "ImportSpecifier") {
        return;
      }
      if (firstSpecifier.type !== "ImportSpecifier") {
        firstSpecifier = node.specifiers[1];
      }
      const first = sourceCode.getTokenBefore(firstSpecifier),
        last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
        second = sourceCode.getTokenAfter(first),
        penultimate = sourceCode.getTokenBefore(last);
      validateBraceSpacing(node, first, second, penultimate, last);
    }

    /**
     * Reports a given export node if spacing in curly braces is invalid.
     * @param {ASTNode} node - An ExportNamedDeclaration node to check.
     * @returns {void}
     */
    function checkForExport(node) {
      if (node.specifiers.length === 0) {
        return;
      }
      const firstSpecifier = node.specifiers[0],
        lastSpecifier = node.specifiers[node.specifiers.length - 1],
        first = sourceCode.getTokenBefore(firstSpecifier),
        last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
        second = sourceCode.getTokenAfter(first),
        penultimate = sourceCode.getTokenBefore(last);
      validateBraceSpacing(node, first, second, penultimate, last);
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      // var {x} = y;
      ObjectPattern: checkForObject,
      // var y = {x: 'y'}
      ObjectExpression: checkForObject,
      // import {y} from 'x';
      ImportDeclaration: checkForImport,
      // export {name} from 'yo';
      ExportNamedDeclaration: checkForExport
    };
  }
};

/***/ }),
/* 427 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce placing object properties on separate lines.
 * @author Vitor Balocco
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce placing object properties on separate lines",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-property-newline"
    },
    schema: [{
      type: "object",
      properties: {
        allowAllPropertiesOnSameLine: {
          type: "boolean",
          default: false
        },
        allowMultiplePropertiesPerLine: {
          // Deprecated
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace"
  },
  create(context) {
    const allowSameLine = context.options[0] && (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine /* Deprecated */);
    const errorMessage = allowSameLine ? "Object properties must go on a new line if they aren't all on the same line." : "Object properties must go on a new line.";
    const sourceCode = context.getSourceCode();
    return {
      ObjectExpression(node) {
        if (allowSameLine) {
          if (node.properties.length > 1) {
            const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
            const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
            if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
              // All keys and values are on the same line
              return;
            }
          }
        }
        for (let i = 1; i < node.properties.length; i++) {
          const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
          const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
          if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
            context.report({
              node,
              loc: firstTokenOfCurrentProperty.loc.start,
              message: errorMessage,
              fix(fixer) {
                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];

                // Don't perform a fix if there are any comments between the comma and the next property.
                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
                  return null;
                }
                return fixer.replaceTextRange(rangeAfterComma, "\n");
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 428 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce concise object methods and properties.
 * @author Jamund Ferguson
 */



const OPTIONS = {
  always: "always",
  never: "never",
  methods: "methods",
  properties: "properties",
  consistent: "consistent",
  consistentAsNeeded: "consistent-as-needed"
};

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow method and property shorthand syntax for object literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/object-shorthand"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods", "properties"]
        }, {
          type: "object",
          properties: {
            avoidQuotes: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods"]
        }, {
          type: "object",
          properties: {
            ignoreConstructors: {
              type: "boolean"
            },
            avoidQuotes: {
              type: "boolean"
            },
            avoidExplicitReturnArrows: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    }
  },
  create(context) {
    const APPLY = context.options[0] || OPTIONS.always;
    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
    const APPLY_NEVER = APPLY === OPTIONS.never;
    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
    const PARAMS = context.options[1] || {};
    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
    const AVOID_QUOTES = PARAMS.avoidQuotes;
    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Determines if the first character of the name is a capital letter.
     * @param {string} name The name of the node to evaluate.
     * @returns {boolean} True if the first character of the property name is a capital letter, false if not.
     * @private
     */
    function isConstructor(name) {
      const firstChar = name.charAt(0);
      return firstChar === firstChar.toUpperCase();
    }

    /**
     * Determines if the property can have a shorthand form.
     * @param {ASTNode} property Property AST node
     * @returns {boolean} True if the property can have a shorthand form
     * @private
     *
     */
    function canHaveShorthand(property) {
      return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
    }

    /**
     * Checks whether a node is a string literal.
     * @param   {ASTNode} node - Any AST node.
     * @returns {boolean} `true` if it is a string literal.
     */
    function isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string";
    }

    /**
     * Determines if the property is a shorthand or not.
     * @param {ASTNode} property Property AST node
     * @returns {boolean} True if the property is considered shorthand, false if not.
     * @private
     *
     */
    function isShorthand(property) {
      // property.method is true when `{a(){}}`.
      return property.shorthand || property.method;
    }

    /**
     * Determines if the property's key and method or value are named equally.
     * @param {ASTNode} property Property AST node
     * @returns {boolean} True if the key and value are named equally, false if not.
     * @private
     *
     */
    function isRedundant(property) {
      const value = property.value;
      if (value.type === "FunctionExpression") {
        return !value.id; // Only anonymous should be shorthand method.
      }
      if (value.type === "Identifier") {
        return astUtils.getStaticPropertyName(property) === value.name;
      }
      return false;
    }

    /**
     * Ensures that an object's properties are consistently shorthand, or not shorthand at all.
     * @param   {ASTNode} node Property AST node
     * @param   {boolean} checkRedundancy Whether to check longform redundancy
     * @returns {void}
     *
     */
    function checkConsistency(node, checkRedundancy) {
      // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.
      const properties = node.properties.filter(canHaveShorthand);

      // Do we still have properties left after filtering the getters and setters?
      if (properties.length > 0) {
        const shorthandProperties = properties.filter(isShorthand);

        /*
         * If we do not have an equal number of longform properties as
         * shorthand properties, we are using the annotations inconsistently
         */
        if (shorthandProperties.length !== properties.length) {
          // We have at least 1 shorthand property
          if (shorthandProperties.length > 0) {
            context.report({
              node,
              message: "Unexpected mix of shorthand and non-shorthand properties."
            });
          } else if (checkRedundancy) {
            /*
             * If all properties of the object contain a method or value with a name matching it's key,
             * all the keys are redundant.
             */
            const canAlwaysUseShorthand = properties.every(isRedundant);
            if (canAlwaysUseShorthand) {
              context.report({
                node,
                message: "Expected shorthand for all properties."
              });
            }
          }
        }
      }
    }

    /**
     * Fixes a FunctionExpression node by making it into a shorthand property.
     * @param {SourceCodeFixer} fixer The fixer object
     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value
     * @returns {Object} A fix for this node
     */
    function makeFunctionShorthand(fixer, node) {
      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
      let keyPrefix = "";
      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {
        return null;
      }
      if (node.value.async) {
        keyPrefix += "async ";
      }
      if (node.value.generator) {
        keyPrefix += "*";
      }
      if (node.value.type === "FunctionExpression") {
        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === "Keyword" && token.value === "function");
        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;
        return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));
      }
      const arrowToken = sourceCode.getTokenBefore(node.value.body, {
        filter: token => token.value === "=>"
      });
      const tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);
      const hasParensAroundParameters = tokenBeforeArrow.type === "Punctuator" && tokenBeforeArrow.value === ")";
      const oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);
      const newParamText = hasParensAroundParameters ? oldParamText : `(${oldParamText})`;
      return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1]));
    }

    /**
     * Fixes a FunctionExpression node by making it into a longform property.
     * @param {SourceCodeFixer} fixer The fixer object
     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value
     * @returns {Object} A fix for this node
     */
    function makeFunctionLongform(fixer, node) {
      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === "[") : sourceCode.getFirstToken(node.key);
      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === "]") : sourceCode.getLastToken(node.key);
      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
      let functionHeader = "function";
      if (node.value.async) {
        functionHeader = `async ${functionHeader}`;
      }
      if (node.value.generator) {
        functionHeader = `${functionHeader}*`;
      }
      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);
    }

    /*
     * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),
     * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is
     * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical
     * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,
     * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.
     * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them
     * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,
     * because converting it into a method would change the value of one of the lexical identifiers.
     */
    const lexicalScopeStack = [];
    const arrowsWithLexicalIdentifiers = new WeakSet();
    const argumentsIdentifiers = new WeakSet();

    /**
     * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.
     * Also, this marks all `arguments` identifiers so that they can be detected later.
     * @returns {void}
     */
    function enterFunction() {
      lexicalScopeStack.unshift(new Set());
      context.getScope().variables.filter(variable => variable.name === "arguments").forEach(variable => {
        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));
      });
    }

    /**
     * Exits a function. This pops the current set of arrow functions off the lexical scope stack.
     * @returns {void}
     */
    function exitFunction() {
      lexicalScopeStack.shift();
    }

    /**
     * Marks the current function as having a lexical keyword. This implies that all arrow functions
     * in the current lexical scope contain a reference to this lexical keyword.
     * @returns {void}
     */
    function reportLexicalIdentifier() {
      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: enterFunction,
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      "Program:exit": exitFunction,
      "FunctionDeclaration:exit": exitFunction,
      "FunctionExpression:exit": exitFunction,
      ArrowFunctionExpression(node) {
        lexicalScopeStack[0].add(node);
      },
      "ArrowFunctionExpression:exit"(node) {
        lexicalScopeStack[0].delete(node);
      },
      ThisExpression: reportLexicalIdentifier,
      Super: reportLexicalIdentifier,
      MetaProperty(node) {
        if (node.meta.name === "new" && node.property.name === "target") {
          reportLexicalIdentifier();
        }
      },
      Identifier(node) {
        if (argumentsIdentifiers.has(node)) {
          reportLexicalIdentifier();
        }
      },
      ObjectExpression(node) {
        if (APPLY_CONSISTENT) {
          checkConsistency(node, false);
        } else if (APPLY_CONSISTENT_AS_NEEDED) {
          checkConsistency(node, true);
        }
      },
      "Property:exit"(node) {
        const isConciseProperty = node.method || node.shorthand;

        // Ignore destructuring assignment
        if (node.parent.type === "ObjectPattern") {
          return;
        }

        // getters and setters are ignored
        if (node.kind === "get" || node.kind === "set") {
          return;
        }

        // only computed methods can fail the following checks
        if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
          return;
        }

        //--------------------------------------------------------------
        // Checks for property/method shorthand.
        if (isConciseProperty) {
          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
            const message = APPLY_NEVER ? "Expected longform method syntax." : "Expected longform method syntax for string literal keys.";

            // { x() {} } should be written as { x: function() {} }
            context.report({
              node,
              message,
              fix: fixer => makeFunctionLongform(fixer, node)
            });
          } else if (APPLY_NEVER) {
            // { x } should be written as { x: x }
            context.report({
              node,
              message: "Expected longform property syntax.",
              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)
            });
          }
        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
          if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
            return;
          }
          if (AVOID_QUOTES && isStringLiteral(node.key)) {
            return;
          }

          // {[x]: function(){}} should be written as {[x]() {}}
          if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
            context.report({
              node,
              message: "Expected method shorthand.",
              fix: fixer => makeFunctionShorthand(fixer, node)
            });
          }
        } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
          // {x: x} should be written as {x}
          context.report({
            node,
            message: "Expected property shorthand.",
            fix(fixer) {
              return fixer.replaceText(node, node.value.name);
            }
          });
        } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
          if (AVOID_QUOTES) {
            return;
          }

          // {"x": x} should be written as {x}
          context.report({
            node,
            message: "Expected property shorthand.",
            fix(fixer) {
              return fixer.replaceText(node, node.value.name);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 429 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to control the use of single variable declarations.
 * @author Ian Christian Myers
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce variables to be declared either together or separately in functions",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/one-var"
    },
    fixable: "code",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consecutive"]
      }, {
        type: "object",
        properties: {
          separateRequires: {
            type: "boolean",
            default: false
          },
          var: {
            enum: ["always", "never", "consecutive"]
          },
          let: {
            enum: ["always", "never", "consecutive"]
          },
          const: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          initialized: {
            enum: ["always", "never", "consecutive"]
          },
          uninitialized: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const MODE_ALWAYS = "always";
    const MODE_NEVER = "never";
    const MODE_CONSECUTIVE = "consecutive";
    const mode = context.options[0] || MODE_ALWAYS;
    const options = {};
    if (typeof mode === "string") {
      // simple options configuration with just a string
      options.var = {
        uninitialized: mode,
        initialized: mode
      };
      options.let = {
        uninitialized: mode,
        initialized: mode
      };
      options.const = {
        uninitialized: mode,
        initialized: mode
      };
    } else if (typeof mode === "object") {
      // options configuration is an object
      options.separateRequires = mode.separateRequires;
      options.var = {
        uninitialized: mode.var,
        initialized: mode.var
      };
      options.let = {
        uninitialized: mode.let,
        initialized: mode.let
      };
      options.const = {
        uninitialized: mode.const,
        initialized: mode.const
      };
      if (Object.prototype.hasOwnProperty.call(mode, "uninitialized")) {
        options.var.uninitialized = mode.uninitialized;
        options.let.uninitialized = mode.uninitialized;
        options.const.uninitialized = mode.uninitialized;
      }
      if (Object.prototype.hasOwnProperty.call(mode, "initialized")) {
        options.var.initialized = mode.initialized;
        options.let.initialized = mode.initialized;
        options.const.initialized = mode.initialized;
      }
    }
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    const functionStack = [];
    const blockStack = [];

    /**
     * Increments the blockStack counter.
     * @returns {void}
     * @private
     */
    function startBlock() {
      blockStack.push({
        let: {
          initialized: false,
          uninitialized: false
        },
        const: {
          initialized: false,
          uninitialized: false
        }
      });
    }

    /**
     * Increments the functionStack counter.
     * @returns {void}
     * @private
     */
    function startFunction() {
      functionStack.push({
        initialized: false,
        uninitialized: false
      });
      startBlock();
    }

    /**
     * Decrements the blockStack counter.
     * @returns {void}
     * @private
     */
    function endBlock() {
      blockStack.pop();
    }

    /**
     * Decrements the functionStack counter.
     * @returns {void}
     * @private
     */
    function endFunction() {
      functionStack.pop();
      endBlock();
    }

    /**
     * Check if a variable declaration is a require.
     * @param {ASTNode} decl variable declaration Node
     * @returns {bool} if decl is a require, return true; else return false.
     * @private
     */
    function isRequire(decl) {
      return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
    }

    /**
     * Records whether initialized/uninitialized/required variables are defined in current scope.
     * @param {string} statementType node.kind, one of: "var", "let", or "const"
     * @param {ASTNode[]} declarations List of declarations
     * @param {Object} currentScope The scope being investigated
     * @returns {void}
     * @private
     */
    function recordTypes(statementType, declarations, currentScope) {
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init === null) {
          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
            currentScope.uninitialized = true;
          }
        } else {
          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
            if (options.separateRequires && isRequire(declarations[i])) {
              currentScope.required = true;
            } else {
              currentScope.initialized = true;
            }
          }
        }
      }
    }

    /**
     * Determines the current scope (function or block)
     * @param  {string} statementType node.kind, one of: "var", "let", or "const"
     * @returns {Object} The scope associated with statementType
     */
    function getCurrentScope(statementType) {
      let currentScope;
      if (statementType === "var") {
        currentScope = functionStack[functionStack.length - 1];
      } else if (statementType === "let") {
        currentScope = blockStack[blockStack.length - 1].let;
      } else if (statementType === "const") {
        currentScope = blockStack[blockStack.length - 1].const;
      }
      return currentScope;
    }

    /**
     * Counts the number of initialized and uninitialized declarations in a list of declarations
     * @param {ASTNode[]} declarations List of declarations
     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations
     * @private
     */
    function countDeclarations(declarations) {
      const counts = {
        uninitialized: 0,
        initialized: 0
      };
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init === null) {
          counts.uninitialized++;
        } else {
          counts.initialized++;
        }
      }
      return counts;
    }

    /**
     * Determines if there is more than one var statement in the current scope.
     * @param {string} statementType node.kind, one of: "var", "let", or "const"
     * @param {ASTNode[]} declarations List of declarations
     * @returns {boolean} Returns true if it is the first var declaration, false if not.
     * @private
     */
    function hasOnlyOneStatement(statementType, declarations) {
      const declarationCounts = countDeclarations(declarations);
      const currentOptions = options[statementType] || {};
      const currentScope = getCurrentScope(statementType);
      const hasRequires = declarations.some(isRequire);
      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
        if (currentScope.uninitialized || currentScope.initialized) {
          if (!hasRequires) {
            return false;
          }
        }
      }
      if (declarationCounts.uninitialized > 0) {
        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
          return false;
        }
      }
      if (declarationCounts.initialized > 0) {
        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
          if (!hasRequires) {
            return false;
          }
        }
      }
      if (currentScope.required && hasRequires) {
        return false;
      }
      recordTypes(statementType, declarations, currentScope);
      return true;
    }

    /**
     * Fixer to join VariableDeclaration's into a single declaration
     * @param   {VariableDeclarator[]} declarations The `VariableDeclaration` to join
     * @returns {Function}                         The fixer function
     */
    function joinDeclarations(declarations) {
      const declaration = declarations[0];
      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);
      const previousNode = body[currentIndex - 1];
      return fixer => {
        const type = sourceCode.getTokenBefore(declaration);
        const prevSemi = sourceCode.getTokenBefore(type);
        const res = [];
        if (previousNode && previousNode.kind === sourceCode.getText(type)) {
          if (prevSemi.value === ";") {
            res.push(fixer.replaceText(prevSemi, ","));
          } else {
            res.push(fixer.insertTextAfter(prevSemi, ","));
          }
          res.push(fixer.replaceText(type, ""));
        }
        return res;
      };
    }

    /**
     * Fixer to split a VariableDeclaration into individual declarations
     * @param   {VariableDeclaration}   declaration The `VariableDeclaration` to split
     * @returns {Function}                          The fixer function
     */
    function splitDeclarations(declaration) {
      return fixer => declaration.declarations.map(declarator => {
        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);
        if (tokenAfterDeclarator === null) {
          return null;
        }
        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {
          includeComments: true
        });
        if (tokenAfterDeclarator.value !== ",") {
          return null;
        }

        /*
         * `var x,y`
         * tokenAfterDeclarator ^^ afterComma
         */
        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {
          return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind} `);
        }

        /*
         * `var x,
         * tokenAfterDeclarator ^
         *      y`
         *      ^ afterComma
         */
        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === "Line" || afterComma.type === "Block") {
          let lastComment = afterComma;
          while (lastComment.type === "Line" || lastComment.type === "Block") {
            lastComment = sourceCode.getTokenAfter(lastComment, {
              includeComments: true
            });
          }
          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${declaration.kind} `);
        }
        return fixer.replaceText(tokenAfterDeclarator, `; ${declaration.kind}`);
      }).filter(x => x);
    }

    /**
     * Checks a given VariableDeclaration node for errors.
     * @param {ASTNode} node The VariableDeclaration node to check
     * @returns {void}
     * @private
     */
    function checkVariableDeclaration(node) {
      const parent = node.parent;
      const type = node.kind;
      if (!options[type]) {
        return;
      }
      const declarations = node.declarations;
      const declarationCounts = countDeclarations(declarations);
      const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);
      if (options[type].initialized === MODE_ALWAYS) {
        if (options.separateRequires && mixedRequires) {
          context.report({
            node,
            message: "Split requires to be separated into a single block."
          });
        }
      }

      // consecutive
      const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;
      if (nodeIndex > 0) {
        const previousNode = parent.body[nodeIndex - 1];
        const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
        const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);
        if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {
          const previousDeclCounts = countDeclarations(previousNode.declarations);
          if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {
            context.report({
              node,
              message: "Combine this with the previous '{{type}}' statement.",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {
            context.report({
              node,
              message: "Combine this with the previous '{{type}}' statement with initialized variables.",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {
            context.report({
              node,
              message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          }
        }
      }

      // always
      if (!hasOnlyOneStatement(type, declarations)) {
        if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
          context.report({
            node,
            message: "Combine this with the previous '{{type}}' statement.",
            data: {
              type
            },
            fix: joinDeclarations(declarations)
          });
        } else {
          if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {
            context.report({
              node,
              message: "Combine this with the previous '{{type}}' statement with initialized variables.",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          }
          if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {
            if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
              return;
            }
            context.report({
              node,
              message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          }
        }
      }

      // never
      if (parent.type !== "ForStatement" || parent.init !== node) {
        const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
        if (totalDeclarations > 1) {
          if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
            // both initialized and uninitialized
            context.report({
              node,
              message: "Split '{{type}}' declarations into multiple statements.",
              data: {
                type
              },
              fix: splitDeclarations(node)
            });
          } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
            // initialized
            context.report({
              node,
              message: "Split initialized '{{type}}' declarations into multiple statements.",
              data: {
                type
              },
              fix: splitDeclarations(node)
            });
          } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
            // uninitialized
            context.report({
              node,
              message: "Split uninitialized '{{type}}' declarations into multiple statements.",
              data: {
                type
              },
              fix: splitDeclarations(node)
            });
          }
        }
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      Program: startFunction,
      FunctionDeclaration: startFunction,
      FunctionExpression: startFunction,
      ArrowFunctionExpression: startFunction,
      BlockStatement: startBlock,
      ForStatement: startBlock,
      ForInStatement: startBlock,
      ForOfStatement: startBlock,
      SwitchStatement: startBlock,
      VariableDeclaration: checkVariableDeclaration,
      "ForStatement:exit": endBlock,
      "ForOfStatement:exit": endBlock,
      "ForInStatement:exit": endBlock,
      "SwitchStatement:exit": endBlock,
      "BlockStatement:exit": endBlock,
      "Program:exit": endFunction,
      "FunctionDeclaration:exit": endFunction,
      "FunctionExpression:exit": endFunction,
      "ArrowFunctionExpression:exit": endFunction
    };
  }
};

/***/ }),
/* 430 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check multiple var declarations per line
 * @author Alberto Rodrguez
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow newlines around variable declarations",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/one-var-declaration-per-line"
    },
    schema: [{
      enum: ["always", "initializations"]
    }],
    fixable: "whitespace"
  },
  create(context) {
    const ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
    const always = context.options[0] === "always";

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Determine if provided keyword is a variant of for specifiers
     * @private
     * @param {string} keyword - keyword to test
     * @returns {boolean} True if `keyword` is a variant of for specifier
     */
    function isForTypeSpecifier(keyword) {
      return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    /**
     * Checks newlines around variable declarations.
     * @private
     * @param {ASTNode} node - `VariableDeclaration` node to test
     * @returns {void}
     */
    function checkForNewLine(node) {
      if (isForTypeSpecifier(node.parent.type)) {
        return;
      }
      const declarations = node.declarations;
      let prev;
      declarations.forEach(current => {
        if (prev && prev.loc.end.line === current.loc.start.line) {
          if (always || prev.init || current.init) {
            context.report({
              node,
              message: ERROR_MESSAGE,
              loc: current.loc.start,
              fix: fixer => fixer.insertTextBefore(current, "\n")
            });
          }
        }
        prev = current;
      });
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      VariableDeclaration: checkForNewLine
    };
  }
};

/***/ }),
/* 431 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to replace assignment expressions with operator assignment
 * @author Brandon Mills
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether an operator is commutative and has an operator assignment
 * shorthand form.
 * @param   {string}  operator Operator to check.
 * @returns {boolean}          True if the operator is commutative and has a
 *     shorthand form.
 */
function isCommutativeOperatorWithShorthand(operator) {
  return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}

/**
 * Checks whether an operator is not commuatative and has an operator assignment
 * shorthand form.
 * @param   {string}  operator Operator to check.
 * @returns {boolean}          True if the operator is not commuatative and has
 *     a shorthand form.
 */
function isNonCommutativeOperatorWithShorthand(operator) {
  return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Checks whether two expressions reference the same value. For example:
 *     a = a
 *     a.b = a.b
 *     a[0] = a[0]
 *     a['b'] = a['b']
 * @param   {ASTNode} a Left side of the comparison.
 * @param   {ASTNode} b Right side of the comparison.
 * @returns {boolean}   True if both sides match and reference the same value.
 */
function same(a, b) {
  if (a.type !== b.type) {
    return false;
  }
  switch (a.type) {
    case "Identifier":
      return a.name === b.name;
    case "Literal":
      return a.value === b.value;
    case "MemberExpression":
      /*
       * x[0] = x[0]
       * x[y] = x[y]
       * x.y = x.y
       */
      return same(a.object, b.object) && same(a.property, b.property);
    default:
      return false;
  }
}

/**
 * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)
 * toString calls regardless of whether assignment shorthand is used)
 * @param {ASTNode} node The node on the left side of the expression
 * @returns {boolean} `true` if the node can be fixed
 */
function canBeFixed(node) {
  return node.type === "Identifier" || node.type === "MemberExpression" && node.object.type === "Identifier" && (!node.computed || node.property.type === "Literal");
}
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow assignment operator shorthand where possible",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/operator-assignment"
    },
    schema: [{
      enum: ["always", "never"]
    }],
    fixable: "code",
    messages: {
      replaced: "Assignment can be replaced with operator assignment.",
      unexpected: "Unexpected operator assignment shorthand."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    /**
     * Returns the operator token of an AssignmentExpression or BinaryExpression
     * @param {ASTNode} node An AssignmentExpression or BinaryExpression node
     * @returns {Token} The operator token in the node
     */
    function getOperatorToken(node) {
      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
    }

    /**
     * Ensures that an assignment uses the shorthand form where possible.
     * @param   {ASTNode} node An AssignmentExpression node.
     * @returns {void}
     */
    function verify(node) {
      if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
        return;
      }
      const left = node.left;
      const expr = node.right;
      const operator = expr.operator;
      if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
        if (same(left, expr.left)) {
          context.report({
            node,
            messageId: "replaced",
            fix(fixer) {
              if (canBeFixed(left)) {
                const equalsToken = getOperatorToken(node);
                const operatorToken = getOperatorToken(expr);
                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);
                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);
              }
              return null;
            }
          });
        } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {
          /*
           * This case can't be fixed safely.
           * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would
           * change the execution order of the valueOf() functions.
           */
          context.report({
            node,
            messageId: "replaced"
          });
        }
      }
    }

    /**
     * Warns if an assignment expression uses operator assignment shorthand.
     * @param   {ASTNode} node An AssignmentExpression node.
     * @returns {void}
     */
    function prohibit(node) {
      if (node.operator !== "=") {
        context.report({
          node,
          messageId: "unexpected",
          fix(fixer) {
            if (canBeFixed(node.left)) {
              const operatorToken = getOperatorToken(node);
              const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
              const newOperator = node.operator.slice(0, -1);
              let rightText;

              // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.
              if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({
                type: "BinaryExpression",
                operator: newOperator
              }) && !astUtils.isParenthesised(sourceCode, node.right)) {
                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
              } else {
                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
              }
              return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
            }
            return null;
          }
        });
      }
    }
    return {
      AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
    };
  }
};

/***/ }),
/* 432 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before
 * @author Benot Zugmeyer
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style for operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/operator-linebreak"
    },
    schema: [{
      enum: ["after", "before", "none", null]
    }, {
      type: "object",
      properties: {
        overrides: {
          type: "object",
          properties: {
            anyOf: {
              type: "string",
              enum: ["after", "before", "none", "ignore"]
            }
          }
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create(context) {
    const usedDefaultGlobal = !context.options[0];
    const globalStyle = context.options[0] || "after";
    const options = context.options[1] || {};
    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
    if (usedDefaultGlobal && !styleOverrides["?"]) {
      styleOverrides["?"] = "before";
    }
    if (usedDefaultGlobal && !styleOverrides[":"]) {
      styleOverrides[":"] = "before";
    }
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Gets a fixer function to fix rule issues
     * @param {Token} operatorToken The operator token of an expression
     * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'
     * @returns {Function} A fixer function
     */
    function getFixer(operatorToken, desiredStyle) {
      return fixer => {
        const tokenBefore = sourceCode.getTokenBefore(operatorToken);
        const tokenAfter = sourceCode.getTokenAfter(operatorToken);
        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
        let newTextBefore, newTextAfter;
        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
          // If there is a comment before and after the operator, don't do a fix.
          if (sourceCode.getTokenBefore(operatorToken, {
            includeComments: true
          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {
            includeComments: true
          }) !== tokenAfter) {
            return null;
          }

          /*
           * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.
           * foo &&
           *           bar
           * would get fixed to
           * foo
           *        && bar
           */
          newTextBefore = textAfter;
          newTextAfter = textBefore;
        } else {
          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();

          // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.
          newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
          newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");

          // If there was no change (due to interfering comments), don't output a fix.
          if (newTextBefore === textBefore && newTextAfter === textAfter) {
            return null;
          }
        }
        if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
          // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.
          newTextAfter += " ";
        }
        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
      };
    }

    /**
     * Checks the operator placement
     * @param {ASTNode} node The node to check
     * @param {ASTNode} leftSide The node that comes before the operator in `node`
     * @private
     * @returns {void}
     */
    function validateNode(node, leftSide) {
      /*
       * When the left part of a binary expression is a single expression wrapped in
       * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression
       * and operatorToken will be the closing parenthesis.
       * The leftToken should be the last closing parenthesis, and the operatorToken
       * should be the token right after that.
       */
      const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
      const leftToken = sourceCode.getTokenBefore(operatorToken);
      const rightToken = sourceCode.getTokenAfter(operatorToken);
      const operator = operatorToken.value;
      const operatorStyleOverride = styleOverrides[operator];
      const style = operatorStyleOverride || globalStyle;
      const fix = getFixer(operatorToken, style);

      // if single line
      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

        // do nothing.
      } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
        // lone operator
        context.report({
          node,
          loc: {
            line: operatorToken.loc.end.line,
            column: operatorToken.loc.end.column
          },
          message: "Bad line breaking before and after '{{operator}}'.",
          data: {
            operator
          },
          fix
        });
      } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
        context.report({
          node,
          loc: {
            line: operatorToken.loc.end.line,
            column: operatorToken.loc.end.column
          },
          message: "'{{operator}}' should be placed at the beginning of the line.",
          data: {
            operator
          },
          fix
        });
      } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
        context.report({
          node,
          loc: {
            line: operatorToken.loc.end.line,
            column: operatorToken.loc.end.column
          },
          message: "'{{operator}}' should be placed at the end of the line.",
          data: {
            operator
          },
          fix
        });
      } else if (style === "none") {
        context.report({
          node,
          loc: {
            line: operatorToken.loc.end.line,
            column: operatorToken.loc.end.column
          },
          message: "There should be no line break before or after '{{operator}}'.",
          data: {
            operator
          },
          fix
        });
      }
    }

    /**
     * Validates a binary expression using `validateNode`
     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated
     * @returns {void}
     */
    function validateBinaryExpression(node) {
      validateNode(node, node.left);
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      BinaryExpression: validateBinaryExpression,
      LogicalExpression: validateBinaryExpression,
      AssignmentExpression: validateBinaryExpression,
      VariableDeclarator(node) {
        if (node.init) {
          validateNode(node, node.id);
        }
      },
      ConditionalExpression(node) {
        validateNode(node, node.test);
        validateNode(node, node.consequent);
      }
    };
  }
};

/***/ }),
/* 433 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to ensure blank lines within blocks.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding within blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/padded-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          blocks: {
            enum: ["always", "never"]
          },
          switches: {
            enum: ["always", "never"]
          },
          classes: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: false,
        minProperties: 1
      }]
    }, {
      type: "object",
      properties: {
        allowSingleLineBlocks: {
          type: "boolean"
        }
      }
    }]
  },
  create(context) {
    const options = {};
    const typeOptions = context.options[0] || "always";
    const exceptOptions = context.options[1] || {};
    if (typeof typeOptions === "string") {
      const shouldHavePadding = typeOptions === "always";
      options.blocks = shouldHavePadding;
      options.switches = shouldHavePadding;
      options.classes = shouldHavePadding;
    } else {
      if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) {
        options.blocks = typeOptions.blocks === "always";
      }
      if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) {
        options.switches = typeOptions.switches === "always";
      }
      if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) {
        options.classes = typeOptions.classes === "always";
      }
    }
    if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) {
      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
    }
    const ALWAYS_MESSAGE = "Block must be padded by blank lines.",
      NEVER_MESSAGE = "Block must not be padded by blank lines.";
    const sourceCode = context.getSourceCode();

    /**
     * Gets the open brace token from a given node.
     * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.
     * @returns {Token} The token of the open brace.
     */
    function getOpenBrace(node) {
      if (node.type === "SwitchStatement") {
        return sourceCode.getTokenBefore(node.cases[0]);
      }
      return sourceCode.getFirstToken(node);
    }

    /**
     * Checks if the given parameter is a comment node
     * @param {ASTNode|Token} node An AST node or token
     * @returns {boolean} True if node is a comment
     */
    function isComment(node) {
      return node.type === "Line" || node.type === "Block";
    }

    /**
     * Checks if there is padding between two tokens
     * @param {Token} first The first token
     * @param {Token} second The second token
     * @returns {boolean} True if there is at least a line between the tokens
     */
    function isPaddingBetweenTokens(first, second) {
      return second.loc.start.line - first.loc.end.line >= 2;
    }

    /**
     * Checks if the given token has a blank line after it.
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the token is followed by a blank line.
     */
    function getFirstBlockToken(token) {
      let prev,
        first = token;
      do {
        prev = first;
        first = sourceCode.getTokenAfter(first, {
          includeComments: true
        });
      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);
      return first;
    }

    /**
     * Checks if the given token is preceeded by a blank line.
     * @param {Token} token The token to check
     * @returns {boolean} Whether or not the token is preceeded by a blank line
     */
    function getLastBlockToken(token) {
      let last = token,
        next;
      do {
        next = last;
        last = sourceCode.getTokenBefore(last, {
          includeComments: true
        });
      } while (isComment(last) && last.loc.end.line === next.loc.start.line);
      return last;
    }

    /**
     * Checks if a node should be padded, according to the rule config.
     * @param {ASTNode} node The AST node to check.
     * @returns {boolean} True if the node should be padded, false otherwise.
     */
    function requirePaddingFor(node) {
      switch (node.type) {
        case "BlockStatement":
          return options.blocks;
        case "SwitchStatement":
          return options.switches;
        case "ClassBody":
          return options.classes;

        /* istanbul ignore next */
        default:
          throw new Error("unreachable");
      }
    }

    /**
     * Checks the given BlockStatement node to be padded if the block is not empty.
     * @param {ASTNode} node The AST node of a BlockStatement.
     * @returns {void} undefined.
     */
    function checkPadding(node) {
      const openBrace = getOpenBrace(node),
        firstBlockToken = getFirstBlockToken(openBrace),
        tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {
          includeComments: true
        }),
        closeBrace = sourceCode.getLastToken(node),
        lastBlockToken = getLastBlockToken(closeBrace),
        tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {
          includeComments: true
        }),
        blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
        blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);
      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
        return;
      }
      if (requirePaddingFor(node)) {
        if (!blockHasTopPadding) {
          context.report({
            node,
            loc: {
              line: tokenBeforeFirst.loc.start.line,
              column: tokenBeforeFirst.loc.start.column
            },
            fix(fixer) {
              return fixer.insertTextAfter(tokenBeforeFirst, "\n");
            },
            message: ALWAYS_MESSAGE
          });
        }
        if (!blockHasBottomPadding) {
          context.report({
            node,
            loc: {
              line: tokenAfterLast.loc.end.line,
              column: tokenAfterLast.loc.end.column - 1
            },
            fix(fixer) {
              return fixer.insertTextBefore(tokenAfterLast, "\n");
            },
            message: ALWAYS_MESSAGE
          });
        }
      } else {
        if (blockHasTopPadding) {
          context.report({
            node,
            loc: {
              line: tokenBeforeFirst.loc.start.line,
              column: tokenBeforeFirst.loc.start.column
            },
            fix(fixer) {
              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
            },
            message: NEVER_MESSAGE
          });
        }
        if (blockHasBottomPadding) {
          context.report({
            node,
            loc: {
              line: tokenAfterLast.loc.end.line,
              column: tokenAfterLast.loc.end.column - 1
            },
            message: NEVER_MESSAGE,
            fix(fixer) {
              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
            }
          });
        }
      }
    }
    const rule = {};
    if (Object.prototype.hasOwnProperty.call(options, "switches")) {
      rule.SwitchStatement = function (node) {
        if (node.cases.length === 0) {
          return;
        }
        checkPadding(node);
      };
    }
    if (Object.prototype.hasOwnProperty.call(options, "blocks")) {
      rule.BlockStatement = function (node) {
        if (node.body.length === 0) {
          return;
        }
        checkPadding(node);
      };
    }
    if (Object.prototype.hasOwnProperty.call(options, "classes")) {
      rule.ClassBody = function (node) {
        if (node.body.length === 0) {
          return;
        }
        checkPadding(node);
      };
    }
    return rule;
  }
};

/***/ }),
/* 434 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require or disallow newlines between statements
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const LT = `[${Array.from(astUtils.LINEBREAKS).join("")}]`;
const PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`, "u");
const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
const CJS_IMPORT = /^require\(/u;

/**
 * Creates tester which check if a node starts with specific keyword.
 *
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword
  };
}

/**
 * Creates tester which check if a node starts with specific keyword and spans a single line.
 *
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newSinglelineKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
  };
}

/**
 * Creates tester which check if a node starts with specific keyword and spans multiple lines.
 *
 * @param {string} keyword The keyword to test.
 * @returns {Object} the created tester.
 * @private
 */
function newMultilineKeywordTester(keyword) {
  return {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
  };
}

/**
 * Creates tester which check if a node is specific type.
 *
 * @param {string} type The node type to test.
 * @returns {Object} the created tester.
 * @private
 */
function newNodeTypeTester(type) {
  return {
    test: node => node.type === type
  };
}

/**
 * Checks the given node is an expression statement of IIFE.
 *
 * @param {ASTNode} node The node to check.
 * @returns {boolean} `true` if the node is an expression statement of IIFE.
 * @private
 */
function isIIFEStatement(node) {
  if (node.type === "ExpressionStatement") {
    let call = node.expression;
    if (call.type === "UnaryExpression") {
      call = call.argument;
    }
    return call.type === "CallExpression" && astUtils.isFunction(call.callee);
  }
  return false;
}

/**
 * Checks whether the given node is a block-like statement.
 * This checks the last token of the node is the closing brace of a block.
 *
 * @param {SourceCode} sourceCode The source code to get tokens.
 * @param {ASTNode} node The node to check.
 * @returns {boolean} `true` if the node is a block-like statement.
 * @private
 */
function isBlockLikeStatement(sourceCode, node) {
  // do-while with a block is a block-like statement.
  if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
    return true;
  }

  /*
   * IIFE is a block-like statement specially from
   * JSCS#disallowPaddingNewLinesAfterBlocks.
   */
  if (isIIFEStatement(node)) {
    return true;
  }

  // Checks the last token is a closing brace of blocks.
  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;
  return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
}

/**
 * Check whether the given node is a directive or not.
 * @param {ASTNode} node The node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is a directive.
 */
function isDirective(node, sourceCode) {
  return node.type === "ExpressionStatement" && (node.parent.type === "Program" || node.parent.type === "BlockStatement" && astUtils.isFunction(node.parent.parent)) && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
}

/**
 * Check whether the given node is a part of directive prologue or not.
 * @param {ASTNode} node The node to check.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {boolean} `true` if the node is a part of directive prologue.
 */
function isDirectivePrologue(node, sourceCode) {
  if (isDirective(node, sourceCode)) {
    for (const sibling of node.parent.body) {
      if (sibling === node) {
        break;
      }
      if (!isDirective(sibling, sourceCode)) {
        return false;
      }
    }
    return true;
  }
  return false;
}

/**
 * Gets the actual last token.
 *
 * If a semicolon is semicolon-less style's semicolon, this ignores it.
 * For example:
 *
 *     foo()
 *     ;[1, 2, 3].forEach(bar)
 *
 * @param {SourceCode} sourceCode The source code to get tokens.
 * @param {ASTNode} node The node to get.
 * @returns {Token} The actual last token.
 * @private
 */
function getActualLastToken(sourceCode, node) {
  const semiToken = sourceCode.getLastToken(node);
  const prevToken = sourceCode.getTokenBefore(semiToken);
  const nextToken = sourceCode.getTokenAfter(semiToken);
  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);
  return isSemicolonLessStyle ? prevToken : semiToken;
}

/**
 * This returns the concatenation of the first 2 captured strings.
 * @param {string} _ Unused. Whole matched string.
 * @param {string} trailingSpaces The trailing spaces of the first line.
 * @param {string} indentSpaces The indentation spaces of the last line.
 * @returns {string} The concatenation of trailingSpaces and indentSpaces.
 * @private
 */
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
  return trailingSpaces + indentSpaces;
}

/**
 * Check and report statements for `any` configuration.
 * It does nothing.
 *
 * @returns {void}
 * @private
 */
function verifyForAny() {}

/**
 * Check and report statements for `never` configuration.
 * This autofix removes blank lines between the given 2 statements.
 * However, if comments exist between 2 blank lines, it does not remove those
 * blank lines automatically.
 *
 * @param {RuleContext} context The rule context to report.
 * @param {ASTNode} _ Unused. The previous node to check.
 * @param {ASTNode} nextNode The next node to check.
 * @param {Array<Token[]>} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForNever(context, _, nextNode, paddingLines) {
  if (paddingLines.length === 0) {
    return;
  }
  context.report({
    node: nextNode,
    message: "Unexpected blank line before this statement.",
    fix(fixer) {
      if (paddingLines.length >= 2) {
        return null;
      }
      const prevToken = paddingLines[0][0];
      const nextToken = paddingLines[0][1];
      const start = prevToken.range[1];
      const end = nextToken.range[0];
      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
      return fixer.replaceTextRange([start, end], text);
    }
  });
}

/**
 * Check and report statements for `always` configuration.
 * This autofix inserts a blank line between the given 2 statements.
 * If the `prevNode` has trailing comments, it inserts a blank line after the
 * trailing comments.
 *
 * @param {RuleContext} context The rule context to report.
 * @param {ASTNode} prevNode The previous node to check.
 * @param {ASTNode} nextNode The next node to check.
 * @param {Array<Token[]>} paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns {void}
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
  if (paddingLines.length > 0) {
    return;
  }
  context.report({
    node: nextNode,
    message: "Expected blank line before this statement.",
    fix(fixer) {
      const sourceCode = context.getSourceCode();
      let prevToken = getActualLastToken(sourceCode, prevNode);
      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
        includeComments: true,
        /**
         * Skip the trailing comments of the previous node.
         * This inserts a blank line after the last trailing comment.
         *
         * For example:
         *
         *     foo(); // trailing comment.
         *     // comment.
         *     bar();
         *
         * Get fixed to:
         *
         *     foo(); // trailing comment.
         *
         *     // comment.
         *     bar();
         *
         * @param {Token} token The token to check.
         * @returns {boolean} `true` if the token is not a trailing comment.
         * @private
         */
        filter(token) {
          if (astUtils.isTokenOnSameLine(prevToken, token)) {
            prevToken = token;
            return false;
          }
          return true;
        }
      }) || nextNode;
      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";
      return fixer.insertTextAfter(prevToken, insertText);
    }
  });
}

/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = {
  any: {
    verify: verifyForAny
  },
  never: {
    verify: verifyForNever
  },
  always: {
    verify: verifyForAlways
  }
};

/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = {
  "*": {
    test: () => true
  },
  "block-like": {
    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
  },
  "cjs-export": {
    test: (node, sourceCode) => node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))
  },
  "cjs-import": {
    test: (node, sourceCode) => node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
  },
  directive: {
    test: isDirectivePrologue
  },
  expression: {
    test: (node, sourceCode) => node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
  },
  iife: {
    test: isIIFEStatement
  },
  "multiline-block-like": {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)
  },
  "multiline-expression": {
    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
  },
  "multiline-const": newMultilineKeywordTester("const"),
  "multiline-let": newMultilineKeywordTester("let"),
  "multiline-var": newMultilineKeywordTester("var"),
  "singleline-const": newSinglelineKeywordTester("const"),
  "singleline-let": newSinglelineKeywordTester("let"),
  "singleline-var": newSinglelineKeywordTester("var"),
  block: newNodeTypeTester("BlockStatement"),
  empty: newNodeTypeTester("EmptyStatement"),
  function: newNodeTypeTester("FunctionDeclaration"),
  break: newKeywordTester("break"),
  case: newKeywordTester("case"),
  class: newKeywordTester("class"),
  const: newKeywordTester("const"),
  continue: newKeywordTester("continue"),
  debugger: newKeywordTester("debugger"),
  default: newKeywordTester("default"),
  do: newKeywordTester("do"),
  export: newKeywordTester("export"),
  for: newKeywordTester("for"),
  if: newKeywordTester("if"),
  import: newKeywordTester("import"),
  let: newKeywordTester("let"),
  return: newKeywordTester("return"),
  switch: newKeywordTester("switch"),
  throw: newKeywordTester("throw"),
  try: newKeywordTester("try"),
  var: newKeywordTester("var"),
  while: newKeywordTester("while"),
  with: newKeywordTester("with")
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding lines between statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/padding-line-between-statements"
    },
    fixable: "whitespace",
    schema: {
      definitions: {
        paddingType: {
          enum: Object.keys(PaddingTypes)
        },
        statementType: {
          anyOf: [{
            enum: Object.keys(StatementTypes)
          }, {
            type: "array",
            items: {
              enum: Object.keys(StatementTypes)
            },
            minItems: 1,
            uniqueItems: true,
            additionalItems: false
          }]
        }
      },
      type: "array",
      items: {
        type: "object",
        properties: {
          blankLine: {
            $ref: "#/definitions/paddingType"
          },
          prev: {
            $ref: "#/definitions/statementType"
          },
          next: {
            $ref: "#/definitions/statementType"
          }
        },
        additionalProperties: false,
        required: ["blankLine", "prev", "next"]
      },
      additionalItems: false
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const configureList = context.options || [];
    let scopeInfo = null;

    /**
     * Processes to enter to new scope.
     * This manages the current previous statement.
     * @returns {void}
     * @private
     */
    function enterScope() {
      scopeInfo = {
        upper: scopeInfo,
        prevNode: null
      };
    }

    /**
     * Processes to exit from the current scope.
     * @returns {void}
     * @private
     */
    function exitScope() {
      scopeInfo = scopeInfo.upper;
    }

    /**
     * Checks whether the given node matches the given type.
     *
     * @param {ASTNode} node The statement node to check.
     * @param {string|string[]} type The statement type to check.
     * @returns {boolean} `true` if the statement node matched the type.
     * @private
     */
    function match(node, type) {
      let innerStatementNode = node;
      while (innerStatementNode.type === "LabeledStatement") {
        innerStatementNode = innerStatementNode.body;
      }
      if (Array.isArray(type)) {
        return type.some(match.bind(null, innerStatementNode));
      }
      return StatementTypes[type].test(innerStatementNode, sourceCode);
    }

    /**
     * Finds the last matched configure from configureList.
     *
     * @param {ASTNode} prevNode The previous statement to match.
     * @param {ASTNode} nextNode The current statement to match.
     * @returns {Object} The tester of the last matched configure.
     * @private
     */
    function getPaddingType(prevNode, nextNode) {
      for (let i = configureList.length - 1; i >= 0; --i) {
        const configure = configureList[i];
        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);
        if (matched) {
          return PaddingTypes[configure.blankLine];
        }
      }
      return PaddingTypes.any;
    }

    /**
     * Gets padding line sequences between the given 2 statements.
     * Comments are separators of the padding line sequences.
     *
     * @param {ASTNode} prevNode The previous statement to count.
     * @param {ASTNode} nextNode The current statement to count.
     * @returns {Array<Token[]>} The array of token pairs.
     * @private
     */
    function getPaddingLineSequences(prevNode, nextNode) {
      const pairs = [];
      let prevToken = getActualLastToken(sourceCode, prevNode);
      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
        do {
          const token = sourceCode.getTokenAfter(prevToken, {
            includeComments: true
          });
          if (token.loc.start.line - prevToken.loc.end.line >= 2) {
            pairs.push([prevToken, token]);
          }
          prevToken = token;
        } while (prevToken.range[0] < nextNode.range[0]);
      }
      return pairs;
    }

    /**
     * Verify padding lines between the given node and the previous node.
     *
     * @param {ASTNode} node The node to verify.
     * @returns {void}
     * @private
     */
    function verify(node) {
      const parentType = node.parent.type;
      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";
      if (!validParent) {
        return;
      }

      // Save this node as the current previous statement.
      const prevNode = scopeInfo.prevNode;

      // Verify.
      if (prevNode) {
        const type = getPaddingType(prevNode, node);
        const paddingLines = getPaddingLineSequences(prevNode, node);
        type.verify(context, prevNode, node, paddingLines);
      }
      scopeInfo.prevNode = node;
    }

    /**
     * Verify padding lines between the given node and the previous node.
     * Then process to enter to new scope.
     *
     * @param {ASTNode} node The node to verify.
     * @returns {void}
     * @private
     */
    function verifyThenEnterScope(node) {
      verify(node);
      enterScope();
    }
    return {
      Program: enterScope,
      BlockStatement: enterScope,
      SwitchStatement: enterScope,
      "Program:exit": exitScope,
      "BlockStatement:exit": exitScope,
      "SwitchStatement:exit": exitScope,
      ":statement": verify,
      SwitchCase: verifyThenEnterScope,
      "SwitchCase:exit": exitScope
    };
  }
};

/***/ }),
/* 435 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview A rule to suggest using arrow functions as callbacks.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable is a function name.
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is a function name.
 */
function isFunctionName(variable) {
  return variable && variable.defs[0].type === "FunctionName";
}

/**
 * Checks whether or not a given MetaProperty node equals to a given value.
 * @param {ASTNode} node - A MetaProperty node to check.
 * @param {string} metaName - The name of `MetaProperty.meta`.
 * @param {string} propertyName - The name of `MetaProperty.property`.
 * @returns {boolean} `true` if the node is the specific value.
 */
function checkMetaProperty(node, metaName, propertyName) {
  return node.meta.name === metaName && node.property.name === propertyName;
}

/**
 * Gets the variable object of `arguments` which is defined implicitly.
 * @param {eslint-scope.Scope} scope - A scope to get.
 * @returns {eslint-scope.Variable} The found variable object.
 */
function getVariableOfArguments(scope) {
  const variables = scope.variables;
  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];
    if (variable.name === "arguments") {
      /*
       * If there was a parameter which is named "arguments", the
       * implicit "arguments" is not defined.
       * So does fast return with null.
       */
      return variable.identifiers.length === 0 ? variable : null;
    }
  }

  /* istanbul ignore next */
  return null;
}

/**
 * Checkes whether or not a given node is a callback.
 * @param {ASTNode} node - A node to check.
 * @returns {Object}
 *   {boolean} retv.isCallback - `true` if the node is a callback.
 *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.
 */
function getCallbackInfo(node) {
  const retv = {
    isCallback: false,
    isLexicalThis: false
  };
  let currentNode = node;
  let parent = node.parent;
  while (currentNode) {
    switch (parent.type) {
      // Checks parents recursively.

      case "LogicalExpression":
      case "ConditionalExpression":
        break;

      // Checks whether the parent node is `.bind(this)` call.
      case "MemberExpression":
        if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind" && parent.parent.type === "CallExpression" && parent.parent.callee === parent) {
          retv.isLexicalThis = parent.parent.arguments.length === 1 && parent.parent.arguments[0].type === "ThisExpression";
          parent = parent.parent;
        } else {
          return retv;
        }
        break;

      // Checks whether the node is a callback.
      case "CallExpression":
      case "NewExpression":
        if (parent.callee !== currentNode) {
          retv.isCallback = true;
        }
        return retv;
      default:
        return retv;
    }
    currentNode = parent;
    parent = parent.parent;
  }

  /* istanbul ignore next */
  throw new Error("unreachable");
}

/**
 * Checks whether a simple list of parameters contains any duplicates. This does not handle complex
 * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate
 * parameter names anyway. Instead, it always returns `false` for complex parameter lists.
 * @param {ASTNode[]} paramsList The list of parameters for a function
 * @returns {boolean} `true` if the list of parameters contains any duplicates
 */
function hasDuplicateParams(paramsList) {
  return paramsList.every(param => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using arrow functions for callbacks",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-arrow-callback"
    },
    schema: [{
      type: "object",
      properties: {
        allowNamedFunctions: {
          type: "boolean",
          default: false
        },
        allowUnboundThis: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create(context) {
    const options = context.options[0] || {};
    const allowUnboundThis = options.allowUnboundThis !== false; // default to true
    const allowNamedFunctions = options.allowNamedFunctions;
    const sourceCode = context.getSourceCode();

    /*
     * {Array<{this: boolean, super: boolean, meta: boolean}>}
     * - this - A flag which shows there are one or more ThisExpression.
     * - super - A flag which shows there are one or more Super.
     * - meta - A flag which shows there are one or more MethProperty.
     */
    let stack = [];

    /**
     * Pushes new function scope with all `false` flags.
     * @returns {void}
     */
    function enterScope() {
      stack.push({
        this: false,
        super: false,
        meta: false
      });
    }

    /**
     * Pops a function scope from the stack.
     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.
     */
    function exitScope() {
      return stack.pop();
    }
    return {
      // Reset internal state.
      Program() {
        stack = [];
      },
      // If there are below, it cannot replace with arrow functions merely.
      ThisExpression() {
        const info = stack[stack.length - 1];
        if (info) {
          info.this = true;
        }
      },
      Super() {
        const info = stack[stack.length - 1];
        if (info) {
          info.super = true;
        }
      },
      MetaProperty(node) {
        const info = stack[stack.length - 1];
        if (info && checkMetaProperty(node, "new", "target")) {
          info.meta = true;
        }
      },
      // To skip nested scopes.
      FunctionDeclaration: enterScope,
      "FunctionDeclaration:exit": exitScope,
      // Main.
      FunctionExpression: enterScope,
      "FunctionExpression:exit"(node) {
        const scopeInfo = exitScope();

        // Skip named function expressions
        if (allowNamedFunctions && node.id && node.id.name) {
          return;
        }

        // Skip generators.
        if (node.generator) {
          return;
        }

        // Skip recursive functions.
        const nameVar = context.getDeclaredVariables(node)[0];
        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        }

        // Skip if it's using arguments.
        const variable = getVariableOfArguments(context.getScope());
        if (variable && variable.references.length > 0) {
          return;
        }

        // Reports if it's a callback which can replace with arrows.
        const callbackInfo = getCallbackInfo(node);
        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
          context.report({
            node,
            message: "Unexpected function expression.",
            fix(fixer) {
              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
                /*
                 * If the callback function does not have .bind(this) and contains a reference to `this`, there
                 * is no way to determine what `this` should be, so don't perform any fixes.
                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),
                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.
                 */
                return null;
              }
              const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
              const paramsRightParen = sourceCode.getTokenBefore(node.body);
              const asyncKeyword = node.async ? "async " : "";
              const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
              const arrowFunctionText = `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`;

              /*
               * If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
               * Otherwise, just replace the arrow function itself.
               */
              const replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;

              /*
               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then
               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even
               * though `foo || function() {}` is valid.
               */
              const needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
              const replacementText = needsParens ? `(${arrowFunctionText})` : arrowFunctionText;
              return fixer.replaceText(replacedNode, replacementText);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 436 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;
const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;

/**
 * Checks whether a given node is located at `ForStatement.init` or not.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is located at `ForStatement.init`.
 */
function isInitOfForStatement(node) {
  return node.parent.type === "ForStatement" && node.parent.init === node;
}

/**
 * Checks whether a given Identifier node becomes a VariableDeclaration or not.
 *
 * @param {ASTNode} identifier - An Identifier node to check.
 * @returns {boolean} `true` if the node can become a VariableDeclaration.
 */
function canBecomeVariableDeclaration(identifier) {
  let node = identifier.parent;
  while (PATTERN_TYPE.test(node.type)) {
    node = node.parent;
  }
  return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
}

/**
 * Checks if an property or element is from outer scope or function parameters
 * in destructing pattern.
 *
 * @param {string} name - A variable name to be checked.
 * @param {eslint-scope.Scope} initScope - A scope to start find.
 * @returns {boolean} Indicates if the variable is from outer scope or function parameters.
 */
function isOuterVariableInDestructing(name, initScope) {
  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {
    return true;
  }
  const variable = astUtils.getVariableByName(initScope, name);
  if (variable !== null) {
    return variable.defs.some(def => def.type === "Parameter");
  }
  return false;
}

/**
 * Gets the VariableDeclarator/AssignmentExpression node that a given reference
 * belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 *
 * @param {eslint-scope.Reference} reference - A reference to get.
 * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or
 *      null.
 */
function getDestructuringHost(reference) {
  if (!reference.isWrite()) {
    return null;
  }
  let node = reference.identifier.parent;
  while (PATTERN_TYPE.test(node.type)) {
    node = node.parent;
  }
  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
    return null;
  }
  return node;
}

/**
 * Determines if a destructuring assignment node contains
 * any MemberExpression nodes. This is used to determine if a
 * variable that is only written once using destructuring can be
 * safely converted into a const declaration.
 * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.
 * @returns {boolean} True if the destructuring pattern contains
 *      a MemberExpression, false if not.
 */
function hasMemberExpressionAssignment(node) {
  switch (node.type) {
    case "ObjectPattern":
      return node.properties.some(prop => {
        if (prop) {
          /*
           * Spread elements have an argument property while
           * others have a value property. Because different
           * parsers use different node types for spread elements,
           * we just check if there is an argument property.
           */
          return hasMemberExpressionAssignment(prop.argument || prop.value);
        }
        return false;
      });
    case "ArrayPattern":
      return node.elements.some(element => {
        if (element) {
          return hasMemberExpressionAssignment(element);
        }
        return false;
      });
    case "AssignmentPattern":
      return hasMemberExpressionAssignment(node.left);
    case "MemberExpression":
      return true;

    // no default
  }
  return false;
}

/**
 * Gets an identifier node of a given variable.
 *
 * If the initialization exists or one or more reading references exist before
 * the first assignment, the identifier node is the node of the declaration.
 * Otherwise, the identifier node is the node of the first assignment.
 *
 * If the variable should not change to const, this function returns null.
 * - If the variable is reassigned.
 * - If the variable is never initialized nor assigned.
 * - If the variable is initialized in a different scope from the declaration.
 * - If the unique assignment of the variable cannot change to a declaration.
 *   e.g. `if (a) b = 1` / `return (b = 1)`
 * - If the variable is declared in the global scope and `eslintUsed` is `true`.
 *   `/*exported foo` directive comment makes such variables. This rule does not
 *   warn such variables because this rule cannot distinguish whether the
 *   exported variables are reassigned or not.
 *
 * @param {eslint-scope.Variable} variable - A variable to get.
 * @param {boolean} ignoreReadBeforeAssign -
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns {ASTNode|null}
 *      An Identifier node if the variable should change to const.
 *      Otherwise, null.
 */
function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
  if (variable.eslintUsed && variable.scope.type === "global") {
    return null;
  }

  // Finds the unique WriteReference.
  let writer = null;
  let isReadBeforeInit = false;
  const references = variable.references;
  for (let i = 0; i < references.length; ++i) {
    const reference = references[i];
    if (reference.isWrite()) {
      const isReassigned = writer !== null && writer.identifier !== reference.identifier;
      if (isReassigned) {
        return null;
      }
      const destructuringHost = getDestructuringHost(reference);
      if (destructuringHost !== null && destructuringHost.left !== void 0) {
        const leftNode = destructuringHost.left;
        let hasOuterVariables = false,
          hasNonIdentifiers = false;
        if (leftNode.type === "ObjectPattern") {
          const properties = leftNode.properties;
          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));
          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
        } else if (leftNode.type === "ArrayPattern") {
          const elements = leftNode.elements;
          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));
          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
        }
        if (hasOuterVariables || hasNonIdentifiers) {
          return null;
        }
      }
      writer = reference;
    } else if (reference.isRead() && writer === null) {
      if (ignoreReadBeforeAssign) {
        return null;
      }
      isReadBeforeInit = true;
    }
  }

  /*
   * If the assignment is from a different scope, ignore it.
   * If the assignment cannot change to a declaration, ignore it.
   */
  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);
  if (!shouldBeConst) {
    return null;
  }
  if (isReadBeforeInit) {
    return variable.defs[0].name;
  }
  return writer.identifier;
}

/**
 * Groups by the VariableDeclarator/AssignmentExpression node that each
 * reference of given variables belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 *
 * @param {eslint-scope.Variable[]} variables - Variables to group by destructuring.
 * @param {boolean} ignoreReadBeforeAssign -
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.
 */
function groupByDestructuring(variables, ignoreReadBeforeAssign) {
  const identifierMap = new Map();
  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];
    const references = variable.references;
    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
    let prevId = null;
    for (let j = 0; j < references.length; ++j) {
      const reference = references[j];
      const id = reference.identifier;

      /*
       * Avoid counting a reference twice or more for default values of
       * destructuring.
       */
      if (id === prevId) {
        continue;
      }
      prevId = id;

      // Add the identifier node into the destructuring group.
      const group = getDestructuringHost(reference);
      if (group) {
        if (identifierMap.has(group)) {
          identifierMap.get(group).push(identifier);
        } else {
          identifierMap.set(group, [identifier]);
        }
      }
    }
  }
  return identifierMap;
}

/**
 * Finds the nearest parent of node with a given type.
 *
 * @param {ASTNode} node  The node to search from.
 * @param {string} type  The type field of the parent node.
 * @param {Function} shouldStop  a predicate that returns true if the traversal should stop, and false otherwise.
 * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.
 */
function findUp(node, type, shouldStop) {
  if (!node || shouldStop(node)) {
    return null;
  }
  if (node.type === type) {
    return node;
  }
  return findUp(node.parent, type, shouldStop);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `const` declarations for variables that are never reassigned after declared",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-const"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        destructuring: {
          enum: ["any", "all"],
          default: "any"
        },
        ignoreReadBeforeAssign: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      useConst: "'{{name}}' is never reassigned. Use 'const' instead."
    }
  },
  create(context) {
    const options = context.options[0] || {};
    const sourceCode = context.getSourceCode();
    const shouldMatchAnyDestructuredVariable = options.destructuring !== "all";
    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
    const variables = [];
    let reportCount = 0;
    let name = "";

    /**
     * Reports given identifier nodes if all of the nodes should be declared
     * as const.
     *
     * The argument 'nodes' is an array of Identifier nodes.
     * This node is the result of 'getIdentifierIfShouldBeConst()', so it's
     * nullable. In simple declaration or assignment cases, the length of
     * the array is 1. In destructuring cases, the length of the array can
     * be 2 or more.
     *
     * @param {(eslint-scope.Reference|null)[]} nodes -
     *      References which are grouped by destructuring to report.
     * @returns {void}
     */
    function checkGroup(nodes) {
      const nodesToReport = nodes.filter(Boolean);
      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {
        const varDeclParent = findUp(nodes[0], "VariableDeclaration", parentNode => parentNode.type.endsWith("Statement"));
        const isVarDecParentNull = varDeclParent === null;
        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {
          const firstDeclaration = varDeclParent.declarations[0];
          if (firstDeclaration.init) {
            const firstDecParent = firstDeclaration.init.parent;

            /*
             * First we check the declaration type and then depending on
             * if the type is a "VariableDeclarator" or its an "ObjectPattern"
             * we compare the name from the first identifier, if the names are different
             * we assign the new name and reset the count of reportCount and nodeCount in
             * order to check each block for the number of reported errors and base our fix
             * based on comparing nodes.length and nodesToReport.length.
             */

            if (firstDecParent.type === "VariableDeclarator") {
              if (firstDecParent.id.name !== name) {
                name = firstDecParent.id.name;
                reportCount = 0;
              }
              if (firstDecParent.id.type === "ObjectPattern") {
                if (firstDecParent.init.name !== name) {
                  name = firstDecParent.init.name;
                  reportCount = 0;
                }
              }
            }
          }
        }
        let shouldFix = varDeclParent && (
        // Don't do a fix unless the variable is initialized (or it's in a for-in or for-of loop)
        varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations[0].init) &&
        /*
         * If options.destructuring is "all", then this warning will not occur unless
         * every assignment in the destructuring should be const. In that case, it's safe
         * to apply the fix.
         */
        nodesToReport.length === nodes.length;
        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {
          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {
            /*
             * Add nodesToReport.length to a count, then comparing the count to the length
             * of the declarations in the current block.
             */

            reportCount += nodesToReport.length;
            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;
          }
        }
        nodesToReport.forEach(node => {
          context.report({
            node,
            messageId: "useConst",
            data: node,
            fix: shouldFix ? fixer => fixer.replaceText(sourceCode.getFirstToken(varDeclParent), "const") : null
          });
        });
      }
    }
    return {
      "Program:exit"() {
        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
      },
      VariableDeclaration(node) {
        if (node.kind === "let" && !isInitOfForStatement(node)) {
          variables.push(...context.getDeclaredVariables(node));
        }
      }
    };
  }
};

/***/ }),
/* 437 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Prefer destructuring from arrays and objects
 * @author Alex LaFroscia
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require destructuring from arrays and/or objects",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-destructuring"
    },
    fixable: "code",
    schema: [{
      /*
       * old support {array: Boolean, object: Boolean}
       * new support {VariableDeclarator: {}, AssignmentExpression: {}}
       */
      oneOf: [{
        type: "object",
        properties: {
          VariableDeclarator: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          AssignmentExpression: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        },
        additionalProperties: false
      }, {
        type: "object",
        properties: {
          array: {
            type: "boolean"
          },
          object: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }, {
      type: "object",
      properties: {
        enforceForRenamedProperties: {
          type: "boolean"
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const enabledTypes = context.options[0];
    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
    let normalizedOptions = {
      VariableDeclarator: {
        array: true,
        object: true
      },
      AssignmentExpression: {
        array: true,
        object: true
      }
    };
    if (enabledTypes) {
      normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? {
        VariableDeclarator: enabledTypes,
        AssignmentExpression: enabledTypes
      } : enabledTypes;
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * @param {string} nodeType "AssignmentExpression" or "VariableDeclarator"
     * @param {string} destructuringType "array" or "object"
     * @returns {boolean} `true` if the destructuring type should be checked for the given node
     */
    function shouldCheck(nodeType, destructuringType) {
      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
    }

    /**
     * Determines if the given node is accessing an array index
     *
     * This is used to differentiate array index access from object property
     * access.
     *
     * @param {ASTNode} node the node to evaluate
     * @returns {boolean} whether or not the node is an integer
     */
    function isArrayIndexAccess(node) {
      return Number.isInteger(node.property.value);
    }

    /**
     * Report that the given node should use destructuring
     *
     * @param {ASTNode} reportNode the node to report
     * @param {string} type the type of destructuring that should have been done
     * @param {Function|null} fix the fix function or null to pass to context.report
     * @returns {void}
     */
    function report(reportNode, type, fix) {
      context.report({
        node: reportNode,
        message: "Use {{type}} destructuring.",
        data: {
          type
        },
        fix
      });
    }

    /**
     * Determines if a node should be fixed into object destructuring
     *
     * The fixer only fixes the simplest case of object destructuring,
     * like: `let x = a.x`;
     *
     * Assignment expression is not fixed.
     * Array destructuring is not fixed.
     * Renamed property is not fixed.
     *
     * @param {ASTNode} node the the node to evaluate
     * @returns {boolean} whether or not the node should be fixed
     */
    function shouldFix(node) {
      return node.type === "VariableDeclarator" && node.id.type === "Identifier" && node.init.type === "MemberExpression" && node.id.name === node.init.property.name;
    }

    /**
     * Fix a node into object destructuring.
     * This function only handles the simplest case of object destructuring,
     * see {@link shouldFix}.
     *
     * @param {SourceCodeFixer} fixer the fixer object
     * @param {ASTNode} node the node to be fixed.
     * @returns {Object} a fix for the node
     */
    function fixIntoObjectDestructuring(fixer, node) {
      const rightNode = node.init;
      const sourceCode = context.getSourceCode();
      return fixer.replaceText(node, `{${rightNode.property.name}} = ${sourceCode.getText(rightNode.object)}`);
    }

    /**
     * Check that the `prefer-destructuring` rules are followed based on the
     * given left- and right-hand side of the assignment.
     *
     * Pulled out into a separate method so that VariableDeclarators and
     * AssignmentExpressions can share the same verification logic.
     *
     * @param {ASTNode} leftNode the left-hand side of the assignment
     * @param {ASTNode} rightNode the right-hand side of the assignment
     * @param {ASTNode} reportNode the node to report the error on
     * @returns {void}
     */
    function performCheck(leftNode, rightNode, reportNode) {
      if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super") {
        return;
      }
      if (isArrayIndexAccess(rightNode)) {
        if (shouldCheck(reportNode.type, "array")) {
          report(reportNode, "array", null);
        }
        return;
      }
      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;
      if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
        report(reportNode, "object", fix);
        return;
      }
      if (shouldCheck(reportNode.type, "object")) {
        const property = rightNode.property;
        if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed) {
          report(reportNode, "object", fix);
        }
      }
    }

    /**
     * Check if a given variable declarator is coming from an property access
     * that should be using destructuring instead
     *
     * @param {ASTNode} node the variable declarator to check
     * @returns {void}
     */
    function checkVariableDeclarator(node) {
      // Skip if variable is declared without assignment
      if (!node.init) {
        return;
      }

      // We only care about member expressions past this point
      if (node.init.type !== "MemberExpression") {
        return;
      }
      performCheck(node.id, node.init, node);
    }

    /**
     * Run the `prefer-destructuring` check on an AssignmentExpression
     *
     * @param {ASTNode} node the AssignmentExpression node
     * @returns {void}
     */
    function checkAssigmentExpression(node) {
      if (node.operator === "=") {
        performCheck(node.left, node.right, node);
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      VariableDeclarator: checkVariableDeclarator,
      AssignmentExpression: checkAssigmentExpression
    };
  }
};

/***/ }),
/* 438 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce requiring named capture groups in regular expression.
 * @author Pig Fang <https://github.com/g-plane>
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const {
  CALL,
  CONSTRUCT,
  ReferenceTracker,
  getStringIfConstant
} = __webpack_require__(339);
const regexpp = __webpack_require__(295);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const parser = new regexpp.RegExpParser();

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce using named capture group in regular expression",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-named-capture-group"
    },
    schema: [],
    messages: {
      required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
    }
  },
  create(context) {
    /**
     * Function to check regular expression.
     *
     * @param {string} regex The regular expression to be check.
     * @param {ASTNode} node AST node which contains regular expression.
     * @param {boolean} uFlag Flag indicates whether unicode mode is enabled or not.
     * @returns {void}
     */
    function checkRegex(regex, node, uFlag) {
      let ast;
      try {
        ast = parser.parsePattern(regex, 0, regex.length, uFlag);
      } catch (_) {
        // ignore regex syntax errors
        return;
      }
      regexpp.visitRegExpAST(ast, {
        onCapturingGroupEnter(group) {
          if (!group.name) {
            const locNode = node.type === "Literal" ? node : node.arguments[0];
            context.report({
              node,
              messageId: "required",
              loc: {
                start: {
                  line: locNode.loc.start.line,
                  column: locNode.loc.start.column + group.start + 1
                },
                end: {
                  line: locNode.loc.start.line,
                  column: locNode.loc.start.column + group.end + 1
                }
              },
              data: {
                group: group.raw
              }
            });
          }
        }
      });
    }
    return {
      Literal(node) {
        if (node.regex) {
          checkRegex(node.regex.pattern, node, node.regex.flags.includes("u"));
        }
      },
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker(scope);
        const traceMap = {
          RegExp: {
            [CALL]: true,
            [CONSTRUCT]: true
          }
        };
        for (const {
          node
        } of tracker.iterateGlobalReferences(traceMap)) {
          const regex = getStringIfConstant(node.arguments[0]);
          const flags = getStringIfConstant(node.arguments[1]);
          if (regex) {
            checkRegex(regex, node, flags && flags.includes("u"));
          }
        }
      }
    };
  }
};

/***/ }),
/* 439 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals
 * @author Annie Zhang, Henry Zhu
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks to see if a CallExpression's callee node is `parseInt` or
 * `Number.parseInt`.
 * @param {ASTNode} calleeNode The callee node to evaluate.
 * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,
 * false otherwise.
 */
function isParseInt(calleeNode) {
  switch (calleeNode.type) {
    case "Identifier":
      return calleeNode.name === "parseInt";
    case "MemberExpression":
      return calleeNode.object.type === "Identifier" && calleeNode.object.name === "Number" && calleeNode.property.type === "Identifier" && calleeNode.property.name === "parseInt";

    // no default
  }
  return false;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-numeric-literals"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const radixMap = {
      2: "binary",
      8: "octal",
      16: "hexadecimal"
    };
    const prefixMap = {
      2: "0b",
      8: "0o",
      16: "0x"
    };

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      CallExpression(node) {
        // doesn't check parseInt() if it doesn't have a radix argument
        if (node.arguments.length !== 2) {
          return;
        }

        // only error if the radix is 2, 8, or 16
        const radixName = radixMap[node.arguments[1].value];
        if (isParseInt(node.callee) && radixName && node.arguments[0].type === "Literal") {
          context.report({
            node,
            message: "Use {{radixName}} literals instead of {{functionName}}().",
            data: {
              radixName,
              functionName: sourceCode.getText(node.callee)
            },
            fix(fixer) {
              const newPrefix = prefixMap[node.arguments[1].value];
              if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {
                /*
                 * If the newly-produced literal would be invalid, (e.g. 0b1234),
                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.
                 */
                return null;
              }
              return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 440 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Prefers object spread property over Object.assign
 * @author Sharmila Jesupaul
 * See LICENSE file in root directory for full license.
 */



const {
  CALL,
  ReferenceTracker
} = __webpack_require__(339);
const {
  isCommaToken,
  isOpeningParenToken,
  isClosingParenToken,
  isParenthesised
} = __webpack_require__(110);
const ANY_SPACE = /\s/u;

/**
 * Helper that checks if the Object.assign call has array spread
 * @param {ASTNode} node - The node that the rule warns on
 * @returns {boolean} - Returns true if the Object.assign call has array spread
 */
function hasArraySpread(node) {
  return node.arguments.some(arg => arg.type === "SpreadElement");
}

/**
 * Helper that checks if the node needs parentheses to be valid JS.
 * The default is to wrap the node in parentheses to avoid parsing errors.
 * @param {ASTNode} node - The node that the rule warns on
 * @param {Object} sourceCode - in context sourcecode object
 * @returns {boolean} - Returns true if the node needs parentheses
 */
function needsParens(node, sourceCode) {
  const parent = node.parent;
  switch (parent.type) {
    case "VariableDeclarator":
    case "ArrayExpression":
    case "ReturnStatement":
    case "CallExpression":
    case "Property":
      return false;
    case "AssignmentExpression":
      return parent.left === node && !isParenthesised(sourceCode, node);
    default:
      return !isParenthesised(sourceCode, node);
  }
}

/**
 * Determines if an argument needs parentheses. The default is to not add parens.
 * @param {ASTNode} node - The node to be checked.
 * @param {Object} sourceCode - in context sourcecode object
 * @returns {boolean} True if the node needs parentheses
 */
function argNeedsParens(node, sourceCode) {
  switch (node.type) {
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "ConditionalExpression":
      return !isParenthesised(sourceCode, node);
    default:
      return false;
  }
}

/**
 * Get the parenthesis tokens of a given ObjectExpression node.
 * This incldues the braces of the object literal and enclosing parentheses.
 * @param {ASTNode} node The node to get.
 * @param {Token} leftArgumentListParen The opening paren token of the argument list.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.
 */
function getParenTokens(node, leftArgumentListParen, sourceCode) {
  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
  let leftNext = sourceCode.getTokenBefore(node);
  let rightNext = sourceCode.getTokenAfter(node);

  // Note: don't include the parens of the argument list.
  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
    parens.push(leftNext, rightNext);
    leftNext = sourceCode.getTokenBefore(leftNext);
    rightNext = sourceCode.getTokenAfter(rightNext);
  }
  return parens.sort((a, b) => a.range[0] - b.range[0]);
}

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The end of the range of the token and around whitespaces.
 */
function getStartWithSpaces(token, sourceCode) {
  const text = sourceCode.text;
  let start = token.range[0];

  // If the previous token is a line comment then skip this step to avoid commenting this token out.
  {
    const prevToken = sourceCode.getTokenBefore(token, {
      includeComments: true
    });
    if (prevToken && prevToken.type === "Line") {
      return start;
    }
  }

  // Detect spaces before the token.
  while (ANY_SPACE.test(text[start - 1] || "")) {
    start -= 1;
  }
  return start;
}

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token} token The token to get range.
 * @param {SourceCode} sourceCode The source code object to get tokens.
 * @returns {number} The start of the range of the token and around whitespaces.
 */
function getEndWithSpaces(token, sourceCode) {
  const text = sourceCode.text;
  let end = token.range[1];

  // Detect spaces after the token.
  while (ANY_SPACE.test(text[end] || "")) {
    end += 1;
  }
  return end;
}

/**
 * Autofixes the Object.assign call to use an object spread instead.
 * @param {ASTNode|null} node - The node that the rule warns on, i.e. the Object.assign call
 * @param {string} sourceCode - sourceCode of the Object.assign call
 * @returns {Function} autofixer - replaces the Object.assign with a spread object.
 */
function defineFixer(node, sourceCode) {
  return function* (fixer) {
    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
    const rightParen = sourceCode.getLastToken(node);

    // Remove the callee `Object.assign`
    yield fixer.remove(node.callee);

    // Replace the parens of argument list to braces.
    if (needsParens(node, sourceCode)) {
      yield fixer.replaceText(leftParen, "({");
      yield fixer.replaceText(rightParen, "})");
    } else {
      yield fixer.replaceText(leftParen, "{");
      yield fixer.replaceText(rightParen, "}");
    }

    // Process arguments.
    for (const argNode of node.arguments) {
      const innerParens = getParenTokens(argNode, leftParen, sourceCode);
      const left = innerParens.shift();
      const right = innerParens.pop();
      if (argNode.type === "ObjectExpression") {
        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
        const maybeArgumentComma = sourceCode.getTokenAfter(right);

        /*
         * Make bare this object literal.
         * And remove spaces inside of the braces for better formatting.
         */
        for (const innerParen of innerParens) {
          yield fixer.remove(innerParen);
        }
        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]),
        // Ensure ranges don't overlap
        right.range[1]];
        yield fixer.removeRange(leftRange);
        yield fixer.removeRange(rightRange);

        // Remove the comma of this argument if it's duplication.
        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {
          yield fixer.remove(maybeArgumentComma);
        }
      } else {
        // Make spread.
        if (argNeedsParens(argNode, sourceCode)) {
          yield fixer.insertTextBefore(left, "...(");
          yield fixer.insertTextAfter(right, ")");
        } else {
          yield fixer.insertTextBefore(left, "...");
        }
      }
    }
  };
}
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-object-spread"
    },
    schema: [],
    fixable: "code",
    messages: {
      useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
      useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker(scope);
        const trackMap = {
          Object: {
            assign: {
              [CALL]: true
            }
          }
        };

        // Iterate all calls of `Object.assign` (only of the global variable `Object`).
        for (const {
          node
        } of tracker.iterateGlobalReferences(trackMap)) {
          if (node.arguments.length >= 1 && node.arguments[0].type === "ObjectExpression" && !hasArraySpread(node)) {
            const messageId = node.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
            const fix = defineFixer(node, sourceCode);
            context.report({
              node,
              messageId,
              fix
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 441 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview restrict values that can be used as Promise rejection reasons
 * @author Teddy Katz
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using Error objects as Promise rejection reasons",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-promise-reject-errors"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowEmptyReject: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    /**
     * Checks the argument of a reject() or Promise.reject() CallExpression, and reports it if it can't be an Error
     * @param {ASTNode} callExpression A CallExpression node which is used to reject a Promise
     * @returns {void}
     */
    function checkRejectCall(callExpression) {
      if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
        return;
      }
      if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
        context.report({
          node: callExpression,
          message: "Expected the Promise rejection reason to be an Error."
        });
      }
    }

    /**
     * Determines whether a function call is a Promise.reject() call
     * @param {ASTNode} node A CallExpression node
     * @returns {boolean} `true` if the call is a Promise.reject() call
     */
    function isPromiseRejectCall(node) {
      return node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "Promise" && node.callee.property.type === "Identifier" && node.callee.property.name === "reject";
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    return {
      // Check `Promise.reject(value)` calls.
      CallExpression(node) {
        if (isPromiseRejectCall(node)) {
          checkRejectCall(node);
        }
      },
      /*
       * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.
       * This function is run on "NewExpression:exit" instead of "NewExpression" to ensure that
       * the nodes in the expression already have the `parent` property.
       */
      "NewExpression:exit"(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
          context.getDeclaredVariables(node.arguments[0])

          /*
           * Find the first variable that matches the second parameter's name.
           * If the first parameter has the same name as the second parameter, then the variable will actually
           * be "declared" when the first parameter is evaluated, but then it will be immediately overwritten
           * by the second parameter. It's not possible for an expression with the variable to be evaluated before
           * the variable is overwritten, because functions with duplicate parameters cannot have destructuring or
           * default assignments in their parameter lists. Therefore, it's not necessary to explicitly account for
           * this case.
           */.find(variable => variable.name === node.arguments[0].params[1].name)

          // Get the references to that variable.
          .references

          // Only check the references that read the parameter's value.
          .filter(ref => ref.isRead())

          // Only check the references that are used as the callee in a function call, e.g. `reject(foo)`.
          .filter(ref => ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee)

          // Check the argument of the function call to determine whether it's an Error.
          .forEach(ref => checkRejectCall(ref.identifier.parent));
        }
      }
    };
  }
};

/***/ }),
/* 442 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to suggest using "Reflect" api over Function/Object methods
 * @author Keith Cirkel <http://keithcirkel.co.uk>
 * @deprecated in ESLint v3.9.0
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `Reflect` methods where applicable",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-reflect"
    },
    deprecated: true,
    replacedBy: [],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"]
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const existingNames = {
      apply: "Function.prototype.apply",
      call: "Function.prototype.call",
      defineProperty: "Object.defineProperty",
      getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
      getPrototypeOf: "Object.getPrototypeOf",
      setPrototypeOf: "Object.setPrototypeOf",
      isExtensible: "Object.isExtensible",
      getOwnPropertyNames: "Object.getOwnPropertyNames",
      preventExtensions: "Object.preventExtensions"
    };
    const reflectSubsitutes = {
      apply: "Reflect.apply",
      call: "Reflect.apply",
      defineProperty: "Reflect.defineProperty",
      getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
      getPrototypeOf: "Reflect.getPrototypeOf",
      setPrototypeOf: "Reflect.setPrototypeOf",
      isExtensible: "Reflect.isExtensible",
      getOwnPropertyNames: "Reflect.getOwnPropertyNames",
      preventExtensions: "Reflect.preventExtensions"
    };
    const exceptions = (context.options[0] || {}).exceptions || [];

    /**
     * Reports the Reflect violation based on the `existing` and `substitute`
     * @param {Object} node The node that violates the rule.
     * @param {string} existing The existing method name that has been used.
     * @param {string} substitute The Reflect substitute that should be used.
     * @returns {void}
     */
    function report(node, existing, substitute) {
      context.report({
        node,
        message: "Avoid using {{existing}}, instead use {{substitute}}.",
        data: {
          existing,
          substitute
        }
      });
    }
    return {
      CallExpression(node) {
        const methodName = (node.callee.property || {}).name;
        const isReflectCall = (node.callee.object || {}).name === "Reflect";
        const hasReflectSubsitute = Object.prototype.hasOwnProperty.call(reflectSubsitutes, methodName);
        const userConfiguredException = exceptions.indexOf(methodName) !== -1;
        if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
          report(node, existingNames[methodName], reflectSubsitutes[methodName]);
        }
      },
      UnaryExpression(node) {
        const isDeleteOperator = node.operator === "delete";
        const targetsIdentifier = node.argument.type === "Identifier";
        const userConfiguredException = exceptions.indexOf("delete") !== -1;
        if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
          report(node, "the delete keyword", "Reflect.deleteProperty");
        }
      }
    };
  }
};

/***/ }),
/* 443 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the variable object of `arguments` which is defined implicitly.
 * @param {eslint-scope.Scope} scope - A scope to get.
 * @returns {eslint-scope.Variable} The found variable object.
 */
function getVariableOfArguments(scope) {
  const variables = scope.variables;
  for (let i = 0; i < variables.length; ++i) {
    const variable = variables[i];
    if (variable.name === "arguments") {
      /*
       * If there was a parameter which is named "arguments", the implicit "arguments" is not defined.
       * So does fast return with null.
       */
      return variable.identifiers.length === 0 ? variable : null;
    }
  }

  /* istanbul ignore next : unreachable */
  return null;
}

/**
 * Checks if the given reference is not normal member access.
 *
 * - arguments         .... true    // not member access
 * - arguments[i]      .... true    // computed member access
 * - arguments[0]      .... true    // computed member access
 * - arguments.length  .... false   // normal member access
 *
 * @param {eslint-scope.Reference} reference - The reference to check.
 * @returns {boolean} `true` if the reference is not normal member access.
 */
function isNotNormalMemberAccess(reference) {
  const id = reference.identifier;
  const parent = id.parent;
  return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require rest parameters instead of `arguments`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-rest-params"
    },
    schema: []
  },
  create(context) {
    /**
     * Reports a given reference.
     *
     * @param {eslint-scope.Reference} reference - A reference to report.
     * @returns {void}
     */
    function report(reference) {
      context.report({
        node: reference.identifier,
        loc: reference.identifier.loc,
        message: "Use the rest parameters instead of 'arguments'."
      });
    }

    /**
     * Reports references of the implicit `arguments` variable if exist.
     *
     * @returns {void}
     */
    function checkForArguments() {
      const argumentsVar = getVariableOfArguments(context.getScope());
      if (argumentsVar) {
        argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
      }
    }
    return {
      "FunctionDeclaration:exit": checkForArguments,
      "FunctionExpression:exit": checkForArguments
    };
  }
};

/***/ }),
/* 444 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.
 * @author Toru Nagashima
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a node is a `.apply()` for variadic.
 * @param {ASTNode} node - A CallExpression node to check.
 * @returns {boolean} Whether or not the node is a `.apply()` for variadic.
 */
function isVariadicApplyCalling(node) {
  return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.property.name === "apply" && node.callee.computed === false && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
}

/**
 * Checks whether or not `thisArg` is not changed by `.apply()`.
 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.
 * @param {RuleContext} context - The ESLint rule context object.
 * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.
 */
function isValidThisArg(expectedThis, thisArg, context) {
  if (!expectedThis) {
    return astUtils.isNullOrUndefined(thisArg);
  }
  return astUtils.equalTokens(expectedThis, thisArg, context);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require spread operators instead of `.apply()`",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-spread"
    },
    schema: [],
    fixable: null
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      CallExpression(node) {
        if (!isVariadicApplyCalling(node)) {
          return;
        }
        const applied = node.callee.object;
        const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
        const thisArg = node.arguments[0];
        if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
          context.report({
            node,
            message: "Use the spread operator instead of '.apply()'."
          });
        }
      }
    };
  }
};

/***/ }),
/* 445 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to suggest using template literals instead of string concatenation.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a concatenation.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a concatenation.
 */
function isConcatenation(node) {
  return node.type === "BinaryExpression" && node.operator === "+";
}

/**
 * Gets the top binary expression node for concatenation in parents of a given node.
 * @param {ASTNode} node - A node to get.
 * @returns {ASTNode} the top binary expression node in parents of a given node.
 */
function getTopConcatBinaryExpression(node) {
  let currentNode = node;
  while (isConcatenation(currentNode.parent)) {
    currentNode = currentNode.parent;
  }
  return currentNode;
}

/**
 * Determines whether a given node is a octal escape sequence
 * @param {ASTNode} node A node to check
 * @returns {boolean} `true` if the node is an octal escape sequence
 */
function isOctalEscapeSequence(node) {
  // No need to check TemplateLiterals  would throw error with octal escape
  const isStringLiteral = node.type === "Literal" && typeof node.value === "string";
  if (!isStringLiteral) {
    return false;
  }
  const match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-7]{1,3})/u);
  if (match) {
    // \0 is actually not considered an octal
    if (match[2] !== "0" || typeof match[3] !== "undefined") {
      return true;
    }
  }
  return false;
}

/**
 * Checks whether or not a node contains a octal escape sequence
 * @param {ASTNode} node A node to check
 * @returns {boolean} `true` if the node contains an octal escape sequence
 */
function hasOctalEscapeSequence(node) {
  if (isConcatenation(node)) {
    return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);
  }
  return isOctalEscapeSequence(node);
}

/**
 * Checks whether or not a given binary expression has string literals.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node has string literals.
 */
function hasStringLiteral(node) {
  if (isConcatenation(node)) {
    // `left` is deeper than `right` normally.
    return hasStringLiteral(node.right) || hasStringLiteral(node.left);
  }
  return astUtils.isStringLiteral(node);
}

/**
 * Checks whether or not a given binary expression has non string literals.
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node has non string literals.
 */
function hasNonStringLiteral(node) {
  if (isConcatenation(node)) {
    // `left` is deeper than `right` normally.
    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
  }
  return !astUtils.isStringLiteral(node);
}

/**
 * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.
 * @param {ASTNode} node The node that will be fixed to a template literal
 * @returns {boolean} `true` if the node will start with a template curly.
 */
function startsWithTemplateCurly(node) {
  if (node.type === "BinaryExpression") {
    return startsWithTemplateCurly(node.left);
  }
  if (node.type === "TemplateLiteral") {
    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
  }
  return node.type !== "Literal" || typeof node.value !== "string";
}

/**
 * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.
 * @param {ASTNode} node The node that will be fixed to a template literal
 * @returns {boolean} `true` if the node will end with a template curly.
 */
function endsWithTemplateCurly(node) {
  if (node.type === "BinaryExpression") {
    return startsWithTemplateCurly(node.right);
  }
  if (node.type === "TemplateLiteral") {
    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
  }
  return node.type !== "Literal" || typeof node.value !== "string";
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require template literals instead of string concatenation",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/prefer-template"
    },
    schema: [],
    fixable: "code"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let done = Object.create(null);

    /**
     * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.
     * @param {ASTNode} node1 The first node
     * @param {ASTNode} node2 The second node
     * @returns {string} The text between the nodes, excluding other tokens
     */
    function getTextBetween(node1, node2) {
      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
      const sourceText = sourceCode.getText();
      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
    }

    /**
     * Returns a template literal form of the given node.
     * @param {ASTNode} currentNode A node that should be converted to a template literal
     * @param {string} textBeforeNode Text that should appear before the node
     * @param {string} textAfterNode Text that should appear after the node
     * @returns {string} A string form of this node, represented as a template literal
     */
    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
      if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
        /*
         * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted
         * as a template placeholder. However, if the code already contains a backslash before the ${ or `
         * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause
         * an actual backslash character to appear before the dollar sign).
         */
        return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, matched => {
          if (matched.lastIndexOf("\\") % 2) {
            return `\\${matched}`;
          }
          return matched;

          // Unescape any quotes that appear in the original Literal that no longer need to be escaped.
        }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "gu"), currentNode.raw[0])}\``;
      }
      if (currentNode.type === "TemplateLiteral") {
        return sourceCode.getText(currentNode);
      }
      if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === "+");
        const textBeforePlus = getTextBetween(currentNode.left, plusSign);
        const textAfterPlus = getTextBetween(plusSign, currentNode.right);
        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);
        if (leftEndsWithCurly) {
          // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.
          // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`
          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
        }
        if (rightStartsWithCurly) {
          // Otherwise, if the right side of the expression starts with a template curly, add the text there.
          // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`
          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
        }

        /*
         * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put
         * the text between them.
         */
        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
      }
      return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
    }

    /**
     * Returns a fixer object that converts a non-string binary expression to a template literal
     * @param {SourceCodeFixer} fixer The fixer object
     * @param {ASTNode} node A node that should be converted to a template literal
     * @returns {Object} A fix for this binary expression
     */
    function fixNonStringBinaryExpression(fixer, node) {
      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
      if (hasOctalEscapeSequence(topBinaryExpr)) {
        return null;
      }
      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
    }

    /**
     * Reports if a given node is string concatenation with non string literals.
     *
     * @param {ASTNode} node - A node to check.
     * @returns {void}
     */
    function checkForStringConcat(node) {
      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
        return;
      }
      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);

      // Checks whether or not this node had been checked already.
      if (done[topBinaryExpr.range[0]]) {
        return;
      }
      done[topBinaryExpr.range[0]] = true;
      if (hasNonStringLiteral(topBinaryExpr)) {
        context.report({
          node: topBinaryExpr,
          message: "Unexpected string concatenation.",
          fix: fixer => fixNonStringBinaryExpression(fixer, node)
        });
      }
    }
    return {
      Program() {
        done = Object.create(null);
      },
      Literal: checkForStringConcat,
      TemplateLiteral: checkForStringConcat
    };
  }
};

/***/ }),
/* 446 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag non-quoted property names in object literals.
 * @author Mathias Bynens <http://mathiasbynens.be/>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const espree = __webpack_require__(91),
  keywords = __webpack_require__(231);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require quotes around object literal property names",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/quote-props"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }, {
          type: "object",
          properties: {
            keywords: {
              type: "boolean"
            },
            unnecessary: {
              type: "boolean"
            },
            numbers: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code"
  },
  create(context) {
    const MODE = context.options[0],
      KEYWORDS = context.options[1] && context.options[1].keywords,
      CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
      NUMBERS = context.options[1] && context.options[1].numbers,
      MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
      MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
      MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
      MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
      sourceCode = context.getSourceCode();

    /**
     * Checks whether a certain string constitutes an ES3 token
     * @param   {string} tokenStr - The string to be checked.
     * @returns {boolean} `true` if it is an ES3 token.
     */
    function isKeyword(tokenStr) {
      return keywords.indexOf(tokenStr) >= 0;
    }

    /**
     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)
     * @param   {string} rawKey The raw key value from the source
     * @param   {espreeTokens} tokens The espree-tokenized node key
     * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
     * @returns {boolean} Whether or not a key has redundant quotes.
     * @private
     */
    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
    }

    /**
     * Returns a string representation of a property node with quotes removed
     * @param {ASTNode} key Key AST Node, which may or may not be quoted
     * @returns {string} A replacement string for this property
     */
    function getUnquotedKey(key) {
      return key.type === "Identifier" ? key.name : key.value;
    }

    /**
     * Returns a string representation of a property node with quotes added
     * @param {ASTNode} key Key AST Node, which may or may not be quoted
     * @returns {string} A replacement string for this property
     */
    function getQuotedKey(key) {
      if (key.type === "Literal" && typeof key.value === "string") {
        // If the key is already a string literal, don't replace the quotes with double quotes.
        return sourceCode.getText(key);
      }

      // Otherwise, the key is either an identifier or a number literal.
      return `"${key.type === "Identifier" ? key.name : key.value}"`;
    }

    /**
     * Ensures that a property's key is quoted only when necessary
     * @param   {ASTNode} node Property AST node
     * @returns {void}
     */
    function checkUnnecessaryQuotes(node) {
      const key = node.key;
      if (node.method || node.computed || node.shorthand) {
        return;
      }
      if (key.type === "Literal" && typeof key.value === "string") {
        let tokens;
        try {
          tokens = espree.tokenize(key.value);
        } catch (e) {
          return;
        }
        if (tokens.length !== 1) {
          return;
        }
        const isKeywordToken = isKeyword(tokens[0].value);
        if (isKeywordToken && KEYWORDS) {
          return;
        }
        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
          context.report({
            node,
            message: MESSAGE_UNNECESSARY,
            data: {
              property: key.value
            },
            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))
          });
        }
      } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
        context.report({
          node,
          message: MESSAGE_RESERVED,
          data: {
            property: key.name
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
        context.report({
          node,
          message: MESSAGE_NUMERIC,
          data: {
            property: key.value
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      }
    }

    /**
     * Ensures that a property's key is quoted
     * @param   {ASTNode} node Property AST node
     * @returns {void}
     */
    function checkOmittedQuotes(node) {
      const key = node.key;
      if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
        context.report({
          node,
          message: MESSAGE_UNQUOTED,
          data: {
            property: key.name || key.value
          },
          fix: fixer => fixer.replaceText(key, getQuotedKey(key))
        });
      }
    }

    /**
     * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes
     * @param   {ASTNode} node Property AST node
     * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
     * @returns {void}
     */
    function checkConsistency(node, checkQuotesRedundancy) {
      const quotedProps = [],
        unquotedProps = [];
      let keywordKeyName = null,
        necessaryQuotes = false;
      node.properties.forEach(property => {
        const key = property.key;
        if (!key || property.method || property.computed || property.shorthand) {
          return;
        }
        if (key.type === "Literal" && typeof key.value === "string") {
          quotedProps.push(property);
          if (checkQuotesRedundancy) {
            let tokens;
            try {
              tokens = espree.tokenize(key.value);
            } catch (e) {
              necessaryQuotes = true;
              return;
            }
            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
          }
        } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
          unquotedProps.push(property);
          necessaryQuotes = true;
          keywordKeyName = key.name;
        } else {
          unquotedProps.push(property);
        }
      });
      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
        quotedProps.forEach(property => {
          context.report({
            node: property,
            message: "Properties shouldn't be quoted as all quotes are redundant.",
            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))
          });
        });
      } else if (unquotedProps.length && keywordKeyName) {
        unquotedProps.forEach(property => {
          context.report({
            node: property,
            message: "Properties should be quoted as '{{property}}' is a reserved word.",
            data: {
              property: keywordKeyName
            },
            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
          });
        });
      } else if (quotedProps.length && unquotedProps.length) {
        unquotedProps.forEach(property => {
          context.report({
            node: property,
            message: "Inconsistently quoted property '{{key}}' found.",
            data: {
              key: property.key.name || property.key.value
            },
            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
          });
        });
      }
    }
    return {
      Property(node) {
        if (MODE === "always" || !MODE) {
          checkOmittedQuotes(node);
        }
        if (MODE === "as-needed") {
          checkUnnecessaryQuotes(node);
        }
      },
      ObjectExpression(node) {
        if (MODE === "consistent") {
          checkConsistency(node, false);
        }
        if (MODE === "consistent-as-needed") {
          checkConsistency(node, true);
        }
      }
    };
  }
};

/***/ }),
/* 447 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to choose between single and double quote marks
 * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const QUOTE_SETTINGS = {
  double: {
    quote: "\"",
    alternateQuote: "'",
    description: "doublequote"
  },
  single: {
    quote: "'",
    alternateQuote: "\"",
    description: "singlequote"
  },
  backtick: {
    quote: "`",
    alternateQuote: "\"",
    description: "backtick"
  }
};

// An unescaped newline is a newline preceded by an even number of backslashes.
const UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`, "u");

/**
 * Switches quoting of javascript string between ' " and `
 * escaping and unescaping as necessary.
 * Only escaping of the minimal set of characters is changed.
 * Note: escaping of newlines when switching from backtick to other quotes is not handled.
 * @param {string} str - A string to convert.
 * @returns {string} The string with changed quotes.
 * @private
 */
QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {
  const newQuote = this.quote;
  const oldQuote = str[0];
  if (newQuote === oldQuote) {
    return str;
  }
  return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
    if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
      return escaped; // unescape
    }
    if (match === newQuote || newQuote === "`" && match === "${") {
      return `\\${match}`; // escape
    }
    if (newline && oldQuote === "`") {
      return "\\n"; // escape newlines
    }
    return match;
  }) + newQuote;
};
const AVOID_ESCAPE = "avoid-escape";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either backticks, double, or single quotes",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/quotes"
    },
    fixable: "code",
    schema: [{
      enum: ["single", "double", "backtick"]
    }, {
      anyOf: [{
        enum: ["avoid-escape"]
      }, {
        type: "object",
        properties: {
          avoidEscape: {
            type: "boolean"
          },
          allowTemplateLiterals: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const quoteOption = context.options[0],
      settings = QUOTE_SETTINGS[quoteOption || "double"],
      options = context.options[1],
      allowTemplateLiterals = options && options.allowTemplateLiterals === true,
      sourceCode = context.getSourceCode();
    let avoidEscape = options && options.avoidEscape === true;

    // deprecated
    if (options === AVOID_ESCAPE) {
      avoidEscape = true;
    }

    /**
     * Determines if a given node is part of JSX syntax.
     *
     * This function returns `true` in the following cases:
     *
     * - `<div className="foo"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.
     * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.
     * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.
     *
     * In particular, this function returns `false` in the following cases:
     *
     * - `<div className={"foo"}></div>`
     * - `<div>{"foo"}</div>`
     *
     * In both cases, inside of the braces is handled as normal JavaScript.
     * The braces are `JSXExpressionContainer` nodes.
     *
     * @param {ASTNode} node The Literal node to check.
     * @returns {boolean} True if the node is a part of JSX, false if not.
     * @private
     */
    function isJSXLiteral(node) {
      return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
    }

    /**
     * Checks whether or not a given node is a directive.
     * The directive is a `ExpressionStatement` which has only a string literal.
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} Whether or not the node is a directive.
     * @private
     */
    function isDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    /**
     * Checks whether or not a given node is a part of directive prologues.
     * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} Whether or not the node is a part of directive prologues.
     * @private
     */
    function isPartOfDirectivePrologue(node) {
      const block = node.parent.parent;
      if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
        return false;
      }

      // Check the node is at a prologue.
      for (let i = 0; i < block.body.length; ++i) {
        const statement = block.body[i];
        if (statement === node.parent) {
          return true;
        }
        if (!isDirective(statement)) {
          break;
        }
      }
      return false;
    }

    /**
     * Checks whether or not a given node is allowed as non backtick.
     * @param {ASTNode} node - A node to check.
     * @returns {boolean} Whether or not the node is allowed as non backtick.
     * @private
     */
    function isAllowedAsNonBacktick(node) {
      const parent = node.parent;
      switch (parent.type) {
        // Directive Prologues.
        case "ExpressionStatement":
          return isPartOfDirectivePrologue(node);

        // LiteralPropertyName.
        case "Property":
        case "MethodDefinition":
          return parent.key === node && !parent.computed;

        // ModuleSpecifier.
        case "ImportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return parent.source === node;

        // Others don't allow.
        default:
          return false;
      }
    }

    /**
     * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.
     * @param {ASTNode} node - A TemplateLiteral node to check.
     * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.
     * @private
     */
    function isUsingFeatureOfTemplateLiteral(node) {
      const hasTag = node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi;
      if (hasTag) {
        return true;
      }
      const hasStringInterpolation = node.expressions.length > 0;
      if (hasStringInterpolation) {
        return true;
      }
      const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);
      if (isMultilineString) {
        return true;
      }
      return false;
    }
    return {
      Literal(node) {
        const val = node.value,
          rawVal = node.raw;
        if (settings && typeof val === "string") {
          let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);
          if (!isValid && avoidEscape) {
            isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
          }
          if (!isValid) {
            context.report({
              node,
              message: "Strings must use {{description}}.",
              data: {
                description: settings.description
              },
              fix(fixer) {
                return fixer.replaceText(node, settings.convert(node.raw));
              }
            });
          }
        }
      },
      TemplateLiteral(node) {
        // Don't throw an error if backticks are expected or a template literal feature is in use.
        if (allowTemplateLiterals || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node)) {
          return;
        }
        context.report({
          node,
          message: "Strings must use {{description}}.",
          data: {
            description: settings.description
          },
          fix(fixer) {
            if (isPartOfDirectivePrologue(node)) {
              /*
               * TemplateLiterals in a directive prologue aren't actually directives, but if they're
               * in the directive prologue, then fixing them might turn them into directives and change
               * the behavior of the code.
               */
              return null;
            }
            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
          }
        });
      }
    };
  }
};

/***/ }),
/* 448 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag use of parseInt without a radix argument
 * @author James Allardice
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const MODE_ALWAYS = "always",
  MODE_AS_NEEDED = "as-needed";

/**
 * Checks whether a given variable is shadowed or not.
 *
 * @param {eslint-scope.Variable} variable - A variable to check.
 * @returns {boolean} `true` if the variable is shadowed.
 */
function isShadowed(variable) {
  return variable.defs.length >= 1;
}

/**
 * Checks whether a given node is a MemberExpression of `parseInt` method or not.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`
 *      method.
 */
function isParseIntMethod(node) {
  return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
}

/**
 * Checks whether a given node is a valid value of radix or not.
 *
 * The following values are invalid.
 *
 * - A literal except numbers.
 * - undefined.
 *
 * @param {ASTNode} radix - A node of radix to check.
 * @returns {boolean} `true` if the node is valid.
 */
function isValidRadix(radix) {
  return !(radix.type === "Literal" && typeof radix.value !== "number" || radix.type === "Identifier" && radix.name === "undefined");
}

/**
 * Checks whether a given node is a default value of radix or not.
 *
 * @param {ASTNode} radix - A node of radix to check.
 * @returns {boolean} `true` if the node is the literal node of `10`.
 */
function isDefaultRadix(radix) {
  return radix.type === "Literal" && radix.value === 10;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of the radix argument when using `parseInt()`",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/radix"
    },
    schema: [{
      enum: ["always", "as-needed"]
    }]
  },
  create(context) {
    const mode = context.options[0] || MODE_ALWAYS;

    /**
     * Checks the arguments of a given CallExpression node and reports it if it
     * offends this rule.
     *
     * @param {ASTNode} node - A CallExpression node to check.
     * @returns {void}
     */
    function checkArguments(node) {
      const args = node.arguments;
      switch (args.length) {
        case 0:
          context.report({
            node,
            message: "Missing parameters."
          });
          break;
        case 1:
          if (mode === MODE_ALWAYS) {
            context.report({
              node,
              message: "Missing radix parameter."
            });
          }
          break;
        default:
          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
            context.report({
              node,
              message: "Redundant radix parameter."
            });
          } else if (!isValidRadix(args[1])) {
            context.report({
              node,
              message: "Invalid radix parameter."
            });
          }
          break;
      }
    }
    return {
      "Program:exit"() {
        const scope = context.getScope();
        let variable;

        // Check `parseInt()`
        variable = astUtils.getVariableByName(scope, "parseInt");
        if (!isShadowed(variable)) {
          variable.references.forEach(reference => {
            const node = reference.identifier;
            if (astUtils.isCallee(node)) {
              checkArguments(node.parent);
            }
          });
        }

        // Check `Number.parseInt()`
        variable = astUtils.getVariableByName(scope, "Number");
        if (!isShadowed(variable)) {
          variable.references.forEach(reference => {
            const node = reference.identifier.parent;
            if (isParseIntMethod(node) && astUtils.isCallee(node)) {
              checkArguments(node.parent);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 449 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`
 * @author Teddy Katz
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-atomic-updates"
    },
    fixable: null,
    schema: [],
    messages: {
      nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const identifierToSurroundingFunctionMap = new WeakMap();
    const expressionsByCodePathSegment = new Map();

    //----------------------------------------------------------------------
    // Helpers
    //----------------------------------------------------------------------

    const resolvedVariableCache = new WeakMap();

    /**
     * Gets the variable scope around this variable reference
     * @param {ASTNode} identifier An `Identifier` AST node
     * @returns {Scope|null} An escope Scope
     */
    function getScope(identifier) {
      for (let currentNode = identifier; currentNode; currentNode = currentNode.parent) {
        const scope = sourceCode.scopeManager.acquire(currentNode, true);
        if (scope) {
          return scope;
        }
      }
      return null;
    }

    /**
     * Resolves a given identifier to a given scope
     * @param {ASTNode} identifier An `Identifier` AST node
     * @param {Scope} scope An escope Scope
     * @returns {Variable|null} An escope Variable corresponding to the given identifier
     */
    function resolveVariableInScope(identifier, scope) {
      return scope.variables.find(variable => variable.name === identifier.name) || (scope.upper ? resolveVariableInScope(identifier, scope.upper) : null);
    }

    /**
     * Resolves an identifier to a variable
     * @param {ASTNode} identifier An identifier node
     * @returns {Variable|null} The escope Variable that uses this identifier
     */
    function resolveVariable(identifier) {
      if (!resolvedVariableCache.has(identifier)) {
        const surroundingScope = getScope(identifier);
        if (surroundingScope) {
          resolvedVariableCache.set(identifier, resolveVariableInScope(identifier, surroundingScope));
        } else {
          resolvedVariableCache.set(identifier, null);
        }
      }
      return resolvedVariableCache.get(identifier);
    }

    /**
     * Checks if an expression is a variable that can only be observed within the given function.
     * @param {ASTNode} expression The expression to check
     * @param {ASTNode} surroundingFunction The function node
     * @returns {boolean} `true` if the expression is a variable which is local to the given function, and is never
     * referenced in a closure.
     */
    function isLocalVariableWithoutEscape(expression, surroundingFunction) {
      if (expression.type !== "Identifier") {
        return false;
      }
      const variable = resolveVariable(expression);
      if (!variable) {
        return false;
      }
      return variable.references.every(reference => identifierToSurroundingFunctionMap.get(reference.identifier) === surroundingFunction) && variable.defs.every(def => identifierToSurroundingFunctionMap.get(def.name) === surroundingFunction);
    }

    /**
     * Reports an AssignmentExpression node that has a non-atomic update
     * @param {ASTNode} assignmentExpression The assignment that is potentially unsafe
     * @returns {void}
     */
    function reportAssignment(assignmentExpression) {
      context.report({
        node: assignmentExpression,
        messageId: "nonAtomicUpdate",
        data: {
          value: sourceCode.getText(assignmentExpression.left)
        }
      });
    }
    const alreadyReportedAssignments = new WeakSet();
    class AssignmentTrackerState {
      constructor() {
        let {
          openAssignmentsWithoutReads = new Set(),
          openAssignmentsWithReads = new Set()
        } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.openAssignmentsWithoutReads = openAssignmentsWithoutReads;
        this.openAssignmentsWithReads = openAssignmentsWithReads;
      }
      copy() {
        return new AssignmentTrackerState({
          openAssignmentsWithoutReads: new Set(this.openAssignmentsWithoutReads),
          openAssignmentsWithReads: new Set(this.openAssignmentsWithReads)
        });
      }
      merge(other) {
        const initialAssignmentsWithoutReadsCount = this.openAssignmentsWithoutReads.size;
        const initialAssignmentsWithReadsCount = this.openAssignmentsWithReads.size;
        other.openAssignmentsWithoutReads.forEach(assignment => this.openAssignmentsWithoutReads.add(assignment));
        other.openAssignmentsWithReads.forEach(assignment => this.openAssignmentsWithReads.add(assignment));
        return this.openAssignmentsWithoutReads.size > initialAssignmentsWithoutReadsCount || this.openAssignmentsWithReads.size > initialAssignmentsWithReadsCount;
      }
      enterAssignment(assignmentExpression) {
        (assignmentExpression.operator === "=" ? this.openAssignmentsWithoutReads : this.openAssignmentsWithReads).add(assignmentExpression);
      }
      exitAssignment(assignmentExpression) {
        this.openAssignmentsWithoutReads.delete(assignmentExpression);
        this.openAssignmentsWithReads.delete(assignmentExpression);
      }
      exitAwaitOrYield(node, surroundingFunction) {
        return [...this.openAssignmentsWithReads].filter(assignment => !isLocalVariableWithoutEscape(assignment.left, surroundingFunction)).forEach(assignment => {
          if (!alreadyReportedAssignments.has(assignment)) {
            reportAssignment(assignment);
            alreadyReportedAssignments.add(assignment);
          }
        });
      }
      exitIdentifierOrMemberExpression(node) {
        [...this.openAssignmentsWithoutReads].filter(assignment => assignment.left !== node && assignment.left.type === node.type && astUtils.equalTokens(assignment.left, node, sourceCode)).forEach(assignment => {
          this.openAssignmentsWithoutReads.delete(assignment);
          this.openAssignmentsWithReads.add(assignment);
        });
      }
    }

    /**
     * If the control flow graph of a function enters an assignment expression, then does the
     * both of the following steps in order (possibly with other steps in between) before exiting the
     * assignment expression, then the assignment might be using an outdated value.
     * 1. Enters a read of the variable or property assigned in the expression (not necessary if operator assignment is used)
     * 2. Exits an `await` or `yield` expression
     *
     * This function checks for the outdated values and reports them.
     * @param {CodePathSegment} codePathSegment The current code path segment to traverse
     * @param {ASTNode} surroundingFunction The function node containing the code path segment
     * @returns {void}
     */
    function findOutdatedReads(codePathSegment, surroundingFunction) {
      let {
        stateBySegmentStart = new WeakMap(),
        stateBySegmentEnd = new WeakMap()
      } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!stateBySegmentStart.has(codePathSegment)) {
        stateBySegmentStart.set(codePathSegment, new AssignmentTrackerState());
      }
      const currentState = stateBySegmentStart.get(codePathSegment).copy();
      expressionsByCodePathSegment.get(codePathSegment).forEach(_ref => {
        let {
          entering,
          node
        } = _ref;
        if (node.type === "AssignmentExpression") {
          if (entering) {
            currentState.enterAssignment(node);
          } else {
            currentState.exitAssignment(node);
          }
        } else if (!entering && (node.type === "AwaitExpression" || node.type === "YieldExpression")) {
          currentState.exitAwaitOrYield(node, surroundingFunction);
        } else if (!entering && (node.type === "Identifier" || node.type === "MemberExpression")) {
          currentState.exitIdentifierOrMemberExpression(node);
        }
      });
      stateBySegmentEnd.set(codePathSegment, currentState);
      codePathSegment.nextSegments.forEach(nextSegment => {
        if (stateBySegmentStart.has(nextSegment)) {
          if (!stateBySegmentStart.get(nextSegment).merge(currentState)) {
            /*
             * This segment has already been processed with the given set of inputs;
             * no need to do it again. After no new state is available to process
             * for any control flow segment in the graph, the analysis reaches a fixpoint and
             * traversal stops.
             */
            return;
          }
        } else {
          stateBySegmentStart.set(nextSegment, currentState.copy());
        }
        findOutdatedReads(nextSegment, surroundingFunction, {
          stateBySegmentStart,
          stateBySegmentEnd
        });
      });
    }

    //----------------------------------------------------------------------
    // Public
    //----------------------------------------------------------------------

    const currentCodePathSegmentStack = [];
    let currentCodePathSegment = null;
    const functionStack = [];
    return {
      onCodePathStart() {
        currentCodePathSegmentStack.push(currentCodePathSegment);
      },
      onCodePathEnd(codePath, node) {
        currentCodePathSegment = currentCodePathSegmentStack.pop();
        if (astUtils.isFunction(node) && (node.async || node.generator)) {
          findOutdatedReads(codePath.initialSegment, node);
        }
      },
      onCodePathSegmentStart(segment) {
        currentCodePathSegment = segment;
        expressionsByCodePathSegment.set(segment, []);
      },
      "AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression"(node) {
        expressionsByCodePathSegment.get(currentCodePathSegment).push({
          entering: true,
          node
        });
      },
      "AssignmentExpression, Identifier, MemberExpression, AwaitExpression, YieldExpression:exit"(node) {
        expressionsByCodePathSegment.get(currentCodePathSegment).push({
          entering: false,
          node
        });
      },
      ":function"(node) {
        functionStack.push(node);
      },
      ":function:exit"() {
        functionStack.pop();
      },
      Identifier(node) {
        if (functionStack.length) {
          identifierToSurroundingFunctionMap.set(node, functionStack[functionStack.length - 1]);
        }
      }
    };
  }
};

/***/ }),
/* 450 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to disallow async functions which have no `await` expression.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Capitalize the 1st letter of the given text.
 *
 * @param {string} text - The text to capitalize.
 * @returns {string} The text that the 1st letter was capitalized.
 */
function capitalizeFirstLetter(text) {
  return text[0].toUpperCase() + text.slice(1);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow async functions which have no `await` expression",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-await"
    },
    schema: []
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    let scopeInfo = null;

    /**
     * Push the scope info object to the stack.
     *
     * @returns {void}
     */
    function enterFunction() {
      scopeInfo = {
        upper: scopeInfo,
        hasAwait: false
      };
    }

    /**
     * Pop the top scope info object from the stack.
     * Also, it reports the function if needed.
     *
     * @param {ASTNode} node - The node to report.
     * @returns {void}
     */
    function exitFunction(node) {
      if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
        context.report({
          node,
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          message: "{{name}} has no 'await' expression.",
          data: {
            name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))
          }
        });
      }
      scopeInfo = scopeInfo.upper;
    }
    return {
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      ArrowFunctionExpression: enterFunction,
      "FunctionDeclaration:exit": exitFunction,
      "FunctionExpression:exit": exitFunction,
      "ArrowFunctionExpression:exit": exitFunction,
      AwaitExpression() {
        scopeInfo.hasAwait = true;
      },
      ForOfStatement(node) {
        if (node.await) {
          scopeInfo.hasAwait = true;
        }
      }
    };
  }
};

/***/ }),
/* 451 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check for jsdoc presence.
 * @author Gyandeep Singh
 */


module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require JSDoc comments",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        require: {
          type: "object",
          properties: {
            ClassDeclaration: {
              type: "boolean",
              default: false
            },
            MethodDefinition: {
              type: "boolean",
              default: false
            },
            FunctionDeclaration: {
              type: "boolean",
              default: true
            },
            ArrowFunctionExpression: {
              type: "boolean",
              default: false
            },
            FunctionExpression: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false,
          default: {}
        }
      },
      additionalProperties: false
    }],
    deprecated: true,
    replacedBy: []
  },
  create(context) {
    const source = context.getSourceCode();
    const DEFAULT_OPTIONS = {
      FunctionDeclaration: true,
      MethodDefinition: false,
      ClassDeclaration: false,
      ArrowFunctionExpression: false,
      FunctionExpression: false
    };
    const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require);

    /**
     * Report the error message
     * @param {ASTNode} node node to report
     * @returns {void}
     */
    function report(node) {
      context.report({
        node,
        message: "Missing JSDoc comment."
      });
    }

    /**
     * Check if the jsdoc comment is present or not.
     * @param {ASTNode} node node to examine
     * @returns {void}
     */
    function checkJsDoc(node) {
      const jsdocComment = source.getJSDocComment(node);
      if (!jsdocComment) {
        report(node);
      }
    }
    return {
      FunctionDeclaration(node) {
        if (options.FunctionDeclaration) {
          checkJsDoc(node);
        }
      },
      FunctionExpression(node) {
        if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
          checkJsDoc(node);
        }
      },
      ClassDeclaration(node) {
        if (options.ClassDeclaration) {
          checkJsDoc(node);
        }
      },
      ArrowFunctionExpression(node) {
        if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
          checkJsDoc(node);
        }
      }
    };
  }
};

/***/ }),
/* 452 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce the use of `u` flag on RegExp.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const {
  CALL,
  CONSTRUCT,
  ReferenceTracker,
  getStringIfConstant
} = __webpack_require__(339);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of `u` flag on RegExp",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/require-unicode-regexp"
    },
    messages: {
      requireUFlag: "Use the 'u' flag."
    },
    schema: []
  },
  create(context) {
    return {
      "Literal[regex]"(node) {
        const flags = node.regex.flags || "";
        if (!flags.includes("u")) {
          context.report({
            node,
            messageId: "requireUFlag"
          });
        }
      },
      Program() {
        const scope = context.getScope();
        const tracker = new ReferenceTracker(scope);
        const trackMap = {
          RegExp: {
            [CALL]: true,
            [CONSTRUCT]: true
          }
        };
        for (const {
          node
        } of tracker.iterateGlobalReferences(trackMap)) {
          const flagsNode = node.arguments[1];
          const flags = getStringIfConstant(flagsNode, scope);
          if (!flagsNode || typeof flags === "string" && !flags.includes("u")) {
            context.report({
              node,
              messageId: "requireUFlag"
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 453 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag the generator functions that does not have yield.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require generator functions to contain `yield`",
      category: "ECMAScript 6",
      recommended: true,
      url: "https://eslint.org/docs/rules/require-yield"
    },
    schema: []
  },
  create(context) {
    const stack = [];

    /**
     * If the node is a generator function, start counting `yield` keywords.
     * @param {Node} node - A function node to check.
     * @returns {void}
     */
    function beginChecking(node) {
      if (node.generator) {
        stack.push(0);
      }
    }

    /**
     * If the node is a generator function, end counting `yield` keywords, then
     * reports result.
     * @param {Node} node - A function node to check.
     * @returns {void}
     */
    function endChecking(node) {
      if (!node.generator) {
        return;
      }
      const countYield = stack.pop();
      if (countYield === 0 && node.body.body.length > 0) {
        context.report({
          node,
          message: "This generator function does not have 'yield'."
        });
      }
    }
    return {
      FunctionDeclaration: beginChecking,
      "FunctionDeclaration:exit": endChecking,
      FunctionExpression: beginChecking,
      "FunctionExpression:exit": endChecking,
      // Increases the count of `yield` keyword.
      YieldExpression() {
        /* istanbul ignore else */
        if (stack.length > 0) {
          stack[stack.length - 1] += 1;
        }
      }
    };
  }
};

/***/ }),
/* 454 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Enforce spacing between rest and spread operators and their expressions.
 * @author Kai Cataldo
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing between rest and spread operators and their expressions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/rest-spread-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode(),
      alwaysSpace = context.options[0] === "always";

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Checks whitespace between rest/spread operators and their expressions
     * @param {ASTNode} node - The node to check
     * @returns {void}
     */
    function checkWhiteSpace(node) {
      const operator = sourceCode.getFirstToken(node),
        nextToken = sourceCode.getTokenAfter(operator),
        hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
      let type;
      switch (node.type) {
        case "SpreadElement":
          type = "spread";
          if (node.parent.type === "ObjectExpression") {
            type += " property";
          }
          break;
        case "RestElement":
          type = "rest";
          if (node.parent.type === "ObjectPattern") {
            type += " property";
          }
          break;
        case "ExperimentalSpreadProperty":
          type = "spread property";
          break;
        case "ExperimentalRestProperty":
          type = "rest property";
          break;
        default:
          return;
      }
      if (alwaysSpace && !hasWhitespace) {
        context.report({
          node,
          loc: {
            line: operator.loc.end.line,
            column: operator.loc.end.column
          },
          message: "Expected whitespace after {{type}} operator.",
          data: {
            type
          },
          fix(fixer) {
            return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
          }
        });
      } else if (!alwaysSpace && hasWhitespace) {
        context.report({
          node,
          loc: {
            line: operator.loc.end.line,
            column: operator.loc.end.column
          },
          message: "Unexpected whitespace after {{type}} operator.",
          data: {
            type
          },
          fix(fixer) {
            return fixer.removeRange([operator.range[1], nextToken.range[0]]);
          }
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      SpreadElement: checkWhiteSpace,
      RestElement: checkWhiteSpace,
      ExperimentalSpreadProperty: checkWhiteSpace,
      ExperimentalRestProperty: checkWhiteSpace
    };
  }
};

/***/ }),
/* 455 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag missing semicolons.
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const FixTracker = __webpack_require__(305);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow semicolons instead of ASI",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            beforeStatementContinuationChars: {
              enum: ["always", "any", "never"]
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            omitLastInOneLineBlock: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }],
        minItems: 0,
        maxItems: 2
      }]
    }
  },
  create(context) {
    const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`
    const options = context.options[1];
    const never = context.options[0] === "never";
    const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
    const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Reports a semicolon error with appropriate location and message.
     * @param {ASTNode} node The node with an extra or missing semicolon.
     * @param {boolean} missing True if the semicolon is missing.
     * @returns {void}
     */
    function report(node, missing) {
      const lastToken = sourceCode.getLastToken(node);
      let message,
        fix,
        loc = lastToken.loc;
      if (!missing) {
        message = "Missing semicolon.";
        loc = loc.end;
        fix = function (fixer) {
          return fixer.insertTextAfter(lastToken, ";");
        };
      } else {
        message = "Extra semicolon.";
        loc = loc.start;
        fix = function (fixer) {
          /*
           * Expand the replacement range to include the surrounding
           * tokens to avoid conflicting with no-extra-semi.
           * https://github.com/eslint/eslint/issues/7928
           */
          return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
        };
      }
      context.report({
        node,
        loc,
        message,
        fix
      });
    }

    /**
     * Check whether a given semicolon token is redandant.
     * @param {Token} semiToken A semicolon token to check.
     * @returns {boolean} `true` if the next token is `;` or `}`.
     */
    function isRedundantSemi(semiToken) {
      const nextToken = sourceCode.getTokenAfter(semiToken);
      return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
    }

    /**
     * Check whether a given token is the closing brace of an arrow function.
     * @param {Token} lastToken A token to check.
     * @returns {boolean} `true` if the token is the closing brace of an arrow function.
     */
    function isEndOfArrowBlock(lastToken) {
      if (!astUtils.isClosingBraceToken(lastToken)) {
        return false;
      }
      const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);
      return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
    }

    /**
     * Check whether a given node is on the same line with the next token.
     * @param {Node} node A statement node to check.
     * @returns {boolean} `true` if the node is on the same line with the next token.
     */
    function isOnSameLineWithNextToken(node) {
      const prevToken = sourceCode.getLastToken(node, 1);
      const nextToken = sourceCode.getTokenAfter(node);
      return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
    }

    /**
     * Check whether a given node can connect the next line if the next line is unreliable.
     * @param {Node} node A statement node to check.
     * @returns {boolean} `true` if the node can connect the next line.
     */
    function maybeAsiHazardAfter(node) {
      const t = node.type;
      if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
        return false;
      }
      if (t === "ReturnStatement") {
        return Boolean(node.argument);
      }
      if (t === "ExportNamedDeclaration") {
        return Boolean(node.declaration);
      }
      if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
        return false;
      }
      return true;
    }

    /**
     * Check whether a given token can connect the previous statement.
     * @param {Token} token A token to check.
     * @returns {boolean} `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.
     */
    function maybeAsiHazardBefore(token) {
      return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
    }

    /**
     * Check if the semicolon of a given node is unnecessary, only true if:
     *   - next token is a valid statement divider (`;` or `}`).
     *   - next token is on a new line and the node is not connectable to the new line.
     * @param {Node} node A statement node to check.
     * @returns {boolean} whether the semicolon is unnecessary.
     */
    function canRemoveSemicolon(node) {
      if (isRedundantSemi(sourceCode.getLastToken(node))) {
        return true; // `;;` or `;}`
      }
      if (isOnSameLineWithNextToken(node)) {
        return false; // One liner.
      }
      if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
        return true; // ASI works. This statement doesn't connect to the next.
      }
      if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
        return true; // ASI works. The next token doesn't connect to this statement.
      }
      return false;
    }

    /**
     * Checks a node to see if it's in a one-liner block statement.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} whether the node is in a one-liner block statement.
     */
    function isOneLinerBlock(node) {
      const parent = node.parent;
      const nextToken = sourceCode.getTokenAfter(node);
      if (!nextToken || nextToken.value !== "}") {
        return false;
      }
      return !!parent && parent.type === "BlockStatement" && parent.loc.start.line === parent.loc.end.line;
    }

    /**
     * Checks a node to see if it's followed by a semicolon.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */
    function checkForSemicolon(node) {
      const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));
      if (never) {
        if (isSemi && canRemoveSemicolon(node)) {
          report(node, true);
        } else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
          report(node);
        }
      } else {
        const oneLinerBlock = exceptOneLine && isOneLinerBlock(node);
        if (isSemi && oneLinerBlock) {
          report(node, true);
        } else if (!isSemi && !oneLinerBlock) {
          report(node);
        }
      }
    }

    /**
     * Checks to see if there's a semicolon after a variable declaration.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */
    function checkForSemicolonForVariableDeclaration(node) {
      const parent = node.parent;
      if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {
        checkForSemicolon(node);
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      VariableDeclaration: checkForSemicolonForVariableDeclaration,
      ExpressionStatement: checkForSemicolon,
      ReturnStatement: checkForSemicolon,
      ThrowStatement: checkForSemicolon,
      DoWhileStatement: checkForSemicolon,
      DebuggerStatement: checkForSemicolon,
      BreakStatement: checkForSemicolon,
      ContinueStatement: checkForSemicolon,
      ImportDeclaration: checkForSemicolon,
      ExportAllDeclaration: checkForSemicolon,
      ExportNamedDeclaration(node) {
        if (!node.declaration) {
          checkForSemicolon(node);
        }
      },
      ExportDefaultDeclaration(node) {
        if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {
          checkForSemicolon(node);
        }
      }
    };
  }
};

/***/ }),
/* 456 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Validates spacing before and after semicolon
 * @author Mathias Schreck
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after semicolons",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const config = context.options[0],
      sourceCode = context.getSourceCode();
    let requireSpaceBefore = false,
      requireSpaceAfter = true;
    if (typeof config === "object") {
      requireSpaceBefore = config.before;
      requireSpaceAfter = config.after;
    }

    /**
     * Checks if a given token has leading whitespace.
     * @param {Object} token The token to check.
     * @returns {boolean} True if the given token has leading space, false if not.
     */
    function hasLeadingSpace(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
    }

    /**
     * Checks if a given token has trailing whitespace.
     * @param {Object} token The token to check.
     * @returns {boolean} True if the given token has trailing space, false if not.
     */
    function hasTrailingSpace(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
    }

    /**
     * Checks if the given token is the last token in its line.
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the token is the last in its line.
     */
    function isLastTokenInCurrentLine(token) {
      const tokenAfter = sourceCode.getTokenAfter(token);
      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
    }

    /**
     * Checks if the given token is the first token in its line
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the token is the first in its line.
     */
    function isFirstTokenInCurrentLine(token) {
      const tokenBefore = sourceCode.getTokenBefore(token);
      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
    }

    /**
     * Checks if the next token of a given token is a closing parenthesis.
     * @param {Token} token The token to check.
     * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.
     */
    function isBeforeClosingParen(token) {
      const nextToken = sourceCode.getTokenAfter(token);
      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
    }

    /**
     * Reports if the given token has invalid spacing.
     * @param {Token} token The semicolon token to check.
     * @param {ASTNode} node The corresponding node of the token.
     * @returns {void}
     */
    function checkSemicolonSpacing(token, node) {
      if (astUtils.isSemicolonToken(token)) {
        const location = token.loc.start;
        if (hasLeadingSpace(token)) {
          if (!requireSpaceBefore) {
            context.report({
              node,
              loc: location,
              message: "Unexpected whitespace before semicolon.",
              fix(fixer) {
                const tokenBefore = sourceCode.getTokenBefore(token);
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
              }
            });
          }
        } else {
          if (requireSpaceBefore) {
            context.report({
              node,
              loc: location,
              message: "Missing whitespace before semicolon.",
              fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }
            });
          }
        }
        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
          if (hasTrailingSpace(token)) {
            if (!requireSpaceAfter) {
              context.report({
                node,
                loc: location,
                message: "Unexpected whitespace after semicolon.",
                fix(fixer) {
                  const tokenAfter = sourceCode.getTokenAfter(token);
                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                }
              });
            }
          } else {
            if (requireSpaceAfter) {
              context.report({
                node,
                loc: location,
                message: "Missing whitespace after semicolon.",
                fix(fixer) {
                  return fixer.insertTextAfter(token, " ");
                }
              });
            }
          }
        }
      }
    }

    /**
     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
     * @param {ASTNode} node The node to check.
     * @returns {void}
     */
    function checkNode(node) {
      const token = sourceCode.getLastToken(node);
      checkSemicolonSpacing(token, node);
    }
    return {
      VariableDeclaration: checkNode,
      ExpressionStatement: checkNode,
      BreakStatement: checkNode,
      ContinueStatement: checkNode,
      DebuggerStatement: checkNode,
      ReturnStatement: checkNode,
      ThrowStatement: checkNode,
      ImportDeclaration: checkNode,
      ExportNamedDeclaration: checkNode,
      ExportAllDeclaration: checkNode,
      ExportDefaultDeclaration: checkNode,
      ForStatement(node) {
        if (node.init) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
        }
        if (node.test) {
          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
        }
      }
    };
  }
};

/***/ }),
/* 457 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce location of semicolons.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const SELECTOR = `:matches(${["BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ImportDeclaration", "ReturnStatement", "ThrowStatement", "VariableDeclaration"].join(",")})`;

/**
 * Get the child node list of a given node.
 * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.
 * This is used to check whether a node is the first/last child.
 * @param {Node} node A node to get child node list.
 * @returns {Node[]|null} The child node list.
 */
function getChildren(node) {
  const t = node.type;
  if (t === "BlockStatement" || t === "Program") {
    return node.body;
  }
  if (t === "SwitchCase") {
    return node.consequent;
  }
  return null;
}

/**
 * Check whether a given node is the last statement in the parent block.
 * @param {Node} node A node to check.
 * @returns {boolean} `true` if the node is the last statement in the parent block.
 */
function isLastChild(node) {
  const t = node.parent.type;
  if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
    // before `else` keyword.
    return true;
  }
  if (t === "DoWhileStatement") {
    // before `while` keyword.
    return true;
  }
  const nodeList = getChildren(node.parent);
  return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.
}
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce location of semicolons",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/semi-style"
    },
    schema: [{
      enum: ["last", "first"]
    }],
    fixable: "whitespace"
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const option = context.options[0] || "last";

    /**
     * Check the given semicolon token.
     * @param {Token} semiToken The semicolon token to check.
     * @param {"first"|"last"} expected The expected location to check.
     * @returns {void}
     */
    function check(semiToken, expected) {
      const prevToken = sourceCode.getTokenBefore(semiToken);
      const nextToken = sourceCode.getTokenAfter(semiToken);
      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);
      if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
        context.report({
          loc: semiToken.loc,
          message: "Expected this semicolon to be at {{pos}}.",
          data: {
            pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
          },
          fix(fixer) {
            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
              return null;
            }
            const start = prevToken ? prevToken.range[1] : semiToken.range[0];
            const end = nextToken ? nextToken.range[0] : semiToken.range[1];
            const text = expected === "last" ? ";\n" : "\n;";
            return fixer.replaceTextRange([start, end], text);
          }
        });
      }
    }
    return {
      [SELECTOR](node) {
        if (option === "first" && isLastChild(node)) {
          return;
        }
        const lastToken = sourceCode.getLastToken(node);
        if (astUtils.isSemicolonToken(lastToken)) {
          check(lastToken, option);
        }
      },
      ForStatement(node) {
        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);
        if (firstSemi) {
          check(firstSemi, "last");
        }
        if (secondSemi) {
          check(secondSemi, "last");
        }
      }
    };
  }
};

/***/ }),
/* 458 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to require sorting of import declarations
 * @author Christian Schuller
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted import declarations within modules",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-imports"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: false
        },
        memberSyntaxSortOrder: {
          type: "array",
          items: {
            enum: ["none", "all", "multiple", "single"]
          },
          uniqueItems: true,
          minItems: 4,
          maxItems: 4
        },
        ignoreDeclarationSort: {
          type: "boolean",
          default: false
        },
        ignoreMemberSort: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create(context) {
    const configuration = context.options[0] || {},
      ignoreCase = configuration.ignoreCase || false,
      ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,
      ignoreMemberSort = configuration.ignoreMemberSort || false,
      memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
      sourceCode = context.getSourceCode();
    let previousDeclaration = null;

    /**
     * Gets the used member syntax style.
     *
     * import "my-module.js" --> none
     * import * as myModule from "my-module.js" --> all
     * import {myMember} from "my-module.js" --> single
     * import {foo, bar} from  "my-module.js" --> multiple
     *
     * @param {ASTNode} node - the ImportDeclaration node.
     * @returns {string} used member parameter style, ["all", "multiple", "single"]
     */
    function usedMemberSyntax(node) {
      if (node.specifiers.length === 0) {
        return "none";
      }
      if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
        return "all";
      }
      if (node.specifiers.length === 1) {
        return "single";
      }
      return "multiple";
    }

    /**
     * Gets the group by member parameter index for given declaration.
     * @param {ASTNode} node - the ImportDeclaration node.
     * @returns {number} the declaration group by member index.
     */
    function getMemberParameterGroupIndex(node) {
      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
    }

    /**
     * Gets the local name of the first imported module.
     * @param {ASTNode} node - the ImportDeclaration node.
     * @returns {?string} the local name of the first imported module.
     */
    function getFirstLocalMemberName(node) {
      if (node.specifiers[0]) {
        return node.specifiers[0].local.name;
      }
      return null;
    }
    return {
      ImportDeclaration(node) {
        if (!ignoreDeclarationSort) {
          if (previousDeclaration) {
            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
              previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
            let currentLocalMemberName = getFirstLocalMemberName(node),
              previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
            if (ignoreCase) {
              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
            }

            /*
             * When the current declaration uses a different member syntax,
             * then check if the ordering is correct.
             * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.
             */
            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                context.report({
                  node,
                  message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
                  data: {
                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                  }
                });
              }
            } else {
              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
                context.report({
                  node,
                  message: "Imports should be sorted alphabetically."
                });
              }
            }
          }
          previousDeclaration = node;
        }
        if (!ignoreMemberSort) {
          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === "ImportSpecifier");
          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;
          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);
          if (firstUnsortedIndex !== -1) {
            context.report({
              node: importSpecifiers[firstUnsortedIndex],
              message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
              data: {
                memberName: importSpecifiers[firstUnsortedIndex].local.name
              },
              fix(fixer) {
                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {
                  // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.
                  return null;
                }
                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers

                // Clone the importSpecifiers array to avoid mutating it
                .slice()

                // Sort the array into the desired order
                .sort((specifierA, specifierB) => {
                  const aName = getSortableName(specifierA);
                  const bName = getSortableName(specifierB);
                  return aName > bName ? 1 : -1;
                })

                // Build a string out of the sorted list of import specifiers and the text between the originals
                .reduce((sourceText, specifier, index) => {
                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);
                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
                }, ""));
              }
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 459 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require object keys to be sorted
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110),
  naturalCompare = __webpack_require__(460);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the property name of the given `Property` node.
 *
 * - If the property's key is an `Identifier` node, this returns the key's name
 *   whether it's a computed property or not.
 * - If the property has a static name, this returns the static name.
 * - Otherwise, this returns null.
 *
 * @param {ASTNode} node - The `Property` node to get.
 * @returns {string|null} The property name or null.
 * @private
 */
function getPropertyName(node) {
  return astUtils.getStaticPropertyName(node) || node.key.name || null;
}

/**
 * Functions which check that the given 2 names are in specific order.
 *
 * Postfix `I` is meant insensitive.
 * Postfix `N` is meant natual.
 *
 * @private
 */
const isValidOrders = {
  asc(a, b) {
    return a <= b;
  },
  ascI(a, b) {
    return a.toLowerCase() <= b.toLowerCase();
  },
  ascN(a, b) {
    return naturalCompare(a, b) <= 0;
  },
  ascIN(a, b) {
    return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
  },
  desc(a, b) {
    return isValidOrders.asc(b, a);
  },
  descI(a, b) {
    return isValidOrders.ascI(b, a);
  },
  descN(a, b) {
    return isValidOrders.ascN(b, a);
  },
  descIN(a, b) {
    return isValidOrders.ascIN(b, a);
  }
};

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require object keys to be sorted",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-keys"
    },
    schema: [{
      enum: ["asc", "desc"]
    }, {
      type: "object",
      properties: {
        caseSensitive: {
          type: "boolean",
          default: true
        },
        natural: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    // Parse options.
    const order = context.options[0] || "asc";
    const options = context.options[1];
    const insensitive = options && options.caseSensitive === false;
    const natual = options && options.natural;
    const isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natual ? "N" : "")];

    // The stack to save the previous property's name for each object literals.
    let stack = null;
    return {
      ObjectExpression() {
        stack = {
          upper: stack,
          prevName: null
        };
      },
      "ObjectExpression:exit"() {
        stack = stack.upper;
      },
      SpreadElement(node) {
        if (node.parent.type === "ObjectExpression") {
          stack.prevName = null;
        }
      },
      Property(node) {
        if (node.parent.type === "ObjectPattern") {
          return;
        }
        const prevName = stack.prevName;
        const thisName = getPropertyName(node);
        stack.prevName = thisName || prevName;
        if (!prevName || !thisName) {
          return;
        }
        if (!isValidOrder(prevName, thisName)) {
          context.report({
            node,
            loc: node.key.loc,
            message: "Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
            data: {
              thisName,
              prevName,
              order,
              insensitive: insensitive ? "insensitive " : "",
              natual: natual ? "natural " : ""
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 460 */
/***/ ((module) => {

/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */

var naturalCompare = function (a, b) {
  var i,
    codeA,
    codeB = 1,
    posA = 0,
    posB = 0,
    alphabet = String.alphabet;
  function getCode(str, pos, code) {
    if (code) {
      for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
      return +str.slice(pos - 1, i);
    }
    code = alphabet && alphabet.indexOf(str.charAt(pos));
    return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 // -
    : code < 48 ? code - 1 : code < 58 ? code + 18 // 0-9
    : code < 65 ? code - 11 : code < 91 ? code + 11 // A-Z
    : code < 97 ? code - 37 : code < 123 ? code + 5 // a-z
    : code - 63;
  }
  if ((a += "") != (b += "")) for (; codeB;) {
    codeA = getCode(a, posA++);
    codeB = getCode(b, posB++);
    if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
      codeA = getCode(a, posA, posA);
      codeB = getCode(b, posB, posA = i);
      posB = i;
    }
    if (codeA != codeB) return codeA < codeB ? -1 : 1;
  }
  return 0;
};
try {
  module.exports = naturalCompare;
} catch (e) {
  String.naturalCompare = naturalCompare;
}

/***/ }),
/* 461 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to require sorting of variables within a single Variable Declaration block
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require variables within the same declaration block to be sorted",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/sort-vars"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code"
  },
  create(context) {
    const configuration = context.options[0] || {},
      ignoreCase = configuration.ignoreCase || false,
      sourceCode = context.getSourceCode();
    return {
      VariableDeclaration(node) {
        const idDeclarations = node.declarations.filter(decl => decl.id.type === "Identifier");
        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;
        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== "Literal");
        let fixed = false;
        idDeclarations.slice(1).reduce((memo, decl) => {
          const lastVariableName = getSortableName(memo),
            currentVariableName = getSortableName(decl);
          if (currentVariableName < lastVariableName) {
            context.report({
              node: decl,
              message: "Variables within the same declaration block should be sorted alphabetically.",
              fix(fixer) {
                if (unfixable || fixed) {
                  return null;
                }
                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations

                // Clone the idDeclarations array to avoid mutating it
                .slice()

                // Sort the array into the desired order
                .sort((declA, declB) => {
                  const aName = getSortableName(declA);
                  const bName = getSortableName(declB);
                  return aName > bName ? 1 : -1;
                })

                // Build a string out of the sorted list of identifier declarations and the text between the originals
                .reduce((sourceText, identifier, index) => {
                  const textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);
                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
                }, ""));
              }
            });
            fixed = true;
            return memo;
          }
          return decl;
        }, idDeclarations[0]);
      }
    };
  }
};

/***/ }),
/* 462 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview A rule to ensure whitespace before blocks.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */



const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before blocks",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-before-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          keywords: {
            enum: ["always", "never", "off"]
          },
          functions: {
            enum: ["always", "never", "off"]
          },
          classes: {
            enum: ["always", "never", "off"]
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const config = context.options[0],
      sourceCode = context.getSourceCode();
    let alwaysFunctions = true,
      alwaysKeywords = true,
      alwaysClasses = true,
      neverFunctions = false,
      neverKeywords = false,
      neverClasses = false;
    if (typeof config === "object") {
      alwaysFunctions = config.functions === "always";
      alwaysKeywords = config.keywords === "always";
      alwaysClasses = config.classes === "always";
      neverFunctions = config.functions === "never";
      neverKeywords = config.keywords === "never";
      neverClasses = config.classes === "never";
    } else if (config === "never") {
      alwaysFunctions = false;
      alwaysKeywords = false;
      alwaysClasses = false;
      neverFunctions = true;
      neverKeywords = true;
      neverClasses = true;
    }

    /**
     * Checks whether or not a given token is an arrow operator (=>) or a keyword
     * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.
     *
     * @param {Token} token - A token to check.
     * @returns {boolean} `true` if the token is an arrow operator.
     */
    function isConflicted(token) {
      return token.type === "Punctuator" && token.value === "=>" || token.type === "Keyword";
    }

    /**
     * Checks the given BlockStatement node has a preceding space if it doesnt start on a new line.
     * @param {ASTNode|Token} node The AST node of a BlockStatement.
     * @returns {void} undefined.
     */
    function checkPrecedingSpace(node) {
      const precedingToken = sourceCode.getTokenBefore(node);
      if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
        const parent = context.getAncestors().pop();
        let requireSpace;
        let requireNoSpace;
        if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
          requireSpace = alwaysFunctions;
          requireNoSpace = neverFunctions;
        } else if (node.type === "ClassBody") {
          requireSpace = alwaysClasses;
          requireNoSpace = neverClasses;
        } else {
          requireSpace = alwaysKeywords;
          requireNoSpace = neverKeywords;
        }
        if (requireSpace && !hasSpace) {
          context.report({
            node,
            message: "Missing space before opening brace.",
            fix(fixer) {
              return fixer.insertTextBefore(node, " ");
            }
          });
        } else if (requireNoSpace && hasSpace) {
          context.report({
            node,
            message: "Unexpected space before opening brace.",
            fix(fixer) {
              return fixer.removeRange([precedingToken.range[1], node.range[0]]);
            }
          });
        }
      }
    }

    /**
     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.
     * @param {ASTNode} node The node of a SwitchStatement.
     * @returns {void} undefined.
     */
    function checkSpaceBeforeCaseBlock(node) {
      const cases = node.cases;
      let openingBrace;
      if (cases.length > 0) {
        openingBrace = sourceCode.getTokenBefore(cases[0]);
      } else {
        openingBrace = sourceCode.getLastToken(node, 1);
      }
      checkPrecedingSpace(openingBrace);
    }
    return {
      BlockStatement: checkPrecedingSpace,
      ClassBody: checkPrecedingSpace,
      SwitchStatement: checkSpaceBeforeCaseBlock
    };
  }
};

/***/ }),
/* 463 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to validate spacing before function paren.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before `function` definition opening parenthesis",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-before-function-paren"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          anonymous: {
            enum: ["always", "never", "ignore"]
          },
          named: {
            enum: ["always", "never", "ignore"]
          },
          asyncArrow: {
            enum: ["always", "never", "ignore"]
          }
        },
        additionalProperties: false
      }]
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
    const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};

    /**
     * Determines whether a function has a name.
     * @param {ASTNode} node The function node.
     * @returns {boolean} Whether the function has a name.
     */
    function isNamedFunction(node) {
      if (node.id) {
        return true;
      }
      const parent = node.parent;
      return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
    }

    /**
     * Gets the config for a given function
     * @param {ASTNode} node The function node
     * @returns {string} "always", "never", or "ignore"
     */
    function getConfigForFunction(node) {
      if (node.type === "ArrowFunctionExpression") {
        // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar
        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {
          skip: 1
        }))) {
          return overrideConfig.asyncArrow || baseConfig;
        }
      } else if (isNamedFunction(node)) {
        return overrideConfig.named || baseConfig;

        // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`
      } else if (!node.generator) {
        return overrideConfig.anonymous || baseConfig;
      }
      return "ignore";
    }

    /**
     * Checks the parens of a function node
     * @param {ASTNode} node A function node
     * @returns {void}
     */
    function checkFunction(node) {
      const functionConfig = getConfigForFunction(node);
      if (functionConfig === "ignore") {
        return;
      }
      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
      const leftToken = sourceCode.getTokenBefore(rightToken);
      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);
      if (hasSpacing && functionConfig === "never") {
        context.report({
          node,
          loc: leftToken.loc.end,
          message: "Unexpected space before function parentheses.",
          fix: fixer => fixer.removeRange([leftToken.range[1], rightToken.range[0]])
        });
      } else if (!hasSpacing && functionConfig === "always") {
        context.report({
          node,
          loc: leftToken.loc.end,
          message: "Missing space before function parentheses.",
          fix: fixer => fixer.insertTextAfter(leftToken, " ")
        });
      }
    }
    return {
      ArrowFunctionExpression: checkFunction,
      FunctionDeclaration: checkFunction,
      FunctionExpression: checkFunction
    };
  }
};

/***/ }),
/* 464 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Disallows or enforces spaces inside of parentheses.
 * @author Jonathan Rajavuori
 */


const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside parentheses",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-in-parens"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["{}", "[]", "()", "empty"]
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
      REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
      ALWAYS = context.options[0] === "always",
      exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],
      options = {};
    let exceptions;
    if (exceptionsArrayOptions.length) {
      options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
      options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
      options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
      options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
    }

    /**
     * Produces an object with the opener and closer exception values
     * @returns {Object} `openers` and `closers` exception values
     * @private
     */
    function getExceptions() {
      const openers = [],
        closers = [];
      if (options.braceException) {
        openers.push("{");
        closers.push("}");
      }
      if (options.bracketException) {
        openers.push("[");
        closers.push("]");
      }
      if (options.parenException) {
        openers.push("(");
        closers.push(")");
      }
      if (options.empty) {
        openers.push(")");
        closers.push("(");
      }
      return {
        openers,
        closers
      };
    }

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------
    const sourceCode = context.getSourceCode();

    /**
     * Determines if a token is one of the exceptions for the opener paren
     * @param {Object} token The token to check
     * @returns {boolean} True if the token is one of the exceptions for the opener paren
     */
    function isOpenerException(token) {
      return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
    }

    /**
     * Determines if a token is one of the exceptions for the closer paren
     * @param {Object} token The token to check
     * @returns {boolean} True if the token is one of the exceptions for the closer paren
     */
    function isCloserException(token) {
      return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
    }

    /**
     * Determines if an opener paren should have a missing space after it
     * @param {Object} left The paren token
     * @param {Object} right The token after it
     * @returns {boolean} True if the paren should have a space
     */
    function shouldOpenerHaveSpace(left, right) {
      if (sourceCode.isSpaceBetweenTokens(left, right)) {
        return false;
      }
      if (ALWAYS) {
        if (astUtils.isClosingParenToken(right)) {
          return false;
        }
        return !isOpenerException(right);
      }
      return isOpenerException(right);
    }

    /**
     * Determines if an closer paren should have a missing space after it
     * @param {Object} left The token before the paren
     * @param {Object} right The paren token
     * @returns {boolean} True if the paren should have a space
     */
    function shouldCloserHaveSpace(left, right) {
      if (astUtils.isOpeningParenToken(left)) {
        return false;
      }
      if (sourceCode.isSpaceBetweenTokens(left, right)) {
        return false;
      }
      if (ALWAYS) {
        return !isCloserException(left);
      }
      return isCloserException(left);
    }

    /**
     * Determines if an opener paren should not have an existing space after it
     * @param {Object} left The paren token
     * @param {Object} right The token after it
     * @returns {boolean} True if the paren should reject the space
     */
    function shouldOpenerRejectSpace(left, right) {
      if (right.type === "Line") {
        return false;
      }
      if (!astUtils.isTokenOnSameLine(left, right)) {
        return false;
      }
      if (!sourceCode.isSpaceBetweenTokens(left, right)) {
        return false;
      }
      if (ALWAYS) {
        return isOpenerException(right);
      }
      return !isOpenerException(right);
    }

    /**
     * Determines if an closer paren should not have an existing space after it
     * @param {Object} left The token before the paren
     * @param {Object} right The paren token
     * @returns {boolean} True if the paren should reject the space
     */
    function shouldCloserRejectSpace(left, right) {
      if (astUtils.isOpeningParenToken(left)) {
        return false;
      }
      if (!astUtils.isTokenOnSameLine(left, right)) {
        return false;
      }
      if (!sourceCode.isSpaceBetweenTokens(left, right)) {
        return false;
      }
      if (ALWAYS) {
        return isCloserException(left);
      }
      return !isCloserException(left);
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: function checkParenSpaces(node) {
        exceptions = getExceptions();
        const tokens = sourceCode.tokensAndComments;
        tokens.forEach((token, i) => {
          const prevToken = tokens[i - 1];
          const nextToken = tokens[i + 1];
          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
            return;
          }
          if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
            context.report({
              node,
              loc: token.loc.start,
              message: MISSING_SPACE_MESSAGE,
              fix(fixer) {
                return fixer.insertTextAfter(token, " ");
              }
            });
          } else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
            context.report({
              node,
              loc: token.loc.start,
              message: REJECTED_SPACE_MESSAGE,
              fix(fixer) {
                return fixer.removeRange([token.range[1], nextToken.range[0]]);
              }
            });
          } else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
            // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);
            context.report({
              node,
              loc: token.loc.start,
              message: MISSING_SPACE_MESSAGE,
              fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }
            });
          } else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
            context.report({
              node,
              loc: token.loc.start,
              message: REJECTED_SPACE_MESSAGE,
              fix(fixer) {
                return fixer.removeRange([prevToken.range[1], token.range[0]]);
              }
            });
          }
        });
      }
    };
  }
};

/***/ }),
/* 465 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Require spaces around infix operators
 * @author Michael Ficarra
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require spacing around infix operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-infix-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        int32Hint: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
    const sourceCode = context.getSourceCode();

    /**
     * Returns the first token which violates the rule
     * @param {ASTNode} left - The left node of the main node
     * @param {ASTNode} right - The right node of the main node
     * @param {string} op - The operator of the main node
     * @returns {Object} The violator token or null
     * @private
     */
    function getFirstNonSpacedToken(left, right, op) {
      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);
      const prev = sourceCode.getTokenBefore(operator);
      const next = sourceCode.getTokenAfter(operator);
      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {
        return operator;
      }
      return null;
    }

    /**
     * Reports an AST node as a rule violation
     * @param {ASTNode} mainNode - The node to report
     * @param {Object} culpritToken - The token which has a problem
     * @returns {void}
     * @private
     */
    function report(mainNode, culpritToken) {
      context.report({
        node: mainNode,
        loc: culpritToken.loc.start,
        message: "Operator '{{operator}}' must be spaced.",
        data: {
          operator: culpritToken.value
        },
        fix(fixer) {
          const previousToken = sourceCode.getTokenBefore(culpritToken);
          const afterToken = sourceCode.getTokenAfter(culpritToken);
          let fixString = "";
          if (culpritToken.range[0] - previousToken.range[1] === 0) {
            fixString = " ";
          }
          fixString += culpritToken.value;
          if (afterToken.range[0] - culpritToken.range[1] === 0) {
            fixString += " ";
          }
          return fixer.replaceText(culpritToken, fixString);
        }
      });
    }

    /**
     * Check if the node is binary then report
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkBinary(node) {
      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
      const rightNode = node.right;

      // search for = in AssignmentPattern nodes
      const operator = node.operator || "=";
      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);
      if (nonSpacedNode) {
        if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
          report(node, nonSpacedNode);
        }
      }
    }

    /**
     * Check if the node is conditional
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkConditional(node) {
      const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent, "?");
      const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, ":");
      if (nonSpacedConsequesntNode) {
        report(node, nonSpacedConsequesntNode);
      } else if (nonSpacedAlternateNode) {
        report(node, nonSpacedAlternateNode);
      }
    }

    /**
     * Check if the node is a variable
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkVar(node) {
      const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
      const rightNode = node.init;
      if (rightNode) {
        const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, "=");
        if (nonSpacedNode) {
          report(node, nonSpacedNode);
        }
      }
    }
    return {
      AssignmentExpression: checkBinary,
      AssignmentPattern: checkBinary,
      BinaryExpression: checkBinary,
      LogicalExpression: checkBinary,
      ConditionalExpression: checkConditional,
      VariableDeclarator: checkVar
    };
  }
};

/***/ }),
/* 466 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview This rule shoud require or disallow spaces before or after unary operations.
 * @author Marcin Kumorek
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before or after unary operators",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/space-unary-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        words: {
          type: "boolean",
          default: true
        },
        nonwords: {
          type: "boolean",
          default: false
        },
        overrides: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
      unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
      unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
      wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
      operator: "Unary operator '{{operator}}' must be followed by whitespace.",
      beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
    }
  },
  create(context) {
    const options = context.options[0] || {
      words: true,
      nonwords: false
    };
    const sourceCode = context.getSourceCode();

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * Check if the node is the first "!" in a "!!" convert to Boolean expression
     * @param {ASTnode} node AST node
     * @returns {boolean} Whether or not the node is first "!" in "!!"
     */
    function isFirstBangInBangBangExpression(node) {
      return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }

    /**
     * Checks if an override exists for a given operator.
     * @param {string} operator Operator
     * @returns {boolean} Whether or not an override has been provided for the operator
     */
    function overrideExistsForOperator(operator) {
      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
    }

    /**
     * Gets the value that the override was set to for this operator
     * @param {string} operator Operator
     * @returns {boolean} Whether or not an override enforces a space with this operator
     */
    function overrideEnforcesSpaces(operator) {
      return options.overrides[operator];
    }

    /**
     * Verify Unary Word Operator has spaces after the word operator
     * @param {ASTnode} node AST node
     * @param {Object} firstToken first token from the AST node
     * @param {Object} secondToken second token from the AST node
     * @param {string} word The word to be used for reporting
     * @returns {void}
     */
    function verifyWordHasSpaces(node, firstToken, secondToken, word) {
      if (secondToken.range[0] === firstToken.range[1]) {
        context.report({
          node,
          messageId: "wordOperator",
          data: {
            word
          },
          fix(fixer) {
            return fixer.insertTextAfter(firstToken, " ");
          }
        });
      }
    }

    /**
     * Verify Unary Word Operator doesn't have spaces after the word operator
     * @param {ASTnode} node AST node
     * @param {Object} firstToken first token from the AST node
     * @param {Object} secondToken second token from the AST node
     * @param {string} word The word to be used for reporting
     * @returns {void}
     */
    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedAfterWord",
            data: {
              word
            },
            fix(fixer) {
              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            }
          });
        }
      }
    }

    /**
     * Check Unary Word Operators for spaces after the word operator
     * @param {ASTnode} node AST node
     * @param {Object} firstToken first token from the AST node
     * @param {Object} secondToken second token from the AST node
     * @param {string} word The word to be used for reporting
     * @returns {void}
     */
    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
      if (overrideExistsForOperator(word)) {
        if (overrideEnforcesSpaces(word)) {
          verifyWordHasSpaces(node, firstToken, secondToken, word);
        } else {
          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
        }
      } else if (options.words) {
        verifyWordHasSpaces(node, firstToken, secondToken, word);
      } else {
        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
      }
    }

    /**
     * Verifies YieldExpressions satisfy spacing requirements
     * @param {ASTnode} node AST node
     * @returns {void}
     */
    function checkForSpacesAfterYield(node) {
      const tokens = sourceCode.getFirstTokens(node, 3),
        word = "yield";
      if (!node.argument || node.delegate) {
        return;
      }
      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
    }

    /**
     * Verifies AwaitExpressions satisfy spacing requirements
     * @param {ASTNode} node AwaitExpression AST node
     * @returns {void}
     */
    function checkForSpacesAfterAwait(node) {
      const tokens = sourceCode.getFirstTokens(node, 3);
      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
    }

    /**
     * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
     * @param {ASTnode} node AST node
     * @param {Object} firstToken First token in the expression
     * @param {Object} secondToken Second token in the expression
     * @returns {void}
     */
    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
      if (node.prefix) {
        if (isFirstBangInBangBangExpression(node)) {
          return;
        }
        if (firstToken.range[1] === secondToken.range[0]) {
          context.report({
            node,
            messageId: "operator",
            data: {
              operator: firstToken.value
            },
            fix(fixer) {
              return fixer.insertTextAfter(firstToken, " ");
            }
          });
        }
      } else {
        if (firstToken.range[1] === secondToken.range[0]) {
          context.report({
            node,
            messageId: "beforeUnaryExpressions",
            data: {
              token: secondToken.value
            },
            fix(fixer) {
              return fixer.insertTextBefore(secondToken, " ");
            }
          });
        }
      }
    }

    /**
     * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator
     * @param {ASTnode} node AST node
     * @param {Object} firstToken First token in the expression
     * @param {Object} secondToken Second token in the expression
     * @returns {void}
     */
    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
      if (node.prefix) {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedAfter",
            data: {
              operator: firstToken.value
            },
            fix(fixer) {
              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
              }
              return null;
            }
          });
        }
      } else {
        if (secondToken.range[0] > firstToken.range[1]) {
          context.report({
            node,
            messageId: "unexpectedBefore",
            data: {
              operator: secondToken.value
            },
            fix(fixer) {
              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            }
          });
        }
      }
    }

    /**
     * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements
     * @param {ASTnode} node AST node
     * @returns {void}
     */
    function checkForSpaces(node) {
      const tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
      const firstToken = tokens[0];
      const secondToken = tokens[1];
      if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
        return;
      }
      const operator = node.prefix ? tokens[0].value : tokens[1].value;
      if (overrideExistsForOperator(operator)) {
        if (overrideEnforcesSpaces(operator)) {
          verifyNonWordsHaveSpaces(node, firstToken, secondToken);
        } else {
          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
        }
      } else if (options.nonwords) {
        verifyNonWordsHaveSpaces(node, firstToken, secondToken);
      } else {
        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      UnaryExpression: checkForSpaces,
      UpdateExpression: checkForSpaces,
      NewExpression: checkForSpaces,
      YieldExpression: checkForSpacesAfterYield,
      AwaitExpression: checkForSpacesAfterAwait
    };
  }
};

/***/ }),
/* 467 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Source code for spaced-comments rule
 * @author Gyandeep Singh
 */


const lodash = __webpack_require__(99);
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Escapes the control characters of a given string.
 * @param {string} s - A string to escape.
 * @returns {string} An escaped string.
 */
function escape(s) {
  return `(?:${lodash.escapeRegExp(s)})`;
}

/**
 * Escapes the control characters of a given string.
 * And adds a repeat flag.
 * @param {string} s - A string to escape.
 * @returns {string} An escaped string.
 */
function escapeAndRepeat(s) {
  return `${escape(s)}+`;
}

/**
 * Parses `markers` option.
 * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
 * @param {string[]} [markers] - A marker list.
 * @returns {string[]} A marker list.
 */
function parseMarkersOption(markers) {
  // `*` is a marker for JSDoc comments.
  if (markers.indexOf("*") === -1) {
    return markers.concat("*");
  }
  return markers;
}

/**
 * Creates string pattern for exceptions.
 * Generated pattern:
 *
 * 1. A space or an exception pattern sequence.
 *
 * @param {string[]} exceptions - An exception pattern list.
 * @returns {string} A regular expression string for exceptions.
 */
function createExceptionsPattern(exceptions) {
  let pattern = "";

  /*
   * A space or an exception pattern sequence.
   * []                 ==> "\s"
   * ["-"]              ==> "(?:\s|\-+$)"
   * ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
   * ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
   */
  if (exceptions.length === 0) {
    // a space.
    pattern += "\\s";
  } else {
    // a space or...
    pattern += "(?:\\s|";
    if (exceptions.length === 1) {
      // a sequence of the exception pattern.
      pattern += escapeAndRepeat(exceptions[0]);
    } else {
      // a sequence of one of the exception patterns.
      pattern += "(?:";
      pattern += exceptions.map(escapeAndRepeat).join("|");
      pattern += ")";
    }
    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;
  }
  return pattern;
}

/**
 * Creates RegExp object for `always` mode.
 * Generated pattern for beginning of comment:
 *
 * 1. First, a marker or nothing.
 * 2. Next, a space or an exception pattern sequence.
 *
 * @param {string[]} markers - A marker list.
 * @param {string[]} exceptions - An exception pattern list.
 * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.
 */
function createAlwaysStylePattern(markers, exceptions) {
  let pattern = "^";

  /*
   * A marker or nothing.
   * ["*"]            ==> "\*?"
   * ["*", "!"]       ==> "(?:\*|!)?"
   * ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
   */
  if (markers.length === 1) {
    // the marker.
    pattern += escape(markers[0]);
  } else {
    // one of markers.
    pattern += "(?:";
    pattern += markers.map(escape).join("|");
    pattern += ")";
  }
  pattern += "?"; // or nothing.
  pattern += createExceptionsPattern(exceptions);
  return new RegExp(pattern); // eslint-disable-line require-unicode-regexp
}

/**
 * Creates RegExp object for `never` mode.
 * Generated pattern for beginning of comment:
 *
 * 1. First, a marker or nothing (captured).
 * 2. Next, a space or a tab.
 *
 * @param {string[]} markers - A marker list.
 * @returns {RegExp} A RegExp object for `never` mode.
 */
function createNeverStylePattern(markers) {
  const pattern = `^(${markers.map(escape).join("|")})?[ \t]+`;
  return new RegExp(pattern); // eslint-disable-line require-unicode-regexp
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent spacing after the `//` or `/*` in a comment",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/spaced-comment"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        markers: {
          type: "array",
          items: {
            type: "string"
          }
        },
        line: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        },
        block: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            balanced: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      },
      additionalProperties: false
    }]
  },
  create(context) {
    const sourceCode = context.getSourceCode();

    // Unless the first option is never, require a space
    const requireSpace = context.options[0] !== "never";

    /*
     * Parse the second options.
     * If markers don't include `"*"`, it's added automatically for JSDoc
     * comments.
     */
    const config = context.options[1] || {};
    const balanced = config.block && config.block.balanced;
    const styleRules = ["block", "line"].reduce((rule, type) => {
      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);
      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
      const endNeverPattern = "[ \t]+$";

      // Create RegExp object for valid patterns.
      rule[type] = {
        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),
        // eslint-disable-line require-unicode-regexp
        hasExceptions: exceptions.length > 0,
        markers: new RegExp(`^(${markers.map(escape).join("|")})`) // eslint-disable-line require-unicode-regexp
      };
      return rule;
    }, {});

    /**
     * Reports a beginning spacing error with an appropriate message.
     * @param {ASTNode} node - A comment node to check.
     * @param {string} message - An error message to report.
     * @param {Array} match - An array of match results for markers.
     * @param {string} refChar - Character used for reference in the error message.
     * @returns {void}
     */
    function reportBegin(node, message, match, refChar) {
      const type = node.type.toLowerCase(),
        commentIdentifier = type === "block" ? "/*" : "//";
      context.report({
        node,
        fix(fixer) {
          const start = node.range[0];
          let end = start + 2;
          if (requireSpace) {
            if (match) {
              end += match[0].length;
            }
            return fixer.insertTextAfterRange([start, end], " ");
          }
          end += match[0].length;
          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
        },
        message,
        data: {
          refChar
        }
      });
    }

    /**
     * Reports an ending spacing error with an appropriate message.
     * @param {ASTNode} node - A comment node to check.
     * @param {string} message - An error message to report.
     * @param {string} match - An array of the matched whitespace characters.
     * @returns {void}
     */
    function reportEnd(node, message, match) {
      context.report({
        node,
        fix(fixer) {
          if (requireSpace) {
            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
          }
          const end = node.range[1] - 2,
            start = end - match[0].length;
          return fixer.replaceTextRange([start, end], "");
        },
        message
      });
    }

    /**
     * Reports a given comment if it's invalid.
     * @param {ASTNode} node - a comment node to check.
     * @returns {void}
     */
    function checkCommentForSpace(node) {
      const type = node.type.toLowerCase(),
        rule = styleRules[type],
        commentIdentifier = type === "block" ? "/*" : "//";

      // Ignores empty comments.
      if (node.value.length === 0) {
        return;
      }
      const beginMatch = rule.beginRegex.exec(node.value);
      const endMatch = rule.endRegex.exec(node.value);

      // Checks.
      if (requireSpace) {
        if (!beginMatch) {
          const hasMarker = rule.markers.exec(node.value);
          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
          if (rule.hasExceptions) {
            reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
          } else {
            reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
          }
        }
        if (balanced && type === "block" && !endMatch) {
          reportEnd(node, "Expected space or tab before '*/' in comment.");
        }
      } else {
        if (beginMatch) {
          if (!beginMatch[1]) {
            reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
          } else {
            reportBegin(node, "Unexpected space or tab after marker ({{refChar}}) in comment.", beginMatch, beginMatch[1]);
          }
        }
        if (balanced && type === "block" && endMatch) {
          reportEnd(node, "Unexpected space or tab before '*/' in comment.", endMatch);
        }
      }
    }
    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.filter(token => token.type !== "Shebang").forEach(checkCommentForSpace);
      }
    };
  }
};

/***/ }),
/* 468 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to control usage of strict mode directives.
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets all of the Use Strict Directives in the Directive Prologue of a group of
 * statements.
 * @param {ASTNode[]} statements Statements in the program or function body.
 * @returns {ASTNode[]} All of the Use Strict Directives.
 */
function getUseStrictDirectives(statements) {
  const directives = [];
  for (let i = 0; i < statements.length; i++) {
    const statement = statements[i];
    if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
      directives[i] = statement;
    } else {
      break;
    }
  }
  return directives;
}

/**
 * Checks whether a given parameter is a simple parameter.
 *
 * @param {ASTNode} node - A pattern node to check.
 * @returns {boolean} `true` if the node is an Identifier node.
 */
function isSimpleParameter(node) {
  return node.type === "Identifier";
}

/**
 * Checks whether a given parameter list is a simple parameter list.
 *
 * @param {ASTNode[]} params - A parameter list to check.
 * @returns {boolean} `true` if the every parameter is an Identifier node.
 */
function isSimpleParameterList(params) {
  return params.every(isSimpleParameter);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow strict mode directives",
      category: "Strict Mode",
      recommended: false,
      url: "https://eslint.org/docs/rules/strict"
    },
    schema: [{
      enum: ["never", "global", "function", "safe"]
    }],
    fixable: "code",
    messages: {
      function: "Use the function form of 'use strict'.",
      global: "Use the global form of 'use strict'.",
      multiple: "Multiple 'use strict' directives.",
      never: "Strict mode is not permitted.",
      unnecessary: "Unnecessary 'use strict' directive.",
      module: "'use strict' is unnecessary inside of modules.",
      implied: "'use strict' is unnecessary when implied strict mode is enabled.",
      unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
      nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
      wrap: "Wrap {{name}} in a function with 'use strict' directive."
    }
  },
  create(context) {
    const ecmaFeatures = context.parserOptions.ecmaFeatures || {},
      scopes = [],
      classScopes = [];
    let mode = context.options[0] || "safe";
    if (ecmaFeatures.impliedStrict) {
      mode = "implied";
    } else if (mode === "safe") {
      mode = ecmaFeatures.globalReturn ? "global" : "function";
    }

    /**
     * Determines whether a reported error should be fixed, depending on the error type.
     * @param {string} errorType The type of error
     * @returns {boolean} `true` if the reported error should be fixed
     */
    function shouldFix(errorType) {
      return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
    }

    /**
     * Gets a fixer function to remove a given 'use strict' directive.
     * @param {ASTNode} node The directive that should be removed
     * @returns {Function} A fixer function
     */
    function getFixFunction(node) {
      return fixer => fixer.remove(node);
    }

    /**
     * Report a slice of an array of nodes with a given message.
     * @param {ASTNode[]} nodes Nodes.
     * @param {string} start Index to start from.
     * @param {string} end Index to end before.
     * @param {string} messageId Message to display.
     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
     * @returns {void}
     */
    function reportSlice(nodes, start, end, messageId, fix) {
      nodes.slice(start, end).forEach(node => {
        context.report({
          node,
          messageId,
          fix: fix ? getFixFunction(node) : null
        });
      });
    }

    /**
     * Report all nodes in an array with a given message.
     * @param {ASTNode[]} nodes Nodes.
     * @param {string} messageId Message id to display.
     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
     * @returns {void}
     */
    function reportAll(nodes, messageId, fix) {
      reportSlice(nodes, 0, nodes.length, messageId, fix);
    }

    /**
     * Report all nodes in an array, except the first, with a given message.
     * @param {ASTNode[]} nodes Nodes.
     * @param {string} messageId Message id to display.
     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
     * @returns {void}
     */
    function reportAllExceptFirst(nodes, messageId, fix) {
      reportSlice(nodes, 1, nodes.length, messageId, fix);
    }

    /**
     * Entering a function in 'function' mode pushes a new nested scope onto the
     * stack. The new scope is true if the nested function is strict mode code.
     * @param {ASTNode} node The function declaration or expression.
     * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.
     * @returns {void}
     */
    function enterFunctionInFunctionMode(node, useStrictDirectives) {
      const isInClass = classScopes.length > 0,
        isParentGlobal = scopes.length === 0 && classScopes.length === 0,
        isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
        isStrict = useStrictDirectives.length > 0;
      if (isStrict) {
        if (!isSimpleParameterList(node.params)) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "nonSimpleParameterList"
          });
        } else if (isParentStrict) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "unnecessary",
            fix: getFixFunction(useStrictDirectives[0])
          });
        } else if (isInClass) {
          context.report({
            node: useStrictDirectives[0],
            messageId: "unnecessaryInClasses",
            fix: getFixFunction(useStrictDirectives[0])
          });
        }
        reportAllExceptFirst(useStrictDirectives, "multiple", true);
      } else if (isParentGlobal) {
        if (isSimpleParameterList(node.params)) {
          context.report({
            node,
            messageId: "function"
          });
        } else {
          context.report({
            node,
            messageId: "wrap",
            data: {
              name: astUtils.getFunctionNameWithKind(node)
            }
          });
        }
      }
      scopes.push(isParentStrict || isStrict);
    }

    /**
     * Exiting a function in 'function' mode pops its scope off the stack.
     * @returns {void}
     */
    function exitFunctionInFunctionMode() {
      scopes.pop();
    }

    /**
     * Enter a function and either:
     * - Push a new nested scope onto the stack (in 'function' mode).
     * - Report all the Use Strict Directives (in the other modes).
     * @param {ASTNode} node The function declaration or expression.
     * @returns {void}
     */
    function enterFunction(node) {
      const isBlock = node.body.type === "BlockStatement",
        useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];
      if (mode === "function") {
        enterFunctionInFunctionMode(node, useStrictDirectives);
      } else if (useStrictDirectives.length > 0) {
        if (isSimpleParameterList(node.params)) {
          reportAll(useStrictDirectives, mode, shouldFix(mode));
        } else {
          context.report({
            node: useStrictDirectives[0],
            messageId: "nonSimpleParameterList"
          });
          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        }
      }
    }
    const rule = {
      Program(node) {
        const useStrictDirectives = getUseStrictDirectives(node.body);
        if (node.sourceType === "module") {
          mode = "module";
        }
        if (mode === "global") {
          if (node.body.length > 0 && useStrictDirectives.length === 0) {
            context.report({
              node,
              messageId: "global"
            });
          }
          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        } else {
          reportAll(useStrictDirectives, mode, shouldFix(mode));
        }
      },
      FunctionDeclaration: enterFunction,
      FunctionExpression: enterFunction,
      ArrowFunctionExpression: enterFunction
    };
    if (mode === "function") {
      Object.assign(rule, {
        // Inside of class bodies are always strict mode.
        ClassBody() {
          classScopes.push(true);
        },
        "ClassBody:exit"() {
          classScopes.pop();
        },
        "FunctionDeclaration:exit": exitFunctionInFunctionMode,
        "FunctionExpression:exit": exitFunctionInFunctionMode,
        "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
      });
    }
    return rule;
  }
};

/***/ }),
/* 469 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce spacing around colons of switch statements.
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing around colons of switch statements",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/switch-colon-spacing"
    },
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: false
        },
        after: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "whitespace",
    messages: {
      expectedBefore: "Expected space(s) before this colon.",
      expectedAfter: "Expected space(s) after this colon.",
      unexpectedBefore: "Unexpected space(s) before this colon.",
      unexpectedAfter: "Unexpected space(s) after this colon."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const options = context.options[0] || {};
    const beforeSpacing = options.before === true; // false by default
    const afterSpacing = options.after !== false; // true by default

    /**
     * Get the colon token of the given SwitchCase node.
     * @param {ASTNode} node The SwitchCase node to get.
     * @returns {Token} The colon token of the node.
     */
    function getColonToken(node) {
      if (node.test) {
        return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
      }
      return sourceCode.getFirstToken(node, 1);
    }

    /**
     * Check whether the spacing between the given 2 tokens is valid or not.
     * @param {Token} left The left token to check.
     * @param {Token} right The right token to check.
     * @param {boolean} expected The expected spacing to check. `true` if there should be a space.
     * @returns {boolean} `true` if the spacing between the tokens is valid.
     */
    function isValidSpacing(left, right, expected) {
      return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
    }

    /**
     * Check whether comments exist between the given 2 tokens.
     * @param {Token} left The left token to check.
     * @param {Token} right The right token to check.
     * @returns {boolean} `true` if comments exist between the given 2 tokens.
     */
    function commentsExistBetween(left, right) {
      return sourceCode.getFirstTokenBetween(left, right, {
        includeComments: true,
        filter: astUtils.isCommentToken
      }) !== null;
    }

    /**
     * Fix the spacing between the given 2 tokens.
     * @param {RuleFixer} fixer The fixer to fix.
     * @param {Token} left The left token of fix range.
     * @param {Token} right The right token of fix range.
     * @param {boolean} spacing The spacing style. `true` if there should be a space.
     * @returns {Fix|null} The fix object.
     */
    function fix(fixer, left, right, spacing) {
      if (commentsExistBetween(left, right)) {
        return null;
      }
      if (spacing) {
        return fixer.insertTextAfter(left, " ");
      }
      return fixer.removeRange([left.range[1], right.range[0]]);
    }
    return {
      SwitchCase(node) {
        const colonToken = getColonToken(node);
        const beforeToken = sourceCode.getTokenBefore(colonToken);
        const afterToken = sourceCode.getTokenAfter(colonToken);
        if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
          context.report({
            node,
            loc: colonToken.loc,
            messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
            fix: fixer => fix(fixer, beforeToken, colonToken, beforeSpacing)
          });
        }
        if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
          context.report({
            node,
            loc: colonToken.loc,
            messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
            fix: fixer => fix(fixer, colonToken, afterToken, afterSpacing)
          });
        }
      }
    };
  }
};

/***/ }),
/* 470 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce description with the `Symbol` object
 * @author Jarek Rencz
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require symbol descriptions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/symbol-description"
    },
    fixable: null,
    schema: [],
    messages: {
      expected: "Expected Symbol to have a description."
    }
  },
  create(context) {
    /**
     * Reports if node does not conform the rule in case rule is set to
     * report missing description
     *
     * @param {ASTNode} node - A CallExpression node to check.
     * @returns {void}
     */
    function checkArgument(node) {
      if (node.arguments.length === 0) {
        context.report({
          node,
          messageId: "expected"
        });
      }
    }
    return {
      "Program:exit"() {
        const scope = context.getScope();
        const variable = astUtils.getVariableByName(scope, "Symbol");
        if (variable && variable.defs.length === 0) {
          variable.references.forEach(reference => {
            const node = reference.identifier;
            if (astUtils.isCallee(node)) {
              checkArgument(node.parent);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 471 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to enforce spacing around embedded expressions of template strings
 * @author Toru Nagashima
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const OPEN_PAREN = /\$\{$/u;
const CLOSE_PAREN = /^\}/u;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around embedded expressions of template strings",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/template-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expectedBefore: "Expected space(s) before '}'.",
      expectedAfter: "Expected space(s) after '${'.",
      unexpectedBefore: "Unexpected space(s) before '}'.",
      unexpectedAfter: "Unexpected space(s) after '${'."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const always = context.options[0] === "always";
    const prefix = always ? "expected" : "unexpected";

    /**
     * Checks spacing before `}` of a given token.
     * @param {Token} token - A token to check. This is a Template token.
     * @returns {void}
     */
    function checkSpacingBefore(token) {
      const prevToken = sourceCode.getTokenBefore(token);
      if (prevToken && CLOSE_PAREN.test(token.value) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token) !== always) {
        context.report({
          loc: token.loc.start,
          messageId: `${prefix}Before`,
          fix(fixer) {
            if (always) {
              return fixer.insertTextBefore(token, " ");
            }
            return fixer.removeRange([prevToken.range[1], token.range[0]]);
          }
        });
      }
    }

    /**
     * Checks spacing after `${` of a given token.
     * @param {Token} token - A token to check. This is a Template token.
     * @returns {void}
     */
    function checkSpacingAfter(token) {
      const nextToken = sourceCode.getTokenAfter(token);
      if (nextToken && OPEN_PAREN.test(token.value) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken) !== always) {
        context.report({
          loc: {
            line: token.loc.end.line,
            column: token.loc.end.column - 2
          },
          messageId: `${prefix}After`,
          fix(fixer) {
            if (always) {
              return fixer.insertTextAfter(token, " ");
            }
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
    }
    return {
      TemplateElement(node) {
        const token = sourceCode.getFirstToken(node);
        checkSpacingBefore(token);
        checkSpacingAfter(token);
      }
    };
  }
};

/***/ }),
/* 472 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check spacing between template tags and their literals
 * @author Jonathan Wilsson
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between template tags and their literals",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/template-tag-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpected: "Unexpected space between template tag and template literal.",
      missing: "Missing space between template tag and template literal."
    }
  },
  create(context) {
    const never = context.options[0] !== "always";
    const sourceCode = context.getSourceCode();

    /**
     * Check if a space is present between a template tag and its literal
     * @param {ASTNode} node node to evaluate
     * @returns {void}
     * @private
     */
    function checkSpacing(node) {
      const tagToken = sourceCode.getTokenBefore(node.quasi);
      const literalToken = sourceCode.getFirstToken(node.quasi);
      const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);
      if (never && hasWhitespace) {
        context.report({
          node,
          loc: tagToken.loc.start,
          messageId: "unexpected",
          fix(fixer) {
            const comments = sourceCode.getCommentsBefore(node.quasi);

            // Don't fix anything if there's a single line comment after the template tag
            if (comments.some(comment => comment.type === "Line")) {
              return null;
            }
            return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
          }
        });
      } else if (!never && !hasWhitespace) {
        context.report({
          node,
          loc: tagToken.loc.start,
          messageId: "missing",
          fix(fixer) {
            return fixer.insertTextAfter(tagToken, " ");
          }
        });
      }
    }
    return {
      TaggedTemplateExpression: checkSpacing
    };
  }
};

/***/ }),
/* 473 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Require or disallow Unicode BOM
 * @author Andrew Johnston <https://github.com/ehjay>
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow Unicode byte order mark (BOM)",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/unicode-bom"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expected: "Expected Unicode BOM (Byte Order Mark).",
      unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      Program: function checkUnicodeBOM(node) {
        const sourceCode = context.getSourceCode(),
          location = {
            column: 0,
            line: 1
          },
          requireBOM = context.options[0] || "never";
        if (!sourceCode.hasBOM && requireBOM === "always") {
          context.report({
            node,
            loc: location,
            messageId: "expected",
            fix(fixer) {
              return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
            }
          });
        } else if (sourceCode.hasBOM && requireBOM === "never") {
          context.report({
            node,
            loc: location,
            messageId: "unexpected",
            fix(fixer) {
              return fixer.removeRange([-1, 0]);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 474 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag comparisons to the value NaN
 * @author James Allardice
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "require calls to `isNaN()` when checking for `NaN`",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/use-isnan"
    },
    schema: [],
    messages: {
      useIsNaN: "Use the isNaN function to compare with NaN."
    }
  },
  create(context) {
    return {
      BinaryExpression(node) {
        if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
          context.report({
            node,
            messageId: "useIsNaN"
          });
        }
      }
    };
  }
};

/***/ }),
/* 475 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Validates JSDoc comments are syntactically correct
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const doctrine = __webpack_require__(476);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce valid JSDoc comments",
      category: "Possible Errors",
      recommended: false,
      url: "https://eslint.org/docs/rules/valid-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        prefer: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        preferType: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        requireReturn: {
          type: "boolean",
          default: true
        },
        requireParamDescription: {
          type: "boolean",
          default: true
        },
        requireReturnDescription: {
          type: "boolean",
          default: true
        },
        matchDescription: {
          type: "string"
        },
        requireReturnType: {
          type: "boolean",
          default: true
        },
        requireParamType: {
          type: "boolean",
          default: true
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
      expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
      use: "Use @{{name}} instead.",
      useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
      syntaxError: "JSDoc syntax error.",
      missingBrace: "JSDoc type missing brace.",
      missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
      missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
      missingReturnType: "Missing JSDoc return type.",
      missingReturnDesc: "Missing JSDoc return description.",
      missingReturn: "Missing JSDoc @{{returns}} for function.",
      missingParam: "Missing JSDoc for parameter '{{name}}'.",
      duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
      unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
    },
    deprecated: true,
    replacedBy: []
  },
  create(context) {
    const options = context.options[0] || {},
      prefer = options.prefer || {},
      sourceCode = context.getSourceCode(),
      // these both default to true, so you have to explicitly make them false
      requireReturn = options.requireReturn !== false,
      requireParamDescription = options.requireParamDescription !== false,
      requireReturnDescription = options.requireReturnDescription !== false,
      requireReturnType = options.requireReturnType !== false,
      requireParamType = options.requireParamType !== false,
      preferType = options.preferType || {},
      checkPreferType = Object.keys(preferType).length !== 0;

    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    // Using a stack to store if a function returns or not (handling nested functions)
    const fns = [];

    /**
     * Check if node type is a Class
     * @param {ASTNode} node node to check.
     * @returns {boolean} True is its a class
     * @private
     */
    function isTypeClass(node) {
      return node.type === "ClassExpression" || node.type === "ClassDeclaration";
    }

    /**
     * When parsing a new function, store it in our function stack.
     * @param {ASTNode} node A function node to check.
     * @returns {void}
     * @private
     */
    function startFunction(node) {
      fns.push({
        returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node) || node.async
      });
    }

    /**
     * Indicate that return has been found in the current function.
     * @param {ASTNode} node The return node.
     * @returns {void}
     * @private
     */
    function addReturn(node) {
      const functionState = fns[fns.length - 1];
      if (functionState && node.argument !== null) {
        functionState.returnPresent = true;
      }
    }

    /**
     * Check if return tag type is void or undefined
     * @param {Object} tag JSDoc tag
     * @returns {boolean} True if its of type void or undefined
     * @private
     */
    function isValidReturnType(tag) {
      return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
    }

    /**
     * Check if type should be validated based on some exceptions
     * @param {Object} type JSDoc tag
     * @returns {boolean} True if it can be validated
     * @private
     */
    function canTypeBeValidated(type) {
      return type !== "UndefinedLiteral" &&
      // {undefined} as there is no name property available.
      type !== "NullLiteral" &&
      // {null}
      type !== "NullableLiteral" &&
      // {?}
      type !== "FunctionType" &&
      // {function(a)}
      type !== "AllLiteral"; // {*}
    }

    /**
     * Extract the current and expected type based on the input type object
     * @param {Object} type JSDoc tag
     * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and
     * the expected name of the annotation
     * @private
     */
    function getCurrentExpectedTypes(type) {
      let currentType;
      if (type.name) {
        currentType = type;
      } else if (type.expression) {
        currentType = type.expression;
      }
      return {
        currentType,
        expectedTypeName: currentType && preferType[currentType.name]
      };
    }

    /**
     * Gets the location of a JSDoc node in a file
     * @param {Token} jsdocComment The comment that this node is parsed from
     * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment
     * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag
     */
    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {
      return {
        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
      };
    }

    /**
     * Validate type for a given JSDoc node
     * @param {Object} jsdocNode JSDoc node
     * @param {Object} type JSDoc tag
     * @returns {void}
     * @private
     */
    function validateType(jsdocNode, type) {
      if (!type || !canTypeBeValidated(type.type)) {
        return;
      }
      const typesToCheck = [];
      let elements = [];
      switch (type.type) {
        case "TypeApplication":
          // {Array.<String>}
          elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
          typesToCheck.push(getCurrentExpectedTypes(type));
          break;
        case "RecordType":
          // {{20:String}}
          elements = type.fields;
          break;
        case "UnionType": // {String|number|Test}
        case "ArrayType":
          // {[String, number, Test]}
          elements = type.elements;
          break;
        case "FieldType":
          // Array.<{count: number, votes: number}>
          if (type.value) {
            typesToCheck.push(getCurrentExpectedTypes(type.value));
          }
          break;
        default:
          typesToCheck.push(getCurrentExpectedTypes(type));
      }
      elements.forEach(validateType.bind(null, jsdocNode));
      typesToCheck.forEach(typeToCheck => {
        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {
          context.report({
            node: jsdocNode,
            messageId: "useType",
            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
            data: {
              currentTypeName: typeToCheck.currentType.name,
              expectedTypeName: typeToCheck.expectedTypeName
            },
            fix(fixer) {
              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);
            }
          });
        }
      });
    }

    /**
     * Validate the JSDoc node and output warnings if anything is wrong.
     * @param {ASTNode} node The AST node to check.
     * @returns {void}
     * @private
     */
    function checkJSDoc(node) {
      const jsdocNode = sourceCode.getJSDocComment(node),
        functionData = fns.pop(),
        paramTagsByName = Object.create(null),
        paramTags = [];
      let hasReturns = false,
        returnsTag,
        hasConstructor = false,
        isInterface = false,
        isOverride = false,
        isAbstract = false;

      // make sure only to validate JSDoc comments
      if (jsdocNode) {
        let jsdoc;
        try {
          jsdoc = doctrine.parse(jsdocNode.value, {
            strict: true,
            unwrap: true,
            sloppy: true,
            range: true
          });
        } catch (ex) {
          if (/braces/iu.test(ex.message)) {
            context.report({
              node: jsdocNode,
              messageId: "missingBrace"
            });
          } else {
            context.report({
              node: jsdocNode,
              messageId: "syntaxError"
            });
          }
          return;
        }
        jsdoc.tags.forEach(tag => {
          switch (tag.title.toLowerCase()) {
            case "param":
            case "arg":
            case "argument":
              paramTags.push(tag);
              break;
            case "return":
            case "returns":
              hasReturns = true;
              returnsTag = tag;
              break;
            case "constructor":
            case "class":
              hasConstructor = true;
              break;
            case "override":
            case "inheritdoc":
              isOverride = true;
              break;
            case "abstract":
            case "virtual":
              isAbstract = true;
              break;
            case "interface":
              isInterface = true;
              break;

            // no default
          }

          // check tag preferences
          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
            const entireTagRange = getAbsoluteRange(jsdocNode, tag);
            context.report({
              node: jsdocNode,
              messageId: "use",
              loc: {
                start: entireTagRange.start,
                end: {
                  line: entireTagRange.start.line,
                  column: entireTagRange.start.column + `@${tag.title}`.length
                }
              },
              data: {
                name: prefer[tag.title]
              },
              fix(fixer) {
                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);
              }
            });
          }

          // validate the types
          if (checkPreferType && tag.type) {
            validateType(jsdocNode, tag.type);
          }
        });
        paramTags.forEach(param => {
          if (requireParamType && !param.type) {
            context.report({
              node: jsdocNode,
              messageId: "missingParamType",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          }
          if (!param.description && requireParamDescription) {
            context.report({
              node: jsdocNode,
              messageId: "missingParamDesc",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          }
          if (paramTagsByName[param.name]) {
            context.report({
              node: jsdocNode,
              messageId: "duplicateParam",
              loc: getAbsoluteRange(jsdocNode, param),
              data: {
                name: param.name
              }
            });
          } else if (param.name.indexOf(".") === -1) {
            paramTagsByName[param.name] = param;
          }
        });
        if (hasReturns) {
          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
            context.report({
              node: jsdocNode,
              messageId: "unexpectedTag",
              loc: getAbsoluteRange(jsdocNode, returnsTag),
              data: {
                title: returnsTag.title
              }
            });
          } else {
            if (requireReturnType && !returnsTag.type) {
              context.report({
                node: jsdocNode,
                messageId: "missingReturnType"
              });
            }
            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
              context.report({
                node: jsdocNode,
                messageId: "missingReturnDesc"
              });
            }
          }
        }

        // check for functions missing @returns
        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
          if (requireReturn || functionData.returnPresent && !node.async) {
            context.report({
              node: jsdocNode,
              messageId: "missingReturn",
              data: {
                returns: prefer.returns || "returns"
              }
            });
          }
        }

        // check the parameters
        const jsdocParamNames = Object.keys(paramTagsByName);
        if (node.params) {
          node.params.forEach((param, paramsIndex) => {
            const bindingParam = param.type === "AssignmentPattern" ? param.left : param;

            // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
            if (bindingParam.type === "Identifier") {
              const name = bindingParam.name;
              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {
                context.report({
                  node: jsdocNode,
                  messageId: "expected",
                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                  data: {
                    name,
                    jsdocName: jsdocParamNames[paramsIndex]
                  }
                });
              } else if (!paramTagsByName[name] && !isOverride) {
                context.report({
                  node: jsdocNode,
                  messageId: "missingParam",
                  data: {
                    name
                  }
                });
              }
            }
          });
        }
        if (options.matchDescription) {
          const regex = new RegExp(options.matchDescription); // eslint-disable-line require-unicode-regexp

          if (!regex.test(jsdoc.description)) {
            context.report({
              node: jsdocNode,
              messageId: "unsatisfiedDesc"
            });
          }
        }
      }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      ArrowFunctionExpression: startFunction,
      FunctionExpression: startFunction,
      FunctionDeclaration: startFunction,
      ClassExpression: startFunction,
      ClassDeclaration: startFunction,
      "ArrowFunctionExpression:exit": checkJSDoc,
      "FunctionExpression:exit": checkJSDoc,
      "FunctionDeclaration:exit": checkJSDoc,
      "ClassExpression:exit": checkJSDoc,
      "ClassDeclaration:exit": checkJSDoc,
      ReturnStatement: addReturn
    };
  }
};

/***/ }),
/* 476 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * @fileoverview Main Doctrine object
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 * @author Dan Tao <daniel.tao@gmail.com>
 * @author Andrew Eisenberg <andrew@eisenberg.as>
 */

(function () {
  'use strict';

  var typed, utility, jsdoc, esutils, hasOwnProperty;
  esutils = __webpack_require__(111);
  typed = __webpack_require__(477);
  utility = __webpack_require__(478);
  function sliceSource(source, index, last) {
    return source.slice(index, last);
  }
  hasOwnProperty = function () {
    var func = Object.prototype.hasOwnProperty;
    return function hasOwnProperty(obj, name) {
      return func.call(obj, name);
    };
  }();
  function shallowCopy(obj) {
    var ret = {},
      key;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  function isASCIIAlphanumeric(ch) {
    return ch >= 0x61 /* 'a' */ && ch <= 0x7A /* 'z' */ || ch >= 0x41 /* 'A' */ && ch <= 0x5A /* 'Z' */ || ch >= 0x30 /* '0' */ && ch <= 0x39 /* '9' */;
  }
  function isParamTitle(title) {
    return title === 'param' || title === 'argument' || title === 'arg';
  }
  function isReturnTitle(title) {
    return title === 'return' || title === 'returns';
  }
  function isProperty(title) {
    return title === 'property' || title === 'prop';
  }
  function isNameParameterRequired(title) {
    return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
  }
  function isAllowedName(title) {
    return isNameParameterRequired(title) || title === 'const' || title === 'constant';
  }
  function isAllowedNested(title) {
    return isProperty(title) || isParamTitle(title);
  }
  function isAllowedOptional(title) {
    return isProperty(title) || isParamTitle(title);
  }
  function isTypeParameterRequired(title) {
    return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);
  }

  // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
  // This would require changes to 'parseType'
  function isAllowedType(title) {
    return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';
  }

  // A regex character class that contains all whitespace except linebreak characters (\r, \n, \u2028, \u2029)
  var WHITESPACE = '[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]';
  var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\*' + WHITESPACE + '?)?)(.+|[\r\n\u2028\u2029])';
  function unwrapComment(doc) {
    // JSDoc comment is following form
    //   /**
    //    * .......
    //    */

    return doc.
    // remove /**
    replace(/^\/\*\*?/, '').
    // remove */
    replace(/\*\/$/, '').
    // remove ' * ' at the beginning of a line
    replace(new RegExp(STAR_MATCHER, 'g'), '$2').
    // remove trailing whitespace
    replace(/\s*$/, '');
  }

  /**
   * Converts an index in an "unwrapped" JSDoc comment to the corresponding index in the original "wrapped" version
   * @param {string} originalSource The original wrapped comment
   * @param {number} unwrappedIndex The index of a character in the unwrapped string
   * @returns {number} The index of the corresponding character in the original wrapped string
   */
  function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {
    var replacedSource = originalSource.replace(/^\/\*\*?/, '');
    var numSkippedChars = 0;
    var matcher = new RegExp(STAR_MATCHER, 'g');
    var match;
    while (match = matcher.exec(replacedSource)) {
      numSkippedChars += match[1].length;
      if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {
        return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;
      }
    }
    return originalSource.replace(/\*\/$/, '').replace(/\s*$/, '').length;
  }

  // JSDoc Tag Parser

  (function (exports) {
    var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;
    function advance() {
      var ch = source.charCodeAt(index);
      index += 1;
      if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(index) === 0x0A /* '\n' */)) {
        lineNumber += 1;
      }
      return String.fromCharCode(ch);
    }
    function scanTitle() {
      var title = '';
      // waste '@'
      advance();
      while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
        title += advance();
      }
      return title;
    }
    function seekContent() {
      var ch,
        waiting,
        last = index;
      waiting = false;
      while (last < length) {
        ch = source.charCodeAt(last);
        if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(last + 1) === 0x0A /* '\n' */)) {
          waiting = true;
        } else if (waiting) {
          if (ch === 0x40 /* '@' */) {
            break;
          }
          if (!esutils.code.isWhiteSpace(ch)) {
            waiting = false;
          }
        }
        last += 1;
      }
      return last;
    }

    // type expression may have nest brace, such as,
    // { { ok: string } }
    //
    // therefore, scanning type expression with balancing braces.
    function parseType(title, last, addRange) {
      var ch,
        brace,
        type,
        startIndex,
        direct = false;

      // search '{'
      while (index < last) {
        ch = source.charCodeAt(index);
        if (esutils.code.isWhiteSpace(ch)) {
          advance();
        } else if (ch === 0x7B /* '{' */) {
          advance();
          break;
        } else {
          // this is direct pattern
          direct = true;
          break;
        }
      }
      if (direct) {
        return null;
      }

      // type expression { is found
      brace = 1;
      type = '';
      while (index < last) {
        ch = source.charCodeAt(index);
        if (esutils.code.isLineTerminator(ch)) {
          advance();
        } else {
          if (ch === 0x7D /* '}' */) {
            brace -= 1;
            if (brace === 0) {
              advance();
              break;
            }
          } else if (ch === 0x7B /* '{' */) {
            brace += 1;
          }
          if (type === '') {
            startIndex = index;
          }
          type += advance();
        }
      }
      if (brace !== 0) {
        // braces is not balanced
        return utility.throwError('Braces are not balanced');
      }
      if (isAllowedOptional(title)) {
        return typed.parseParamType(type, {
          startIndex: convertIndex(startIndex),
          range: addRange
        });
      }
      return typed.parseType(type, {
        startIndex: convertIndex(startIndex),
        range: addRange
      });
    }
    function scanIdentifier(last) {
      var identifier;
      if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
        return null;
      }
      identifier = advance();
      while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
        identifier += advance();
      }
      return identifier;
    }
    function skipWhiteSpace(last) {
      while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
        advance();
      }
    }
    function parseName(last, allowBrackets, allowNestedParams) {
      var name = '',
        useBrackets,
        insideString;
      skipWhiteSpace(last);
      if (index >= last) {
        return null;
      }
      if (source.charCodeAt(index) === 0x5B /* '[' */) {
        if (allowBrackets) {
          useBrackets = true;
          name = advance();
        } else {
          return null;
        }
      }
      name += scanIdentifier(last);
      if (allowNestedParams) {
        if (source.charCodeAt(index) === 0x3A /* ':' */ && (name === 'module' || name === 'external' || name === 'event')) {
          name += advance();
          name += scanIdentifier(last);
        }
        if (source.charCodeAt(index) === 0x5B /* '[' */ && source.charCodeAt(index + 1) === 0x5D /* ']' */) {
          name += advance();
          name += advance();
        }
        while (source.charCodeAt(index) === 0x2E /* '.' */ || source.charCodeAt(index) === 0x2F /* '/' */ || source.charCodeAt(index) === 0x23 /* '#' */ || source.charCodeAt(index) === 0x2D /* '-' */ || source.charCodeAt(index) === 0x7E /* '~' */) {
          name += advance();
          name += scanIdentifier(last);
        }
      }
      if (useBrackets) {
        skipWhiteSpace(last);
        // do we have a default value for this?
        if (source.charCodeAt(index) === 0x3D /* '=' */) {
          // consume the '='' symbol
          name += advance();
          skipWhiteSpace(last);
          var ch;
          var bracketDepth = 1;

          // scan in the default value
          while (index < last) {
            ch = source.charCodeAt(index);
            if (esutils.code.isWhiteSpace(ch)) {
              if (!insideString) {
                skipWhiteSpace(last);
                ch = source.charCodeAt(index);
              }
            }
            if (ch === 0x27 /* ''' */) {
              if (!insideString) {
                insideString = '\'';
              } else {
                if (insideString === '\'') {
                  insideString = '';
                }
              }
            }
            if (ch === 0x22 /* '"' */) {
              if (!insideString) {
                insideString = '"';
              } else {
                if (insideString === '"') {
                  insideString = '';
                }
              }
            }
            if (ch === 0x5B /* '[' */) {
              bracketDepth++;
            } else if (ch === 0x5D /* ']' */ && --bracketDepth === 0) {
              break;
            }
            name += advance();
          }
        }
        skipWhiteSpace(last);
        if (index >= last || source.charCodeAt(index) !== 0x5D /* ']' */) {
          // we never found a closing ']'
          return null;
        }

        // collect the last ']'
        name += advance();
      }
      return name;
    }
    function skipToTag() {
      while (index < length && source.charCodeAt(index) !== 0x40 /* '@' */) {
        advance();
      }
      if (index >= length) {
        return false;
      }
      utility.assert(source.charCodeAt(index) === 0x40 /* '@' */);
      return true;
    }
    function convertIndex(rangeIndex) {
      if (source === originalSource) {
        return rangeIndex;
      }
      return convertUnwrappedCommentIndex(originalSource, rangeIndex);
    }
    function TagParser(options, title) {
      this._options = options;
      this._title = title.toLowerCase();
      this._tag = {
        title: title,
        description: null
      };
      if (this._options.lineNumbers) {
        this._tag.lineNumber = lineNumber;
      }
      this._first = index - title.length - 1;
      this._last = 0;
      // space to save special information for title parsers.
      this._extra = {};
    }

    // addError(err, ...)
    TagParser.prototype.addError = function addError(errorText) {
      var args = Array.prototype.slice.call(arguments, 1),
        msg = errorText.replace(/%(\d)/g, function (whole, index) {
          utility.assert(index < args.length, 'Message reference must be in range');
          return args[index];
        });
      if (!this._tag.errors) {
        this._tag.errors = [];
      }
      if (strict) {
        utility.throwError(msg);
      }
      this._tag.errors.push(msg);
      return recoverable;
    };
    TagParser.prototype.parseType = function () {
      // type required titles
      if (isTypeParameterRequired(this._title)) {
        try {
          this._tag.type = parseType(this._title, this._last, this._options.range);
          if (!this._tag.type) {
            if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
              if (!this.addError('Missing or invalid tag type')) {
                return false;
              }
            }
          }
        } catch (error) {
          this._tag.type = null;
          if (!this.addError(error.message)) {
            return false;
          }
        }
      } else if (isAllowedType(this._title)) {
        // optional types
        try {
          this._tag.type = parseType(this._title, this._last, this._options.range);
        } catch (e) {
          //For optional types, lets drop the thrown error when we hit the end of the file
        }
      }
      return true;
    };
    TagParser.prototype._parseNamePath = function (optional) {
      var name;
      name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
      if (!name) {
        if (!optional) {
          if (!this.addError('Missing or invalid tag name')) {
            return false;
          }
        }
      }
      this._tag.name = name;
      return true;
    };
    TagParser.prototype.parseNamePath = function () {
      return this._parseNamePath(false);
    };
    TagParser.prototype.parseNamePathOptional = function () {
      return this._parseNamePath(true);
    };
    TagParser.prototype.parseName = function () {
      var assign, name;

      // param, property requires name
      if (isAllowedName(this._title)) {
        this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
        if (!this._tag.name) {
          if (!isNameParameterRequired(this._title)) {
            return true;
          }

          // it's possible the name has already been parsed but interpreted as a type
          // it's also possible this is a sloppy declaration, in which case it will be
          // fixed at the end
          if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
            this._extra.name = this._tag.type;
            this._tag.name = this._tag.type.name;
            this._tag.type = null;
          } else {
            if (!this.addError('Missing or invalid tag name')) {
              return false;
            }
          }
        } else {
          name = this._tag.name;
          if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
            // extract the default value if there is one
            // example: @param {string} [somebody=John Doe] description
            assign = name.substring(1, name.length - 1).split('=');
            if (assign.length > 1) {
              this._tag['default'] = assign.slice(1).join('=');
            }
            this._tag.name = assign[0];

            // convert to an optional type
            if (this._tag.type && this._tag.type.type !== 'OptionalType') {
              this._tag.type = {
                type: 'OptionalType',
                expression: this._tag.type
              };
            }
          }
        }
      }
      return true;
    };
    TagParser.prototype.parseDescription = function parseDescription() {
      var description = sliceSource(source, index, this._last).trim();
      if (description) {
        if (/^-\s+/.test(description)) {
          description = description.substring(2);
        }
        this._tag.description = description;
      }
      return true;
    };
    TagParser.prototype.parseCaption = function parseDescription() {
      var description = sliceSource(source, index, this._last).trim();
      var captionStartTag = '<caption>';
      var captionEndTag = '</caption>';
      var captionStart = description.indexOf(captionStartTag);
      var captionEnd = description.indexOf(captionEndTag);
      if (captionStart >= 0 && captionEnd >= 0) {
        this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();
        this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
      } else {
        this._tag.description = description;
      }
      return true;
    };
    TagParser.prototype.parseKind = function parseKind() {
      var kind, kinds;
      kinds = {
        'class': true,
        'constant': true,
        'event': true,
        'external': true,
        'file': true,
        'function': true,
        'member': true,
        'mixin': true,
        'module': true,
        'namespace': true,
        'typedef': true
      };
      kind = sliceSource(source, index, this._last).trim();
      this._tag.kind = kind;
      if (!hasOwnProperty(kinds, kind)) {
        if (!this.addError('Invalid kind name \'%0\'', kind)) {
          return false;
        }
      }
      return true;
    };
    TagParser.prototype.parseAccess = function parseAccess() {
      var access;
      access = sliceSource(source, index, this._last).trim();
      this._tag.access = access;
      if (access !== 'private' && access !== 'protected' && access !== 'public') {
        if (!this.addError('Invalid access name \'%0\'', access)) {
          return false;
        }
      }
      return true;
    };
    TagParser.prototype.parseThis = function parseThis() {
      // this name may be a name expression (e.g. {foo.bar}),
      // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)
      var value = sliceSource(source, index, this._last).trim();
      if (value && value.charAt(0) === '{') {
        var gotType = this.parseType();
        if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {
          this._tag.name = this._tag.type.name;
          return true;
        } else {
          return this.addError('Invalid name for this');
        }
      } else {
        return this.parseNamePath();
      }
    };
    TagParser.prototype.parseVariation = function parseVariation() {
      var variation, text;
      text = sliceSource(source, index, this._last).trim();
      variation = parseFloat(text, 10);
      this._tag.variation = variation;
      if (isNaN(variation)) {
        if (!this.addError('Invalid variation \'%0\'', text)) {
          return false;
        }
      }
      return true;
    };
    TagParser.prototype.ensureEnd = function () {
      var shouldBeEmpty = sliceSource(source, index, this._last).trim();
      if (shouldBeEmpty) {
        if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
          return false;
        }
      }
      return true;
    };
    TagParser.prototype.epilogue = function epilogue() {
      var description;
      description = this._tag.description;
      // un-fix potentially sloppy declaration
      if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
        this._tag.type = this._extra.name;
        if (!this._tag.name) {
          this._tag.name = undefined;
        }
        if (!sloppy) {
          if (!this.addError('Missing or invalid tag name')) {
            return false;
          }
        }
      }
      return true;
    };
    Rules = {
      // http://usejsdoc.org/tags-access.html
      'access': ['parseAccess'],
      // http://usejsdoc.org/tags-alias.html
      'alias': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-augments.html
      'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-constructor.html
      'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-constructor.html
      'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-extends.html
      'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-example.html
      'example': ['parseCaption'],
      // http://usejsdoc.org/tags-deprecated.html
      'deprecated': ['parseDescription'],
      // http://usejsdoc.org/tags-global.html
      'global': ['ensureEnd'],
      // http://usejsdoc.org/tags-inner.html
      'inner': ['ensureEnd'],
      // http://usejsdoc.org/tags-instance.html
      'instance': ['ensureEnd'],
      // http://usejsdoc.org/tags-kind.html
      'kind': ['parseKind'],
      // http://usejsdoc.org/tags-mixes.html
      'mixes': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-mixin.html
      'mixin': ['parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-member.html
      'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-method.html
      'method': ['parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-module.html
      'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-method.html
      'func': ['parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-method.html
      'function': ['parseNamePathOptional', 'ensureEnd'],
      // Synonym: http://usejsdoc.org/tags-member.html
      'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-name.html
      'name': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-namespace.html
      'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
      // http://usejsdoc.org/tags-private.html
      'private': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-protected.html
      'protected': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-public.html
      'public': ['parseType', 'parseDescription'],
      // http://usejsdoc.org/tags-readonly.html
      'readonly': ['ensureEnd'],
      // http://usejsdoc.org/tags-requires.html
      'requires': ['parseNamePath', 'ensureEnd'],
      // http://usejsdoc.org/tags-since.html
      'since': ['parseDescription'],
      // http://usejsdoc.org/tags-static.html
      'static': ['ensureEnd'],
      // http://usejsdoc.org/tags-summary.html
      'summary': ['parseDescription'],
      // http://usejsdoc.org/tags-this.html
      'this': ['parseThis', 'ensureEnd'],
      // http://usejsdoc.org/tags-todo.html
      'todo': ['parseDescription'],
      // http://usejsdoc.org/tags-typedef.html
      'typedef': ['parseType', 'parseNamePathOptional'],
      // http://usejsdoc.org/tags-variation.html
      'variation': ['parseVariation'],
      // http://usejsdoc.org/tags-version.html
      'version': ['parseDescription']
    };
    TagParser.prototype.parse = function parse() {
      var i, iz, sequences, method;

      // empty title
      if (!this._title) {
        if (!this.addError('Missing or invalid title')) {
          return null;
        }
      }

      // Seek to content last index.
      this._last = seekContent(this._title);
      if (this._options.range) {
        this._tag.range = [this._first, source.slice(0, this._last).replace(/\s*$/, '').length].map(convertIndex);
      }
      if (hasOwnProperty(Rules, this._title)) {
        sequences = Rules[this._title];
      } else {
        // default sequences
        sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
      }
      for (i = 0, iz = sequences.length; i < iz; ++i) {
        method = sequences[i];
        if (!this[method]()) {
          return null;
        }
      }
      return this._tag;
    };
    function parseTag(options) {
      var title, parser, tag;

      // skip to tag
      if (!skipToTag()) {
        return null;
      }

      // scan title
      title = scanTitle();

      // construct tag parser
      parser = new TagParser(options, title);
      tag = parser.parse();

      // Seek global index to end of this tag.
      while (index < parser._last) {
        advance();
      }
      return tag;
    }

    //
    // Parse JSDoc
    //

    function scanJSDocDescription(preserveWhitespace) {
      var description = '',
        ch,
        atAllowed;
      atAllowed = true;
      while (index < length) {
        ch = source.charCodeAt(index);
        if (atAllowed && ch === 0x40 /* '@' */) {
          break;
        }
        if (esutils.code.isLineTerminator(ch)) {
          atAllowed = true;
        } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
          atAllowed = false;
        }
        description += advance();
      }
      return preserveWhitespace ? description : description.trim();
    }
    function parse(comment, options) {
      var tags = [],
        tag,
        description,
        interestingTags,
        i,
        iz;
      if (options === undefined) {
        options = {};
      }
      if (typeof options.unwrap === 'boolean' && options.unwrap) {
        source = unwrapComment(comment);
      } else {
        source = comment;
      }
      originalSource = comment;

      // array of relevant tags
      if (options.tags) {
        if (Array.isArray(options.tags)) {
          interestingTags = {};
          for (i = 0, iz = options.tags.length; i < iz; i++) {
            if (typeof options.tags[i] === 'string') {
              interestingTags[options.tags[i]] = true;
            } else {
              utility.throwError('Invalid "tags" parameter: ' + options.tags);
            }
          }
        } else {
          utility.throwError('Invalid "tags" parameter: ' + options.tags);
        }
      }
      length = source.length;
      index = 0;
      lineNumber = 0;
      recoverable = options.recoverable;
      sloppy = options.sloppy;
      strict = options.strict;
      description = scanJSDocDescription(options.preserveWhitespace);
      while (true) {
        tag = parseTag(options);
        if (!tag) {
          break;
        }
        if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
          tags.push(tag);
        }
      }
      return {
        description: description,
        tags: tags
      };
    }
    exports.parse = parse;
  })(jsdoc = {});
  exports.version = utility.VERSION;
  exports.parse = jsdoc.parse;
  exports.parseType = typed.parseType;
  exports.parseParamType = typed.parseParamType;
  exports.unwrapComment = unwrapComment;
  exports.Syntax = shallowCopy(typed.Syntax);
  exports.Error = utility.DoctrineError;
  exports.type = {
    Syntax: exports.Syntax,
    parseType: typed.parseType,
    parseParamType: typed.parseParamType,
    stringify: typed.stringify
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 477 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * @fileoverview Type expression parser.
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 * @author Dan Tao <daniel.tao@gmail.com>
 * @author Andrew Eisenberg <andrew@eisenberg.as>
 */

// "typed", the Type Expression Parser for doctrine.

(function () {
  'use strict';

  var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;
  esutils = __webpack_require__(111);
  utility = __webpack_require__(478);
  Syntax = {
    NullableLiteral: 'NullableLiteral',
    AllLiteral: 'AllLiteral',
    NullLiteral: 'NullLiteral',
    UndefinedLiteral: 'UndefinedLiteral',
    VoidLiteral: 'VoidLiteral',
    UnionType: 'UnionType',
    ArrayType: 'ArrayType',
    RecordType: 'RecordType',
    FieldType: 'FieldType',
    FunctionType: 'FunctionType',
    ParameterType: 'ParameterType',
    RestType: 'RestType',
    NonNullableType: 'NonNullableType',
    OptionalType: 'OptionalType',
    NullableType: 'NullableType',
    NameExpression: 'NameExpression',
    TypeApplication: 'TypeApplication',
    StringLiteralType: 'StringLiteralType',
    NumericLiteralType: 'NumericLiteralType',
    BooleanLiteralType: 'BooleanLiteralType'
  };
  Token = {
    ILLEGAL: 0,
    // ILLEGAL
    DOT_LT: 1,
    // .<
    REST: 2,
    // ...
    LT: 3,
    // <
    GT: 4,
    // >
    LPAREN: 5,
    // (
    RPAREN: 6,
    // )
    LBRACE: 7,
    // {
    RBRACE: 8,
    // }
    LBRACK: 9,
    // [
    RBRACK: 10,
    // ]
    COMMA: 11,
    // ,
    COLON: 12,
    // :
    STAR: 13,
    // *
    PIPE: 14,
    // |
    QUESTION: 15,
    // ?
    BANG: 16,
    // !
    EQUAL: 17,
    // =
    NAME: 18,
    // name token
    STRING: 19,
    // string
    NUMBER: 20,
    // number
    EOF: 21
  };
  function isTypeName(ch) {
    return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
  }
  function Context(previous, index, token, value) {
    this._previous = previous;
    this._index = index;
    this._token = token;
    this._value = value;
  }
  Context.prototype.restore = function () {
    previous = this._previous;
    index = this._index;
    token = this._token;
    value = this._value;
  };
  Context.save = function () {
    return new Context(previous, index, token, value);
  };
  function maybeAddRange(node, range) {
    if (addRange) {
      node.range = [range[0] + rangeOffset, range[1] + rangeOffset];
    }
    return node;
  }
  function advance() {
    var ch = source.charAt(index);
    index += 1;
    return ch;
  }
  function scanHexEscape(prefix) {
    var i,
      len,
      ch,
      code = 0;
    len = prefix === 'u' ? 4 : 2;
    for (i = 0; i < len; ++i) {
      if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
        ch = advance();
        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
      } else {
        return '';
      }
    }
    return String.fromCharCode(code);
  }
  function scanString() {
    var str = '',
      quote,
      ch,
      code,
      unescaped,
      restore; //TODO review removal octal = false
    quote = source.charAt(index);
    ++index;
    while (index < length) {
      ch = advance();
      if (ch === quote) {
        quote = '';
        break;
      } else if (ch === '\\') {
        ch = advance();
        if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
          switch (ch) {
            case 'n':
              str += '\n';
              break;
            case 'r':
              str += '\r';
              break;
            case 't':
              str += '\t';
              break;
            case 'u':
            case 'x':
              restore = index;
              unescaped = scanHexEscape(ch);
              if (unescaped) {
                str += unescaped;
              } else {
                index = restore;
                str += ch;
              }
              break;
            case 'b':
              str += '\b';
              break;
            case 'f':
              str += '\f';
              break;
            case 'v':
              str += '\v';
              break;
            default:
              if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                code = '01234567'.indexOf(ch);

                // \0 is not octal escape sequence
                // Deprecating unused code. TODO review removal
                //if (code !== 0) {
                //    octal = true;
                //}

                if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                  //TODO Review Removal octal = true;
                  code = code * 8 + '01234567'.indexOf(advance());

                  // 3 digits are only allowed when string starts
                  // with 0, 1, 2, 3
                  if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                    code = code * 8 + '01234567'.indexOf(advance());
                  }
                }
                str += String.fromCharCode(code);
              } else {
                str += ch;
              }
              break;
          }
        } else {
          if (ch === '\r' && source.charCodeAt(index) === 0x0A /* '\n' */) {
            ++index;
          }
        }
      } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
        break;
      } else {
        str += ch;
      }
    }
    if (quote !== '') {
      utility.throwError('unexpected quote');
    }
    value = str;
    return Token.STRING;
  }
  function scanNumber() {
    var number, ch;
    number = '';
    ch = source.charCodeAt(index);
    if (ch !== 0x2E /* '.' */) {
      number = advance();
      ch = source.charCodeAt(index);
      if (number === '0') {
        if (ch === 0x78 /* 'x' */ || ch === 0x58 /* 'X' */) {
          number += advance();
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isHexDigit(ch)) {
              break;
            }
            number += advance();
          }
          if (number.length <= 2) {
            // only 0x
            utility.throwError('unexpected token');
          }
          if (index < length) {
            ch = source.charCodeAt(index);
            if (esutils.code.isIdentifierStartES5(ch)) {
              utility.throwError('unexpected token');
            }
          }
          value = parseInt(number, 16);
          return Token.NUMBER;
        }
        if (esutils.code.isOctalDigit(ch)) {
          number += advance();
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isOctalDigit(ch)) {
              break;
            }
            number += advance();
          }
          if (index < length) {
            ch = source.charCodeAt(index);
            if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
              utility.throwError('unexpected token');
            }
          }
          value = parseInt(number, 8);
          return Token.NUMBER;
        }
        if (esutils.code.isDecimalDigit(ch)) {
          utility.throwError('unexpected token');
        }
      }
      while (index < length) {
        ch = source.charCodeAt(index);
        if (!esutils.code.isDecimalDigit(ch)) {
          break;
        }
        number += advance();
      }
    }
    if (ch === 0x2E /* '.' */) {
      number += advance();
      while (index < length) {
        ch = source.charCodeAt(index);
        if (!esutils.code.isDecimalDigit(ch)) {
          break;
        }
        number += advance();
      }
    }
    if (ch === 0x65 /* 'e' */ || ch === 0x45 /* 'E' */) {
      number += advance();
      ch = source.charCodeAt(index);
      if (ch === 0x2B /* '+' */ || ch === 0x2D /* '-' */) {
        number += advance();
      }
      ch = source.charCodeAt(index);
      if (esutils.code.isDecimalDigit(ch)) {
        number += advance();
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!esutils.code.isDecimalDigit(ch)) {
            break;
          }
          number += advance();
        }
      } else {
        utility.throwError('unexpected token');
      }
    }
    if (index < length) {
      ch = source.charCodeAt(index);
      if (esutils.code.isIdentifierStartES5(ch)) {
        utility.throwError('unexpected token');
      }
    }
    value = parseFloat(number);
    return Token.NUMBER;
  }
  function scanTypeName() {
    var ch, ch2;
    value = advance();
    while (index < length && isTypeName(source.charCodeAt(index))) {
      ch = source.charCodeAt(index);
      if (ch === 0x2E /* '.' */) {
        if (index + 1 >= length) {
          return Token.ILLEGAL;
        }
        ch2 = source.charCodeAt(index + 1);
        if (ch2 === 0x3C /* '<' */) {
          break;
        }
      }
      value += advance();
    }
    return Token.NAME;
  }
  function next() {
    var ch;
    previous = index;
    while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
      advance();
    }
    if (index >= length) {
      token = Token.EOF;
      return token;
    }
    ch = source.charCodeAt(index);
    switch (ch) {
      case 0x27: /* ''' */
      case 0x22:
        /* '"' */
        token = scanString();
        return token;
      case 0x3A:
        /* ':' */
        advance();
        token = Token.COLON;
        return token;
      case 0x2C:
        /* ',' */
        advance();
        token = Token.COMMA;
        return token;
      case 0x28:
        /* '(' */
        advance();
        token = Token.LPAREN;
        return token;
      case 0x29:
        /* ')' */
        advance();
        token = Token.RPAREN;
        return token;
      case 0x5B:
        /* '[' */
        advance();
        token = Token.LBRACK;
        return token;
      case 0x5D:
        /* ']' */
        advance();
        token = Token.RBRACK;
        return token;
      case 0x7B:
        /* '{' */
        advance();
        token = Token.LBRACE;
        return token;
      case 0x7D:
        /* '}' */
        advance();
        token = Token.RBRACE;
        return token;
      case 0x2E:
        /* '.' */
        if (index + 1 < length) {
          ch = source.charCodeAt(index + 1);
          if (ch === 0x3C /* '<' */) {
            advance(); // '.'
            advance(); // '<'
            token = Token.DOT_LT;
            return token;
          }
          if (ch === 0x2E /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E /* '.' */) {
            advance(); // '.'
            advance(); // '.'
            advance(); // '.'
            token = Token.REST;
            return token;
          }
          if (esutils.code.isDecimalDigit(ch)) {
            token = scanNumber();
            return token;
          }
        }
        token = Token.ILLEGAL;
        return token;
      case 0x3C:
        /* '<' */
        advance();
        token = Token.LT;
        return token;
      case 0x3E:
        /* '>' */
        advance();
        token = Token.GT;
        return token;
      case 0x2A:
        /* '*' */
        advance();
        token = Token.STAR;
        return token;
      case 0x7C:
        /* '|' */
        advance();
        token = Token.PIPE;
        return token;
      case 0x3F:
        /* '?' */
        advance();
        token = Token.QUESTION;
        return token;
      case 0x21:
        /* '!' */
        advance();
        token = Token.BANG;
        return token;
      case 0x3D:
        /* '=' */
        advance();
        token = Token.EQUAL;
        return token;
      case 0x2D:
        /* '-' */
        token = scanNumber();
        return token;
      default:
        if (esutils.code.isDecimalDigit(ch)) {
          token = scanNumber();
          return token;
        }

        // type string permits following case,
        //
        // namespace.module.MyClass
        //
        // this reduced 1 token TK_NAME
        utility.assert(isTypeName(ch));
        token = scanTypeName();
        return token;
    }
  }
  function consume(target, text) {
    utility.assert(token === target, text || 'consumed token not matched');
    next();
  }
  function expect(target, message) {
    if (token !== target) {
      utility.throwError(message || 'unexpected token');
    }
    next();
  }

  // UnionType := '(' TypeUnionList ')'
  //
  // TypeUnionList :=
  //     <<empty>>
  //   | NonemptyTypeUnionList
  //
  // NonemptyTypeUnionList :=
  //     TypeExpression
  //   | TypeExpression '|' NonemptyTypeUnionList
  function parseUnionType() {
    var elements,
      startIndex = index - 1;
    consume(Token.LPAREN, 'UnionType should start with (');
    elements = [];
    if (token !== Token.RPAREN) {
      while (true) {
        elements.push(parseTypeExpression());
        if (token === Token.RPAREN) {
          break;
        }
        expect(Token.PIPE);
      }
    }
    consume(Token.RPAREN, 'UnionType should end with )');
    return maybeAddRange({
      type: Syntax.UnionType,
      elements: elements
    }, [startIndex, previous]);
  }

  // ArrayType := '[' ElementTypeList ']'
  //
  // ElementTypeList :=
  //     <<empty>>
  //  | TypeExpression
  //  | '...' TypeExpression
  //  | TypeExpression ',' ElementTypeList
  function parseArrayType() {
    var elements,
      startIndex = index - 1,
      restStartIndex;
    consume(Token.LBRACK, 'ArrayType should start with [');
    elements = [];
    while (token !== Token.RBRACK) {
      if (token === Token.REST) {
        restStartIndex = index - 3;
        consume(Token.REST);
        elements.push(maybeAddRange({
          type: Syntax.RestType,
          expression: parseTypeExpression()
        }, [restStartIndex, previous]));
        break;
      } else {
        elements.push(parseTypeExpression());
      }
      if (token !== Token.RBRACK) {
        expect(Token.COMMA);
      }
    }
    expect(Token.RBRACK);
    return maybeAddRange({
      type: Syntax.ArrayType,
      elements: elements
    }, [startIndex, previous]);
  }
  function parseFieldName() {
    var v = value;
    if (token === Token.NAME || token === Token.STRING) {
      next();
      return v;
    }
    if (token === Token.NUMBER) {
      consume(Token.NUMBER);
      return String(v);
    }
    utility.throwError('unexpected token');
  }

  // FieldType :=
  //     FieldName
  //   | FieldName ':' TypeExpression
  //
  // FieldName :=
  //     NameExpression
  //   | StringLiteral
  //   | NumberLiteral
  //   | ReservedIdentifier
  function parseFieldType() {
    var key,
      rangeStart = previous;
    key = parseFieldName();
    if (token === Token.COLON) {
      consume(Token.COLON);
      return maybeAddRange({
        type: Syntax.FieldType,
        key: key,
        value: parseTypeExpression()
      }, [rangeStart, previous]);
    }
    return maybeAddRange({
      type: Syntax.FieldType,
      key: key,
      value: null
    }, [rangeStart, previous]);
  }

  // RecordType := '{' FieldTypeList '}'
  //
  // FieldTypeList :=
  //     <<empty>>
  //   | FieldType
  //   | FieldType ',' FieldTypeList
  function parseRecordType() {
    var fields,
      rangeStart = index - 1,
      rangeEnd;
    consume(Token.LBRACE, 'RecordType should start with {');
    fields = [];
    if (token === Token.COMMA) {
      consume(Token.COMMA);
    } else {
      while (token !== Token.RBRACE) {
        fields.push(parseFieldType());
        if (token !== Token.RBRACE) {
          expect(Token.COMMA);
        }
      }
    }
    rangeEnd = index;
    expect(Token.RBRACE);
    return maybeAddRange({
      type: Syntax.RecordType,
      fields: fields
    }, [rangeStart, rangeEnd]);
  }

  // NameExpression :=
  //    Identifier
  //  | TagIdentifier ':' Identifier
  //
  // Tag identifier is one of "module", "external" or "event"
  // Identifier is the same as Token.NAME, including any dots, something like
  // namespace.module.MyClass
  function parseNameExpression() {
    var name = value,
      rangeStart = index - name.length;
    expect(Token.NAME);
    if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {
      consume(Token.COLON);
      name += ':' + value;
      expect(Token.NAME);
    }
    return maybeAddRange({
      type: Syntax.NameExpression,
      name: name
    }, [rangeStart, previous]);
  }

  // TypeExpressionList :=
  //     TopLevelTypeExpression
  //   | TopLevelTypeExpression ',' TypeExpressionList
  function parseTypeExpressionList() {
    var elements = [];
    elements.push(parseTop());
    while (token === Token.COMMA) {
      consume(Token.COMMA);
      elements.push(parseTop());
    }
    return elements;
  }

  // TypeName :=
  //     NameExpression
  //   | NameExpression TypeApplication
  //
  // TypeApplication :=
  //     '.<' TypeExpressionList '>'
  //   | '<' TypeExpressionList '>'   // this is extension of doctrine
  function parseTypeName() {
    var expr,
      applications,
      startIndex = index - value.length;
    expr = parseNameExpression();
    if (token === Token.DOT_LT || token === Token.LT) {
      next();
      applications = parseTypeExpressionList();
      expect(Token.GT);
      return maybeAddRange({
        type: Syntax.TypeApplication,
        expression: expr,
        applications: applications
      }, [startIndex, previous]);
    }
    return expr;
  }

  // ResultType :=
  //     <<empty>>
  //   | ':' void
  //   | ':' TypeExpression
  //
  // BNF is above
  // but, we remove <<empty>> pattern, so token is always TypeToken::COLON
  function parseResultType() {
    consume(Token.COLON, 'ResultType should start with :');
    if (token === Token.NAME && value === 'void') {
      consume(Token.NAME);
      return {
        type: Syntax.VoidLiteral
      };
    }
    return parseTypeExpression();
  }

  // ParametersType :=
  //     RestParameterType
  //   | NonRestParametersType
  //   | NonRestParametersType ',' RestParameterType
  //
  // RestParameterType :=
  //     '...'
  //     '...' Identifier
  //
  // NonRestParametersType :=
  //     ParameterType ',' NonRestParametersType
  //   | ParameterType
  //   | OptionalParametersType
  //
  // OptionalParametersType :=
  //     OptionalParameterType
  //   | OptionalParameterType, OptionalParametersType
  //
  // OptionalParameterType := ParameterType=
  //
  // ParameterType := TypeExpression | Identifier ':' TypeExpression
  //
  // Identifier is "new" or "this"
  function parseParametersType() {
    var params = [],
      optionalSequence = false,
      expr,
      rest = false,
      startIndex,
      restStartIndex = index - 3,
      nameStartIndex;
    while (token !== Token.RPAREN) {
      if (token === Token.REST) {
        // RestParameterType
        consume(Token.REST);
        rest = true;
      }
      startIndex = previous;
      expr = parseTypeExpression();
      if (expr.type === Syntax.NameExpression && token === Token.COLON) {
        nameStartIndex = previous - expr.name.length;
        // Identifier ':' TypeExpression
        consume(Token.COLON);
        expr = maybeAddRange({
          type: Syntax.ParameterType,
          name: expr.name,
          expression: parseTypeExpression()
        }, [nameStartIndex, previous]);
      }
      if (token === Token.EQUAL) {
        consume(Token.EQUAL);
        expr = maybeAddRange({
          type: Syntax.OptionalType,
          expression: expr
        }, [startIndex, previous]);
        optionalSequence = true;
      } else {
        if (optionalSequence) {
          utility.throwError('unexpected token');
        }
      }
      if (rest) {
        expr = maybeAddRange({
          type: Syntax.RestType,
          expression: expr
        }, [restStartIndex, previous]);
      }
      params.push(expr);
      if (token !== Token.RPAREN) {
        expect(Token.COMMA);
      }
    }
    return params;
  }

  // FunctionType := 'function' FunctionSignatureType
  //
  // FunctionSignatureType :=
  //   | TypeParameters '(' ')' ResultType
  //   | TypeParameters '(' ParametersType ')' ResultType
  //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType
  //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType
  function parseFunctionType() {
    var isNew,
      thisBinding,
      params,
      result,
      fnType,
      startIndex = index - value.length;
    utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
    consume(Token.NAME);

    // Google Closure Compiler is not implementing TypeParameters.
    // So we do not. if we don't get '(', we see it as error.
    expect(Token.LPAREN);
    isNew = false;
    params = [];
    thisBinding = null;
    if (token !== Token.RPAREN) {
      // ParametersType or 'this'
      if (token === Token.NAME && (value === 'this' || value === 'new')) {
        // 'this' or 'new'
        // 'new' is Closure Compiler extension
        isNew = value === 'new';
        consume(Token.NAME);
        expect(Token.COLON);
        thisBinding = parseTypeName();
        if (token === Token.COMMA) {
          consume(Token.COMMA);
          params = parseParametersType();
        }
      } else {
        params = parseParametersType();
      }
    }
    expect(Token.RPAREN);
    result = null;
    if (token === Token.COLON) {
      result = parseResultType();
    }
    fnType = maybeAddRange({
      type: Syntax.FunctionType,
      params: params,
      result: result
    }, [startIndex, previous]);
    if (thisBinding) {
      // avoid adding null 'new' and 'this' properties
      fnType['this'] = thisBinding;
      if (isNew) {
        fnType['new'] = true;
      }
    }
    return fnType;
  }

  // BasicTypeExpression :=
  //     '*'
  //   | 'null'
  //   | 'undefined'
  //   | TypeName
  //   | FunctionType
  //   | UnionType
  //   | RecordType
  //   | ArrayType
  function parseBasicTypeExpression() {
    var context, startIndex;
    switch (token) {
      case Token.STAR:
        consume(Token.STAR);
        return maybeAddRange({
          type: Syntax.AllLiteral
        }, [previous - 1, previous]);
      case Token.LPAREN:
        return parseUnionType();
      case Token.LBRACK:
        return parseArrayType();
      case Token.LBRACE:
        return parseRecordType();
      case Token.NAME:
        startIndex = index - value.length;
        if (value === 'null') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.NullLiteral
          }, [startIndex, previous]);
        }
        if (value === 'undefined') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.UndefinedLiteral
          }, [startIndex, previous]);
        }
        if (value === 'true' || value === 'false') {
          consume(Token.NAME);
          return maybeAddRange({
            type: Syntax.BooleanLiteralType,
            value: value === 'true'
          }, [startIndex, previous]);
        }
        context = Context.save();
        if (value === 'function') {
          try {
            return parseFunctionType();
          } catch (e) {
            context.restore();
          }
        }
        return parseTypeName();
      case Token.STRING:
        next();
        return maybeAddRange({
          type: Syntax.StringLiteralType,
          value: value
        }, [previous - value.length - 2, previous]);
      case Token.NUMBER:
        next();
        return maybeAddRange({
          type: Syntax.NumericLiteralType,
          value: value
        }, [previous - String(value).length, previous]);
      default:
        utility.throwError('unexpected token');
    }
  }

  // TypeExpression :=
  //     BasicTypeExpression
  //   | '?' BasicTypeExpression
  //   | '!' BasicTypeExpression
  //   | BasicTypeExpression '?'
  //   | BasicTypeExpression '!'
  //   | '?'
  //   | BasicTypeExpression '[]'
  function parseTypeExpression() {
    var expr, rangeStart;
    if (token === Token.QUESTION) {
      rangeStart = index - 1;
      consume(Token.QUESTION);
      if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
        return maybeAddRange({
          type: Syntax.NullableLiteral
        }, [rangeStart, previous]);
      }
      return maybeAddRange({
        type: Syntax.NullableType,
        expression: parseBasicTypeExpression(),
        prefix: true
      }, [rangeStart, previous]);
    } else if (token === Token.BANG) {
      rangeStart = index - 1;
      consume(Token.BANG);
      return maybeAddRange({
        type: Syntax.NonNullableType,
        expression: parseBasicTypeExpression(),
        prefix: true
      }, [rangeStart, previous]);
    } else {
      rangeStart = previous;
    }
    expr = parseBasicTypeExpression();
    if (token === Token.BANG) {
      consume(Token.BANG);
      return maybeAddRange({
        type: Syntax.NonNullableType,
        expression: expr,
        prefix: false
      }, [rangeStart, previous]);
    }
    if (token === Token.QUESTION) {
      consume(Token.QUESTION);
      return maybeAddRange({
        type: Syntax.NullableType,
        expression: expr,
        prefix: false
      }, [rangeStart, previous]);
    }
    if (token === Token.LBRACK) {
      consume(Token.LBRACK);
      expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
      return maybeAddRange({
        type: Syntax.TypeApplication,
        expression: maybeAddRange({
          type: Syntax.NameExpression,
          name: 'Array'
        }, [rangeStart, previous]),
        applications: [expr]
      }, [rangeStart, previous]);
    }
    return expr;
  }

  // TopLevelTypeExpression :=
  //      TypeExpression
  //    | TypeUnionList
  //
  // This rule is Google Closure Compiler extension, not ES4
  // like,
  //   { number | string }
  // If strict to ES4, we should write it as
  //   { (number|string) }
  function parseTop() {
    var expr, elements;
    expr = parseTypeExpression();
    if (token !== Token.PIPE) {
      return expr;
    }
    elements = [expr];
    consume(Token.PIPE);
    while (true) {
      elements.push(parseTypeExpression());
      if (token !== Token.PIPE) {
        break;
      }
      consume(Token.PIPE);
    }
    return maybeAddRange({
      type: Syntax.UnionType,
      elements: elements
    }, [0, index]);
  }
  function parseTopParamType() {
    var expr;
    if (token === Token.REST) {
      consume(Token.REST);
      return maybeAddRange({
        type: Syntax.RestType,
        expression: parseTop()
      }, [0, index]);
    }
    expr = parseTop();
    if (token === Token.EQUAL) {
      consume(Token.EQUAL);
      return maybeAddRange({
        type: Syntax.OptionalType,
        expression: expr
      }, [0, index]);
    }
    return expr;
  }
  function parseType(src, opt) {
    var expr;
    source = src;
    length = source.length;
    index = 0;
    previous = 0;
    addRange = opt && opt.range;
    rangeOffset = opt && opt.startIndex || 0;
    next();
    expr = parseTop();
    if (opt && opt.midstream) {
      return {
        expression: expr,
        index: previous
      };
    }
    if (token !== Token.EOF) {
      utility.throwError('not reach to EOF');
    }
    return expr;
  }
  function parseParamType(src, opt) {
    var expr;
    source = src;
    length = source.length;
    index = 0;
    previous = 0;
    addRange = opt && opt.range;
    rangeOffset = opt && opt.startIndex || 0;
    next();
    expr = parseTopParamType();
    if (opt && opt.midstream) {
      return {
        expression: expr,
        index: previous
      };
    }
    if (token !== Token.EOF) {
      utility.throwError('not reach to EOF');
    }
    return expr;
  }
  function stringifyImpl(node, compact, topLevel) {
    var result, i, iz;
    switch (node.type) {
      case Syntax.NullableLiteral:
        result = '?';
        break;
      case Syntax.AllLiteral:
        result = '*';
        break;
      case Syntax.NullLiteral:
        result = 'null';
        break;
      case Syntax.UndefinedLiteral:
        result = 'undefined';
        break;
      case Syntax.VoidLiteral:
        result = 'void';
        break;
      case Syntax.UnionType:
        if (!topLevel) {
          result = '(';
        } else {
          result = '';
        }
        for (i = 0, iz = node.elements.length; i < iz; ++i) {
          result += stringifyImpl(node.elements[i], compact);
          if (i + 1 !== iz) {
            result += compact ? '|' : ' | ';
          }
        }
        if (!topLevel) {
          result += ')';
        }
        break;
      case Syntax.ArrayType:
        result = '[';
        for (i = 0, iz = node.elements.length; i < iz; ++i) {
          result += stringifyImpl(node.elements[i], compact);
          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }
        result += ']';
        break;
      case Syntax.RecordType:
        result = '{';
        for (i = 0, iz = node.fields.length; i < iz; ++i) {
          result += stringifyImpl(node.fields[i], compact);
          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }
        result += '}';
        break;
      case Syntax.FieldType:
        if (node.value) {
          result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
        } else {
          result = node.key;
        }
        break;
      case Syntax.FunctionType:
        result = compact ? 'function(' : 'function (';
        if (node['this']) {
          if (node['new']) {
            result += compact ? 'new:' : 'new: ';
          } else {
            result += compact ? 'this:' : 'this: ';
          }
          result += stringifyImpl(node['this'], compact);
          if (node.params.length !== 0) {
            result += compact ? ',' : ', ';
          }
        }
        for (i = 0, iz = node.params.length; i < iz; ++i) {
          result += stringifyImpl(node.params[i], compact);
          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }
        result += ')';
        if (node.result) {
          result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
        }
        break;
      case Syntax.ParameterType:
        result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
        break;
      case Syntax.RestType:
        result = '...';
        if (node.expression) {
          result += stringifyImpl(node.expression, compact);
        }
        break;
      case Syntax.NonNullableType:
        if (node.prefix) {
          result = '!' + stringifyImpl(node.expression, compact);
        } else {
          result = stringifyImpl(node.expression, compact) + '!';
        }
        break;
      case Syntax.OptionalType:
        result = stringifyImpl(node.expression, compact) + '=';
        break;
      case Syntax.NullableType:
        if (node.prefix) {
          result = '?' + stringifyImpl(node.expression, compact);
        } else {
          result = stringifyImpl(node.expression, compact) + '?';
        }
        break;
      case Syntax.NameExpression:
        result = node.name;
        break;
      case Syntax.TypeApplication:
        result = stringifyImpl(node.expression, compact) + '.<';
        for (i = 0, iz = node.applications.length; i < iz; ++i) {
          result += stringifyImpl(node.applications[i], compact);
          if (i + 1 !== iz) {
            result += compact ? ',' : ', ';
          }
        }
        result += '>';
        break;
      case Syntax.StringLiteralType:
        result = '"' + node.value + '"';
        break;
      case Syntax.NumericLiteralType:
        result = String(node.value);
        break;
      case Syntax.BooleanLiteralType:
        result = String(node.value);
        break;
      default:
        utility.throwError('Unknown type ' + node.type);
    }
    return result;
  }
  function stringify(node, options) {
    if (options == null) {
      options = {};
    }
    return stringifyImpl(node, options.compact, options.topLevel);
  }
  exports.parseType = parseType;
  exports.parseParamType = parseParamType;
  exports.stringify = stringify;
  exports.Syntax = Syntax;
})();
/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 478 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * @fileoverview Utilities for Doctrine
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 */

(function () {
  'use strict';

  var VERSION;
  VERSION = (__webpack_require__(479).version);
  exports.VERSION = VERSION;
  function DoctrineError(message) {
    this.name = 'DoctrineError';
    this.message = message;
  }
  DoctrineError.prototype = function () {
    var Middle = function () {};
    Middle.prototype = Error.prototype;
    return new Middle();
  }();
  DoctrineError.prototype.constructor = DoctrineError;
  exports.DoctrineError = DoctrineError;
  function throwError(message) {
    throw new DoctrineError(message);
  }
  exports.throwError = throwError;
  exports.assert = __webpack_require__(3);
})();

/* vim: set sw=4 ts=4 et tw=80 : */

/***/ }),
/* 479 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"doctrine","description":"JSDoc parser","homepage":"https://github.com/eslint/doctrine","main":"lib/doctrine.js","version":"3.0.0","engines":{"node":">=6.0.0"},"directories":{"lib":"./lib"},"files":["lib"],"maintainers":[{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com","web":"https://www.nczonline.net"},{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"https://github.com/Constellation"}],"repository":"eslint/doctrine","devDependencies":{"coveralls":"^3.0.1","dateformat":"^1.0.11","eslint":"^1.10.3","eslint-release":"^1.0.0","linefix":"^0.1.1","mocha":"^3.4.2","npm-license":"^0.3.1","nyc":"^10.3.2","semver":"^5.0.3","shelljs":"^0.5.3","shelljs-nodecli":"^0.1.1","should":"^5.0.1"},"license":"Apache-2.0","scripts":{"pretest":"npm run lint","test":"nyc mocha","coveralls":"nyc report --reporter=text-lcov | coveralls","lint":"eslint lib/","generate-release":"eslint-generate-release","generate-alpharelease":"eslint-generate-prerelease alpha","generate-betarelease":"eslint-generate-prerelease beta","generate-rcrelease":"eslint-generate-prerelease rc","publish-release":"eslint-publish-release"},"dependencies":{"esutils":"^2.0.2"}}');

/***/ }),
/* 480 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Ensures that the results of typeof are compared against a valid string
 * @author Ian Christian Myers
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce comparing `typeof` expressions against valid strings",
      category: "Possible Errors",
      recommended: true,
      url: "https://eslint.org/docs/rules/valid-typeof"
    },
    schema: [{
      type: "object",
      properties: {
        requireStringLiterals: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    messages: {
      invalidValue: "Invalid typeof comparison value.",
      notString: "Typeof comparisons should be to string literals."
    }
  },
  create(context) {
    const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
      OPERATORS = ["==", "===", "!=", "!=="];
    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;

    /**
     * Determines whether a node is a typeof expression.
     * @param {ASTNode} node The node
     * @returns {boolean} `true` if the node is a typeof expression
     */
    function isTypeofExpression(node) {
      return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      UnaryExpression(node) {
        if (isTypeofExpression(node)) {
          const parent = context.getAncestors().pop();
          if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
            const sibling = parent.left === node ? parent.right : parent.left;
            if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
              const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
              if (VALID_TYPES.indexOf(value) === -1) {
                context.report({
                  node: sibling,
                  messageId: "invalidValue"
                });
              }
            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
              context.report({
                node: sibling,
                messageId: "notString"
              });
            }
          }
        }
      }
    };
  }
};

/***/ }),
/* 481 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to enforce var declarations are only at the top of a function.
 * @author Danny Fritz
 * @author Gyandeep Singh
 */


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `var` declarations be placed at the top of their containing scope",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/vars-on-top"
    },
    schema: [],
    messages: {
      top: "All 'var' declarations must be at the top of the function scope."
    }
  },
  create(context) {
    //--------------------------------------------------------------------------
    // Helpers
    //--------------------------------------------------------------------------

    /**
     * @param {ASTNode} node - any node
     * @returns {boolean} whether the given node structurally represents a directive
     */
    function looksLikeDirective(node) {
      return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    /**
     * Check to see if its a ES6 import declaration
     * @param {ASTNode} node - any node
     * @returns {boolean} whether the given node represents a import declaration
     */
    function looksLikeImport(node) {
      return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
    }

    /**
     * Checks whether a given node is a variable declaration or not.
     *
     * @param {ASTNode} node - any node
     * @returns {boolean} `true` if the node is a variable declaration.
     */
    function isVariableDeclaration(node) {
      return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
    }

    /**
     * Checks whether this variable is on top of the block body
     * @param {ASTNode} node - The node to check
     * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block
     * @returns {boolean} True if var is on top otherwise false
     */
    function isVarOnTop(node, statements) {
      const l = statements.length;
      let i = 0;

      // skip over directives
      for (; i < l; ++i) {
        if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
          break;
        }
      }
      for (; i < l; ++i) {
        if (!isVariableDeclaration(statements[i])) {
          return false;
        }
        if (statements[i] === node) {
          return true;
        }
      }
      return false;
    }

    /**
     * Checks whether variable is on top at the global level
     * @param {ASTNode} node - The node to check
     * @param {ASTNode} parent - Parent of the node
     * @returns {void}
     */
    function globalVarCheck(node, parent) {
      if (!isVarOnTop(node, parent.body)) {
        context.report({
          node,
          messageId: "top"
        });
      }
    }

    /**
     * Checks whether variable is on top at functional block scope level
     * @param {ASTNode} node - The node to check
     * @param {ASTNode} parent - Parent of the node
     * @param {ASTNode} grandParent - Parent of the node's parent
     * @returns {void}
     */
    function blockScopeVarCheck(node, parent, grandParent) {
      if (!(/Function/u.test(grandParent.type) && parent.type === "BlockStatement" && isVarOnTop(node, parent.body))) {
        context.report({
          node,
          messageId: "top"
        });
      }
    }

    //--------------------------------------------------------------------------
    // Public API
    //--------------------------------------------------------------------------

    return {
      "VariableDeclaration[kind='var']"(node) {
        if (node.parent.type === "ExportNamedDeclaration") {
          globalVarCheck(node.parent, node.parent.parent);
        } else if (node.parent.type === "Program") {
          globalVarCheck(node, node.parent);
        } else {
          blockScopeVarCheck(node, node.parent, node.parent.parent);
        }
      }
    };
  }
};

/***/ }),
/* 482 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to flag when IIFE is not wrapped in parens
 * @author Ilya Volodin
 */



//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around immediate `function` invocations",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/wrap-iife"
    },
    schema: [{
      enum: ["outside", "inside", "any"]
    }, {
      type: "object",
      properties: {
        functionPrototypeMethods: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      wrapInvocation: "Wrap an immediate function invocation in parentheses.",
      wrapExpression: "Wrap only the function expression in parens.",
      moveInvocation: "Move the invocation into the parens that contain the function."
    }
  },
  create(context) {
    const style = context.options[0] || "outside";
    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;
    const sourceCode = context.getSourceCode();

    /**
     * Check if the node is wrapped in ()
     * @param {ASTNode} node node to evaluate
     * @returns {boolean} True if it is wrapped
     * @private
     */
    function wrapped(node) {
      return astUtils.isParenthesised(sourceCode, node);
    }

    /**
     * Get the function node from an IIFE
     * @param {ASTNode} node node to evaluate
     * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist
     */
    function getFunctionNodeFromIIFE(node) {
      const callee = node.callee;
      if (callee.type === "FunctionExpression") {
        return callee;
      }
      if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
        return callee.object;
      }
      return null;
    }
    return {
      CallExpression(node) {
        const innerNode = getFunctionNodeFromIIFE(node);
        if (!innerNode) {
          return;
        }
        const callExpressionWrapped = wrapped(node),
          functionExpressionWrapped = wrapped(innerNode);
        if (!callExpressionWrapped && !functionExpressionWrapped) {
          context.report({
            node,
            messageId: "wrapInvocation",
            fix(fixer) {
              const nodeToSurround = style === "inside" ? innerNode : node;
              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
            }
          });
        } else if (style === "inside" && !functionExpressionWrapped) {
          context.report({
            node,
            messageId: "wrapExpression",
            fix(fixer) {
              /*
               * The outer call expression will always be wrapped at this point.
               * Replace the range between the end of the function expression and the end of the call expression.
               * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.
               * Replace the parens from the outer expression, and parenthesize the function expression.
               */
              const parenAfter = sourceCode.getTokenAfter(node);
              return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);
            }
          });
        } else if (style === "outside" && !callExpressionWrapped) {
          context.report({
            node,
            messageId: "moveInvocation",
            fix(fixer) {
              /*
               * The inner function expression will always be wrapped at this point.
               * It's only necessary to replace the range between the end of the function expression
               * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`
               * should get replaced with `(bar))`.
               */
              const parenAfter = sourceCode.getTokenAfter(innerNode);
              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);
            }
          });
        }
      }
    };
  }
};

/***/ }),
/* 483 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to flag when regex literals are not wrapped in parens
 * @author Matt DuVall <http://www.mattduvall.com>
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require parenthesis around regex literals",
      category: "Stylistic Issues",
      recommended: false,
      url: "https://eslint.org/docs/rules/wrap-regex"
    },
    schema: [],
    fixable: "code",
    messages: {
      requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    return {
      Literal(node) {
        const token = sourceCode.getFirstToken(node),
          nodeType = token.type;
        if (nodeType === "RegularExpression") {
          const beforeToken = sourceCode.getTokenBefore(node);
          const afterToken = sourceCode.getTokenAfter(node);
          const ancestors = context.getAncestors();
          const grandparent = ancestors[ancestors.length - 1];
          if (grandparent.type === "MemberExpression" && grandparent.object === node && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) {
            context.report({
              node,
              messageId: "requireParens",
              fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
            });
          }
        }
      }
    };
  }
};

/***/ }),
/* 484 */
/***/ ((module) => {

"use strict";
/**
 * @fileoverview Rule to check the spacing around the * in yield* expressions.
 * @author Bryan Smith
 */



//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around the `*` in `yield*` expressions",
      category: "ECMAScript 6",
      recommended: false,
      url: "https://eslint.org/docs/rules/yield-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(context) {
    const sourceCode = context.getSourceCode();
    const mode = function (option) {
      if (!option || typeof option === "string") {
        return {
          before: {
            before: true,
            after: false
          },
          after: {
            before: false,
            after: true
          },
          both: {
            before: true,
            after: true
          },
          neither: {
            before: false,
            after: false
          }
        }[option || "after"];
      }
      return option;
    }(context.options[0]);

    /**
     * Checks the spacing between two tokens before or after the star token.
     * @param {string} side Either "before" or "after".
     * @param {Token} leftToken `function` keyword token if side is "before", or
     *     star token if side is "after".
     * @param {Token} rightToken Star token if side is "before", or identifier
     *     token if side is "after".
     * @returns {void}
     */
    function checkSpacing(side, leftToken, rightToken) {
      if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
        const after = leftToken.value === "*";
        const spaceRequired = mode[side];
        const node = after ? leftToken : rightToken;
        let messageId = "";
        if (spaceRequired) {
          messageId = side === "before" ? "missingBefore" : "missingAfter";
        } else {
          messageId = side === "before" ? "unexpectedBefore" : "unexpectedAfter";
        }
        context.report({
          node,
          messageId,
          fix(fixer) {
            if (spaceRequired) {
              if (after) {
                return fixer.insertTextAfter(node, " ");
              }
              return fixer.insertTextBefore(node, " ");
            }
            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
          }
        });
      }
    }

    /**
     * Enforces the spacing around the star if node is a yield* expression.
     * @param {ASTNode} node A yield expression node.
     * @returns {void}
     */
    function checkExpression(node) {
      if (!node.delegate) {
        return;
      }
      const tokens = sourceCode.getFirstTokens(node, 3);
      const yieldToken = tokens[0];
      const starToken = tokens[1];
      const nextToken = tokens[2];
      checkSpacing("before", yieldToken, starToken);
      checkSpacing("after", starToken, nextToken);
    }
    return {
      YieldExpression: checkExpression
    };
  }
};

/***/ }),
/* 485 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Rule to require or disallow yoda comparisons
 * @author Nicholas C. Zakas
 */


//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------
const astUtils = __webpack_require__(110);

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines whether an operator is a comparison operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is a comparison operator.
 */
function isComparisonOperator(operator) {
  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);
}

/**
 * Determines whether an operator is an equality operator.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether or not it is an equality operator.
 */
function isEqualityOperator(operator) {
  return /^(==|===)$/u.test(operator);
}

/**
 * Determines whether an operator is one used in a range test.
 * Allowed operators are `<` and `<=`.
 * @param {string} operator The operator to check.
 * @returns {boolean} Whether the operator is used in range tests.
 */
function isRangeTestOperator(operator) {
  return ["<", "<="].indexOf(operator) >= 0;
}

/**
 * Determines whether a non-Literal node is a negative number that should be
 * treated as if it were a single Literal node.
 * @param {ASTNode} node Node to test.
 * @returns {boolean} True if the node is a negative number that looks like a
 *                    real literal and should be treated as such.
 */
function looksLikeLiteral(node) {
  return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && node.argument.type === "Literal" && typeof node.argument.value === "number";
}

/**
 * Attempts to derive a Literal node from nodes that are treated like literals.
 * @param {ASTNode} node Node to normalize.
 * @param {number} [defaultValue] The default value to be returned if the node
 *                                is not a Literal.
 * @returns {ASTNode} One of the following options.
 *  1. The original node if the node is already a Literal
 *  2. A normalized Literal node with the negative number as the value if the
 *     node represents a negative number literal.
 *  3. The Literal node which has the `defaultValue` argument if it exists.
 *  4. Otherwise `null`.
 */
function getNormalizedLiteral(node, defaultValue) {
  if (node.type === "Literal") {
    return node;
  }
  if (looksLikeLiteral(node)) {
    return {
      type: "Literal",
      value: -node.argument.value,
      raw: `-${node.argument.value}`
    };
  }
  if (defaultValue) {
    return {
      type: "Literal",
      value: defaultValue,
      raw: String(defaultValue)
    };
  }
  return null;
}

/**
 * Checks whether two expressions reference the same value. For example:
 *     a = a
 *     a.b = a.b
 *     a[0] = a[0]
 *     a['b'] = a['b']
 * @param   {ASTNode} a Left side of the comparison.
 * @param   {ASTNode} b Right side of the comparison.
 * @returns {boolean}   True if both sides match and reference the same value.
 */
function same(a, b) {
  if (a.type !== b.type) {
    return false;
  }
  switch (a.type) {
    case "Identifier":
      return a.name === b.name;
    case "Literal":
      return a.value === b.value;
    case "MemberExpression":
      {
        const nameA = astUtils.getStaticPropertyName(a);

        // x.y = x["y"]
        if (nameA) {
          return same(a.object, b.object) && nameA === astUtils.getStaticPropertyName(b);
        }

        /*
         * x[0] = x[0]
         * x[y] = x[y]
         * x.y = x.y
         */
        return a.computed === b.computed && same(a.object, b.object) && same(a.property, b.property);
      }
    case "ThisExpression":
      return true;
    default:
      return false;
  }
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow \"Yoda\" conditions",
      category: "Best Practices",
      recommended: false,
      url: "https://eslint.org/docs/rules/yoda"
    },
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptRange: {
          type: "boolean",
          default: false
        },
        onlyEquality: {
          type: "boolean",
          default: false
        }
      },
      additionalProperties: false
    }],
    fixable: "code",
    messages: {
      expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
    }
  },
  create(context) {
    // Default to "never" (!always) if no option
    const always = context.options[0] === "always";
    const exceptRange = context.options[1] && context.options[1].exceptRange;
    const onlyEquality = context.options[1] && context.options[1].onlyEquality;
    const sourceCode = context.getSourceCode();

    /**
     * Determines whether node represents a range test.
     * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
     * both operators must be `<` or `<=`. Finally, the literal on the left side
     * must be less than or equal to the literal on the right side so that the
     * test makes any sense.
     * @param {ASTNode} node LogicalExpression node to test.
     * @returns {boolean} Whether node is a range test.
     */
    function isRangeTest(node) {
      const left = node.left,
        right = node.right;

      /**
       * Determines whether node is of the form `0 <= x && x < 1`.
       * @returns {boolean} Whether node is a "between" range test.
       */
      function isBetweenTest() {
        let leftLiteral, rightLiteral;
        return node.operator === "&&" && (leftLiteral = getNormalizedLiteral(left.left)) && (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) && leftLiteral.value <= rightLiteral.value && same(left.right, right.left);
      }

      /**
       * Determines whether node is of the form `x < 0 || 1 <= x`.
       * @returns {boolean} Whether node is an "outside" range test.
       */
      function isOutsideTest() {
        let leftLiteral, rightLiteral;
        return node.operator === "||" && (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) && (rightLiteral = getNormalizedLiteral(right.left)) && leftLiteral.value <= rightLiteral.value && same(left.left, right.right);
      }

      /**
       * Determines whether node is wrapped in parentheses.
       * @returns {boolean} Whether node is preceded immediately by an open
       *                    paren token and followed immediately by a close
       *                    paren token.
       */
      function isParenWrapped() {
        return astUtils.isParenthesised(sourceCode, node);
      }
      return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
    }
    const OPERATOR_FLIP_MAP = {
      "===": "===",
      "!==": "!==",
      "==": "==",
      "!=": "!=",
      "<": ">",
      ">": "<",
      "<=": ">=",
      ">=": "<="
    };

    /**
     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
     * @param {ASTNode} node The BinaryExpression node
     * @returns {string} A string representation of the node with the sides and operator flipped
     */
    function getFlippedString(node) {
      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
      const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
      const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
      const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
      const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);
      return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    return {
      BinaryExpression(node) {
        const expectedLiteral = always ? node.left : node.right;
        const expectedNonLiteral = always ? node.right : node.left;

        // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
        if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {
          context.report({
            node,
            messageId: "expected",
            data: {
              operator: node.operator,
              expectedSide: always ? "left" : "right"
            },
            fix: fixer => fixer.replaceText(node, getFlippedString(node))
          });
        }
      }
    };
  }
};

/***/ }),
/* 486 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(6);
/**
 * @fileoverview Tracks performance of individual rules.
 * @author Brandon Mills
 */



//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/* istanbul ignore next */
/**
 * Align the string to left
 * @param {string} str string to evaluate
 * @param {int} len length of the string
 * @param {string} ch delimiter character
 * @returns {string} modified string
 * @private
 */
function alignLeft(str, len, ch) {
  return str + new Array(len - str.length + 1).join(ch || " ");
}

/* istanbul ignore next */
/**
 * Align the string to right
 * @param {string} str string to evaluate
 * @param {int} len length of the string
 * @param {string} ch delimiter character
 * @returns {string} modified string
 * @private
 */
function alignRight(str, len, ch) {
  return new Array(len - str.length + 1).join(ch || " ") + str;
}

//------------------------------------------------------------------------------
// Module definition
//------------------------------------------------------------------------------

const enabled = !!process.env.TIMING;
const HEADERS = ["Rule", "Time (ms)", "Relative"];
const ALIGN = [alignLeft, alignRight, alignRight];

/* istanbul ignore next */
/**
 * display the data
 * @param {Object} data Data object to be displayed
 * @returns {string} modified string
 * @private
 */
function display(data) {
  let total = 0;
  const rows = Object.keys(data).map(key => {
    const time = data[key];
    total += time;
    return [key, time];
  }).sort((a, b) => b[1] - a[1]).slice(0, 10);
  rows.forEach(row => {
    row.push(`${(row[1] * 100 / total).toFixed(1)}%`);
    row[1] = row[1].toFixed(3);
  });
  rows.unshift(HEADERS);
  const widths = [];
  rows.forEach(row => {
    const len = row.length;
    for (let i = 0; i < len; i++) {
      const n = row[i].length;
      if (!widths[i] || n > widths[i]) {
        widths[i] = n;
      }
    }
  });
  const table = rows.map(row => row.map((cell, index) => ALIGN[index](cell, widths[index])).join(" | "));
  table.splice(1, 0, widths.map((width, index) => {
    const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;
    return ALIGN[index](":", width + extraAlignment, "-");
  }).join("|"));
  console.log(table.join("\n")); // eslint-disable-line no-console
}

/* istanbul ignore next */
module.exports = function () {
  const data = Object.create(null);

  /**
   * Time the run
   * @param {*} key key from the data object
   * @param {Function} fn function to be called
   * @returns {Function} function to be executed
   * @private
   */
  function time(key, fn) {
    if (typeof data[key] === "undefined") {
      data[key] = 0;
    }
    return function () {
      let t = process.hrtime();
      fn(...arguments);
      t = process.hrtime(t);
      data[key] += t[0] * 1e3 + t[1] / 1e6;
    };
  }
  if (enabled) {
    process.on("exit", () => {
      display(data);
    });
  }
  return {
    time,
    enabled
  };
}();

/***/ }),
/* 487 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Config Comment Parser
 * @author Nicholas C. Zakas
 */

/* eslint-disable class-methods-use-this*/


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const levn = __webpack_require__(488),
  ConfigOps = __webpack_require__(115);
const debug = __webpack_require__(105)("eslint:config-comment-parser");

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object to parse ESLint configuration comments inside JavaScript files.
 * @name ConfigCommentParser
 */
module.exports = class ConfigCommentParser {
  /**
   * Parses a list of "name:string_value" or/and "name" options divided by comma or
   * whitespace. Used for "global" and "exported" comments.
   * @param {string} string The string to parse.
   * @param {Comment} comment The comment node which has the string.
   * @returns {Object} Result map object of names and string values, or null values if no value was provided
   */
  parseStringConfig(string, comment) {
    debug("Parsing String config");
    const items = {};

    // Collapse whitespace around `:` and `,` to make parsing easier
    const trimmedString = string.replace(/\s*([:,])\s*/gu, "$1");
    trimmedString.split(/\s|,+/u).forEach(name => {
      if (!name) {
        return;
      }

      // value defaults to null (if not provided), e.g: "foo" => ["foo", null]
      const [key, value = null] = name.split(":");
      items[key] = {
        value,
        comment
      };
    });
    return items;
  }

  /**
   * Parses a JSON-like config.
   * @param {string} string The string to parse.
   * @param {Object} location Start line and column of comments for potential error message.
   * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object
   */
  parseJsonConfig(string, location) {
    debug("Parsing JSON config");
    let items = {};

    // Parses a JSON-like comment by the same way as parsing CLI option.
    try {
      items = levn.parse("Object", string) || {};

      // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.
      // Also, commaless notations have invalid severity:
      //     "no-alert: 2 no-console: 2" --> {"no-alert": "2 no-console: 2"}
      // Should ignore that case as well.
      if (ConfigOps.isEverySeverityValid(items)) {
        return {
          success: true,
          config: items
        };
      }
    } catch (ex) {
      debug("Levn parsing failed; falling back to manual parsing.");

      // ignore to parse the string by a fallback.
    }

    /*
     * Optionator cannot parse commaless notations.
     * But we are supporting that. So this is a fallback for that.
     */
    items = {};
    const normalizedString = string.replace(/([a-zA-Z0-9\-/]+):/gu, "\"$1\":").replace(/(\]|[0-9])\s+(?=")/u, "$1,");
    try {
      items = JSON.parse(`{${normalizedString}}`);
    } catch (ex) {
      debug("Manual parsing failed.");
      return {
        success: false,
        error: {
          ruleId: null,
          fatal: true,
          severity: 2,
          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,
          line: location.start.line,
          column: location.start.column + 1
        }
      };
    }
    return {
      success: true,
      config: items
    };
  }

  /**
   * Parses a config of values separated by comma.
   * @param {string} string The string to parse.
   * @returns {Object} Result map of values and true values
   */
  parseListConfig(string) {
    debug("Parsing list config");
    const items = {};

    // Collapse whitespace around commas
    string.replace(/\s*,\s*/gu, ",").split(/,+/u).forEach(name => {
      const trimmedName = name.trim();
      if (trimmedName) {
        items[trimmedName] = true;
      }
    });
    return items;
  }
};

/***/ }),
/* 488 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function () {
  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
  parseString = __webpack_require__(489);
  cast = __webpack_require__(496);
  parseType = (__webpack_require__(497).parseType);
  VERSION = '0.3.0';
  parsedTypeParse = function (parsedType, string, options) {
    options == null && (options = {});
    options.explicit == null && (options.explicit = false);
    options.customTypes == null && (options.customTypes = {});
    return cast(parseString(parsedType, string, options), parsedType, options);
  };
  parse = function (type, string, options) {
    return parsedTypeParse(parseType(type), string, options);
  };
  module.exports = {
    VERSION: VERSION,
    parse: parse,
    parsedTypeParse: parsedTypeParse
  };
}).call(this);

/***/ }),
/* 489 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function () {
  var reject, special, tokenRegex;
  reject = (__webpack_require__(490).reject);
  function consumeOp(tokens, op) {
    if (tokens[0] === op) {
      return tokens.shift();
    } else {
      throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
    }
  }
  function maybeConsumeOp(tokens, op) {
    if (tokens[0] === op) {
      return tokens.shift();
    }
  }
  function consumeList(tokens, arg$, hasDelimiters) {
    var open, close, result, untilTest;
    open = arg$[0], close = arg$[1];
    if (hasDelimiters) {
      consumeOp(tokens, open);
    }
    result = [];
    untilTest = "," + (hasDelimiters ? close : '');
    while (tokens.length && hasDelimiters && tokens[0] !== close) {
      result.push(consumeElement(tokens, untilTest));
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, close);
    }
    return result;
  }
  function consumeArray(tokens, hasDelimiters) {
    return consumeList(tokens, ['[', ']'], hasDelimiters);
  }
  function consumeTuple(tokens, hasDelimiters) {
    return consumeList(tokens, ['(', ')'], hasDelimiters);
  }
  function consumeFields(tokens, hasDelimiters) {
    var result, untilTest, key;
    if (hasDelimiters) {
      consumeOp(tokens, '{');
    }
    result = {};
    untilTest = "," + (hasDelimiters ? '}' : '');
    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
      key = consumeValue(tokens, ':');
      consumeOp(tokens, ':');
      result[key] = consumeElement(tokens, untilTest);
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, '}');
    }
    return result;
  }
  function consumeValue(tokens, untilTest) {
    var out;
    untilTest == null && (untilTest = '');
    out = '';
    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
      out += tokens.shift();
    }
    return out;
  }
  function consumeElement(tokens, untilTest) {
    switch (tokens[0]) {
      case '[':
        return consumeArray(tokens, true);
      case '(':
        return consumeTuple(tokens, true);
      case '{':
        return consumeFields(tokens, true);
      default:
        return consumeValue(tokens, untilTest);
    }
  }
  function consumeTopLevel(tokens, types, options) {
    var ref$, type, structure, origTokens, result, finalResult, x$, y$;
    ref$ = types[0], type = ref$.type, structure = ref$.structure;
    origTokens = tokens.concat();
    if (!options.explicit && types.length === 1 && (!type && structure || type === 'Array' || type === 'Object')) {
      result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');
      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
    } else {
      finalResult = consumeElement(tokens);
    }
    return finalResult;
  }
  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
  module.exports = function (types, string, options) {
    var tokens, node;
    options == null && (options = {});
    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return "'" + string.replace(/\\'/g, "\\\\'") + "'";
    }
    tokens = reject(not$, string.split(tokenRegex));
    node = consumeTopLevel(tokens, types, options);
    if (!node) {
      throw new Error("Error parsing '" + string + "'.");
    }
    return node;
  };
  function not$(x) {
    return !x;
  }
}).call(this);

/***/ }),
/* 490 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by LiveScript 1.4.0
var Func,
  List,
  Obj,
  Str,
  Num,
  id,
  isType,
  replicate,
  prelude,
  toString$ = {}.toString;
Func = __webpack_require__(491);
List = __webpack_require__(492);
Obj = __webpack_require__(493);
Str = __webpack_require__(494);
Num = __webpack_require__(495);
id = function (x) {
  return x;
};
isType = curry$(function (type, x) {
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function (n, x) {
  var i$,
    results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.2';
module.exports = prelude;
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}

/***/ }),
/* 491 */
/***/ ((module) => {

// Generated by LiveScript 1.4.0
var apply,
  curry,
  flip,
  fix,
  over,
  memoize,
  slice$ = [].slice,
  toString$ = {}.toString;
apply = curry$(function (f, list) {
  return f.apply(null, list);
});
curry = function (f) {
  return curry$(f);
};
flip = curry$(function (f, x, y) {
  return f(y, x);
});
fix = function (f) {
  return function (g) {
    return function () {
      return f(g(g)).apply(null, arguments);
    };
  }(function (g) {
    return function () {
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function (f, g, x, y) {
  return f(g(x), g(y));
});
memoize = function (f) {
  var memo;
  memo = {};
  return function () {
    var args, key, arg;
    args = slice$.call(arguments);
    key = function () {
      var i$,
        ref$,
        len$,
        results$ = [];
      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
        arg = ref$[i$];
        results$.push(arg + toString$.call(arg).slice(8, -1));
      }
      return results$;
    }().join('');
    return memo[key] = key in memo ? memo[key] : f.apply(null, args);
  };
};
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}

/***/ }),
/* 492 */
/***/ ((module) => {

// Generated by LiveScript 1.4.0
var each,
  map,
  compact,
  filter,
  reject,
  partition,
  find,
  head,
  first,
  tail,
  last,
  initial,
  empty,
  reverse,
  unique,
  uniqueBy,
  fold,
  foldl,
  fold1,
  foldl1,
  foldr,
  foldr1,
  unfoldr,
  concat,
  concatMap,
  flatten,
  difference,
  intersection,
  union,
  countBy,
  groupBy,
  andList,
  orList,
  any,
  all,
  sort,
  sortWith,
  sortBy,
  sum,
  product,
  mean,
  average,
  maximum,
  minimum,
  maximumBy,
  minimumBy,
  scan,
  scanl,
  scan1,
  scanl1,
  scanr,
  scanr1,
  slice,
  take,
  drop,
  splitAt,
  takeWhile,
  dropWhile,
  span,
  breakList,
  zip,
  zipWith,
  zipAll,
  zipAllWith,
  at,
  elemIndex,
  elemIndices,
  findIndex,
  findIndices,
  toString$ = {}.toString,
  slice$ = [].slice;
each = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function (f, xs) {
  var i$,
    len$,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function (xs) {
  var i$,
    len$,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function (f, xs) {
  var i$,
    len$,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function (f, xs) {
  var i$,
    len$,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function (f, xs) {
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function (xs) {
  return xs[0];
};
tail = function (xs) {
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function (xs) {
  return xs[xs.length - 1];
};
initial = function (xs) {
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function (xs) {
  return !xs.length;
};
reverse = function (xs) {
  return xs.concat().reverse();
};
unique = function (xs) {
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function (f, xs) {
  var seen,
    i$,
    len$,
    x,
    val,
    results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function (f, memo, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function (f, xs) {
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function (f, memo, xs) {
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function (f, xs) {
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function (f, b) {
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function (xss) {
  return [].concat.apply([], xss);
};
concatMap = curry$(function (f, xs) {
  var x;
  return [].concat.apply([], function () {
    var i$,
      ref$,
      len$,
      results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }());
});
flatten = function (xs) {
  var x;
  return [].concat.apply([], function () {
    var i$,
      ref$,
      len$,
      results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }());
};
difference = function (xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function (xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function () {
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function (xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function (xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function (xs) {
  return xs.concat().sort(function (x, y) {
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function (f, xs) {
  return xs.concat().sort(f);
});
sortBy = curry$(function (f, xs) {
  return xs.concat().sort(function (x, y) {
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function (xs) {
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function (xs) {
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function (xs) {
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function (xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function (xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function (f, xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function (f, xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function (f, memo, xs) {
  var last, x;
  last = memo;
  return [memo].concat(function () {
    var i$,
      ref$,
      len$,
      results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }());
});
scan1 = scanl1 = curry$(function (f, xs) {
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function (f, memo, xs) {
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function (f, xs) {
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function (x, y, xs) {
  return xs.slice(x, y);
});
take = curry$(function (n, xs) {
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function (n, xs) {
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function (n, xs) {
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function (p, xs) {
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function (p, xs) {
  return span(compose$(p, not$), xs);
});
zip = curry$(function (xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function (f, xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function () {
  var xss,
    minLength,
    i$,
    len$,
    xs,
    ref$,
    i,
    lresult$,
    j$,
    results$ = [];
  xss = slice$.call(arguments);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function (f) {
  var xss,
    minLength,
    i$,
    len$,
    xs,
    ref$,
    i,
    results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, fn$()));
  }
  return results$;
  function fn$() {
    var i$,
      ref$,
      len$,
      results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function (n, xs) {
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function (el, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function (el, xs) {
  var i$,
    len$,
    i,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function (f, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function (f, xs) {
  var i$,
    len$,
    i,
    x,
    results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}
function in$(x, xs) {
  var i = -1,
    l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function compose$() {
  var functions = arguments;
  return function () {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
function not$(x) {
  return !x;
}

/***/ }),
/* 493 */
/***/ ((module) => {

// Generated by LiveScript 1.4.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function (object) {
  var i$,
    x,
    results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function (object) {
  var x,
    results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function (object) {
  var i$,
    len$,
    x,
    resultObj$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    resultObj$[x[0]] = x[1];
  }
  return resultObj$;
};
objToPairs = function (object) {
  var key,
    value,
    results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function (keys, values) {
  var i$,
    len$,
    i,
    key,
    resultObj$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    resultObj$[key] = values[i];
  }
  return resultObj$;
});
objToLists = function (object) {
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function (object) {
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function (f, object) {
  var k,
    x,
    resultObj$ = {};
  for (k in object) {
    x = object[k];
    resultObj$[k] = f(x);
  }
  return resultObj$;
});
compact = function (object) {
  var k,
    x,
    resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (x) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
};
filter = curry$(function (f, object) {
  var k,
    x,
    resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
reject = curry$(function (f, object) {
  var k,
    x,
    resultObj$ = {};
  for (k in object) {
    x = object[k];
    if (!f(x)) {
      resultObj$[k] = x;
    }
  }
  return resultObj$;
});
partition = curry$(function (f, object) {
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}

/***/ }),
/* 494 */
/***/ ((module) => {

// Generated by LiveScript 1.4.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function (sep, str) {
  return str.split(sep);
});
join = curry$(function (sep, xs) {
  return xs.join(sep);
});
lines = function (str) {
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function (it) {
  return it.join('\n');
};
words = function (str) {
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function (it) {
  return it.join(' ');
};
chars = function (it) {
  return it.split('');
};
unchars = function (it) {
  return it.join('');
};
reverse = function (str) {
  return str.split('').reverse().join('');
};
repeat = curry$(function (n, str) {
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function (it) {
  return it.replace(/[-_]+(.)?/g, function (arg$, c) {
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function (str) {
  return str.replace(/([^-A-Z])([A-Z]+)/g, function (arg$, lower, upper) {
    return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function (arg$, upper) {
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}

/***/ }),
/* 495 */
/***/ ((module) => {

// Generated by LiveScript 1.4.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function (x$, y$) {
  return x$ > y$ ? x$ : y$;
});
min = curry$(function (x$, y$) {
  return x$ < y$ ? x$ : y$;
});
negate = function (x) {
  return -x;
};
abs = Math.abs;
signum = function (x) {
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function (x, y) {
  return ~~(x / y);
});
rem = curry$(function (x$, y$) {
  return x$ % y$;
});
div = curry$(function (x, y) {
  return Math.floor(x / y);
});
mod = curry$(function (x$, y$) {
  var ref$;
  return (x$ % (ref$ = y$) + ref$) % ref$;
});
recip = function (it) {
  return 1 / it;
};
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function (x$, y$) {
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function (x, y) {
  return Math.atan2(x, y);
});
truncate = function (x) {
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function (x) {
  return x !== x;
};
even = function (x) {
  return x % 2 === 0;
};
odd = function (x) {
  return x % 2 !== 0;
};
gcd = curry$(function (x, y) {
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function (x, y) {
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound) {
  var context,
    _curry = function (args) {
      return f.length > 1 ? function () {
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
  return _curry();
}

/***/ }),
/* 496 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function () {
  var parsedTypeCheck,
    types,
    toString$ = {}.toString;
  parsedTypeCheck = (__webpack_require__(497).parsedTypeCheck);
  types = {
    '*': function (value, options) {
      switch (toString$.call(value).slice(8, -1)) {
        case 'Array':
          return typeCast(value, {
            type: 'Array'
          }, options);
        case 'Object':
          return typeCast(value, {
            type: 'Object'
          }, options);
        default:
          return {
            type: 'Just',
            value: typesCast(value, [{
              type: 'Undefined'
            }, {
              type: 'Null'
            }, {
              type: 'NaN'
            }, {
              type: 'Boolean'
            }, {
              type: 'Number'
            }, {
              type: 'Date'
            }, {
              type: 'RegExp'
            }, {
              type: 'Array'
            }, {
              type: 'Object'
            }, {
              type: 'String'
            }], (options.explicit = true, options))
          };
      }
    },
    Undefined: function (it) {
      if (it === 'undefined' || it === void 8) {
        return {
          type: 'Just',
          value: void 8
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Null: function (it) {
      if (it === 'null') {
        return {
          type: 'Just',
          value: null
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    NaN: function (it) {
      if (it === 'NaN') {
        return {
          type: 'Just',
          value: NaN
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Boolean: function (it) {
      if (it === 'true') {
        return {
          type: 'Just',
          value: true
        };
      } else if (it === 'false') {
        return {
          type: 'Just',
          value: false
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Number: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Int: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Float: function (it) {
      return {
        type: 'Just',
        value: +it
      };
    },
    Date: function (value, options) {
      var that;
      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
        return {
          type: 'Just',
          value: new Date(+that[1] || that[1])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new Date(+value || value)
        };
      }
    },
    RegExp: function (value, options) {
      var that;
      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
        return {
          type: 'Just',
          value: new RegExp(that[1], that[2])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new RegExp(value)
        };
      }
    },
    Array: function (value, options) {
      return castArray(value, {
        of: [{
          type: '*'
        }]
      }, options);
    },
    Object: function (value, options) {
      return castFields(value, {
        of: {}
      }, options);
    },
    String: function (it) {
      var that;
      if (toString$.call(it).slice(8, -1) !== 'String') {
        return {
          type: 'Nothing'
        };
      }
      if (that = it.match(/^'([\s\S]*)'$/)) {
        return {
          type: 'Just',
          value: that[1].replace(/\\'/g, "'")
        };
      } else if (that = it.match(/^"([\s\S]*)"$/)) {
        return {
          type: 'Just',
          value: that[1].replace(/\\"/g, '"')
        };
      } else {
        return {
          type: 'Just',
          value: it
        };
      }
    }
  };
  function castArray(node, type, options) {
    var typeOf, element;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: function () {
        var i$,
          ref$,
          len$,
          results$ = [];
        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
          element = ref$[i$];
          results$.push(typesCast(element, typeOf, options));
        }
        return results$;
      }()
    };
  }
  function castTuple(node, type, options) {
    var result, i, i$, ref$, len$, types, cast;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    result = [];
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      cast = typesCast(node[i], types, options);
      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
        result.push(cast);
      }
      i++;
    }
    if (node.length <= i) {
      return {
        type: 'Just',
        value: result
      };
    } else {
      return {
        type: 'Nothing'
      };
    }
  }
  function castFields(node, type, options) {
    var typeOf, key, value;
    if (toString$.call(node).slice(8, -1) !== 'Object') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: function () {
        var ref$,
          resultObj$ = {};
        for (key in ref$ = node) {
          value = ref$[key];
          resultObj$[typesCast(key, [{
            type: 'String'
          }], options)] = typesCast(value, typeOf[key] || [{
            type: '*'
          }], options);
        }
        return resultObj$;
      }()
    };
  }
  function typeCast(node, typeObj, options) {
    var type, structure, castFunc, ref$;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
      if (!castFunc) {
        throw new Error("Type not defined: " + type + ".");
      }
      return castFunc(node, options, typesCast);
    } else {
      switch (structure) {
        case 'array':
          return castArray(node, typeObj, options);
        case 'tuple':
          return castTuple(node, typeObj, options);
        case 'fields':
          return castFields(node, typeObj, options);
      }
    }
  }
  function typesCast(node, types, options) {
    var i$, len$, type, ref$, valueType, value;
    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
      type = types[i$];
      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
      if (valueType === 'Nothing') {
        continue;
      }
      if (parsedTypeCheck([type], value, {
        customTypes: options.customTypes
      })) {
        return value;
      }
    }
    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }
  module.exports = typesCast;
}).call(this);

/***/ }),
/* 497 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function () {
  var VERSION, parseType, parsedTypeCheck, typeCheck;
  VERSION = '0.3.2';
  parseType = __webpack_require__(498);
  parsedTypeCheck = __webpack_require__(499);
  typeCheck = function (type, input, options) {
    return parsedTypeCheck(parseType(type), input, options);
  };
  module.exports = {
    VERSION: VERSION,
    typeCheck: typeCheck,
    parsedTypeCheck: parsedTypeCheck,
    parseType: parseType
  };
}).call(this);

/***/ }),
/* 498 */
/***/ (function(module) {

// Generated by LiveScript 1.4.0
(function () {
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens) {
    var token;
    token = tokens[0];
    if (token == null) {
      throw new Error('Unexpected end of input.');
    }
    return token;
  }
  function consumeIdent(tokens) {
    var token;
    token = peek(tokens);
    if (!identifierRegex.test(token)) {
      throw new Error("Expected text, got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function consumeOp(tokens, op) {
    var token;
    token = peek(tokens);
    if (token !== op) {
      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function maybeConsumeOp(tokens, op) {
    var token;
    token = tokens[0];
    if (token === op) {
      return tokens.shift();
    } else {
      return null;
    }
  }
  function consumeArray(tokens) {
    var types;
    consumeOp(tokens, '[');
    if (peek(tokens) === ']') {
      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
    }
    types = consumeTypes(tokens);
    consumeOp(tokens, ']');
    return {
      structure: 'array',
      of: types
    };
  }
  function consumeTuple(tokens) {
    var components;
    components = [];
    consumeOp(tokens, '(');
    if (peek(tokens) === ')') {
      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
    }
    for (;;) {
      components.push(consumeTypes(tokens));
      maybeConsumeOp(tokens, ',');
      if (')' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, ')');
    return {
      structure: 'tuple',
      of: components
    };
  }
  function consumeFields(tokens) {
    var fields, subset, ref$, key, types;
    fields = {};
    consumeOp(tokens, '{');
    subset = false;
    for (;;) {
      if (maybeConsumeOp(tokens, '...')) {
        subset = true;
        break;
      }
      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
      fields[key] = types;
      maybeConsumeOp(tokens, ',');
      if ('}' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, '}');
    return {
      structure: 'fields',
      of: fields,
      subset: subset
    };
  }
  function consumeField(tokens) {
    var key, types;
    key = consumeIdent(tokens);
    consumeOp(tokens, ':');
    types = consumeTypes(tokens);
    return [key, types];
  }
  function maybeConsumeStructure(tokens) {
    switch (tokens[0]) {
      case '[':
        return consumeArray(tokens);
      case '(':
        return consumeTuple(tokens);
      case '{':
        return consumeFields(tokens);
    }
  }
  function consumeType(tokens) {
    var token, wildcard, type, structure;
    token = peek(tokens);
    wildcard = token === '*';
    if (wildcard || identifierRegex.test(token)) {
      type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);
      structure = maybeConsumeStructure(tokens);
      if (structure) {
        return structure.type = type, structure;
      } else {
        return {
          type: type
        };
      }
    } else {
      structure = maybeConsumeStructure(tokens);
      if (!structure) {
        throw new Error("Unexpected character: " + token);
      }
      return structure;
    }
  }
  function consumeTypes(tokens) {
    var lookahead, types, typesSoFar, typeObj, type;
    if ('::' === peek(tokens)) {
      throw new Error("No comment before comment separator '::' found.");
    }
    lookahead = tokens[1];
    if (lookahead != null && lookahead === '::') {
      tokens.shift();
      tokens.shift();
    }
    types = [];
    typesSoFar = {};
    if ('Maybe' === peek(tokens)) {
      tokens.shift();
      types = [{
        type: 'Undefined'
      }, {
        type: 'Null'
      }];
      typesSoFar = {
        Undefined: true,
        Null: true
      };
    }
    for (;;) {
      typeObj = consumeType(tokens), type = typeObj.type;
      if (!typesSoFar[type]) {
        types.push(typeObj);
      }
      typesSoFar[type] = true;
      if (!maybeConsumeOp(tokens, '|')) {
        break;
      }
    }
    return types;
  }
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function (input) {
    var tokens, e;
    if (!input.length) {
      throw new Error('No type specified.');
    }
    tokens = input.match(tokenRegex) || [];
    if (in$('->', tokens)) {
      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
    }
    try {
      return consumeTypes(tokens);
    } catch (e$) {
      e = e$;
      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
    }
  };
  function in$(x, xs) {
    var i = -1,
      l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

/***/ }),
/* 499 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by LiveScript 1.4.0
(function () {
  var ref$,
    any,
    all,
    isItNaN,
    types,
    defaultType,
    customTypes,
    toString$ = {}.toString;
  ref$ = __webpack_require__(490), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
    Number: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it);
      }
    },
    NaN: {
      typeOf: 'Number',
      validate: isItNaN
    },
    Int: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it) && it % 1 === 0;
      }
    },
    Float: {
      typeOf: 'Number',
      validate: function (it) {
        return !isItNaN(it);
      }
    },
    Date: {
      typeOf: 'Date',
      validate: function (it) {
        return !isItNaN(it.getTime());
      }
    }
  };
  defaultType = {
    array: 'Array',
    tuple: 'Array'
  };
  function checkArray(input, type) {
    return all(function (it) {
      return checkMultiple(it, type.of);
    }, input);
  }
  function checkTuple(input, type) {
    var i, i$, ref$, len$, types;
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      if (!checkMultiple(input[i], types)) {
        return false;
      }
      i++;
    }
    return input.length <= i;
  }
  function checkFields(input, type) {
    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
    inputKeys = {};
    numInputKeys = 0;
    for (k in input) {
      inputKeys[k] = true;
      numInputKeys++;
    }
    numOfKeys = 0;
    for (key in ref$ = type.of) {
      types = ref$[key];
      if (!checkMultiple(input[key], types)) {
        return false;
      }
      if (inputKeys[key]) {
        numOfKeys++;
      }
    }
    return type.subset || numInputKeys === numOfKeys;
  }
  function checkStructure(input, type) {
    if (!(input instanceof Object)) {
      return false;
    }
    switch (type.structure) {
      case 'fields':
        return checkFields(input, type);
      case 'array':
        return checkArray(input, type);
      case 'tuple':
        return checkTuple(input, type);
    }
  }
  function check(input, typeObj) {
    var type, structure, setting, that;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      if (type === '*') {
        return true;
      }
      setting = customTypes[type] || types[type];
      if (setting) {
        return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
      } else {
        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
      }
    } else if (structure) {
      if (that = defaultType[structure]) {
        if (that !== toString$.call(input).slice(8, -1)) {
          return false;
        }
      }
      return checkStructure(input, typeObj);
    } else {
      throw new Error("No type defined. Input: " + input + ".");
    }
  }
  function checkMultiple(input, types) {
    if (toString$.call(types).slice(8, -1) !== 'Array') {
      throw new Error("Types must be in an array. Input: " + input + ".");
    }
    return any(function (it) {
      return check(input, it);
    }, types);
  }
  module.exports = function (parsedType, input, options) {
    options == null && (options = {});
    customTypes = options.customTypes || {};
    return checkMultiple(input, parsedType);
  };
}).call(this);

/***/ }),
/* 500 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"eslint","version":"5.16.0","author":"Nicholas C. Zakas <nicholas+npm@nczconsulting.com>","description":"An AST-based pattern checker for JavaScript.","bin":{"eslint":"./bin/eslint.js"},"main":"./lib/api.js","scripts":{"test":"node Makefile.js test","lint":"node Makefile.js lint","fuzz":"node Makefile.js fuzz","generate-release":"node Makefile.js generateRelease","generate-alpharelease":"node Makefile.js generatePrerelease -- alpha","generate-betarelease":"node Makefile.js generatePrerelease -- beta","generate-rcrelease":"node Makefile.js generatePrerelease -- rc","publish-release":"node Makefile.js publishRelease","docs":"node Makefile.js docs","gensite":"node Makefile.js gensite","webpack":"node Makefile.js webpack","perf":"node Makefile.js perf","profile":"beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree","coveralls":"cat ./coverage/lcov.info | coveralls"},"files":["LICENSE","README.md","bin","conf","lib","messages"],"repository":"eslint/eslint","homepage":"https://eslint.org","bugs":"https://github.com/eslint/eslint/issues/","dependencies":{"@babel/code-frame":"^7.0.0","ajv":"^6.9.1","chalk":"^2.1.0","cross-spawn":"^6.0.5","debug":"^4.0.1","doctrine":"^3.0.0","eslint-scope":"^4.0.3","eslint-utils":"^1.3.1","eslint-visitor-keys":"^1.0.0","espree":"^5.0.1","esquery":"^1.0.1","esutils":"^2.0.2","file-entry-cache":"^5.0.1","functional-red-black-tree":"^1.0.1","glob":"^7.1.2","globals":"^11.7.0","ignore":"^4.0.6","import-fresh":"^3.0.0","imurmurhash":"^0.1.4","inquirer":"^6.2.2","js-yaml":"^3.13.0","json-stable-stringify-without-jsonify":"^1.0.1","levn":"^0.3.0","lodash":"^4.17.11","minimatch":"^3.0.4","mkdirp":"^0.5.1","natural-compare":"^1.4.0","optionator":"^0.8.2","path-is-inside":"^1.0.2","progress":"^2.0.0","regexpp":"^2.0.1","semver":"^5.5.1","strip-ansi":"^4.0.0","strip-json-comments":"^2.0.1","table":"^5.2.3","text-table":"^0.2.0"},"devDependencies":{"@babel/core":"^7.2.2","@babel/polyfill":"^7.2.5","@babel/preset-env":"^7.3.1","babel-loader":"^8.0.5","beefy":"^2.1.8","brfs":"^2.0.0","chai":"^4.0.1","cheerio":"^0.22.0","common-tags":"^1.8.0","coveralls":"^3.0.1","dateformat":"^3.0.3","ejs":"^2.6.1","eslint-config-eslint":"file:packages/eslint-config-eslint","eslint-plugin-eslint-plugin":"^2.0.1","eslint-plugin-internal-rules":"file:tools/internal-rules","eslint-plugin-node":"^8.0.0","eslint-release":"^1.2.0","eslump":"^2.0.0","esprima":"^4.0.1","jsdoc":"^3.5.5","karma":"^3.1.4","karma-chrome-launcher":"^2.2.0","karma-mocha":"^1.3.0","karma-mocha-reporter":"^2.2.3","karma-webpack":"^4.0.0-rc.6","leche":"^2.2.3","load-perf":"^0.2.0","markdownlint":"^0.12.0","mocha":"^5.0.5","mock-fs":"^4.8.0","npm-license":"^0.3.3","nyc":"^13.3.0","proxyquire":"^2.0.1","puppeteer":"^1.12.2","shelljs":"^0.8.2","sinon":"^3.3.0","temp":"^0.9.0","through":"^2.3.8","webpack":"^4.29.3","webpack-cli":"^3.2.3"},"keywords":["ast","lint","javascript","ecmascript","espree"],"license":"MIT","engines":{"node":"^6.14.0 || ^8.10.0 || >=9.10.0"}}');

/***/ }),
/* 501 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview An object that caches and applies source code fixes.
 * @author Nicholas C. Zakas
 */


//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const debug = __webpack_require__(105)("eslint:source-code-fixer");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const BOM = "\uFEFF";

/**
 * Compares items in a messages array by range.
 * @param {Message} a The first message.
 * @param {Message} b The second message.
 * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareMessagesByFixRange(a, b) {
  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
}

/**
 * Compares items in a messages array by line and column.
 * @param {Message} a The first message.
 * @param {Message} b The second message.
 * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareMessagesByLocation(a, b) {
  return a.line - b.line || a.column - b.column;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Utility for apply fixes to source code.
 * @constructor
 */
function SourceCodeFixer() {
  Object.freeze(this);
}

/**
 * Applies the fixes specified by the messages to the given text. Tries to be
 * smart about the fixes and won't apply fixes over the same area in the text.
 * @param {string} sourceText The text to apply the changes to.
 * @param {Message[]} messages The array of messages reported by ESLint.
 * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed
 * @returns {Object} An object containing the fixed text and any unfixed messages.
 */
SourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {
  debug("Applying fixes");
  if (shouldFix === false) {
    debug("shouldFix parameter was false, not attempting fixes");
    return {
      fixed: false,
      messages,
      output: sourceText
    };
  }

  // clone the array
  const remainingMessages = [],
    fixes = [],
    bom = sourceText.startsWith(BOM) ? BOM : "",
    text = bom ? sourceText.slice(1) : sourceText;
  let lastPos = Number.NEGATIVE_INFINITY,
    output = bom;

  /**
   * Try to use the 'fix' from a problem.
   * @param   {Message} problem The message object to apply fixes from
   * @returns {boolean}         Whether fix was successfully applied
   */
  function attemptFix(problem) {
    const fix = problem.fix;
    const start = fix.range[0];
    const end = fix.range[1];

    // Remain it as a problem if it's overlapped or it's a negative range
    if (lastPos >= start || start > end) {
      remainingMessages.push(problem);
      return false;
    }

    // Remove BOM.
    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
      output = "";
    }

    // Make output to this fix.
    output += text.slice(Math.max(0, lastPos), Math.max(0, start));
    output += fix.text;
    lastPos = end;
    return true;
  }
  messages.forEach(problem => {
    if (Object.prototype.hasOwnProperty.call(problem, "fix")) {
      fixes.push(problem);
    } else {
      remainingMessages.push(problem);
    }
  });
  if (fixes.length) {
    debug("Found fixes to apply");
    let fixesWereApplied = false;
    for (const problem of fixes.sort(compareMessagesByFixRange)) {
      if (typeof shouldFix !== "function" || shouldFix(problem)) {
        attemptFix(problem);

        /*
         * The only time attemptFix will fail is if a previous fix was
         * applied which conflicts with it.  So we can mark this as true.
         */
        fixesWereApplied = true;
      } else {
        remainingMessages.push(problem);
      }
    }
    output += text.slice(Math.max(0, lastPos));
    return {
      fixed: fixesWereApplied,
      messages: remainingMessages.sort(compareMessagesByLocation),
      output
    };
  }
  debug("No fixes to apply");
  return {
    fixed: false,
    messages,
    output: bom + text
  };
};
module.exports = SourceCodeFixer;

/***/ }),
/* 502 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * @fileoverview Configuration applied when a user configuration extends from
 * eslint:recommended.
 * @author Nicholas C. Zakas
 */



const builtInRules = __webpack_require__(202);
module.exports = {
  rules: Object.assign({}, ...Object.keys(builtInRules).map(ruleId => ({
    [ruleId]: builtInRules[ruleId].meta.docs.recommended ? "error" : "off"
  })))
};

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eslint_lib_linter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var eslint_lib_linter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eslint_lib_linter__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var eslint_conf_eslint_recommended__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(502);
/* harmony import */ var eslint_conf_eslint_recommended__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eslint_conf_eslint_recommended__WEBPACK_IMPORTED_MODULE_1__);


(eslint_lib_linter__WEBPACK_IMPORTED_MODULE_0___default().DEFAULT_RECOMMENDED_RULES) = Object.assign({}, (eslint_conf_eslint_recommended__WEBPACK_IMPORTED_MODULE_1___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((eslint_lib_linter__WEBPACK_IMPORTED_MODULE_0___default()));
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});